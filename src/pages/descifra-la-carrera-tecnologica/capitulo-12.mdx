
import Layoutcarrera from "../../layouts/Layoutcarrera.astro"

<Layoutcarrera title="Descifra la carrera tecnológica">

<header class="flex justify-between">
  <img class="h-10" src="/public/javascript/doce.svg" alt="capitulo Doce" />
  <h1 class="text-right inline">La entrevista de programación</h1>
</header>
Si optas a un puesto de desarrollo de software, tienes que preparar un conjunto especial de habilidades. Sí, te pedirán que programes. No, no te darán un ordenador (normalmente), sino una pizarra o, a veces, una hoja de papel. La codificación con pizarra y entrevistas requiere una serie de habilidades especiales. Incluso los mejores programadores pueden fracasar en las preguntas de programación.

Una entrevista típica de desarrollo de software consiste en un poco de conversación al principio sobre tu experiencia previa y un poco al final sobre la empresa. La mayor parte de la entrevista se dedica a preguntas sobre codificación y algoritmos.

Las preguntas de codificación pueden ser muy rápidas, pero suelen ocupar todo el tiempo de la entrevista. No se espera que seas un programador impecable. La mayoría de las preguntas son lo suficientemente complicadas como para que incluso los mejores candidatos cometan algún error.

## ¿Cuál es el objetivo?

Las entrevistas de programación son un punto delicado para muchos solicitantes de empleo. ¿Qué sentido tiene codificar en una pizarra? ¿Acaso no saben que sabes programar basándose en tu experiencia previa? ¿Y por qué te obligan a utilizar una pizarra en lugar de un ordenador? Al fin y al cabo, es imposible que escribas correctamente en una pizarra.

Cuando se lo preguntan, los empresarios suelen hacer una o varias de las siguientes observaciones:

- <span>⏺</span> Al codificar en una pizarra, te animas a mantener una conversación con tu entrevistador. Esto ayuda al entrevistador a entender cómo piensas.

- <span>⏺</span> La codificación en una pizarra te anima a centrarte en la esencia del algoritmo y el código, en lugar de perderte en los detalles. Por ejemplo, en un ordenador, es probable que un candidato dedique tiempo a corregir la sintaxis exacta de un método de ordenación. Este no es el tipo de cosas que preocupan a los entrevistadores.

- <span>⏺</span> Como no estás preocupado por hacer que todas las pequeñas piezas funcionen correctamente, puedes escribir código más complejo. ¿Necesitas una función de ayuda para encontrar el valor más pequeño de un array? No hay problema. Haz como si tuvieras una.

- <span>⏺</span> Escribir código en una pizarra pone a prueba tu capacidad de razonar sobre el funcionamiento del código. ¿Te limitas a comprobar que tu código funciona ejecutándolo? ¿O realmente piensas conceptualmente en cómo funciona?

- <span>⏺</span> La programación con pizarra te anima a escribir código bueno y limpio desde el principio, porque es mucho más lenta. Cuando tienes un ordenador, puedes ser un poco más descuidado y limpiarlo después.

Esto no se dice para defender absolutamente estas entrevistas, sino para ayudarte a entender cuál es el razonamiento de la empresa.

## Qué se espera y qué no

No se espera que escribas un código de pizarra impecable. Después de haber pasado por el proceso, los entrevistadores saben que escribir un código perfecto no es una expectativa razonable.

Sin embargo, el pseudocódigo no suele ser aceptable. El código debe estar en un lenguaje específico (Python, Java, C++, etc.) y el objetivo debe ser lo más cercano posible a un código correcto. Si cometes pequeños errores -por ejemplo, utilizar list.add en lugar de list.append- a los entrevistadores no debería importarles mucho.

Haz lo que puedas para demostrar que te preocupas por un código limpio y bonito. Envuelve tu código en una declaración de método; el código suelto parece descuidado y puede ser confuso. Por lo general, no es necesario escribir la definición de la clase, a menos que sea particularmente relevante para el problema en cuestión.

Modularice su código. Esto demuestra un ojo para la mantenibilidad.

Si usted nota partes de su código que puede refactorizar o limpiar después, sólo seguir adelante y hacer los cambios. Quieres demostrar que eres el tipo de persona que se preocupa por la belleza del código.

## En qué se diferencian: Microsoft, Facebook, Google, Amazon, Yahoo y Apple

En su mayor parte, las principales empresas tecnológicas son mucho más parecidas que diferentes. Realmente no hay "preguntas de entrevista de Google" o "preguntas de entrevista de Microsoft". Cada entrevistador decide sus propias preguntas, y casi cualquier pregunta formulada en una empresa encajaría igual de bien en cualquiera de las otras.

Sin embargo, algunas empresas se inclinan por determinados tipos de preguntas:

- <span>⏺</span> Google tiende a hacer más hincapié en las preguntas sobre escalabilidad que otras empresas (por ejemplo, "Diseña un rastreador web"). Las preguntas sobre manipulación de bits también son bastante comunes.

- <span>⏺</span> A Amazon le encantan las preguntas sobre diseño orientado a objetos. Si vas a hacer una entrevista en Amazon, asegúrate de estudiar estos problemas. Y, puesto que Amazon es una empresa basada en la web, también querrás prepararte para las preguntas sobre escalabilidad.

- <span>⏺</span> Microsoft se mueve por todo el mapa, lo cual es de esperar ya que tiene un conjunto de proyectos bastante diverso. Sus entrevistadores suelen hacer más preguntas sobre C y C++. Si no incluyes estos lenguajes en tu currículum, no tienes nada que temer. Sin embargo, si incluyes estos lenguajes, deberás asegurarte de que te sientes cómodo codificando en ellos. Además, Microsoft tiende a hacer más hincapié que otras empresas en las habilidades de prueba y diseño de los desarrolladores, así que prepárate para estas preguntas.

- <span>⏺</span> Apple quiere gente a la que le apasione la empresa. Asegúrate de que entiendes los productos de Apple, especialmente los del equipo con el que te entrevistas. ¿Qué mejorarías del producto? Recuerda que en Apple hay mucha gente inteligente que aún no ha hecho lo que tú sugieres. Piensa por qué no lo han hecho.

- <span>⏺</span> Facebook tiene funciones específicas para sus entrevistadores a fin de garantizar la diversidad de preguntas. Suelen dar prioridad a ser un buen hacker, es decir, a saber hacer cosas. Prepárate para hablar de tu experiencia previa.

- <span>⏺</span> Históricamente, Yahoo ha hecho más hincapié en las preguntas basadas en terminología y conocimientos, pero ha empezado a orientarse más hacia las típicas preguntas sobre algoritmos y resolución de problemas.

Una buena regla general es fijarse en el puesto y la empresa. Si se trata de una empresa, un equipo o una función basada en la web, es de esperar que haya preguntas sobre escalabilidad. Si es un puesto de front-end, espera algunas preguntas de front-end. Pero para casi todas las empresas, espera preguntas sobre algoritmos y resolución de problemas.

## Cómo prepararse

Cuando se trata de practicar las preguntas de la entrevista, la calidad importa más que la cantidad. Hay literalmente miles de ejemplos de preguntas de entrevista en Internet para empresas como Google, Microsoft y Amazon. No intentes memorizar las respuestas. Es imposible y no te servirá de nada.

Tómate tu tiempo para resolver los problemas e intenta seguir el siguiente método de siete pasos para practicar las preguntas:

1. Implementa las estructuras de datos y los algoritmos más comunes desde cero, primero a mano y luego mediante un ordenador. Muchas preguntas de la entrevista requieren estos conocimientos, por lo que es esencial que te sientas muy cómodo con ellos. Deduce también la complejidad temporal de estos algoritmos.
2. Practica con preguntas reales de la entrevista. Un libro sobre algoritmos o estructuras de datos puede ser útil, pero a menudo va mucho más allá de los conocimientos que necesitas saber. Deja que las preguntas de la entrevista te orienten sobre lo que necesitas saber.
3. Intenta resolver el problema por tu cuenta, de verdad. Si lees una pregunta y te quedas atascado resolviéndola, no pasa nada y es normal. Las preguntas están diseñadas para ser difíciles. Pero no te rindas. Sigue trabajando en el problema.
4. Escribe el código del algoritmo en papel. Llevas toda la vida codificando en un ordenador y te has acostumbrado a sus muchas ventajas: compiladores, completado de código, etcétera. En una entrevista no tendrás nada de eso, así que será mejor que te vayas acostumbrando. Implementa el código a la antigua usanza, hasta el último punto y coma.
5. Prueba el código. A mano, claro. No hagas trampas con el ordenador.
6. Escribe el código en el ordenador tal cual. Vuelve a ejecutar los casos de prueba que has probado y otros nuevos.
7. Haz una lista de todos los errores que has cometido y analiza qué tipo de errores cometes con más frecuencia. ¿Hay errores específicos?

En [CareerCup.com](https://www.gayle.com/consulting) puedes encontrar miles de preguntas de entrevistas de codificación que los candidatos han recibido de Google, Microsoft, Amazon y otras grandes empresas tecnológicas.

### ¿Qué pasa si me hacen una pregunta que conozco?

Si te preparas bien, es probable que te hagan algunas preguntas que ya conoces. Si esto ocurre, dile a tu entrevistador: "Creo que he oído esta pregunta antes" o "He oído un problema similar a este, ¿quiere que continúe de todos modos?".

Con las preguntas sobre algoritmos complejos, los entrevistadores buscan ver cómo resuelves el problema. Si no ven tu forma de resolver el problema, no pueden pensar que eres un buen solucionador de problemas.

Peor aún: muchos entrevistadores creen que no admitir que has oído una pregunta antes es una forma de hacer trampa, y podrían rechazarte sólo por eso.

Sin embargo, si eres sincero y dices que has oído la pregunta antes, ganarás muchos puntos extra. A los entrevistadores les importa la honestidad, aunque normalmente no haya forma de comprobarla directamente.

## Estructuras de datos, algoritmos y temas imprescindibles

La mayoría de los entrevistadores no te preguntarán sobre algoritmos específicos para equilibrar árboles binarios u otros algoritmos complejos. Francamente, es probable que tampoco recuerden estos algoritmos. (Sí, eso significa que puedes dejar a un lado el libro de algoritmos extravagantes).

Normalmente se espera que sólo conozcas lo básico. Aquí tienes una lista de temas esenciales. Por supuesto, no se trata de una lista exhaustiva. Es posible que te hagan preguntas sobre otros temas. Se trata simplemente de una lista imprescindible.

| Estructuras de datos | Algoritmos | Conceptos |
| --- | --- | --- |
| Listas enlazadas | Búsqueda exhaustiva | Manipulación de bits |
| Árboles binarios | Búsqueda profunda | Recursión |
| Pruebas | Busqueda binaria | Memorización / programación dinámica |
| Pilas | Ordenación combinada | Memoria (pila vs. montón) |
| Colas | Ordenación rápida | Tiempo Big-O |
| Matrices redimensionadas dinámicamente | Insertar / encontrar / etc. en árbol |  |
| Tablas hash |  |  |
| Montones |  |  |
| Grafos |  |  |

Para cada uno de los temas, asegúrate de que entiendes cómo implementarlos y utilizarlos, y (en su caso) la complejidad espacial y temporal.

Practica la implementación de las estructuras de datos y los algoritmos. Puede que te pidan que los implementes directamente, o puede que te pidan que implementes una modificación de los mismos. En cualquier caso, cuanto más cómodo te sientas con las implementaciones, mejor.

### Uso de la memoria

Cuando repases las estructuras de datos, recuerda practicar el cálculo del uso de memoria de una estructura de datos o un algoritmo. Puede que tu entrevistador te pregunte directamente cuánta memoria ocupa algo, o puede que tengas que calcularlo tú mismo si tu problema implica grandes cantidades de datos.

- <span>⏺</span> **Estructuras de datos.** No olvides incluir los punteros a otros datos. Por ejemplo, una lista doblemente enlazada que contenga 1.000 enteros suele ocupar unos 12 KB de memoria (4 bytes para los datos, 4 bytes para el puntero anterior y 4 bytes para el puntero siguiente). Esto significa que convertir una lista enlazada simple en una lista doblemente enlazada puede aumentar drásticamente el uso de memoria.

- <span>⏺</span> **Algoritmos.** Un algoritmo recursivo suele ocupar mucho más espacio que un algoritmo iterativo. Consideremos, por ejemplo, un algoritmo para calcular el j-ésimo último elemento de una lista unicatenaria. Un enfoque que utilice una matriz para ordenar cada elemento puede no ser mejor que un algoritmo recursivo: ¡ambos utilizan memoria O(n)! (La mejor solución implica el uso de dos punteros, donde uno comienza j espacios por delante).

Muchos candidatos piensan en sus algoritmos en una sola dimensión -el tiempo-, pero es importante tener en cuenta también la complejidad espacial. A menudo tenemos que hacer concesiones entre tiempo y espacio, y a veces sacrificamos la eficiencia temporal para reducir el uso de memoria.

## Preguntas de codificación

Se supone que las entrevistas son difíciles. Lo normal es que no sepas cómo resolver una pregunta en cuanto la escuches. Tendrás que esforzarte, recibir un poco de ayuda del entrevistador (o mucha, dependiendo de la dificultad de la pregunta) y llegar a una solución mejor que la que tenías al principio.

Cuando te hagan una pregunta difícil, no te asustes. Empieza a hablar en voz alta sobre cómo la resolverías.

El siguiente enfoque en siete pasos funciona bien para muchos problemas:

1. **Entiende la pregunta.** Si hay algo que no entiendes, acláralo aquí. Presta especial atención a los detalles específicos de la pregunta, como que la entrada esté ordenada. Necesitas todos esos detalles.
2. **Dibuja un ejemplo.** Resolver las preguntas mentalmente es muy distinto; acércate a la pizarra y dibuja un ejemplo. Además, debe ser un buen ejemplo. El ejemplo debe ser razonablemente grande (por ejemplo, si es un problema típico de matrices, probablemente quieras uno con unos ocho elementos) y no un caso especial. Esto es mucho más fácil de decir que de hacer.
3. **Diseña un algoritmo de fuerza bruta.** Si hay un enfoque de fuerza bruta/ingenuo, o incluso una solución que sólo funciona parcialmente, explícalo. Es un punto de partida y garantiza que tu entrevistador sepa que has llegado al menos hasta ahí.
4. **Optimiza la fuerza bruta.** No siempre, pero muy a menudo, hay un camino desde la fuerza bruta hasta la solución óptima.
5. **Comprende el código.** Una vez que tengas un algoritmo óptimo, tómate un momento para entender realmente tu algoritmo. Merece la pena no sumergirse en el código todavía.
6. **Implementa el código.** Si te sientes cómodo con tu proceso, sigue adelante e impleméntalo. Sin embargo, no tengas miedo de volver al ejemplo si empiezas a confundirte.
7. **Pruébalo.** No es habitual que el código de la pizarra sea perfecto. Si encuentras errores, no pasa nada. Analiza por qué te has equivocado e intenta corregirlo.

Y recuerda: ¡no has terminado hasta que el entrevistador diga que has terminado! Esto vale tanto para la parte del algoritmo como para la parte del código. Cuando se te ocurra un algoritmo, empieza a pensar en los problemas que lo acompañan. Cuando escribas el código, empieza a buscar errores. La gran mayoría de los candidatos cometen errores.

### Paso 1: Entender la pregunta

Los problemas técnicos son más ambiguos de lo que parecen, así que asegúrate de hacer preguntas para resolver cualquier cosa que pueda estar poco clara. Puede que al final te encuentres con un problema muy diferente -o mucho más fácil- de lo que habías pensado en un principio. De hecho, algunos entrevistadores (especialmente en Microsoft) comprueban específicamente si haces buenas preguntas. Una pregunta como "Diseña un algoritmo para ordenar una lista" puede convertirse en "Ordena una secuencia de valores entre 1 y 10 que están almacenados en una lista enlazada". Se trata de un problema muy diferente.

Además, es importante que te asegures de que realmente recuerdas todos los detalles que mencionó el entrevistador. Si el entrevistador mencionó que los datos están ordenados, entonces tu algoritmo óptimo probablemente depende de eso. O, si el conjunto de datos tiene todos valores únicos, probablemente se trate de información necesaria.

Si crees que has olvidado algún detalle, siempre puedes pedir a tu entrevistador que repita el problema.

### Paso 2: Dibujar un ejemplo

Por alguna razón, la mayoría de los candidatos tienen el instinto de quedarse en sus sillas para resolver el problema. No lo haga. Levántate y ve a la pizarra. Es muy difícil resolver un problema sin un ejemplo.

Asegúrese de que su ejemplo es suficientemente interesante. Esto significa que no debe ser demasiado pequeño, pero tampoco abrumadoramente difícil, y tampoco un caso especial.

Es sorprendentemente común que los candidatos utilicen un ejemplo de caso especial. El problema de los casos especiales es que pueden hacerte ver patrones que no existen o hacer que no veas patrones que sí existen. Es difícil distinguir entre "funciona para este problema" y "funciona en general".

Consideremos, por ejemplo, un problema para contar el número de elementos que tienen en común dos matrices ordenadas y distintas. Un ejemplo típico que se le puede ocurrir a un candidato es:

A: [1, 3, 8, 9]

B: [3, 4, 5, 10]

Es un mal ejemplo por dos razones. Primero, es demasiado pequeño. Segundo, es un caso especial: las matrices tienen la misma longitud.

¿Qué te parece este ejemplo?

A: [1, 3, 8, 9]

B: [2, 3, 4, 5, 10]

Esto es un poco mejor, pero sigue siendo un caso especial. Las matrices sólo tienen un elemento en común y ese elemento está incluso en el mismo índice en ambas matrices.

Este ejemplo es bastante bueno:

A: [1, 5, 9, 13, 14, 20, 21]

B: [1, 9, 10, 11, 13, 14, 15, 16, 21]

Este ejemplo es bastante grande (pero no demasiado engorroso). Tiene varios elementos en común y están dispersos por todo el array. Incluso tenemos dos elementos superpuestos (13 y 14) que están uno al lado del otro.

### Paso 3: Diseñar un algoritmo de fuerza bruta

En cuanto oigas una pregunta de la entrevista, intenta sacar una solución, aunque sea imperfecta. Puedes trabajar con un algoritmo de fuerza bruta para optimizarla.

Si tienes problemas para idear un algoritmo, recuerda nuestras aproximaciones a los problemas de algoritmos (presentadas más adelante en este capítulo).

Además, cuando diseñes tu algoritmo, no olvides pensar en:

- <span>⏺</span> ¿Cuáles son las complejidades de espacio y tiempo?

- <span>⏺</span> ¿Qué ocurre si hay muchos datos?

- <span>⏺</span> ¿Causa tu diseño otros problemas? (Es decir, si estás creando una versión modificada de un árbol de búsqueda binario, ¿impactó tu diseño en el tiempo para insertar/encontrar/borrar?)

- <span>⏺</span> Si hay otros problemas, ¿has hecho las concesiones adecuadas?

- <span>⏺</span> Si el entrevistador te dio datos específicos (por ejemplo, mencionó que los datos son por edades o están ordenados), ¿has aprovechado esa información? Es probable que te la hayan dado por alguna razón.

Incluso una mala solución es mejor que ninguna solución. Exponga su mala solución y, a continuación, los problemas que plantea.

### Paso 4: Optimizar la fuerza bruta

Una vez que tengas una solución, céntrate en mejorarla.

Si tiene un algoritmo de fuerza bruta, a menudo funciona bien recorrer el algoritmo -a mano con su ejemplo, no escribiendo código- y buscar áreas que optimizar. En concreto, busque los cuellos de botella, el trabajo innecesario y las áreas de trabajo duplicado (BUD):

- <span>⏺</span> Cuellos de botella. ¿Hay alguna parte del código que esté tardando mucho? Por ejemplo, si su algoritmo tiene un primer paso que es O(N log N) y un segundo paso que es O(N), no tiene mucho sentido optimizar el segundo paso. El primer paso siempre será un cuello de botella. Un cuello de botella también podría ser una parte particularmente lenta del código que se llama repetidamente. Ese podría ser un buen lugar en el que centrar las optimizaciones.

- <span>⏺</span> Trabajo innecesario. ¿Hay algo que esté haciendo que no sea realmente necesario? Por ejemplo, quizás esté buscando un elemento en ambos lados del árbol, cuando en realidad debería tener alguna pista de por qué estaría en un lado.

- <span>⏺</span> Trabajo duplicado. ¿Hay algo que estés haciendo una y otra vez? Por ejemplo, si estás buscando continuamente los mismos elementos, esto podría constituir trabajo duplicado y podrías optimizarlo con una tabla hash.

Por supuesto, si se te ocurre un enfoque realmente novedoso y no relacionado, no tengas miedo de empezar de cero.

### Paso 5: Entender el código

Los entrevistados dedican muy poco tiempo a este paso y, por desgracia, suele dar lugar a que escriban código descuidado e incorrecto.

Es un mal hábito inculcado a los programadores desde que usan el ordenador. Si el código es lo suficientemente corto, estás acostumbrado a escribirlo y ejecutarlo, y luego arreglar lo que no funciona. Esto está bien en un ordenador: escribir un problema corto es bastante rápido.

En una pizarra, sin embargo, es muy lento escribir código y aún más lento probarlo. Por eso es importante asegurarse de que realmente sabes lo que estás haciendo.

Repasa tu algoritmo meticulosamente antes de codificarlo. Por ejemplo, imagina que intentas combinar dos matrices ordenadas en una nueva matriz ordenada. Muchos candidatos empiezan a codificar cuando entienden lo básico: dos punteros, moverlos por la matriz, copiar los elementos en orden.

Probablemente esto no sea suficiente. En su lugar, deberías entenderlo en profundidad. Necesitas entender qué son las variables, cuándo se actualizan y por qué. Deberías tener una lógica como esta formulada antes de empezar a codificar:

1. Inicializa dos punteros, p y q, que apuntan al principio de A y B, respectivamente.
2. Inicialice k a un índice al principio de la matriz de resultados, R.
3. Compare los valores en p y q.
4. Si A[p] es menor, inserte A[p] en R[k]. Incremente p y k.
5. Si B[q] es menor, inserte B[q] en R[k]. Incremente q y k.
6. Vaya al paso 3.

No tienes que escribir esto a mano, pero necesitas entenderlo a este nivel. Intentar saltarte un paso y codificar antes de que te sientas totalmente cómodo sólo te retrasará.

### Paso 6: Implementar el código

No necesita apresurarse con el código; de hecho, lo más probable es que esto le perjudique. Simplemente ve a un ritmo agradable, lento y metódico, y recuerda este consejo:

- <span>⏺</span> **Utiliza las estructuras de datos con generosidad.** Cuando sea pertinente, utiliza una buena estructura de datos o define una propia. Por ejemplo, si te plantean un problema sobre la edad mínima de un grupo de personas, considera la posibilidad de definir una estructura de datos que represente a una persona. Esto demuestra a tu entrevistador que te preocupas por un buen diseño orientado a objetos.

- <span>⏺</span> **Modulariza primero tu código.** Si hay pasos diferenciados en tu algoritmo, muévelos a funciones separadas. De hecho, esto puede ayudarte a evitar hacer un trabajo tedioso. Imagina que, como parte de un algoritmo más amplio, necesitas convertir una letra de la A a la Z en un número del 0 al 26. Esto es algo tedioso de hacer. Esto es algo tedioso de escribir. Simplemente modularízalo en otra función y probablemente no tendrás que preocuparte de escribirlo nunca.

- <span>⏺</span> **No abarrotes tu código.** Muchos candidatos empezarán a escribir su código en medio de la pizarra. Esto está bien para las primeras líneas, pero las pizarras no son tan grandes.

Si te confundes mientras escribes, para y vuelve al ejemplo. No hace falta que codifiques directamente. Es mucho mejor tomarse un descanso que escribir código sin sentido.

### Paso 7: Prueba

Es raro que un candidato escriba un código impecable. Por tanto, no probarlo plantea dos problemas. En primer lugar, deja errores en tu código. Segundo, sugiere que eres el tipo de persona que no prueba bien su código.

Por lo tanto, es muy importante probar tu código.

Para descubrir errores lo más rápido posible, siga estos cinco pasos:

1. **Revise su código conceptualmente.** ¿Qué significa cada línea? ¿Hace lo que crees que debería hacer?
2. **Revise los puntos calientes de error.** ¿Hay algo en su código que parezca raro (por ejemplo, "int n = longitud - 2")? ¿Las condiciones de contorno son correctas? ¿Y los casos base (si el código es recursivo)?
3. **Prueba con un pequeño ejemplo.** Quieres que tu ejemplo para crear un algoritmo sea grande, pero ahora quieres uno pequeño. Un ejemplo demasiado grande tardará mucho tiempo en ejecutarse. Esto lleva mucho tiempo, pero también puede hacer que te precipites en las pruebas y pases por alto errores graves.
4. **Identifique los problemas potenciales.** ¿Qué tipo de casos de prueba podrían comprobar problemas potenciales específicos? Por ejemplo, podrías intuir que podría haber un error con una matriz que es mucho más corta que la otra; prueba esta situación específicamente.
5. **Prueba los casos de error.** Por último, comprueba las condiciones de error reales. ¿Qué ocurre con una cadena nula o con valores negativos?

Cuando encuentres un error (que lo encontrarás), relájate. Casi nadie escribe código libre de errores; lo importante es cómo reaccionas ante ellos. Señala el error y analiza detenidamente por qué se produce. ¿Es realmente sólo cuando pasas 0, o también ocurre en otros casos?

Los errores no son gran cosa (un código sin errores es muy poco habitual). Lo importante es que pienses bien cómo solucionar los problemas que veas en lugar de hacer una solución rápida y sucia. Una solución que funciona para ese caso de prueba puede no funcionar para todos los casos de prueba, así que asegúrate de que es la correcta.

## Preguntas sobre algoritmos: Cuatro maneras de crear un algoritmo

No hay un método infalible para resolver un problema de algoritmo complicado, pero los siguientes enfoques pueden ser útiles. Ten en cuenta que cuantos más problemas practiques, más fácil te resultará identificar qué enfoque utilizar.

Además, recuerda que los cuatro enfoques se pueden mezclar y combinar. Es decir, una vez que haya aplicado Simplificar y Generalizar, es posible que desee aplicar la Comparación de Patrones a continuación.

### Enfoque 1: Correspondencia de patrones

Emparejar patrones significa relacionar un problema con otros similares y averiguar si se puede modificar la solución para resolver el nuevo problema. Esta es una de las razones por las que es importante practicar con muchos problemas: cuantos más problemas haga, mejor lo hará.

**Ejemplo: Una matriz ordenada se ha girado de modo que los elementos pueden aparecer en el orden 3 4 5 6 7 1 2. ¿Cómo encontrarías el elemento mínimo? ¿Cómo encontrarías el elemento mínimo?**

Esta pregunta es muy parecida a los dos problemas siguientes, muy conocidos:

1. Encontrar el elemento mínimo en una matriz sin ordenar.
2. Encontrar un elemento específico en una matriz (por ejemplo, búsqueda binaria).

Encontrar el elemento mínimo en una matriz sin ordenar no es un algoritmo particularmente interesante (se podría iterar a través de todos los elementos), ni utiliza la información proporcionada (que la matriz está ordenada). Es poco probable que sea útil en este caso.

Sin embargo, la búsqueda binaria es muy aplicable. Sabe que la matriz está ordenada pero girada. Así que debe proceder en un orden creciente, a continuación, restablecer y aumentar de nuevo. El elemento mínimo es el punto de reinicio.

Si comparas los elementos primero y medio (3 y 6), sabes que el rango sigue aumentando. Esto significa que el punto de reinicio debe estar después del 6 (o el 3 es el elemento mínimo y el array nunca fue rotado). Podemos seguir aplicando las lecciones de la búsqueda binaria para localizar este punto de reinicio, buscando rangos donde IZQUIERDA > DERECHA. Es decir, para un punto en particular, si IZQUIERDA &lt; DERECHA, entonces el rango no contiene el reinicio. Si IZQUIERDA > DERECHA, entonces sí.

### Enfoque 2: Simplificar y generalizar

En Simplificar y generalizar, cambiamos las restricciones (tipo de datos, tamaño, etc.) para simplificar el problema y, a continuación, intentamos resolver el problema simplificado. Una vez que tengas un algoritmo para el problema simplificado, puedes generalizar el problema a su forma original. ¿Puedes aplicar las nuevas lecciones?

**Ejemplo: Una nota de rescate se puede formar recortando palabras de una revista para formar una nueva frase. ¿Cómo podrías averiguar si se puede formar una nota de rescate (cadena) a partir de una revista dada (cadena)?**

Podemos simplificar el problema de la siguiente manera: en lugar de resolver el problema con palabras, resuélvelo con caracteres. Es decir, imaginemos que estamos recortando caracteres de una revista para formar una nota de rescate.

Podemos resolver el problema simplificado de la nota de rescate con caracteres simplemente creando una matriz y contando los caracteres. Cada punto de la matriz corresponde a una letra. En primer lugar, contamos el número de veces que aparece cada carácter en la nota de rescate y, a continuación, repasamos la revista para ver si tenemos todos esos caracteres.

Cuando generalizamos el algoritmo, hacemos algo muy parecido. Esta vez, en lugar de crear una matriz con el recuento de caracteres, creamos una tabla hash. Cada palabra se asigna al número de veces que aparece.

### Enfoque 3: Caso base y construcción

Caso base y construcción sugiere que resuelvas el algoritmo primero para un caso base (por ejemplo, sólo un elemento). A continuación, intente resolverlo para los elementos 1 y 2, suponiendo que tiene la respuesta para el elemento 1. A continuación, intente resolverlo para los elementos 1, 2 y 3, suponiendo que tiene la respuesta para los elementos 1 y 2.

Te darás cuenta de que los algoritmos Base Case y Build a menudo conducen a algoritmos recursivos naturales.

**Ejemplo: Diseñe un algoritmo para imprimir todas las permutaciones de una cadena. Para simplificar, suponga que todos los caracteres son únicos.**

Considere la siguiente cadena: abcdefg

- <span>⏺</span> Caso "a" → &lbrace; a}

- <span>⏺</span> Caso "ab" → &lbrace; ab, ba}

- <span>⏺</span> Caso "abc" → ?

Este es el primer caso interesante. Si tuviéramos la respuesta a las permutaciones "ab", ¿cómo podríamos generar las permutaciones "abc"? Bueno, la letra adicional es c, así que podemos meter c en todos los puntos posibles. Es decir:

- <span>⏺</span> merge(c, ab) → cab, acb, abc

- <span>⏺</span> merge(c, ba) → cba, bca, bac

Podemos utilizar un algoritmo recursivo para resolver este problema. Primero, generamos todas las permutaciones de una cadena cortando el último carácter y generando todas las permutaciones de s[1 . . . n - 1]. A continuación, inserta s[n] en cada posición de la cadena permutada.

### Método 4: Tormenta de ideas sobre estructuras de datos

Hay que admitir que el método de Tormenta de Ideas de Estructuras de Datos es un poco complicado, pero a menudo funciona. En este enfoque, simplemente recorremos una lista de estructuras de datos e intentamos aplicar cada una de ellas. Este enfoque funciona porque muchos algoritmos son bastante sencillos una vez que encontramos la estructura de datos adecuada.

Un buen indicio de que puedes aplicar la tormenta de ideas de estructuras de datos es que el entrevistador no haya especificado una estructura de datos para los datos. Esto significa que probablemente tendrás que idear una estructura de datos, que podría ser la clave del problema.

**Ejemplo: Estás construyendo una clase con dos funciones: add-Number(n) y getMedian(). El método addNumber(n) será llamado periódicamente por alguna función externa con un valor entero. Cuando se llama a getMedian(), se necesita devolver eficientemente la mediana de todos los números anteriores. (Si usted tiene un número impar de valores, la mediana es el medio exacto de los valores ordenados. Si tienes un número par de valores, la mediana es la media entre los dos valores medios). ¿Cómo se implementan estos dos métodos?**

Repasemos las estructuras de datos más comunes y veamos si sería útil utilizar alguna de ellas.

- <span>⏺</span> **¿Lista enlazada?** Probablemente las listas no enlazadas no suelen funcionar muy bien a la hora de acceder y ordenar números.

- <span>⏺</span> **¿Matriz?** Tal vez, si mantenemos los elementos ordenados. Pero probablemente sea caro. Dejémoslo para cuando sea necesario.

- <span>⏺</span> **¿Arbol binario?** Esto es posible, ya que los árboles binarios hacen bastante bien con el ordenamiento. De hecho, si el árbol de búsqueda binario está perfectamente equilibrado, la parte superior podría ser la mediana. Pero cuidado: si hay un número par de elementos, la mediana es en realidad la media de los dos elementos centrales. Los dos elementos centrales no pueden estar en la cima. Podría haber un algoritmo viable, pero volvamos a ello.

- <span>⏺</span> **¿Un montón?** Un montón es realmente bueno en el ordenamiento básico y el seguimiento de máximos y mínimos. Esto es realmente interesante: si tuvieras dos montones, podrías hacer un seguimiento de la mitad mayor y la mitad menor de los elementos. La mitad mayor se guarda en un montón mínimo, de forma que el elemento más pequeño de la mitad mayor esté en la raíz. La mitad más pequeña se guarda en un montón máximo, de forma que el elemento más grande de la mitad más pequeña esté en la raíz. Ahora, con estas estructuras de datos, tienes los elementos medianos potenciales en las raíces. Si los montones ya no tienen el mismo tamaño, puedes reequilibrarlos rápidamente sacando un elemento de un montón y poniéndolo en el otro.

Ten en cuenta que cuantos más problemas hagas, más desarrollado estará tu instinto sobre qué estructura de datos aplicar. Las tablas hash, los árboles, los tries y los montones son algunas de las mejores estructuras de datos para resolver problemas.

## Diseño orientado a objetos

Las cuestiones de diseño orientado a objetos (DPO) son de dos tipos: OOD para una pieza de software y OOD para un objeto del mundo real. A pesar de la aparente gran diferencia entre estos temas, se abordan de la misma manera:

- <span>⏺</span> **¿Cuáles son tus objetivos?** Imagina, por ejemplo, que te piden que diseñes las clases para una baraja de cartas genérica. ¿Qué tipo de cartas? ¿Son cartas estándar, cartas UNO o de otro tipo? ¿Cómo de genérica tiene que ser?

- <span>⏺</span> ¿Cuáles son los objetos principales? Por ejemplo, si estás haciendo el OOD para un restaurante, tus objetos principales podrían ser Restaurante, Patrón, Fiesta, Anfitrión, Servidor, Camarero, Mesa, y así sucesivamente. Cada uno de ellos se convertirá en una clase.

- <span>⏺</span> **¿Cómo se relacionan los objetos entre sí?** Probablemente sólo haya un Restaurante, por lo que puede ser una clase singleton. El restaurante tiene muchos camareros, un anfitrión, muchos camareros, muchas mesas, muchas fiestas y muchos clientes. (Nota: Esto es sólo una suposición; hable con su interlocutor al respecto.) Cada Mesa tiene un Servidor y una Parte. Busque y elimine redundancias. Por ejemplo, el Restaurante puede no necesitar una lista de Clientes, ya que puede obtenerla de la lista de Partes.

- <span>⏺</span> **¿Cómo interactúan los objetos?** Piense en las principales acciones que tienen lugar en el restaurante. Por ejemplo, un cliente hace una reserva con un anfitrión. El Anfitrión sienta al Cliente en una Mesa y le asigna un Servidor. Cada una de estas acciones se corresponde con uno o varios métodos. Al repasar estos métodos, es posible que descubra que ha omitido algunos objetos o que su diseño no es del todo correcto. No pasa nada, ¡ahora es un buen momento para añadirlos!

- <span>⏺</span> **¿Hay algún algoritmo complicado?** En algunos casos, puede haber un algoritmo que afecte al diseño. Por ejemplo, la implementación de findNextReservation(int partySize) puede requerir algunos cambios en la forma en que se hace referencia a las reservas. Comente estos detalles con su entrevistador.

Recuerde que las preguntas de diseño orientado a objetos requieren mucha comunicación con su entrevistador acerca de lo flexible que debe ser su diseño y cómo equilibrar ciertas compensaciones. No existe una respuesta "correcta" a una pregunta de diseño orientado a objetos.

## Preguntas sobre escalabilidad

Las preguntas sobre escalabilidad pueden intimidar mucho a los candidatos, especialmente a los recién licenciados o a los que no han hecho mucho diseño de grandes sistemas. Te pueden hacer preguntas muy amplias, como diseñar Google Maps. O las preguntas pueden ser más específicas, como diseñar un rastreador web.

Fundamentalmente, se trata de preguntas de resolución de problemas y pueden abordarse como tales. No son pruebas de conocimientos. Por ejemplo, Google no espera que conozcas tecnologías de Google como MapReduce y BigTable.

### Preparación

Una de las mejores cosas que puedes hacer es leer cómo se implementaron los sistemas del mundo real. ¿Cuáles son los componentes que intervienen en el diseño? ¿Por qué tomaron los diseñadores las decisiones que tomaron? ¿Cuáles fueron las compensaciones?

Estos sistemas pueden ser productos importantes (por ejemplo, Twitter, Google Maps) o componentes de productos existentes (por ejemplo, MapReduce, BigTable).

Cuanto más analices cómo se diseñan otros sistemas, mejor podrás diseñar uno nuevo. De nuevo, no se trata de memorizar cómo están diseñados estos sistemas. Tienes que analizar por qué se han diseñado así.

### Cómo enfocarlo

Una estructura general como la siguiente secuencia de cuatro pasos funciona bien:

1. **Analice el problema.** No se puede construir un sistema sin saber qué debe hacer. Al tiempo que formula las preguntas necesarias, haga una lista de los algoritmos o componentes necesarios. Por ejemplo, si estás diseñando Google Maps, puede que necesites dirigir a las personas, mostrar mapas, recopilar datos de tráfico, etc.
2. **Estructura la arquitectura.** Esboza cuáles son los componentes clave del problema. Por ejemplo, puede que tengas un almacén de datos, un rastreador, una pieza de front-end para obtener datos de la estructura de datos, etcétera. Este es un buen momento para levantarse y utilizar la pizarra. Hará que tu proceso de pensamiento sea claro y organizado, tanto para ti como para el entrevistador.
3. **Identifique los problemas clave.** Describa cuáles son los problemas clave a los que se enfrentará el sistema. ¿Se trata de una aplicación que requiere mucha lectura o mucha escritura? ¿Qué significa eso? ¿Cuáles son los cuellos de botella o los recursos críticos? ¿Necesita distribuir su base de datos entre varias máquinas?
4. **Resuelva los problemas.** Una vez identificados los problemas, es hora de resolverlos. Si no está claro de cuál debes hablar, pregúntale a tu entrevistadora qué le gustaría que hicieras.

Aunque esta estructura se proporciona de forma lineal, no tienes por qué ceñirte a ella de forma absoluta. La identificación de una cuestión clave puede dar lugar a un ajuste en la arquitectura central, o puede que tengas preguntas de seguimiento para tu entrevistadora. Dé prioridad a la comunicación a lo largo de este proceso.

## Entrevistas sobre pruebas

Los trabajos relacionados con las pruebas tienen muchos nombres y se confunden fácilmente, pero pueden agruparse en dos áreas:

1. **Garantía de calidad/ingeniero de pruebas de software/probador.** En estos puestos se diseñan y ejecutan planes de pruebas. No se puede probar todo lo que hay en un programa informático; hay demasiadas configuraciones diferentes. Los probadores dan prioridad a los aspectos más importantes del software que hay que probar y luego los llevan a cabo.
2. **Ingeniero de software en pruebas/ingeniero de diseño de software en pruebas.** Las personas que ocupan estos puestos son programadores -escriben código todo el día-, pero en lugar de crear funciones, escriben código de automatización. Por ejemplo, pueden probar Microsoft Word creando automáticamente un conjunto de archivos grandes y automatizando Word para que abra, procese y cierre los archivos repetidamente.

No te fíes por completo de los nombres de los puestos que acabas de dar. En una empresa concreta, un ingeniero de software en pruebas puede dedicarse más a las pruebas manuales y menos a las pruebas de código automatizado.

Si un trabajo específico de pruebas requiere codificación (independientemente del nombre del puesto), es posible que te hagan preguntas de codificación. Esto significa que tendrás que practicar la codificación, los algoritmos y las estructuras de datos, además de todos los problemas habituales de las pruebas. Si eres evaluador, hazte un favor y asegúrate de practicar la codificación: es una forma excelente de diferenciarte.

Además, se le plantearán preguntas de comprobación de las tres categorías siguientes:

1. ¿Cómo probaría este objeto del mundo real?
2. Explica cómo probarías este programa informático.
3. Probar un método (posiblemente uno que acabe de escribir).

En algunos casos, también se pueden plantear preguntas de prueba a los desarrolladores.

### Probar un objeto real

¿Qué tiene que ver probar clips y bolígrafos con probar Office o Gmail? Quizás no mucho, pero tu entrevistador seguro que piensa que sí.

Tu entrevistador está utilizando esta pregunta para poner a prueba tu capacidad para lidiar con la ambigüedad, para entender tu capacidad para pensar en el comportamiento esperado e inesperado y, como siempre, para poner a prueba tu capacidad para estructurar y comunicar tus pensamientos.

Analicemos este enfoque de seis pasos recomendado para un problema de ejemplo: probar un bolígrafo.

1. Haz preguntas para entender qué es el objeto. Un bolígrafo no parece tan ambiguo, pero lo es. Un bolígrafo puede ser cualquier cosa, desde una estilográfica hasta un rotulador para niños con varios colores o un bolígrafo para astronautas. Haga preguntas a su entrevistador para resolver esta ambigüedad.
2. ¿Quién lo utiliza y qué hace con él? Los niños pequeños con poca destreza dibujan con él, así que probablemente tenga que ser bonito y grueso. Probablemente dibujen sobre papel en el suelo, pero esto significa que pueden acabar dibujando un poco en el propio suelo.
3. ¿Cuáles son los usos inesperados? Comérselo: los niños se llevan cualquier cosa a la boca. Dibujar sobre otros niños o sobre las paredes (como descubrió una vez mi madre en casa de una amiga cuando interrumpió a mi hermana jugando a un divertido juego llamado "¿Puedo dibujar una línea continua que atraviese todo el piso de arriba?"). Pisotearlo. Tirarla.
4. ¿Existen otros casos de estrés? Piensa en el calor, el frío, etc. No todos ellos serán aplicables a todos los problemas.
5. ¿Puede fallar con elegancia? Lo ideal sería que nuestro bolígrafo no se rompiera nunca. Pero si lo hace, ¿podemos evitar que explote?
6. ¿Cuáles son los casos de prueba? Llegados a este punto, hemos descubierto que probablemente queramos probar al menos los siguientes elementos:
  - <span>⏺</span> *Que no sea tóxico.* Quizás debatamos los ingredientes con el servicio de toxicología, que podría ofrecernos pruebas más específicas si fuera necesario.
  - <span>⏺</span> *Lavable.* Prueba el dibujo en suelos, paredes, ropa y piel.
  - <span>⏺</span> *Espesor.* Probablemente querremos realizar una serie de pruebas para saber qué anchuras resultan incómodas para los niños, además de probar en vivo nuestro prototipo de rotulador.
  - <span>⏺</span> *Suavidad/ligereza.* El material debe ser un plástico ligero, para que no duela demasiado si te golpea.
  - <span>⏺</span> *Durabilidad.* El bolígrafo no debe romperse fácilmente. Debemos discutir con nuestro entrevistador cuánta presión debe soportar.
  - <span>⏺</span> *Fugas.* Si el bolígrafo se rompe, queremos asegurarnos de que la tinta no hace daño.

Puede que te hayas dado cuenta de cómo las pruebas se integran en el diseño: es de esperar. Al fin y al cabo, los probadores tienen que analizar si el objeto se ajusta a los requisitos de diseño.

### Probar un programa informático

Ahora que ya nos hemos quitado de encima lo que muchos consideran las preguntas más difíciles, probar una pieza de software no es terriblemente difícil. De hecho, se aborda de la misma manera que una pregunta sobre un objeto del mundo real.

**Ejemplo: Explique cómo probaría un cliente de correo electrónico.**

1. **Haga preguntas para resolver ambigüedades.** No todos los clientes de correo electrónico son iguales. ¿Es un cliente de correo electrónico corporativo? ¿Un cliente de correo electrónico personal? ¿Es un cliente de correo electrónico web o de escritorio?
2. **¿Quién es el usuario?** Un usuario corporativo tendrá necesidades muy diferentes a las de un usuario personal, en términos de seguridad, almacenamiento, mantenimiento, etc.
3. **¿Qué características tiene?** Algunas funciones se pueden dar por supuestas (consultar el correo electrónico, enviarlo, etc.), pero otras requieren más tiempo de conversación. ¿El correo electrónico está en un servidor? ¿Está cifrado?
4. **¿Hay usos inesperados o casos de estrés?** En el caso de un cliente de correo electrónico, esto puede significar una avalancha de mensajes, archivos adjuntos enormes y cosas por el estilo.
5. **Cuando hay fallos, ¿cómo se puede fallar con elegancia?** Si un archivo es demasiado grande para ser manejado por el cliente de correo electrónico, querrás asegurarte de que falla correctamente. Es decir, que el cliente rechace como mucho el archivo adjunto, pero que no se bloquee permanentemente.
6. **¿Qué puede automatizarse y qué debe probarse manualmente?** Por supuesto, hay un conjunto casi interminable de cosas que se pueden probar; después de todo, las empresas tienen equipos completos para hacerlo. Lo importante es centrarse en los elementos más importantes (o más interesantes) y estudiar cómo probarlos. ¿Qué puede automatizarse y qué debe probarse manualmente?

### Probar un método

Después de escribir el código, es posible que te pidan que lo pruebes o que simplemente generes los casos de prueba. En tus casos de prueba, recuerda tener en cuenta lo siguiente.

**Ejemplo: Probar un método que ordena una matriz.**

1. **Haga preguntas para resolver la ambigüedad.** ¿La matriz debe ordenarse de forma ascendente o descendente? ¿Cuáles son las expectativas en cuanto a tiempo, uso de memoria, etc.? ¿Qué tipo de datos debe tener la matriz?
2. **¿Qué hay que comprobar?** Haz una lista de todo lo que hay que comprobar. En muchos casos, esto puede ser sólo el resultado (por ejemplo, ¿está ordenado el array?), pero en otros casos puede que quieras comprobar otros efectos secundarios (por ejemplo, uso de memoria, cambio de otros datos, etc.).
3. **Escribe los casos esperados.** Este es el más fácil: uno de tus casos de prueba debería ser simplemente un array sin ordenar.
4. **Escribe los casos extremos.** Comprueba si hay matrices nulas o vacías, matrices enormes, matrices ya ordenadas, etc.

## Preguntas y respuestas

### Demasiada preparación, poco tiempo

<article class="optionOne">
Llevo unos años trabajando como programador de software en una empresa de consultoría, pero mi trabajo es aburrido y principalmente de mantenimiento de código. El poco código que escribo está en C, no hay programación orientada a objetos. No siento que esté aprendiendo mucho y, desde luego, no estoy ascendiendo.

Mi sueño es trabajar para una gran empresa como Microsoft. Creo que necesitaría meses para prepararme para estas entrevistas. ¿Debería dejarlo ahora para poder centrarme en prepararme?
</article>

<article class="optionDos">
Voy a ser sincera: no me entusiasma la idea de dejarlo para preparar las entrevistas. En primer lugar, Microsoft y empresas similares contratan a menos del 5% de los candidatos. Incluso con mucha preparación, tus posibilidades son escasas. En segundo lugar, puede que tengas que dar una explicación a los entrevistadores de por qué lo dejas, y "para prepararme para ti" no es una buena razón. En tercer lugar, el valor de una preparación intensiva y a largo plazo depende realmente de cuáles sean tus puntos débiles. Lo único que has mencionado es la falta de conocimientos sobre programación orientada a objetos, y probablemente no necesites meses para aprender eso.

Yo recomendaría dejarlo sólo si las tres afirmaciones siguientes son ciertas:

1. Sabes que puedes encontrar un trabajo igual de bueno que el actual sin necesidad de prepararte.
2. No puedes prepararte simultáneamente con el trabajo.
3. Te llevará mucho tiempo prepararte.

Si has decidido dejarlo, te recomiendo que hagas algo un poco más tangible con tu tiempo. En lugar de centrarte únicamente en superar las entrevistas, dedica tu tiempo a crear lo que podría ser una empresa. Construye un programa informático o un sitio web y utilízalo como herramienta principal para aprender lo que necesitas saber (programación orientada a objetos, etc.).

La ventaja de esto es que cuando los empresarios te pregunten qué has estado haciendo desde que lo dejaste, podrás decirles que querías intentar crear una empresa, pero que te diste cuenta de que no era para ti (descubriste que prefieres trabajar con equipos más grandes, etc.). Y tendrás algo tangible que enumerar en tu currículum que mostrará experiencia y enmascarará cualquier laguna.
</article>

### Conócelo todo

<article class="optionOne">
Para preparar mi entrevista con Google, he repasado todos mis cursos anteriores de informática. He dedicado la mayor parte del tiempo a los algoritmos y, en concreto, a la programación dinámica y al equilibrio de árboles. Aún no estoy seguro de ser capaz de resolver un problema como este durante una entrevista.

¿Cómo afrontan estas preguntas los candidatos con éxito?
</article>

<article class="optionOne">
Demos un paso atrás y pongámonos en la mente de nuestros entrevistadores. Quieren saber si somos inteligentes y si sabemos programar. Tener conocimientos específicos no es importante, a menos que sean (1) necesarios para desempeñar bien el trabajo o (2) tan integrales para una formación básica en informática que probablemente los conozcas.

Insertar un elemento en un árbol entra en la categoría 2. En realidad, los árboles no se utilizan tan a menudo en la industria, pero son tan fundamentales, ¿cómo no conocerlos?

El equilibrado de árboles, sin embargo, no entra en esta categoría. Deberías saber que el equilibrado de árboles existe, y deberías saber básicamente cómo funciona (rotaciones cuando los lados son demasiado desiguales), pero los pequeños detalles no son tan esenciales de conocer. Sáltatelo.

Las preguntas complejas de programación dinámica -las que se leen en los grandes libros de algoritmos- suelen ser demasiado complejas para una entrevista. Pueden surgir, pero no suelen ser buenas preguntas.

Sin embargo, las preguntas sencillas de programación dinámica -memorización (o almacenamiento en caché de resultados entre llamadas recursivas)- pueden surgir. Vale la pena dedicar un poco de tiempo a practicar esas preguntas, pero no son tan complejas como se podría suponer.

Recuerda también que el código en una entrevista es relativamente corto. Normalmente no se escriben más de 20 líneas. Entre diseñar un algoritmo, probar el código y corregir errores, no hay tiempo suficiente para escribir mucho más que eso.

Así que relájate. Céntrate en prepararte para las preguntas normales, las que puedes responder en 45 minutos.
</article>

### Información engañosa

<article class="optionOne">
Me entrevistaron en Microsoft y me hicieron una pregunta difícil. Empecé a pensar en una solución de fuerza bruta, y el entrevistador dijo que la fuerza bruta estaba bien. Empecé a escribir el código y, antes de terminar, el entrevistador empezó a bombardearme a preguntas. Sus preguntas me llevaron a una solución mejor. También me di cuenta más tarde de que tenía algunos fallos y otros errores en mi código, pero parecían bastante menores.

Creo que me engañó al decirme que mi solución inicial de fuerza bruta estaba bien, y como resultado acabé siendo rechazado. ¿Tengo alguna posibilidad de presentar un argumento?
</article>

<article class="optionDos">
Hay muchas cosas en juego en esta pregunta, así que voy a desglosarlas.

¿Te engañó tu entrevistador al decirte que la fuerza bruta estaba bien (cuando en realidad no lo estaba)?
Es posible que tuvieras un mal entrevistador que no te dirigió correctamente. Los malos entrevistadores existen, incluso en las mejores empresas. Sospecho que tu entrevistador probablemente buscaba saber si te darías cuenta y buscarías una solución más óptima, o si te conformarías con una solución suficientemente buena. Dependiendo de lo avanzado que estuvieras en la entrevista, el entrevistador también puede haber estado pensando: "Vale, no tenemos mucho tiempo y quiero asegurarme de que veo el código de este candidato. Déjeme animarle a que se ponga manos a la obra".

¿Esto hizo que le rechazaran?
De nuevo, es muy difícil decir que esto realmente causó el rechazo. En primer lugar, normalmente entre el 50% y el 75% de los candidatos son rechazados en cada fase, así que es casi como si tuvieras que hacer las cosas muy, muy bien para no ser rechazado. En segundo lugar, es poco probable que un solo problema sea la causa del rechazo. Como has señalado, tenías algunos fallos y otros errores. Supongo que lo que pensó tu entrevistador fue más bien "Hmm, este chico me cae bien, pero su solución no es muy buena, y tiene algunos fallos en el código y otros errores".

¿Puedes argumentarlo?
No te lo recomiendo. Digas lo que digas a tu reclutador, es casi seguro que se pondrá de parte de tu entrevistador. Lo más probable es que eches a perder tu buena reputación en la empresa, y no merece la pena.

Siento que las cosas no te hayan salido bien, pero no estás solo. Las entrevistas son difíciles y, por desgracia, muy aleatorias. La mayoría de mis compañeros de Google admitieron que no creían que pasarían las entrevistas la segunda vez. Por suerte, la mayoría de las empresas lo entienden y te permiten volver a presentarte en un plazo de entre seis meses y un año.
</article>

</Layoutcarrera>