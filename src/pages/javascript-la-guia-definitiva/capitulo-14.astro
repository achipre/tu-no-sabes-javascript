---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-13" capSiguiente="capitulo-15" />
  <section class="fadeIn">
    <h1>Metaprogramación</h1>
    <p>Este capítulo cubre una serie de características avanzadas de JavaScript que no se utilizan habitualmente en la programación diaria, pero que pueden ser valiosas para los programadores que escriben bibliotecas reutilizables y de interés para cualquiera que quiera juguetear con los detalles sobre cómo se comportan los objetos de JavaScript.</p>
    <p>Muchas de las características descritas aquí pueden describirse vagamente como "metaprogramación": si la programación normal consiste en escribir código para manipular datos, la metaprogramación consiste en escribir código para manipular otro código. En un lenguaje dinámico como JavaScript, los límites entre programación y metaprogramación son difusos: incluso la simple capacidad de iterar sobre las propiedades de un objeto con un bucle <codeinline>for/in</codeinline> podría ser considerada "meta" por programadores acostumbrados a lenguajes más estáticos.</p>
    <p>Los temas de metaprogramación tratados en este capítulo incluyen:</p>
    <ul>
      <li class="font-normal"><a href="#1">§14.1</a> Control de la enumerabilidad, suprimibilidad y configurabilidad de las propiedades de los objetos</li>
      <li class="font-normal"><a href="#2">§14.2</a> Control de la extensibilidad de los objetos y creación de objetos "sellados" y "congelados</li>
      <li class="font-normal"><a href="#3">§14.3</a> Consultar y establecer los prototipos de los objetos</li>
      <li class="font-normal"><a href="#4">§14.4</a> Ajustar el comportamiento de los tipos con símbolos conocidos</li>
      <li class="font-normal"><a href="#5">§14.5</a> Creación de DSL (lenguajes específicos de dominio) con funciones de etiquetas de plantilla</li>
      <li class="font-normal"><a href="#6">§14.6</a> Sondear objetos con métodos <codeinline>reflect</codeinline></li>
      <li class="font-normal"><a href="#7">§14.7</a> Controlar el comportamiento de los objetos con Proxy</li>
    </ul>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>14.1 Atributos de la propiedad</h2>
    <p>Las propiedades de un objeto JavaScript tienen nombres y valores, por supuesto, pero cada propiedad también tiene tres atributos asociados que especifican cómo se comporta y qué se puede hacer con ella:</p>
    <ul>
      <li class="font-normal">El atributo writable especifica si el valor de una propiedad puede cambiar o no.</li>
      <li class="font-normal">El atributo enumerable especifica si la propiedad está enumerada por el atributo bucle for/in y el método Object.keys().</li>
      <li class="font-normal">El atributo configurable especifica si una propiedad puede ser eliminada y también si los atributos de la propiedad pueden ser modificados.</li>
    </ul>
    <p>Las propiedades definidas en literales de objeto o por asignación ordinaria a un objeto son escribibles, enumerables y configurables. Pero muchas de las propiedades definidas por la biblioteca estándar Java Script no lo son.</p>
    <p>Esta sección explica la API para consultar y establecer atributos de propiedades. Esta API es especialmente importante para los autores de bibliotecas porque:</p>
    <ul>
      <li class="font-normal">Les permite añadir métodos a los objetos prototipo y hacerlos no enumerables, como los métodos incorporados.</li>
      <li class="font-normal">Les permite "bloquear" sus objetos, definiendo propiedades que no pueden modificarse ni suprimirse.</li>
    </ul>
    <p>Recuerda de §6.10.6 que, mientras que las "propiedades de datos" tienen un valor, las "propiedades accesorias" tienen un método getter y/o setter. Para los propósitos de esta sección, vamos a considerar los métodos getter y setter de una propiedad accessor como atributos de la propiedad. Siguiendo esta lógica, incluso diremos que el valor de una propiedad de datos también es un atributo. Así, podemos decir que una propiedad tiene un nombre y cuatro atributos. Los cuatro atributos de una propiedad de datos son value, writable, enumerable y configurable. Las propiedades accesorias no tienen un atributo de valor ni un atributo de escritura: su escritura viene determinada por la presencia o ausencia de un definidor. Así que los cuatro atributos de una propiedad accessor son get, set, enumerable y configurable.</p>
    <p>Los métodos de JavaScript para consultar y establecer los atributos de una propiedad utilizan un objeto denominado descriptor de propiedad para representar el conjunto de cuatro atributos. Un objeto descriptor de propiedad tiene propiedades con los mismos nombres que los atributos de la propiedad que describe. Así, el objeto descriptor de propiedad de una propiedad de datos tiene propiedades denominadas valor, escribible, enumerable y configurable. Y el descriptor de una propiedad accessor tiene propiedades get y set en lugar de value y writable. Las propiedades writable, enumerable y configurable son valores booleanos, y las propiedades get y set son valores de función.</p>
    <p>Para obtener el descriptor de propiedad de una propiedad con nombre de un objeto especificado, llame a Object.getOwnPropertyDescriptor():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Como su nombre indica, Object.getOwnPropertyDescriptor() sólo funciona para las propiedades propias. Para consultar los atributos de las propiedades heredadas, debe tra- verse explícitamente la cadena de prototipos. (Véase Object.getPrototypeOf() en §14.3); véase también la función similar Reflect.getOwnPropertyDescriptor() en §14.6).</p>
    <p>Para establecer los atributos de una propiedad o crear una nueva propiedad con los atributos especificados, llame a Object.defineProperty(), pasando el objeto a modificar, el nombre de la propiedad a crear o alterar y el objeto descriptor de la propiedad:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El descriptor de propiedad que pasas a Object.defineProperty() no tiene por qué incluir los cuatro atributos. Si estás creando una nueva propiedad, los atributos omitidos se toman como falsos o indefinidos. Si estás modificando una propiedad existente, entonces los atributos que omitas simplemente se dejan sin cambios. Tenga en cuenta que este método modifica una propiedad propia existente o crea una nueva propiedad propia, pero no modificará una propiedad heredada. Véase también la función muy similar Reflect.defineProperty() en §14.6.</p>
    <p>Si desea crear o modificar más de una propiedad a la vez, utilice Object.define Properties(). El primer argumento es el objeto que se va a modificar. El segundo argumento es un objeto que asigna los nombres de las propiedades que se van a crear o modificar a los descriptores de propiedad de dichas propiedades. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este código comienza con un objeto vacío, al que añade dos propiedades de datos y una propiedad accesoria de sólo lectura. Se basa en el hecho de que Object.defineProperties() devuelve el objeto modificado (al igual que Object.defineProperty()).</p>
    <p>El método Object.create() fue introducido en §6.2. Allí aprendimos que el primer argumento de ese método es el objeto prototipo del objeto recién creado. Este método también acepta un segundo argumento opcional, que es el mismo que el segundo argumento de Object.defineProperties(). Si pasas un conjunto de descriptores de propiedades a Object.create(), entonces se utilizan para añadir propiedades al objeto recién creado.</p>
    <p>Object.defineProperty() y Object.defineProperties() lanzan TypeError si el intento de crear o modificar una propiedad no está permitido. Esto ocurre si se intenta añadir una nueva propiedad a un objeto no extensible (véase §14.2). Las otras razones por las que estos métodos pueden lanzar TypeError tienen que ver con los propios atributos. El atributo writable gobierna los intentos de cambiar el atributo value. Y el atributo configurable gobierna los intentos de cambiar los otros atributos (y también especifica si una propiedad puede ser borrada). Sin embargo, las reglas no son del todo sencillas. Por ejemplo, es posible cambiar el valor de una propiedad no escribible si dicha propiedad es configurable. También es posible cambiar una propiedad de escribible a no escribible incluso si esa propiedad no es configurable.</p>
    <p>Aquí están las reglas completas.</p>
    <p>Las llamadas a Object.defineProperty() o Object.defineProperties() que intentan violarlas lanzan un TypeError:</p>
    <ul>
      <li class="font-normal">Si un objeto no es extensible, puede editar sus propiedades existentes, pero no puede añadirle propiedades nuevas.</li>
      <li class="font-normal">Si una propiedad no es configurable, no podrá modificar sus atributos configurables o enumerables.</li>
      <li class="font-normal">Si una propiedad accessor no es configurable, no puedes cambiar su método getter o setter, y no puedes cambiarla a una propiedad de datos.</li>
      <li class="font-normal">Si una propiedad de datos no es configurable, no podrá cambiarla por una propiedad accessor.</li>
      <li class="font-normal">Si una propiedad de datos no es configurable, no podrás cambiar su atributo writable de false a true, pero sí de true a false.</li>
      <li class="font-normal">Si una propiedad de datos no es configurable ni escribible, no puede cambiar su valor. Sin embargo, puede cambiar el valor de una propiedad configurable pero no escribible (porque sería lo mismo que hacerla escribible, cambiar el valor y volver a convertirla en no escribible).</li>
    </ul>
    <p>En §6.7 se describe la función Object.assign() que copia valores de propiedades de uno o más objetos origen en un objeto destino. Object.assign() sólo copia propiedades enumerables y valores de propiedades, no atributos de propiedades. Esto es normalmente lo que queremos, pero significa, por ejemplo, que si uno de los objetos fuente tiene una propiedad accessor, es el valor devuelto por la función getter el que se copia en el objeto destino, no la propia función getter. El Ejemplo 14-1 demuestra cómo podemos utilizar Object.getOwnPropertyDescriptor() y Object.defineProperty() para crear una variante de Object.assign() que copia descriptores de propiedades enteros en lugar de sólo copiando valores de propiedades.</p>
    <p><em>Ejemplo 14-1. Copiar propiedades y sus atributos de un objeto a otro</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="2">
    <h2>14.2 Extensibilidad de objetos</h2>
    <p>El atributo extensible de un objeto especifica si se pueden añadir o no nuevas propiedades al objeto. Los objetos ordinarios de JavaScript son extensibles por defecto, pero puedes cambiarlo con las funciones descritas en esta sección.</p>
    <p>Para determinar si un objeto es extensible, páselo a Object.isExtensible(). Para hacer que un objeto no sea extensible, páselo a Object.preventExtensions(). Una vez hecho esto, cualquier intento de añadir una nueva propiedad al objeto lanzará un TypeError en modo estricto y simplemente fallará silenciosamente sin error en modo no estricto. Además, intentar cambiar el prototipo (ver §14.3) de un objeto no extensible siempre lanzará un TypeError.</p>
    <p>Tenga en cuenta que no hay manera de hacer un objeto extensible de nuevo una vez que lo ha hecho no extensible. Tenga en cuenta también que llamar a Object.preventExtensions() sólo afecta al objeto extensibilidad del propio objeto. Si se añaden nuevas propiedades al prototipo de un objeto no extensible, el objeto no extensible heredará esas nuevas propiedades.</p>
    <p>En §14.6 se describen dos funciones similares, Reflect.isExtensible() y Reflect.preventExten sions().</p>
    <p>El propósito del atributo extensible es poder "bloquear" objetos en un estado conocido y evitar manipulaciones externas. El atributo extensible de los objetos se utiliza a menudo junto con los atributos configurable y escribible de las propiedades, y JavaScript define funciones que facilitan la configuración conjunta de estos atributos:</p>
    <ul>
      <li class="font-normal">Object.seal() funciona como Object.preventExtensions(), pero además de hacer que el objeto no sea extensible, también hace que todas las propiedades propias de ese objeto no sean configurables. Esto significa que no se pueden añadir nuevas propiedades al objeto, y que las propiedades existentes no se pueden borrar ni configurar. Sin embargo, las propiedades existentes que se pueden escribir aún se pueden configurar. No hay forma de desprecintar un objeto sellado. Puede utilizar Object.isSealed() para determinar si un objeto está sellado.</li>
      <li class="font-normal">Object.freeze() bloquea aún más los objetos. Además de hacer el objeto no extensible y sus propiedades no configurables, también hace que todas las propiedades de datos del objeto sean de sólo lectura. (Si el objeto tiene propiedades accesorias con métodos setter, éstos no se ven afectados y pueden seguir siendo invocados mediante asignación a la propiedad). Utilice Object.isFrozen() para determinar si un objeto está congelado.</li>
    </ul>
    <p>Es importante entender que Object.seal() y Object.freeze() sólo afectan al objeto que se les pasa: no tienen efecto sobre el prototipo de ese objeto. Si quieres bloquear completamente un objeto, probablemente necesites sellar o congelar también los objetos de la cadena de prototipos.</p>
    <p>Object.preventExtensions(), Object.seal() y Object.freeze() devuelven el objeto que se les pasa, lo que significa que puede utilizarlos en invocaciones de funciones anidadas:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si estás escribiendo una librería JavaScript que pasa objetos a funciones callback escritas por los usuarios de tu librería, puedes usar Object.freeze() en esos objetos para evitar que el código del usuario los modifique. Esto es fácil y conveniente de hacer, pero hay desventajas: los objetos congelados pueden interferir con las estrategias comunes de pruebas de JavaScript, por ejemplo.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>14.3 El prototipo Atributo</h2>
    <p>El atributo prototipo de un objeto especifica el objeto del que hereda propiedades. (Revise §6.2.3 y §6.3.2 para más información sobre prototipos y herencia de propiedades.) Se trata de un atributo tan importante que normalmente decimos simplemente "el prototipo de o" en lugar de "el atributo prototipo de o". Recuerde también que cuando prototipo aparece en fuente de código, se refiere a una propiedad ordinaria del objeto, no al atributo prototipo: En el capítulo 9 se explica que la propiedad prototype de una función constructora especifica el atributo prototype de los objetos creados con ese constructor.</p>
    <p>El atributo prototype se establece cuando se crea un objeto. Los objetos creados a partir de literales de objeto utilizan Object.prototype como prototipo. Los objetos creados con new utilizan como prototipo el valor de la propiedad prototype de su función constructora. Y los objetos creados con Object.create() utilizan el primer argumento de esa función (que puede ser null) como su prototipo.</p>
    <p>Puede consultar el prototipo de cualquier objeto pasando ese objeto a Object.getProto typeOf():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Una función muy similar, Reflect.getPrototypeOf(), se describe en §14.6.</p>
    <p>Para determinar si un objeto es el prototipo de (o forma parte de la cadena de prototipos de) otro objeto, utilice el método isPrototypeOf():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Tenga en cuenta que isPrototypeOf() realiza una función similar a la del operador instanceof (véase §4.9.4).</p>
    <p>El atributo prototipo de un objeto se establece cuando se crea el objeto y normalmente permanece fijo. Sin embargo, puede cambiar el prototipo de un objeto con Object.set PrototypeOf():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Por lo general, no es necesario utilizar nunca Object.setPrototypeOf(). Las implementaciones de JavaScript pueden hacer optimizaciones agresivas basadas en la suposición de que el prototipo de un objeto es fijo e inmutable. Esto significa que si alguna vez llama a Object.setPrototypeOf(), cualquier código que utilice los objetos alterados puede ejecutarse mucho más lento de lo que lo haría normalmente.</p>
    <p>Una función similar, Reflect.setPrototypeOf(), se describe en §14.6.</p>
    <p>Algunas de las primeras implementaciones de JavaScript en navegadores mostraban el atributo prototype de un objeto a través de la propiedad proto (escrita con dos guiones bajos al principio y al final). Esto hace tiempo que ha quedado obsoleto, pero hay suficiente código en la web que depende de proto como para que el estándar ECMAScript lo exija para todas las implementaciones de JavaScript que se ejecuten en navegadores web. (Node también lo soporta, aunque el estándar no lo requiere para Node.) En JavaScript moderno, proto es legible y escribible, y puedes (aunque no deberías) usarlo como una alternativa a Object.get PrototypeOf() y Object.setPrototypeOf(). Un uso interesante de proto , sin embargo, es definir el prototipo de un literal de objeto:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="4">
    <h2>14.4 Símbolos conocidos</h2>
    <p>El tipo Symbol se añadió a JavaScript en ES6, y una de las principales razones para hacerlo fue añadir de forma segura extensiones al lenguaje sin romper la compatibilidad con el código ya desplegado en la web. Vimos un ejemplo de esto en el Capítulo 12, donde aprendimos que se puede hacer iterable una clase implementando un método cuyo "nombre" es el Symbol Symbol.iterator.</p>
    <p>Symbol.iterator es el ejemplo más conocido de los "Símbolos conocidos". Se trata de un conjunto de valores Symbol almacenados como propiedades de la función de fábrica Symbol() que se utilizan para permitir que el código JavaScript controle ciertos comportamientos de bajo nivel de objetos y clases. Las subsecciones siguientes describen cada uno de estos Símbolos conocidos y explican cómo pueden utilizarse.</p>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>14.4.1 Symbol.iterator y Symbol.asyncIterator</h2>
    <p>Los símbolos Symbol.iterator y Symbol.asyncIterator permiten a los objetos o clases hacerse iterables o asíncronamente iterables. Fueron cubiertos en detalle en el Capítulo 12 y §13.4.2, respectivamente, y se mencionan de nuevo aquí sólo para completar.</p>
  </section>
  <section id="4-2">
    <h2>14.4.2 Símbolo.hasInstance</h2>
    <p>Cuando se describió el operador instanceof en §4.9.4, dijimos que el lado derecho debe ser una función constructora y que la expresión o instanceof f se evaluaba buscando el valor f.prototype dentro de la cadena de prototipos de o. Esto sigue siendo cierto, pero en ES6 y posteriores, Symbol.hasInstance proporciona una alternativa. En ES6, si el lado derecho de instanceof es cualquier objeto con un método [Symbol.hasInstance], entonces ese método se invoca con el valor del lado izquierdo como argumento, y el valor de retorno del método, convertido a booleano, se convierte en el valor del operador instanceof. Y, por supuesto, si el valor del lado derecho no tiene un método [Symbol.hasInstance] sino que es una función, entonces el operador instanceof se comporta de la forma habitual.</p>
    <p>Symbol.hasInstance significa que podemos utilizar el operador instanceof para realizar una comprobación de tipos genérica con objetos pseudotipo convenientemente definidos. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observe que este ejemplo es inteligente pero confuso porque utiliza un objeto no- clase donde normalmente se esperaría una clase. Sería igual de fácil -y más claro para los lectores de su código- escribir una función isUint8() en lugar de depender de este comportamiento Symbol.hasIn stance.</p>
  </section>
  <section id="4-3" class="py-4 xs:py-5 sm:py-6">
    <h2>14.4.3 Símbolo.toStringTag</h2>
    <p>Si invocas el método toString() de un objeto JavaScript básico, obtienes la cadena "[objeto Objeto]":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si se invoca esta misma función Object.prototype.toString() como método de instancias de tipos incorporados, se obtienen algunos resultados interesantes:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Resulta que se puede utilizar esta técnica Object.prototype.toString().call() con cualquier valor JavaScript para obtener el "atributo de clase" de un objeto que contiene información de tipo que no está disponible de otro modo. La siguiente función classof() es posiblemente más útil que el operador typeof, que no distingue entre tipos de objetos:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Antes de ES6, este comportamiento especial del método Object.prototype.toString() sólo estaba disponible para instancias de tipos incorporados, y si llamabas a esta función classof() en una instancia de una clase que habías definido tú mismo, simplemente devolvía "Object". En ES6, sin embargo, Object.prototype.toString() busca una propiedad con el nombre simbólico Symbol.toStringTag en su argumento, y si tal propiedad existe, utiliza el valor de la propiedad en su salida. Esto significa que si defines una clase propia, puedes hacerla funcionar fácilmente con funciones como classof():</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="4-4">
    <h2>14.4.4 Símbolo.especie</h2>
    <p>Antes de ES6, JavaScript no proporcionaba ninguna forma real de crear subclases robustas de clases incorporadas como Array. En ES6, sin embargo, puedes extender cualquier clase incorporada simplemente usando las palabras clave class y extends. §9.5.2 lo demostró con esta simple subclase de Array:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Array define los métodos concat(), filter(), map(), slice() y splice(), que devuelven arrays. Cuando creamos una subclase de array como EZArray que hereda estos métodos, ¿debería el método heredado devolver instancias de Array o instancias de EZArray? Se pueden dar buenos argumentos para cualquiera de las dos opciones, pero la especificación ES6 dice que (por defecto) los cinco métodos que devuelven arrays devolverán instancias de la subclase.</p>
    <p>Así es como funciona:</p>
    <ul>
      <li class="font-normal">En ES6 y posteriores, el constructor Array() tiene una propiedad con el nombre simbólico Symbol.species. (Nótese que este Symbol se utiliza como nombre de una propiedad de la función constructora. La mayoría de los otros Símbolos bien conocidos descritos aquí se utilizan como nombre de métodos de un objeto prototipo).</li>
      <li class="font-normal">Cuando creamos una subclase con extends, el constructor resultante de la subclase hereda propiedades del constructor de la superclase. (Esto es adicional al tipo normal de herencia, donde las instancias de la subclase heredan métodos de la superclase). Esto significa que el constructor de cada subclase de Array también tiene una propiedad heredada con el nombre Symbol.species. (O una subclase puede definir su propia propiedad con este nombre, si lo desea).</li>
      <li class="font-normal">Métodos como map() y slice() que crean y devuelven nuevas matrices se han modificado ligeramente en ES6 y posteriores. En lugar de simplemente crear un Array normal, invocan (en efecto) a new this.constructor[Symbol.species]() para crear el nuevo array.</li>
    </ul>
    <p>Ahora viene lo interesante. Supongamos que Array[Symbol.species] fuera sólo una propiedad de datos regular, definida así:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>En ese caso, los constructores de las subclases heredarían el constructor Array() como su "especie", e invocar map() en una subclase de array devolvería una instancia de la superclase en lugar de una instancia de la subclase. Sin embargo, ES6 no se comporta así. La razón es que Array[Symbol.species] es una propiedad de sólo lectura cuya función getter simplemente devuelve esto. Los constructores de subclase heredan esta función getter, lo que significa que por defecto, cada constructor de subclase es su propia "especie".</p>
    <p>Sin embargo, a veces este comportamiento por defecto no es lo que quieres. Si quieres que los métodos de EZArray que devuelven arrays devuelvan objetos Array normales, sólo tienes que establecer EZArray[Symbol.species] a Array. Pero como la propiedad heredada es un accesor de sólo lectura, no puedes establecerla con un operador de asignación. Sin embargo, puedes utilizar define Property():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La opción más sencilla es probablemente definir explícitamente su propio getter Symbol.species al crear la subclase en primer lugar:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La creación de subclases útiles de Array fue el principal caso de uso que motivó la introducción de Symbol.species, pero no es el único lugar en el que s e utiliza este conocido Symbol. Las clases de array tipificadas utilizan Symbol de la misma forma que la clase Array. Del mismo modo, el método slice() de ArrayBuffer mira la propiedad Symbol.species de this.constructor en lugar de simplemente crear un nuevo ArrayBuffer. Y los métodos Promise como then() que devuelven nuevos objetos Promise también los crean a través de este protocolo de especies. Finalmente, si te encuentras subclasificando Map (por ejemplo) y definiendo métodos que devuelven nuevos objetos Map, puede que quieras usar Symbol.spe cies tú mismo para el beneficio de las subclases de tu subclase.</p>
  </section>
  <section id="4-5" class="py-4 xs:py-5 sm:py-6">
    <h2>14.4.5 Símbolo.isConcatSpreadable</h2>
    <p>El método Array concat() es uno de los métodos descritos en la sección anterior que utiliza Symbol.species para determinar qué constructor utilizar para el array devuelto. Pero concat() también utiliza Symbol.isConcatSpreadable. Recordemos de §7.8.3 que el método concat() de una matriz trata su valor this y sus argumentos de matriz de forma diferente a sus argumentos que no son de matriz: los argumentos que no son de matriz simplemente se añaden a la nueva matriz, pero la matriz this y cualquier argumento de matriz se aplanan o "extienden" de forma que se concatenan los elementos de la matriz en lugar del propio argumento de matriz.</p>
    <p>Antes de ES6, concat() simplemente usaba Array.isArray() para determinar si tratar un valor como un array o no. En ES6, el algoritmo ha cambiado ligeramente: si el argumento (o el valor this) a concat() es un objeto y tiene una propiedad con el nombre simbólico Symbol.isConcatSpreadable, entonces el valor booleano de esa propiedad se utiliza para determinar si el argumento debe ser "spread". Si no existe tal propiedad, entonces se utiliza Array.isArray() como en versiones anteriores del lenguaje.</p>
    <p>Este símbolo puede utilizarse en dos casos:</p>
    <ul>
      <li class="font-normal">Si crea un objeto tipo array (véase §7.9) y desea que se comporte como un array real cuando se pasa a concat(), puede simplemente añadir la propiedad simbólica a su objeto:</li>
      <pre>
      <code class="language-js"></code></pre>
      <li class="font-normal">Las subclases de array son extensibles por defecto, así que si estás definiendo una subclase de array que no quieres que actúe como un array cuando se usa con concat(), entonces puedes1 añadir un getter como este a tu subclase:</li>
      <pre>
      <code class="language-js"></code></pre>
    </ul>
  </section>
  <section id="4-6">
    <h2>14.4.6 Símbolos de coincidencia de patrones</h2>
    <p>§11.3.2 documentó los métodos String que realizan operaciones de concordancia de patrones usando un argumento RegExp. En ES6 y posteriores, estos métodos se han generalizado para trabajar con objetos RegExp o cualquier objeto que defina el comportamiento de concordancia de patrones mediante propiedades con nombres simbólicos. Para cada uno de los métodos de cadena match(), match All(), search(), replace(), y split(), hay un correspondiente Symbol bien conocido: Symbol.match, Symbol.search, etc.</p>
    <p>Los RegExps son una forma general y muy potente de describir patrones textuales, pero pueden ser complicados y no muy adecuados para las coincidencias difusas. Con los métodos de cadena generalizados, puede definir sus propias clases de patrones utilizando los conocidos métodos Symbol para realizar comparaciones personalizadas. Por ejemplo, puede realizar comparaciones de cadenas utilizando Intl.Collator (véase §11.7.3) para ignorar los acentos en la comparación. También puede definir una clase de patrón basada en el algoritmo Soundex para comparar palabras en función de sus sonidos aproximados o para emparejar libremente las cuerdas hasta una distancia Levenshtein determinada.</p>
    <p>En general, cuando se invoca uno de estos cinco métodos String en un objeto patrón como este:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>esa invocación se convierte en una invocación de un método con nombre simbólico en su objeto patrón:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Como ejemplo, considere la clase de concordancia de patrones del siguiente ejemplo, que implementa la concordancia de patrones utilizando los comodines simples * y ? que probablemente conozca de los sistemas de ficheros. Este estilo de concordancia de patrones se remonta a los primeros días del sistema operativo Unix, y los patrones a menudo se denominan globos:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="4-7" class="py-4 xs:py-5 sm:py-6">
    <h2>14.4.7 Símbolo.toPrimitive</h2>
    <p>En §3.9.3 se explica que JavaScript tiene tres algoritmos ligeramente diferentes para convertir objetos en valores primitivos. En términos generales, para las conversiones en las que se espera o se prefiere un valor de cadena, JavaScript invoca primero el método toString() de un objeto y vuelve al método valueOf() si toString() no está definido o no devuelve un valor primitivo. Para las conversiones en las que se prefiere un valor numérico, JavaScript prueba primero el método valueOf() y vuelve a toString() si valueOf() no está definido o si no devuelve un valor primitivo. Por último, en los casos en los que no hay preferencia, deja que la clase decida cómo realizar la conversión. Los objetos fecha se convierten primero con toString(), y todos los demás tipos prueban primero con valueOf().</p>
    <p>En ES6, el conocido Símbolo Symbol.toPrimitive le permite anular este comportamiento predeterminado de objeto a primitivo y le da un control completo sobre cómo las instancias de sus propias clases se convertirán en valores primitivos. Para ello, defina un método con este nombre simbólico. El método debe devolver un valor primitivo que represente de algún modo el objeto. El método que defina se invocará con un único argumento de cadena que le indicará qué tipo de conversión está intentando realizar JavaScript en su objeto:</p>
    <ul>
      <li class="font-normal">Si el argumento es "cadena", significa que JavaScript está realizando la conversión en un contexto en el que esperaría o preferiría (pero no requeriría) una cadena. Esto ocurre cuando se interpola el objeto en un literal de plantilla, por ejemplo.</li>
      <li class="font-normal">Si el argumento es "number", significa que JavaScript está realizando la conversión en un contexto en el que esperaría o preferiría (pero no requeriría) un valor numérico. Esto ocurre cuando se utiliza el objeto con un operador < o > o con operadores aritméticos como - y *.</li>
      <li class="font-normal">Si el argumento es "default", significa que JavaScript está convirtiendo su objeto en un contexto en el que podría funcionar un valor numérico o de cadena. Esto ocurre con los operadores +, == y !=.</li>
    </ul>
    <p>Muchas clases pueden ignorar el argumento y simplemente devolver el mismo valor primitivo en todos los casos. Si desea que las instancias de su clase sean comparables y ordenables con &lt; y >, entonces es una buena razón para definir un método [Symbol.toPrimitive].</p>
  </section>
  <section id="4-8">
    <h2>14.4.8 Símbolo.unscopable</h2>
    <p>El último Símbolo bien conocido que cubriremos aquí es uno oscuro que fue introducido como una solución para los problemas de compatibilidad causados por el estado obsoleto with. Recuerda que la sentencia with toma un objeto y ejecuta el cuerpo de la sentencia como si estuviera en un ámbito donde las propiedades de ese objeto fueran variables. Esto causaba problemas de compatibilidad cuando se añadían nuevos métodos a la clase Array, y rompía parte del código existente. Symbol.unscopables es el resultado. En ES6 y posteriores, el método</p>
    <p>La sentencia with se ha modificado ligeramente. Cuando se utiliza con un objeto o, una sentencia with computa Object.keys(o[Symbol.unscopables]||&lbrace;}) e ignora las propiedades cuyos nombres están en la matriz resultante al crear el ámbito simulado en el que ejecutar su cuerpo. ES6 utiliza esto para añadir nuevos métodos a Array.prototype sin romper el código existente en la web. Esto significa que usted puede encontrar una lista de los nuevos métodos de Array mediante la evaluación:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>14.5 Etiquetas de plantilla</h2>
    <p>Las cadenas entre comillas se conocen como "literales de plantilla" y se trataron en §3.3.4. Cuando una expresión cuyo valor es una función va seguida de un literal de plantilla, se convierte en una invocación a una función, y la llamamos "literal de plantilla etiquetado". Definir una nueva función de etiqueta para utilizarla con literales de plantilla etiquetados puede considerarse una metaprogresión, porque las plantillas etiquetadas se utilizan a menudo para definir DSL (lenguajes específicos de dominio) y definir una nueva función de etiqueta es como añadir una nueva sintaxis a JavaScript. Los literales de plantilla etiquetados han sido adoptados por varios paquetes de JavaScript front-end. El lenguaje de consulta GraphQL utiliza una función de etiqueta gql`` para permitir que las consultas se incrusten en el código JavaScript. Y la biblioteca Emotion utiliza una función de etiqueta css`` para permitir que los estilos CSS se incrusten en JavaScript. Esta sección muestra cómo escribir tus propias funciones de etiquetas como éstas.</p>
    <p>Las funciones de etiqueta no tienen nada de especial: son funciones normales de JavaScript y no se requiere una sintaxis especial para definirlas. Cuando una expresión de función va seguida de un literal de plantilla, se invoca la función. El primer argumento es una matriz de cadenas, seguida de cero o más argumentos adicionales, que pueden tener valores de cualquier tipo.</p>
    <p>El número de argumentos depende del número de valores que se interpolen en el literal de plantilla. Si el literal de plantilla es simplemente una cadena constante sin interpolaciones, la función de etiqueta se llamará con una matriz de esa cadena y sin argumentos adicionales. Si el literal de plantilla incluye un valor interpolado, la función de etiqueta se llama con dos argumentos. El primero es una matriz de dos cadenas y el segundo es el valor interpolado. Las cadenas de esa matriz inicial son la cadena a la izquierda del valor interpolado y la cadena a su derecha, y cualquiera de ellas puede ser la cadena vacía. Si la plantilla literal incluye dos valores interpolados, la función de etiqueta se invoca con tres argumentos: una matriz de tres cadenas y los dos valores interpolados. Las tres cadenas (que pueden estar vacías) son el texto a la izquierda del primer valor, el texto entre los dos valores y el texto a la derecha del segundo valor. En el caso general, si la plantilla literal tiene n valores interpolados, la función de etiqueta se invocará con n+1 argumentos. El primer argumento será una matriz de n+1 cadenas, y los argumentos restantes son los n valores interpolados, en el orden en que aparecen en el literal de plantilla.</p>
    <p>El valor de un literal de plantilla es siempre una cadena. Pero el valor de un literal de plantilla etiquetado es cualquier valor que devuelva la función de etiquetado. Esto puede ser una cadena, pero cuando la función de etiqueta se utiliza para implementar un DSL, el valor de retorno es típicamente una estructura de datos no cadena que es una representación analizada de la cadena.</p>
    <p>Como ejemplo de una función de etiqueta de plantilla que devuelve una cadena, considere la siguiente plantilla html``, que resulta útil cuando desea interpolar valores de forma segura en una cadena de HTML. La etiqueta realiza un escape HTML en cada uno de los valores antes de utilizarlo para construir la cadena final:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si desea ver un ejemplo de una función de etiqueta que no devuelve una cadena, sino una representación analizada de una cadena, recuerde la clase de patrones Glob definida en §14.4.6. Como el constructor Glob() toma un único argumento de cadena, podemos definir una función de etiqueta para crear nuevos objetos Glob. Dado que el constructor Glob() toma un único argumento de cadena, podemos definir una función de etiqueta para crear nuevos objetos Glob:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Una de las características mencionadas de pasada en §3.3.4 es la función de etiqueta String.raw`` que devuelve una cadena en su forma "cruda" sin interpretar ninguna de las secuencias de escape de la barra invertida. Esto se implementa utilizando una característica de la invocación de funciones de etiquetas que aún no hemos discutido. Cuando se invoca una función de etiqueta, hemos visto que su primer argumento es una matriz de cadenas. Pero esta matriz también tiene una propiedad llamada raw, y el valor de esa propiedad es otra matriz de cadenas, con el mismo número de elementos. La matriz de argumentos incluye cadenas en las que se han interpretado las secuencias de escape como es habitual. Y la matriz raw incluye cadenas en las que no se han inter- pretado secuencias de escape. Esta oscura característica es importante si quieres definir un DSL con una gramática que utilice barras invertidas. Por ejemplo, si quisiéramos que nuestra función de etiqueta glob`` soportara la coincidencia de patrones en rutas al estilo Windows (que usan barras invertidas en lugar de diagonales) y no quisiéramos que los usuarios de la etiqueta tuvieran que doblar cada barra invertida, podríamos reescribir esa función para usar strings.raw[] en lugar de strings[]. El lado negativo, por supuesto, sería que ya no podríamos usar escapes como \u en nuestros literales glob.</p>
  </section>
  <section id="6">
    <h2>14.6 La API de Reflect</h2>
    <p>El objeto Reflect no es una clase; al igual que el objeto Math, sus propiedades simplemente definen una colección de funciones relacionadas. Estas funciones, añadidas en ES6, definen una API para "reflexionar sobre" objetos y sus propiedades. Aquí hay poca funcionalidad nueva: el objeto Reflect define un cómodo conjunto de funciones, todas en un único espacio de nombres, que imitan el comportamiento de la sintaxis central del lenguaje y duplican las características de varias funciones Object preexistentes.</p>
    <p>Aunque las funciones Reflect no proporcionan ninguna característica nueva, agrupan las características en una práctica API. Y, lo que es más importante, el conjunto de funciones Reflect es idéntico al conjunto de métodos de gestión de proxy que conoceremos en §14.7.</p>
    <p>La API de Reflect consta de las siguientes funciones:</p>
    <p><codeinline>Reflect.apply(f, o, args)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función invoca la función f como un método de o (o la invoca como una función sin este valor si o es nulo) y pasa los valores de la matriz args como argumentos. Es equivalente a f.apply(o, args).</p>
    <p><codeinline>Reflect.construct(c, args, newTarget)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función invoca al constructor c como si se hubiera utilizado la palabra clave new y pasa los elementos del array args como argumentos. Si se especifica el argumento opcional newTarget, se utiliza como valor de new.target dentro de la invocación del constructor. Si no se especifica, el valor de new.target será c.</p>
    <p><codeinline>Reflect.defineProperty(o, nombre, descriptor)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función define una propiedad en el objeto o, utilizando name (una cadena o símbolo) como nombre de la propiedad. El objeto Descriptor debe definir el valor (o getter y/o setter) y los atributos de la propiedad. Reflect.defineProperty() es muy similar a Object.defineProperty() pero devuelve true en caso de éxito y false en caso de fallo. (Object.defineProperty() devuelve o en caso de éxito y lanza TypeError en caso de error).</p>
    <p><codeinline>Reflect.deleteProperty(o, nombre)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función borra la propiedad con la cadena o nombre simbólico especificado del objeto o, devolviendo true si tiene éxito (o si no existe tal propiedad) y false si la propiedad no ha podido ser borrada. Llamar a esta función es similar a escribir delete o[nombre].</p>
    <p><codeinline>Reflect.get(o, nombre, receptor)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve el valor de la propiedad de o con el nombre especificado (una cadena o un símbolo). Si la propiedad es un método accessor con un getter, y si se especifica el argumento opcional receiver, entonces se llama a la función getter como un método de receiver en lugar de como un método de o. Llamar a esta función es similar a evaluar o[nombre].</p>
    <p><codeinline>Reflect.getOwnPropertyDescriptor(o, nombre)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve un objeto descriptor de propiedad que describe los atributos de la propiedad denominada name del objeto o, o devuelve undefined si no existe dicha propiedad. Esta función es prácticamente idéntica a Object.getOwnPropertyDescrip tor(), excepto en que la versión de la función de la API de Reflect requiere que el primer argumento sea un objeto y genera un error de tipo TypeError si no lo es.</p>
    <p><codeinline>Reflect.getPrototypeOf(o)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve el prototipo del objeto o o null si el objeto no tiene prototipo. Lanza un TypeError si o es un valor primitivo en lugar de un objeto. Esta función es casi idéntica a Object.getPrototypeOf() excepto que Object.getPrototypeOf() sólo lanza un TypeError para argumentos null e indefinidos y coacciona otros valores primitivos a sus objetos envoltorio.</p>
    <p><codeinline>Reflect.has(o, nombre)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve verdadero si el objeto o tiene una propiedad con el nombre especificado (que debe ser una cadena o un símbolo). Llamar a esta función es similar a evaluar nombre en o.</p>
    <p><codeinline>Reflect.isExtensible(o)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve true si el objeto o es extensible (§14.2) y false si no lo es. Lanza un TypeError si o no es un objeto. Object.isExtensible() es similar pero simplemente devuelve false cuando se le pasa un argumento que no es un objeto.</p>
    <p><codeinline>Reflect.ownKeys(o)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función devuelve un array con los nombres de las propiedades del objeto o o lanza un TypeError si o no es un objeto. Los nombres de la matriz devuelta serán cadenas y/o símbolos. Llamar a esta función es similar a llamar a Object.getOwn PropertyNames() y Object.getOwnPropertySymbols() y combinar sus resultados.</p>
    <p><codeinline>Reflect.preventExtensions(o)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función establece el atributo extensible (§14.2) del objeto o a false y devuelve true para indicar éxito. Lanza un TypeError si o no es un objeto. Object.preventExtensions() tiene el mismo efecto pero devuelve o en lugar de true y no lanza TypeError para argumentos que no sean objetos.</p>
    <p><codeinline>Reflect.set(o, nombre, valor, receptor)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función establece la propiedad con el nombre especificado del objeto o al valor especificado. Devuelve true en caso de éxito y false en caso de fallo (lo que puede ocurrir si la propiedad es de sólo lectura). Lanza TypeError si o no es un objeto. Si la propiedad especificada es una propiedad accessor con una función setter, y si se pasa el argumento opcional receiver, entonces el setter será invocado como un método de receiver en lugar de ser invocado como un método de o. Llamar a esta función es normalmente lo mismo que evaluar o[name] = value.</p>
    <p><codeinline>Reflect.setPrototypeOf(o, p)</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función establece el prototipo del objeto o en p, devolviendo true en caso de éxito y false en caso de fallo (lo que puede ocurrir si o no es extensible o si la operación causaría una cadena circular de prototipos). Lanza un TypeError si o no es un objeto o si p no es ni un objeto ni null. Object.setPrototypeOf() es similar, pero devuelve o en caso de éxito y lanza un TypeError en caso de fallo. Recuerde que llamar a cualquiera de estas funciones es probable que haga su código más lento al interrumpir las optimizaciones del intérprete Java- Script.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>14.7 Objetos proxy</h2>
    <p>La clase Proxy, disponible en ES6 y posteriores, es la característica metaprog ramadora más potente de JavaScript. Nos permite escribir código que altera el comportamiento fundamental de los objetos JavaScript. La API Reflect descrita en §14.6 es un conjunto de funciones que nos da acceso directo a un conjunto de operaciones fundamentales sobre objetos JavaScript. Lo que hace la clase Proxy es permitirnos implementar esas operaciones fundamentales nosotros mismos y crear objetos que se comportan de formas que no son posibles para los objetos normales.</p>
    <p>Cuando creamos un objeto Proxy, especificamos otros dos objetos, el objeto destino y el objeto manejadores:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El objeto Proxy resultante no tiene estado ni comportamiento propios. Cada vez que se realiza una operación en él (leer una propiedad, escribir una propiedad, definir una nueva propiedad, buscar el prototipo, invocarlo como una función), envía esas operaciones al objeto controlador o al objeto de destino.</p>
    <p>Las operaciones admitidas por los objetos Proxy son las mismas que las definidas por la API de Reflect. Supongamos que p es un objeto Proxy y se escribe delete p.x. La función Reflect.deleteProperty() tiene el mismo comportamiento que el operador delete. Y cuando se utiliza el operador delete para eliminar una propiedad de un objeto Proxy, busca un mé todo deleteProperty() en el objeto handlers. Si tal método existe, lo invoca. Y si no existe tal método, entonces el objeto Proxy realiza el borrado de la propiedad en el objeto destino.</p>
    <p>Los proxies funcionan de esta manera para todas las operaciones fundamentales: si existe un método apropiado en el objeto manejador, invoca ese método para realizar la operación. (Los nombres y firmas de los métodos son los mismos que los de las funciones Reflect que se tratan en §14.6.) Y si ese método no existe en el objeto manejador, entonces el Proxy realiza la operación fundamental en el objeto de destino. Esto significa que un Proxy puede obtener su comportamiento del objeto destino o del objeto manejador. Si el objeto handlers está vacío, entonces el proxy es esencialmente una envoltura transparente alrededor del objeto objetivo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este tipo de proxy envoltorio transparente es esencialmente equivalente al objeto tar- get subyacente, lo que significa que realmente no hay ninguna razón para utilizarlo en lugar del objeto envuelto. Las envolturas transparentes pueden ser útiles, sin embargo, cuando se crean como "proxies revocables". En lugar de crear un Proxy con el constructor Proxy(), puede utilizar la función de fábrica Proxy.revocable(). Esta función devuelve un objeto que incluye un objeto Proxy y también una función revoke(). Una vez que se llama a la función revoke(), el proxy deja de funcionar inmediatamente:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Tenga en cuenta que además de demostrar los proxies revocables, el código anterior también demuestra que los proxies pueden trabajar con funciones de destino, así como con objetos de destino. Pero el punto principal aquí es que los proxies revocables son un bloque de construcción para un tipo de aislamiento de código, y podrías usarlos cuando trates con librerías de terceros no confiables, por ejemplo. Si tienes que pasar una función a una biblioteca que no controlas, puedes pasar un proxy revocable en su lugar y luego revocar el proxy cuando hayas terminado con la biblioteca. Esto evita que la biblioteca guarde una referencia a tu función y la llame en momentos inesperados. Este tipo de programación defensiva no es típica en los programas JavaScript, pero la clase Proxy al menos lo hace posible.</p>
    <p>Si pasamos un objeto handlers no vacío al constructor Proxy(), entonces ya no estamos definiendo un objeto envoltorio transparente y en su lugar estamos implementando un comportamiento personalizado para nuestro proxy. Con el conjunto adecuado de manejadores, el objeto de destino subyacente se vuelve esencialmente irrelevante.</p>
    <p>En el siguiente código, por ejemplo, se muestra cómo podríamos implementar un objeto que parezca tener un número infinito de propiedades de sólo lectura, donde el valor de cada propiedad es el mismo que el nombre de la propiedad:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los objetos proxy pueden derivar su comportamiento del objeto destino y del objeto manejador, y los ejemplos que hemos visto hasta ahora han utilizado un objeto u otro. Pero normalmente es más útil definir proxies que utilicen ambos objetos.</p>
    <p>El siguiente código, por ejemplo, utiliza Proxy para crear una envoltura de sólo lectura para un objeto de destino. Cuando el código intenta leer valores del objeto, esas lecturas se reenvían al objeto de destino normalmente. Pero si algún código intenta modificar el objeto o sus propiedades, los métodos del objeto manejador lanzan un TypeError. Un proxy como este podría ser útil para escribir pruebas: supongamos que has escrito una función que toma un argumento de objeto y quieres asegurarte de que tu función no hace ningún intento de modificar el argumento de entrada. Si su prueba pasa un objeto envoltorio de sólo lectura, entonces cualquier escritura lanzará excepciones que harán que la prueba falle:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Otra técnica para escribir proxies consiste en definir métodos manejadores que intercepten operaciones en un objeto pero que deleguen las operaciones en el objeto de destino. Las funciones de la API Reflect (§14.6) tienen exactamente las mismas firmas que los métodos manejadores, por lo que facilitan este tipo de delegación.</p>
    <p>Aquí, por ejemplo, hay un proxy que delega todas las operaciones en el objeto de destino, pero utiliza métodos manejadores para registrar las operaciones:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La función loggingProxy() definida anteriormente crea proxies que registran todas las formas en que se utilizan. Si estás tratando de entender cómo una función no documentada utiliza los objetos que le pasas, usar un proxy de registro puede ayudar.</p>
    <p>Considere los siguientes ejemplos, que dan lugar a algunas ideas genuinas sobre la iteración de matrices:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Del primer trozo de registro de salida, aprendemos que el método Array.map() comprueba explícitamente la existencia de cada elemento del array (causando la invocación del manejador has()) antes de leer el valor del elemento (que activa el manejador get()). Esto es presumiblemente para poder distinguir elementos de array inexistentes de elementos que existen pero no están definidos.</p>
    <p>El segundo trozo de la salida de registro podría recordarnos que la función que pasamos a Array.map() se invoca con tres argumentos: el valor del elemento, el índice del elemento y el propio array. (Hay un problema en nuestra salida de registro: el método Array.toString() no incluye corchetes en su salida, y los mensajes de registro serían más claros si se incluyeran en la lista de argumentos (10,0, [10,20]).</p>
    <p>El tercer trozo de la salida de registro nos muestra que el bucle for/of funciona buscando un método con nombre simbólico [Symbol.iterator]. También demuestra que la implementación de la clase Array de este método iterador tiene cuidado de comprobar la longitud del array en cada iteración y no asume que la longitud del array permanece constante durante la iteración.</p>
  </section>
  <section id="7-1">
    <h2>14.7.1 Invariantes de proxy</h2>
    <p>La función readOnlyProxy() definida anteriormente crea objetos proxy que están efectivamente congelados: cualquier intento de alterar un valor de propiedad o un atributo de propiedad o de añadir o eliminar propiedades producirá una excepción. Pero mientras el objeto de destino no esté fro- zado, encontraremos que si podemos consultar el proxy con Reflect.isExtensible() y Reflect.getOwnPropertyDescriptor(), y nos dirá que deberíamos poder establecer, añadir y eliminar propiedades. Por lo tanto, readOnlyProxy() crea objetos en un estado incoherente. Podríamos arreglar esto añadiendo manejadores isExtensible() y getOwnPropertyDescrip tor(), o podemos vivir con este tipo de inconsistencia menor.</p>
    <p>Sin embargo, la API del manejador Proxy nos permite definir objetos con inconsistencias mayores, y en este caso, la propia clase Proxy nos prevendrá de crear objetos Proxy que sean inconsistentes de mala manera. Al principio de esta sección, describimos los proxies como objetos sin comportamiento propio porque simplemente reenvían todas las operaciones a el objeto manejador y el objeto destino. Pero esto no es del todo cierto: después de reenviar una operación, la clase Proxy realiza algunas comprobaciones de sanidad en el resultado para asegurarse de que no se violan invariantes importantes de JavaScript. Si detecta una violación, el proxy lanzará un TypeError en lugar de permitir que la operación continúe.</p>
    <p>Por ejemplo, si creas un proxy para un objeto no extensible, el proxy lanzará un TypeError si el manejador isExtensible() devuelve alguna vez true:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>En relación con esto, los objetos proxy para objetivos no extensibles no pueden tener un manejador getPrototypeOf() que devuelva otra cosa que no sea el objeto prototipo real del objetivo. Además, si el objeto de destino tiene propiedades no configurables y no escribibles, la clase Proxy lanzará un TypeError si el manejador get() devuelve cualquier cosa que no sea el valor real:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Proxy impone una serie de invariantes adicionales, casi todas e l l a s relacionadas con objetos de destino no extensibles y propiedades no configurables del objeto de destino .</p>
  </section>
  <section id="8" class="py-4 xs:py-5 sm:py-6">
    <h2>14.8 Resumen</h2>
    <p>En este capítulo has aprendido:</p>
    <ul>
      <li class="font-normal">Los objetos JavaScript tienen un atributo extensible y las propiedades de los objetos tienen atributos escribibles, enumerables y configurables, así como un valor y un atributo getter y/o set- ter. Puedes utilizar estos atributos para "bloquear" tus objetos de varias formas, incluida la creación de objetos "sellados" y "congelados".</li>
      <li class="font-normal">JavaScript define funciones que permiten recorrer la cadena de prototipos de un objeto e incluso cambiar el prototipo de un objeto (aunque esto puede ralentizar el código).</li>
      <li class="font-normal">Las propiedades del objeto Symbol tienen valores que son "símbolos bien conocidos", que puede utilizar como nombres de propiedades o métodos para los objetos y clases que defina. Esto le permite controlar cómo interactúa su objeto con las características del lenguaje Java Script y con la biblioteca central. Por ejemplo, los conocidos Sym- bols permiten hacer iterables las clases y controlar la cadena que se muestra cuando se pasa una instancia a Object.prototype.toString(). Antes de ES6, este tipo de personalización sólo estaba disponible para las clases nativas que se incorporaban a una implementación.</li>
      <li class="font-normal">Los literales de plantilla etiquetados son una sintaxis de invocación de funciones, y definir una nueva función de etiqueta es algo así como añadir una nueva sintaxis literal al lenguaje. Definir una función de etiqueta que analice su argumento de cadena de plantilla permite incrustar DSL en el código JavaScript. Las funciones de etiqueta también proporcionan acceso a una forma de literales de cadena en bruto, sin mayúsculas, en la que las barras invertidas no tienen un significado especial.</li>
      <li class="font-normal">La clase Proxy y la API Reflect relacionada permiten un control de bajo nivel sobre los comportamientos fun- damentales de los objetos JavaScript. Los objetos proxy se pueden utilizar como envolturas opcionalmente revocables para mejorar la encapsulación del código, y también se pueden utilizar para implementar comportamientos de objetos no estándar (como algunas de las API de casos especiales definidas por los primeros navegadores web).</li>
    </ul>
  </section>
  </Layoutjavascript>
