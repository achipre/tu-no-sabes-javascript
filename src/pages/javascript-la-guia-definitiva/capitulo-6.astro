---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-5" capSiguiente="capitulo-7" />
  <section class="fadeIn">
    <h1>Objetos</h1>
    <p>Los objetos son el tipo de datos más fundamental de JavaScript, y ya los has visto
      muchas veces en los capítulos que preceden a éste. Debido a que los objetos son tan
      importantes para el lenguaje JavaScript, es importante que entiendas cómo funcionan
      en detalle, y este capítulo proporciona ese detalle. Comienza con una descripción
      formal de los objetos, y luego se sumerge en secciones prácticas sobre la creación de
      objetos y la consulta, configuración, eliminación, comprobación y enumeración de
      las propiedades de los objetos. Estas secciones centradas en las propiedades van
      seguidas de otras que explican cómo extender, serializar y definir métodos
      importantes en los objetos. Finalmente, el capítulo concluye con una larga sección
      sobre la nueva sintaxis literal de objetos en ES6 y versiones más recientes del lenguaje.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>6.1 Introducción a los objetos</h2>
    <p>Un objeto es un valor compuesto: agrega múltiples valores (valores primitivos u otros
      objetos) y permite almacenar y recuperar esos valores por su nombre. Un objeto es
      una colección desordenada de <em>propiedades</em>, cada una de las cuales tiene un nombre y
      un valor. Los nombres de las propiedades suelen ser cadenas (aunque, como veremos
      en <a href="#6-10-3">§6.10.3</a>, los nombres de las propiedades también pueden ser símbolos), por lo que
      podemos decir que los objetos convierten cadenas en valores. Este mapeo de cadena a
      valor recibe varios nombres, probablemente ya estés familiarizado con la estructura
      de datos fundamental bajo el nombre de "hash", "hashtable", "diccionario" o "array
      asociativo". Sin embargo, un objeto es más que un simple mapa cadena-valor.
      Además de mantener su propio conjunto de propiedades, un objeto JavaScript
      también hereda las propiedades de otro objeto, conocido como su "prototipo". Los
      métodos de un objeto suelen ser propiedades heredadas, y esta "herencia prototípica"
      es una característica clave de JavaScript.</p>
    <p>Los objetos JavaScript son dinámicos (normalmente se pueden añadir y eliminar
      propiedades), pero se pueden utilizar para simular los objetos estáticos y los "structs" de los lenguajes tipados estáticamente. También pueden utilizarse (ignorando la parte
      de valor del mapeo cadena-valor) para representar conjuntos de cadenas.</p>
    <p>Cualquier valor en JavaScript que no sea una cadena, un número, un Símbolo, o
      <codeinline>true</codeinline>, <codeinline>false</codeinline>, <codeinline>null</codeinline> o <codeinline>undefined</codeinline> es un objeto. Y aunque las cadenas, los
      números y los booleanos no son objetos, pueden comportarse como objetos
      inmutables.</p>
    <p>Recordemos de <a href="capitulo-3#8">§3.8</a> que los objetos son <em>mutables</em> y se manipulan por referencia en
      lugar de por valor. Si la variable <codeinline>x</codeinline> se refiere a un objeto y se ejecuta el código <codeinline>let y = x;</codeinline> la variable <codeinline>y</codeinline> contiene una referencia al mismo objeto, no una copia de ese objeto. Cualquier modificación hecha al objeto a través de la variable <codeinline>y</codeinline> es también visible a través de la variable <codeinline>x</codeinline>.</p>
    <p>Lo más habitual con los objetos es crearlos y establecer, consultar, borrar, comprobar
      y enumerar sus propiedades. Estas operaciones fundamentales se describen en las
      primeras secciones de este capítulo. Las secciones siguientes tratan temas más
      avanzados.</p>
    <p>Una <em>propiedad</em> tiene un nombre y un valor. El nombre de una propiedad puede ser
      cualquier cadena, incluida la cadena vacía (o cualquier Símbolo), pero ningún objeto
      puede tener dos propiedades con el mismo nombre. El valor puede ser cualquier
      valor JavaScript, o puede ser una función getter o setter (o ambas). Aprenderemos
      sobre las funciones getter y setter en <a href="#6-10-6">§6.10.6</a>.</p>
    <p>A veces es importante saber distinguir entre las propiedades definidas directamente
      en un objeto y las que se heredan de un objeto prototipo. JavaScript utiliza el término
      <em>propiedad propia</em> para referirse a las propiedades no heredadas.</p>
    <p>Además de su nombre y valor, cada propiedad tiene tres <em>atributos</em>:</p>
    <ul>
      <li class="font-normal">El atributo <em>writable</em> especifica si se puede establecer el valor de la propiedad.</li>
      <li class="font-normal">El atributo <em>enumerable</em> especifica si el nombre de la propiedad es devuelto por un bucle <codeinline>for/in</codeinline>.</li>
      <li class="font-normal">El atributo <em>configurable</em> especifica si la propiedad se puede eliminar y si se
        pueden modificar sus atributos.</li>
    </ul>
    <p>Muchos de los objetos incorporados de JavaScript tienen propiedades que son de sólo
      lectura, no enumerables o no configurables. Por defecto, sin embargo, todas las
      propiedades de los objetos que creas son escribibles, enumerables y configurables. En
      <a href="capitulo-14#1">§14.1</a> se explican técnicas para especificar valores de atributos de propiedades no
      predeterminados para los objetos.</p>
  </section>
  <section id="2">
    <h3>6.2 Creación de objetos</h3>
    <p>Los objetos pueden crearse con literales de objeto, con la palabra clave new y con la función <codeinline>Object.create()</codeinline>. Las subsecciones siguientes describen cada técnica.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h3>6.2.1 Literales de objeto</h3>
    <p>La forma más sencilla de crear un objeto es incluir un literal de objeto en el código
      JavaScript. En su forma más simple, un <em>literal de objeto</em> es una lista separada por
      comas de pares nombre:valor separados por dos puntos, encerrados entre llaves. Un
      nombre de propiedad es un identificador de Java Script o un literal de cadena (se
      permite la cadena vacía). Un valor de propiedad es cualquier expresión de JavaScript;
      el valor de la expresión (puede ser un valor primitivo o un valor de objeto) se
      convierte en el valor de la propiedad. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">let empty = &lbrace;}; // Un objeto sin propiedades
    let point = &lbrace; x: 0, y: 0 }; // Dos propiedades numéricas
    let p2 = &lbrace; x: point.x, y: point.y+1 }; // Valores mas complejos
    let book = &lbrace;
      "main title": "JavaScript", // Estas propiedades incluyen espacios
      "sub-title": "The Definitive Guide", // y guiones, asi que utilice literales de cadena.
      for: "all audiences", // para esta reservado, pero sin comillas
      author: &lbrace; // El valor de esta propiedad es
        firstname: "David", // un objeto por si mismo.
        surname: "Flanagan"
      }
    };</code></pre>
    <p>Una coma al final de la última propiedad en un objeto literal es legal, y algunos estilos
        de programación fomentan el uso de estas comas al final para que sea menos
        probable que se produzca un error de sintaxis si se añade una nueva propiedad al
        final del objeto literal en algún momento posterior.</p>
    <p>Un literal de objeto es una expresión que crea e inicializa un objeto nuevo y distinto
      cada vez que se evalúa. El valor de cada propiedad se evalúa cada vez que se evalúa el
      literal. Esto significa que un único literal de objeto puede crear muchos objetos
      nuevos si aparece dentro del cuerpo de un bucle o en una función que se llama
      repetidamente, y que los valores de las propiedades de estos objetos pueden diferir
      entre sí.</p>
    <p>Los literales de objeto mostrados aquí utilizan una sintaxis simple que ha sido legal
      desde las primeras versiones de JavaScript. Las versiones recientes del lenguaje han
      introducido una serie de nuevas características de literales de objeto, que se tratan en
      <a href="#6-10">§6.10</a>.</p>
  </section>
  <section id="2-2">
    <h2>6.2.2 Creación de objetos con new</h2>
    <p>El operador <codeinline>new</codeinline> crea e inicializa un nuevo objeto. La palabra clave <codeinline>new</codeinline> debe ir
      seguida de una invocación a una función. Una función utilizada de este modo se
      denomina <em>constructor</em> y sirve para inicializar un objeto recién creado. JavaScript
      incluye constructores para sus tipos incorporados. Por ejemplo:</p>
    <pre>
    <code class="language-js">let o = new Object(); // Crea un objeto vacio: igual a &lbrace;}.
    let a = new Array(); // Crea un array vacío: igual a [].
    let d = new Date(); // Crea un objeto Date representando la fecha actual.
    let r = new Map(); // Crea un objeto Map para mapeos clave-valor.</code></pre>
    <p>Además de estos constructores incorporados, es común definir sus propias funciones
      constructoras para inicializar los objetos recién creados. Esto se explica en el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>6.2.3 Prototipos</h2>
    <p>Antes de que podamos cubrir la tercera técnica de creación de objetos, debemos
      detenernos un momento para explicar los <em>prototipos</em>. Casi todos los objetos
      JavaScript tienen un segundo objeto JavaScript asociado. Este segundo objeto se
      conoce como prototipo, y el primer objeto hereda propiedades del prototipo.</p>
    <p>Todos los objetos creados por literales de objeto tienen el mismo objeto prototipo, y
      podemos referirnos a este objeto prototipo en código JavaScript como
      <codeinline>Object.prototype</codeinline>. Los objetos creados mediante la palabra clave <codeinline>new</codeinline> y la
      invocación de un constructor utilizan como prototipo el valor de la propiedad
      <codeinline>prototype</codeinline> de la función constructora. Así, el objeto creado por <codeinline>new Object()</codeinline>
      hereda de <codeinline>Object.prototype</codeinline>, al igual que el objeto creado por <codeinline>&lbrace;}</codeinline>. Del mismo modo,
      el objeto creado por <codeinline>new Array()</codeinline> utiliza <codeinline>Array.prototype</codeinline> como su prototipo, y el
      objeto creado por <codeinline>new Date()</codeinline> utiliza <codeinline>Date.prototype</codeinline> como su prototipo. Esto
      puede resultar confuso cuando se aprende JavaScript por primera vez. Recuerda: casi
      todos los objetos tienen un <em>prototipo</em>, pero sólo un número relativamente pequeño de
      objetos tienen una propiedad <codeline>prototype</codeline>. Son estos objetos con propiedades <codeinline>prototype</codeinline> los
      que definen los <em>prototipos</em> para todos los demás objetos.</p>
    <p><codeinline>Object.prototype</codeinline> es uno de los raros objetos que no tiene prototipo: no hereda
      ninguna propiedad. Otros objetos prototipo son objetos normales que sí tienen un
      prototipo. La mayoría de los constructores incorporados (y la mayoría de los
      constructores definidos por el usuario) tienen un prototipo que hereda de
      <codeinline>Object.prototype</codeinline>. Por ejemplo, <codeinline>Date.prototype</codeinline> hereda las propiedades de
      <codeinline>Object.prototype</codeinline>, por lo que un objeto Date creado por <codeinline>new Date()</codeinline> hereda las
      propiedades tanto de <codeinline>Date.prototype</codeinline> como de <codeinline>Object.prototype</codeinline>. Esta serie
      enlazada de objetos prototipo se conoce como <em>cadena prototipo</em>.</p>
    <p>En <a href="#6-3">§6.3.2</a> se explica cómo funciona la herencia de propiedades. El <a href="capitulo-9">capítulo 9</a> explica con más detalle la conexión entre prototipos y constructores: muestra cómo definirnuevas "clases" de objetos escribiendo una función constructora y estableciendo su propiedad proto type en el objeto prototipo que utilizarán las "instancias" creadas con ese constructor. Y aprenderemos cómo consultar (e incluso cambiar) el prototipo de un objeto en <a href="#14-3">§14.3</a>.</p>
  </section>
  <section id="2-4">
    <h2>6.2.4 Object.create()</h2>
    <p><codeinline>Object.create()</codeinline> crea un nuevo objeto, utilizando su primer argumento como el prototipo de dicho objeto:</p>
    <pre>
    <code class="language-js">let o1 = Object.create(&lbrace;x: 1, y: 2}); // o1 hereda las propiedades x e y.
    o1.x + o1.y                           // => 3</code></pre>
    <p>Puedes pasar <codeinline>null</codeinline> para crear un nuevo objeto que no tenga prototipo, pero si haces
      esto, el objeto recién creado no heredará nada, ni siquiera métodos básicos como <codeinline>toString()</codeinline> (lo que significa que tampoco funcionará con el operador <codeinline>+</codeinline>):</p>
    <pre>
    <code class="language-js">let o2 = Object.create(null); // o2 no hereda props ni metodos.</code></pre>
    <p>Si desea crear un objeto vacío ordinario (como el objeto devuelto por <codeinline>&lbrace;}</codeinline> o <codeinline>new Object()</codeinline>), pase <codeinline>Object.prototype</codeinline>:</p>
    <pre>
    <code class="language-js">let o3 = Object.create(Object.prototype); // o3 es como &lbrace;} o new Object().</code></pre>
    <p>La capacidad de crear un nuevo objeto con un prototipo arbitrario es muy poderosa,
      y utilizaremos <codeinline>Object.create()</codeinline> en varios lugares a lo largo de este capítulo.
      (<codeinline>Object.create()</codeinline> también toma un segundo argumento opcional que describe las
      propiedades del nuevo objeto. Este segundo argumento es una característica
      avanzada cubierta en <a href="capitulo-14#1">§14.1</a>.)</p>
    <p>Un uso de <codeinline>Object.create()</codeinline> es cuando se quiere evitar la modificación no
      intencionada (pero no maliciosa) de un objeto por una función de la biblioteca sobre
      la que no se tiene control. En lugar de pasar el objeto directamente a la función,
      puede pasar un objeto que herede de él. Si la función lee propiedades de ese objeto,
      verá los valores heredados. Sin embargo, si establece propiedades, esas escrituras no
      afectarán al objeto original.</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: "no cambies este valor" };
    library.function(Object.create(o)); // Protéjase contra modificaciones accidentales</code></pre>
    <p>Para entender por qué funciona esto, necesitas saber cómo se consultan y establecen
      las propiedades en JavaScript. Estos son los temas de la siguiente sección.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>6.3 Consulta y configuración de propiedades</h2>
    <p>Para obtener el valor de una propiedad, utilice los operadores punto (<codeinline>.</codeinline>) o corchete
      (<codeinline>[]</codeinline>) descritos en <a href="#4-4">§4.4</a>. El lado izquierdo debe ser una expresión cuyo valor sea un objeto. Si se utiliza el operador de punto, el lado derecho debe ser un identificador
      simple que nombre la propiedad. Si se utilizan corchetes, el valor dentro de los
      corchetes debe ser una expresión que se evalúe como una cadena que contenga el
      nombre de la propiedad deseada:</p>
    <pre>
    <code class="language-js">let author = book.author; // Obtener la propiedad "author" del libro.
    let name = author.surname; // Obtener la propiedad "surname" del autor.
    let title = book["main title"]; // Obtener la propiedad "main title" del libro.</code></pre>
    <p>Para crear o establecer una propiedad, utilice un punto o corchetes como lo haría
      para consultar la propiedad, pero póngalos en el lado izquierdo de una expresión de
      asignación:</p>
    <pre>
    <code class="language-js">book.edition = 7; // Crea una propiedad llamada "edition" en el libro.
    book["main title"] = "ECMAScript"; // Cambia el valor de la propiedad "main title".</code></pre>
    <p>Al utilizar la notación de corchetes, hemos dicho que la expresión dentro de los
      corchetes debe evaluarse a una cadena. Una afirmación más precisa es que la
      expresión debe evaluarse a una cadena o a un valor que pueda convertirse a una cadena o a un
      Símbolo (<a href="#10-3">§6.10.3</a>). En el <a href="capitulo-7">Capítulo 7</a>, por ejemplo, veremos que es habitual utilizar números dentro de los corchetes.</p>
  </section>
  <section id="3-1">
    <h2>6.3.1 Objetos como matrices asociativas</h2>
    <p>Como se ha explicado en la sección anterior, las dos expresiones JavaScript siguientes tienen el mismo valor:</p>
    <pre>
    <code class="language-js">object.property
    object["property"]</code></pre>
    <p>La primera sintaxis, que utiliza el punto y un identificador, es similar a la utilizada
      para acceder a un campo estático de una estructura o un objeto en C o Java. La
      segunda sintaxis, que utiliza corchetes y una cadena, se parece al acceso a un array,
      pero a un array indexado por cadenas en lugar de por números. Este tipo de matriz se
      conoce como <em>matriz asociativa</em> (o hash o mapa o diccionario). Los objetos JavaScript
      son arrays asociativos, y esta sección explica por qué es importante.</p>
    <p>En C, C++, Java y lenguajes de tipado fuerte similares, un objeto sólo puede tener un
      número fijo de propiedades, y los nombres de estas propiedades deben definirse de
      antemano. Dado que JavaScript es un lenguaje poco tipado, esta regla no se aplica: un
      programa puede crear cualquier número de propiedades en cualquier objeto. Sin
      embargo, cuando se utiliza el operador <codeinline>.</codeinline> para acceder a una propiedad de un objeto,
      el nombre de la propiedad se expresa como un identificador. Los identificadores
      deben escribirse literalmente en su programa JavaScript; no son un tipo de dato, por
      lo que no pueden ser manipulados por el programa.</p>
    <p>Por otro lado, cuando se accede a una propiedad de un objeto con la anotación de
      matriz <codeinline>[]</codeinline>, el nombre de la propiedad se expresa como una cadena. Las cadenas son
      tipos de datos de JavaScript, por lo que pueden manipularse y crearse mientras se
      ejecuta un programa. Así, por ejemplo, puede escribir el siguiente código en
      JavaScript:</p>
    <pre>
    <code class="language-js">let addr = "";
    for(let i = 0; i &lt; 4; i++) &lbrace;
      addr += customer[`address$&lbrace;i}`] + "\n";
    }</code></pre>
    <p>Este código lee y concatena la <codeinline>address0</codeinline>, <codeinline>address1</codeinline>,<codeinline>address2</codeinline> y <codeinline>address3</codeinline>
      del objeto <codeinline>customer</codeinline>.</p>
    <p>Este breve ejemplo demuestra la flexibilidad de utilizar la notación de matrices para
      acceder a las propiedades de un objeto con expresiones de cadena. Este código podría
      reescribirse utilizando la notación de puntos, pero hay casos en los que sólo la
      notación de matrices servirá. Supongamos, por ejemplo, que está escribiendo un
      programa que utiliza recursos de red para calcular el valor actual de las inversiones
      bursátiles del usuario. El programa permite al usuario escribir el nombre de cada
      acción que posee, así como el número de acciones de cada acción. Puede utilizar un objeto llamado <codeinline>portfolio</codeinline> para almacenar esta información. El objeto tiene una propiedad por cada acción. El nombre de la propiedad es el nombre de la acción, y el valor de la propiedad es el número de acciones de esa acción. Así, por ejemplo, si
      un usuario tiene 50 acciones de IBM, la propiedad <codeinline>portfolio.ibm</codeinline> tiene el valor <codeinline>50</codeinline>.</p>
    <p>Parte de este programa podría ser una función para añadir una nueva acción a la cartera:</p>
    <pre>
    <code class="language-js">function addstock(portfolio, stockname, shares) &lbrace;
      portfolio[stockname] = shares;
    }</code></pre>
    <p>Dado que el usuario introduce los nombres de las acciones en tiempo de ejecución,
      no hay forma de que pueda conocer los nombres de las propiedades de antemano.
      Como no puede conocer los nombres de las propiedades cuando escribe el programa,
      no hay forma de que pueda utilizar el operador <codeinline>.</codeinline> para acceder a las propiedades del
      objeto <codeinline>portfolio</codeinline>. Puede utilizar el operador <codeinline>[]</codeinline>, sin embargo, porque utiliza un valor de cadena (que es dinámico y puede cambiar en tiempo de ejecución) en lugar de un
      identificador (que es estático y debe ser codificado en el programa) para nombrar la
      propiedad.</p>
    <p>En el <a href="capitulo-5">Capítulo 5</a>, introdujimos el bucle <codeinline>for/in</codeinline> (y volveremos a verlo en breve, en <a href="#6-6">§6.6</a>). El poder de esta sentencia JavaScript se hace evidente cuando se considera su uso con matrices asociativas. Así es como se utilizaría para calcular el valor total de portfolio:</p>
    <pre>
    <code class="language-js">function computeValue(portfolio) &lbrace;
      let total = 0.0;
      for(let stock in portfolio) &lbrace;     // Por cada stock en el portfolio
        let shares = portfolio[stock];  // obtener el número de accione
        let price = getQuote(stock);    // buscar el precio de acción
        total += shares * price;        // agregar el valor de acción
      }
      return total; // Devolver el valor total
    }</code></pre>
    <p>Los objetos JavaScript se utilizan comúnmente como matrices asociativas, como se
      muestra aquí, y es importante entender cómo funciona. En ES6 y posteriores, sin
      embargo, la clase Map descrita en <a href="capitulo-11#1-2">§11.1.2</a> es a menudo una mejor opción que usar un
      objeto plano.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>6.3.2 Herencia</h2>
    <p>Los objetos JavaScript tienen un conjunto de "propiedades propias" y también
      heredan un conjunto de propiedades de su objeto prototipo. Para entender esto,
      debemos considerar el acceso a las propiedades con más detalle. Los ejemplos de esta
      sección utilizan la función <codeinline>Object.create()</codeinline> para crear objetos con prototipos
      específicos. Sin embargo, veremos en el <a href="capitulo-9">Capítulo 9</a> que cada vez que se crea una
      instancia de una clase con new, se está creando un objeto que hereda propiedades de
      un objeto prototipo.</p>
    <p>Supongamos que se consulta la propiedad <codeinline>x</codeinline> en el objeto <codeinline>o</codeinline>. Si <codeinline>o</codeinline> no tiene una propiedad propia con ese nombre, Se consulta el objeto prototipo de <codeinline>o</codeinline><sup>1</sup> para la propiedad <codeinline>x</codeinline>. Si el objeto prototipo no tiene una propiedad propia con ese nombre, pero tiene un prototipo, l a consulta se realiza en el prototipo del prototipo. Esto continúa hasta que se encuentra la propiedad <codeinline>x</codeinline> o hasta que se busca un objeto con un prototipo <codeinline>null</codeinline>. Como puede ver, el atributo <codeinline>prototype</codeinline> de un objeto crea una cadena o lista enlazada de la que se heredan propiedades:</p>
    <pre>
    <code class="language-js">let o = &lbrace;};               // o hereda los metodos de Object.prototype
    o.x = 1;                  // y ahora tiene una propiedad propia x.
    let p = Object.create(o); // p hereda las propiedades de o, y Object.prototype
    p.y = 2;                  // y tiene una propiedad propia y.
    let q = Object.create(p); // q hereda las propiedades de p, o y...
    q.z = 3;                  // ...Object.prototype tiene una propiedad propia z.
    let f = q.toString();     // toString se hereda de Object.prototype
    q.x + q.y                 // => 3; x e y se heredan de o y p</code></pre>
    <p>Supongamos ahora que asigna a la propiedad <codeinline>x</codeinline> del objeto <codeinline>o</codeinline>. Si <codeinline>o</codeinline> ya tiene una propiedad propia (no heredada) llamada <codeinline>x</codeinline>, entonces la asignación simplemente cambia el valor de esta propiedad existente. De lo contrario, la asignación crea una
      nueva propiedad llamada <codeinline>x</codeinline> en el objeto <codeinline>o</codeinline>. Si o heredó previamente la propiedad <codeinline>x</codeinline>, esa propiedad heredada está ahora oculta por la propiedad propia recién creada con el mismo nombre.</p>
    <p>La asignación de propiedades examina la cadena de prototipos sólo para determinar si la asignación está permitida. Si o hereda una propiedad de sólo lectura llamada <codeinline>x</codeinline>, por ejemplo, entonces la asignación no está permitida . (Los detalles sobre cuándo se puede asignar una propiedad se encuentran en <a href="#3-3">§6.3.3</a>.) Sin embargo, si la asignación está permitida, siempre crea o establece una propiedad en el objeto original y nunca modifica objetos en la cadena de prototipos. El hecho de que la herencia se produzca cuando se consultan propiedades pero no cuando se establecen es una característica clave de JavaScript porque nos permite anular selectivamente las propiedades heredadas:</p>
    <pre>
    <code class="language-js">let unitcircle = &lbrace; r: 1 };          // Un objeto para heredar de
    let c = Object.create(unitcircle);  // c hereda la propiedad r
    c.x = 1; c.y = 1;                   // c define dos propiedades propias
    c.r = 2;                            // c anula su propiedad heredada
    unitcircle.r                        // => 1: el prototipo no se ve afectada</code></pre>
    <p>Hay una excepción a la regla de que una asignación de propiedad falla o crea o establece una propiedad en el objeto original. Si <codeinline>o</codeinline> hereda la propiedad <codeinline>x</codeinline>, y esa propiedad es una propiedad accesoria con un método setter (véase <a href="#10-6">§6.10.6</a>), entonces se llama a ese método setter en lugar de crear una nueva propiedad <codeinline>x</codeinline> en <codeinline>o</codeinline>. Observe, sin embargo, que el método setter se llama en el objeto <codeinline>o</codeinline>, no en el objeto prototipo que define la propiedad por lo que si el método setter define alguna propiedad, lo hará en <codeinline>o</codeinline>, y volverá a dejar la cadena de prototipos sin modificar.</p>
  </section>
  <section id="3-3">
    <h2>6.3.3 Errores de acceso a la propiedad</h2>
    <p>Las expresiones de acceso a propiedades no siempre devuelven o establecen un valor.
      En esta sección se explican las cosas que pueden salir mal al consultar o establecer
      una propiedad.</p>
    <p>No es un error consultar una propiedad que no existe. Si la propiedad <codeinline>x</codeinline> no se
      encuentra como propiedad propia o heredada de <codeinline>o</codeinline>, la expresión de acceso a la propiedad <codeinline>o.x</codeinline> se evalúa como <codeinline>undefined</codeinline>. Recordemos que nuestro objeto libro tiene una propiedad "subtítulo", pero no una propiedad "subtítulo":</p>
    <pre>
    <code class="language-js">book.subtitle // => undefined: propiedad no existe</code></pre>
    <p>Sin embargo, es un error intentar consultar una propiedad de un objeto que no existe. Los valores <codeinline>null</codeinline> y <codeinline>undefined</codeinline> no tienen propiedades, y es un error consultar propiedades de estos valores. Continuando con el ejemplo anterior:</p>
    <pre>
    <code class="language-js">let len = book.subtitle.length; // !TypeError: indefinido no tiene propiedades</code></pre>
    <p>Las expresiones de acceso a propiedades fallarán si el lado izquierdo de <codeinline>.</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Por lo tanto, al escribir una expresión como <codeinline>book.author.surname</codeinline>, debe tener cuidado si no está seguro de que <codeinline>book</codeinline> y <codeinline>book.author</codeinline> están realmente definidos. He aquí dos formas de evitar este tipo de problemas:</p>
    <pre>
    <code class="language-js">// Una técnica verbosa y explicito
    let surname = undefined;
    if (book) &lbrace;
      if (book.author) &lbrace;
        surname = book.author.surname;
      }
    }
    // Una alternativa concisa e idiomatica para obtener surname o null o undefined
    surname = book && book.author && book.author.surname;</code></pre>
    <p>Para entender por qué esta expresión idiomática funciona para prevenir excepciones TypeError, puede que quiera revisar el comportamiento de cortocircuito del operador <codeinline>&amp;&amp;</codeinline> en <a href="capitulo-4#4-1">§4.10.1</a>.</p>
    <pre>
    <code class="language-js">let surname = book?.author?.surname;</code></pre>
    <p>Como se describe en <a href="capitulo-4#4-1">§4.4.1</a>, ES2020 admite el acceso condicional a propiedades con <codeinline>?.</codeinline>, lo que nos permite reescribir la expresión de asignación anterior como:</p>
    <p>Intentar establecer una propiedad en <codeinline>null</codeinline> o <codeinline>undefined</codeinline> también causa un TypeError. Los intentos de establecer propiedades sobre otros valores no siempre tienen éxito: algunas propiedades son de sólo lectura y no pueden establecerse, y algunos objetos no permiten la adición de nuevas propiedades. En modo estricto (<a href="capitulo-5#6-3">§5.6.3</a>), se lanza un TypeError cada vez que falla un intento de establecer una propiedad. Fuera del modo estricto, estos fallos suelen ser silenciosos.</p>
    <p>Las reglas que especifican cuándo una asignación de propiedad tiene éxito y cuándo falla son intuitivas pero difíciles de expresar de forma concisa. Un intento de establecer una propiedad <codeinline>p</codeinline> de un objeto <codeinline>o</codeinline> falla en estas circunstancias:</p>
    <ul>
      <li class="font-normal"><codeinline>o</codeinline> tiene una propiedad propia <codeinline>p</codeinline> que es de sólo lectura: no es posible establecer propiedades de sólo lectura.</li>
      <li class="font-normal"><codeinline>o</codeinline> tiene una propiedad heredada <codeinline>p</codeinline> que es de sólo lectura: no es posible ocultar una propiedad heredada de sólo lectura con una propiedad propia del mismo nombre.</li>
      <li class="font-normal"><codeinline>o</codeinline> no tiene una propiedad propia <codeinline>p</codeinline>; <codeinline>o</codeinline> no hereda una propiedad <codeinline>p</codeinline> con un método setter, y el atributo <em>extensible</em> de <codeinline>o</codeinline> (véase <a href="capitulo-14#2">§14.2</a>) es <codeinline>false</codeinline>. Como <codeinline>p</codeinline> no existe ya en <codeinline>o</codeinline>, y si no hay ningún método setter al que llamar, entonces <codeinline>p</codeinline> debe añadirse a <codeinline>o</codeinline>. Pero si <codeinline>o</codeinline> no es extensible, entonces no pueden definirse nuevas propiedades en él.</li>
    </ul>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>6.4 Borrar propiedades</h2>
    <p>El operador <codeinline>delete</codeinline> (<a href="capitulo-4#13-4">§4.13.4</a>) elimina una propiedad de un objeto. Su único operando debe ser una expresión de acceso a una propiedad. Sorprendentemente, <codeinline>delete</codeinline> no opera sobre el valor de la propiedad, sino sobre la propiedad misma:</p>
    <pre>
    <code class="language-js">delete book.author;         // El objeto book ahora no tiene una propiedad "author".
    delete book["main title"];  // Ahora tampoco tiene una propiedad "main title".</code></pre>
    <p>El operador <codeinline>delete</codeinline> sólo borra las propiedades propias, no las heredadas. (Para borrar una propiedad heredada, debe borrarla del objeto prototipo en el que está definida. Hacer esto afecta a todos los objetos que hereden de ese prototipo).</p>
    <p>Una expresión <codeinline>delete</codeinline> se evalúa como <codeinline>true</codeinline> si el borrado se ha realizado correctamente o si no ha tenido ningún efecto (como borrar una propiedad inexistente). <codeinline>delete</codeinline> también se evalúa como <codeinline>true</codeinline> cuando se utiliza (sin sentido) con una expresión que no es una expresión de acceso a una propiedad:</p>
    <pre>
    <code class="language-js">let o = &lbrace;x: 1};   // o tiene propiedad propia x y hereda propiedad toString
    delete o.x        // => true: borra la propiedad x
    delete o.x        // => true: no hace nada (x no existe) pero true de todas formas
    delete o.toString // => true: no hace nada (toString no es una propiedad propia)
    delete 1          // => true: no hace nada pero true de todas formas.</code></pre>
    <p><codeinline>delete</codeinline> no elimina las propiedades cuyo atributo <em>configurable</em> sea <codeinline>false</codeinline>. Ciertas propiedades de los objetos incorporados no son configurables, al igual que las propiedades del objeto global creado por la declaración de variables y la declaración de funciones. En modo estricto, el intento de eliminar una propiedad no configurable provoca un TypeError. En modo no estricto, <codeinline>delete</codeinline> simplemente se evalúa como <codeinline>false</codeinline> en este caso:</p>
    <pre>
    <code class="language-js">// En modo estricto, todas estas eliminaciones lanzan TypeError en lugar de devolver false
    delete Object.prototype // => false: la propiedad no es configurable
    var x = 1;              // Declara una variable global
    delete globalThis.x     // => false: no se puede borrar esta propiedad
    function f() &lbrace;}         // Declara una función global
    delete globalThis.f     // => false: tampoco se puede borrar esta propiedad</code></pre>
    <p>Al eliminar propiedades configurables del objeto global en modo no estricto, puede omitir la referencia al objeto global y simplemente seguir el operador <codeinline>delete</codeinline> con el nombre de la propiedad:</p>
    <pre>
    <code class="language-js">globalThis.x = 1; // Crea una propiedad global configurable (no let o var)
    delete x          // => true: esta propiedad puede ser borrada</code></pre>
    <p>En modo estricto, sin embargo, <codeinline>delete</codeinline> genera un SyntaxError si su operando es un identificador no cualificado como <codeinline>x</codeinline>, y tienes que ser explícito sobre el acceso a la propiedad:</p>
    <pre>
    <code class="language-js">delete x; // SyntaxError en modo estricto
    delete globalThis.x; // Esto funciona</code></pre>
  </section>
  <section id="5">
    <h2>6.5 Pruebas de propiedades</h2>
    <p>Los objetos JavaScript pueden considerarse como conjuntos de propiedades, y a menudo es útil poder comprobar la pertenencia al conjunto, es decir, comprobar si un objeto tiene una propiedad con un nombre determinado. Esto se puede hacer con el operador in, con los métodos <codeinline>hasOwnProperty()</codeinline> y <codeinline>propertyIsEnumerable()</codeinline>, o simplemente consultando la propiedad. Todos los ejemplos que se muestran aquí utilizan cadenas como nombres de propiedades, pero también funcionan con Symbols ( <a href="#10.3">§6.10.3</a>).</p>
    <p>El operador <codeinline>in</codeinline> espera un nombre de propiedad a la izquierda y un objeto a la derecha. Devuelve <codeinline>true</codeinline> si el objeto tiene una propiedad propia o heredada con ese nombre:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    "x" in o        // => true: o tiene una propiedad propia "x"
    "y" in o        // => false: o no tiene una propiedad "y"
    "toString" in o // => true: o hereda una propiedad toString</code></pre>
    <p>El método <codeinline>hasOwnProperty()</codeinline> de un objeto comprueba si ese objeto tiene una propiedad propia con el nombre dado. Devuelve <codeinline>false</codeinline> para las propiedades heredadas:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.hasOwnProperty("x")         // => true: o tiene una propiedad propia "x"
    o.hasOwnProperty("y")         // => false: o no tiene una propiedad "y"
    o.hasOwnProperty("toString")  // => false: toString es una propiedad heredada</code></pre>
    <p><codeinline>propertyIsEnumerable()</codeinline> refina la prueba <codeinline>hasOwnProperty()</codeinline>. Devuelve <codeinline>true</codeinline> sólo si la propiedad nombrada es una propiedad propia y su atributo <em>enumerable</em> es <codeinline>true</codeinline>. Algunas propiedades incorporadas no son enumerables. Las propiedades creadas por código Java Script normal son enumerables a menos que haya utilizado una de las técnicas mostradas en <a href="capitulo-14#1">§14.1</a> para hacerlas no enumerables.</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.propertyIsEnumerable("x")                       // => true: o tiene una propiedad propia enumerable "x"
    o.propertyIsEnumerable("toString")                // => false: no es una propiedad propia
    Object.prototype.propertyIsEnumerable("toString") // => false: no enumerable</code></pre>
    <p>En lugar de utilizar el operador <codeinline>in</codeinline>, a menudo basta con consultar la propiedad y utilizar <codeinline>!==</codeinline> para asegurarse de que no está indefinida:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.x !== undefined // => true: o tiene una propiedad propia "x"
    o.y !== undefined // => false: o no tiene una propiedad "y"
    o.toString !== undefined // => true: o hereda una propiedad "toString"</code></pre>
    <p>Hay una cosa que el operador <codeinline>in</codeinline> puede hacer que la simple técnica de acceso a propiedades mostrada aquí no puede hacer. <codeinline>in</codeinline> puede distinguir entre propiedades que no existen y propiedades que existen pero han sido establecidas a <codeinline>undefined</codeinline>. Considere este código:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: undefined }; // La propiedad se establece explicitamente a undefined
    o.x !== undefined         // => false: la propiedad existe pero no esta definida
    o.y !== undefined         // => false: la propiedad ni siquiera existe
    "x" in o                  // => true: la propiedad existe
    "y" in o                  // => false: la propiedad no existe
    delete o.x;               // Borra la propiedad x
    "x" in o                  // => false: ya no existe</code></pre>
  </section>
  <section id="6" class="py-4 xs:py-5 sm:py-6">
    <h2>6.6 Enumeración de propiedades</h2>
    <p>En lugar de comprobar la existencia de propiedades individuales, a veces queremos iterar u obtener una lista de todas las propiedades de un objeto. Hay varias formas de hacerlo.</p>
    <p>El bucle <codeinline>for/in</codeinline> se trató en <a href="capitulo-5#4-5">§5.4.5</a>. Ejecuta el cuerpo del bucle una vez por cada propiedad enumerable (propia o heredada) del objeto especificado, asignando el nombre de la propiedad a la variable del bucle. Los métodos incorporados que heredan los objetos no son enumerables, pero las propiedades que tu código añade a los objetos son enumerables por defecto. Por ejemplo:</p>
    <pre>
    <code class="language-js">let o = &lbrace;x: 1, y: 2, z: 3}; // Tres propiedades propias enumerables
    o.propertyIsEnumerable("toString") // => false: no enumerable
    for(let p in o) &lbrace; // Recorre las propiedades
    console.log(p); // Imprime x, y, y z, pero no toString
    }</code></pre>
    <p>Para evitar enumerar propiedades heredadas con <codeinline>for/in</codeinline>, puede añadir una comprobación explícita dentro del cuerpo del bucle:</p>
    <pre>
    <code class="language-js">for(let p in o) &lbrace;
      if (!o.hasOwnProperty(p)) continue; // Saltar propiedades heredadas
    }
    for(let p in o) &lbrace;
      if (typeof o[p] === "function") continue; // Saltar todos los métodos
    }</code></pre>
    <p>Como alternativa al uso de un bucle <codeinline>for/in</codeinline>, a menudo es más fácil obtener una matriz de nombres de propiedades para un objeto y luego recorrer esa matriz con un bucle <codeinline>for/of</codeinline>. Hay cuatro funciones que puedes utilizar para obtener un array de nombres de propiedades:</p>
    <ul>
      <li class="font-normal"><codeinline>Object.keys()</codeinline> devuelve una matriz con los nombres de las propiedades propias enumerables de un objeto. No incluye propiedades no enumerables, propiedades heredadas o propiedades cuyo nombre es un Símbolo (véase <a href="capitulo-6#10-3">§6.10.3</a>).</li>
      <li class="font-normal"><codeinline>Object.getOwnPropertyNames()</codeinline> funciona como <codeinline>Object.keys()</codeinline> pero devuelve también una matriz con los nombres de las propiedades propias no enumerables, siempre que sus nombres sean cadenas.</li>
      <li class="font-normal"><codeinline>Object.getOwnPropertySymbols()</codeinline> devuelve las propiedades propias cuyos nombres son Symbols, sean o no enumerables.</li>
      <li class="font-normal"><codeinline>Reflect.ownKeys()</codeinline> devuelve todos los nombres de propiedades propias, tanto enumerables como no enumerables, y tanto de cadena como de símbolo. (Véase <a href="capitulo-14#6">§14.6</a>.)</li>
    </ul>
    <p>Hay ejemplos del uso de <codeinline>Object.keys()</codeinline> con un bucle <codeinline>for/of</codeinline> en <a href="capitulo-6#7">§6.7</a>.</p>
  </section>
  <section id="6-1">
    <h2>6.6.1 Orden de enumeración de propiedades</h2>
    <p>ES6 define formalmente el orden en que se enumeran las propiedades propias de un objeto. <codeinline>Object.keys()</codeinline>, <codeinline>Object.getOwnPropertyNames()</codeinline>, <codeinline>Object.getOwnPropertySymbols()</codeinline>, <codeinline>Reflect.ownKeys()</codeinline> y métodos relacionados como <codeinline>JSON.stringify()</codeinline> enumeran todas las propiedades en el siguiente orden, sujeto a sus propias restricciones adicionales sobre si enumeran propiedades no enumerables o propiedades cuyos nombres son cadenas o símbolos:</p>
    <ul>
      <li class="font-normal">Las propiedades de cadena cuyos nombres son enteros no negativos se enumeran primero, en orden numérico de menor a mayor. Esta regla significa que las matrices y los objetos similares a matrices tendrán sus propiedades enumeradas en orden.</li>
      <li class="font-normal">Después de enumerar todas las propiedades que parecen índices de matrices, se enumeran todas las propiedades restantes con nombres de cadena (incluidas las propiedades que parecen números negativos o números de coma flotante). Estas propiedades se enumeran en el orden en que se añadieron al objeto. Para las propiedades definidas en un literal de objeto, este orden es el mismo en el que aparecen en el literal.</li>
      <li class="font-normal">Por último, las propiedades cuyos nombres son objetos Symbol se enumeran en el orden en que se añadieron al objeto.</li>
    </ul>
    <p>El orden de enumeración para el bucle <codeinline>for/in</codeinline> no está tan especificado como para estas funciones de enumeración, pero las implementaciones suelen enumerar las propiedades propias en el orden que se acaba de describir, y luego viajan por la cadena de prototipos enumerando las propiedades en el mismo orden para cada objeto prototipo. Tenga en cuenta, sin embargo, que una propiedad no será enumerada si ya se ha enumerado una propiedad con ese mismo nombre, o incluso si ya se ha considerado una propiedad no enumerable con el mismo nombre.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>6.7 Ampliación de objetos</h2>
    <p>Una operación común en los programas JavaScript es necesitar copiar las propiedades de un objeto a otro objeto. Es fácil hacerlo con código como este:</p>
    <pre>
    <code class="language-js">let target = &lbrace;x: 1}, source = &lbrace;y: 2, z: 3};
    for(let key of Object.keys(source)) &lbrace;
      target[key] = source[key];
    }
    target // => &lbrace;x: 1, y: 2, z: 3}</code></pre>
    <p>Pero como se trata de una operación común, varios frameworks de JavaScript han definido funciones de utilidad, a menudo denominadas <codeinline>extend()</codeinline>, para realizar esta operación de copia. Finalmente, en ES6, esta capacidad llega al núcleo del lenguaje JavaScript en forma de <codeinline>Object.assign()</codeinline>.</p>
    <p><codeinline>Object.assign()</codeinline> espera dos o más objetos como argumentos. Modifica y devuelve el primer argumento, que es el objeto de destino, pero no altera el segundo ni ningún argumento posterior, que son los objetos de origen. Para cada objeto de origen, copia las propiedades propias enumerables de ese objeto (incluidas aquellas cuyos nombres son Símbolos) en el objeto de destino. Procesa los objetos fuente en orden de lista de argumentos, de forma que las propiedades del primer objeto fuente anulen las propiedades con el mismo nombre del objeto destino y las propiedades del segundo objeto fuente (si existe) anulen las propiedades con el mismo nombre del primer objeto fuente.</p>
    <p><codeinline>Object.assign()</codeinline> copia propiedades con operaciones get y set de propiedades ordinarias, por lo que si un objeto origen tiene un método getter o el objeto destino tiene un método setter, serán invocados durante la copia, pero no serán copiados ellos mismos.</p>
    <p>Una razón para asignar propiedades de un objeto a otro es cuando tienes un objeto que define valores por defecto para muchas propiedades y quieres copiar esas propiedades por defecto en otro objeto si una propiedad con ese nombre no existe ya en ese objeto. Utilizar <codeinline>Object.assign()</codeinline> ingenuamente no hará lo que quieres:</p>
    <pre>
    <code class="language-js">Object.assign(o, defaults); // sobreescribe todos los objetos en o con los default</code></pre>
    <p>En su lugar, lo que puedes hacer es crear un nuevo objeto, copiar los valores predeterminados en él, y luego anular los valores predeterminados con las propiedades en <codeinline>o</codeinline>:</p>
    <pre>
    <code class="language-js">o = Object.assign(&lbrace;}, defaults, o);</code></pre>
    <p>Veremos en <a href="capitulo-6#10-4">§6.10.4</a> que también se puede expresar esta operación de copia y anulación de objetos utilizando el operador de propagación <codeinline>...</codeinline> de la siguiente manera:</p>
    <pre>
    <code class="language-js">o = &lbrace;...defaults, ...o};</code></pre>
    <p>También podríamos evitar la sobrecarga de la creación y copia extra de objetos escribiendo una versión de <codeinline>Object.assign()</codeinline> que copie las propiedades sólo si faltan:</p>
    <pre>
    <code class="language-js">// Como Object.assign() pero no sobreescribe propiedades existentes
    // (y también no maneja propiedades de Símbolos)
    function merge(target, ...sources) &lbrace;
      for(let source of sources) &lbrace;
        for(let key of Object.keys(source)) &lbrace;
          if (!(key in target)) &lbrace; // Este es diferente a Object.assign()
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    Object.assign(&lbrace;x: 1}, &lbrace;x: 2, y: 2}, &lbrace;y: 3, z: 4}) // => &lbrace;x: 2, y: 3, z: 4}
    merge(&lbrace;x: 1}, &lbrace;y: 3, z: 4}) // => &lbrace;x: 1, y: 2, z: 4}</code></pre>
    <p>Es sencillo escribir otras utilidades de manipulación de propiedades como esta función <codeinline>merge()</codeinline>. Una funció <codeinline>restrict()</codeinline> podría eliminar propiedades de un objeto si no aparecen en otro objeto de plantilla, por ejemplo. O una función <codeinline>subtract()</codeinline> podría eliminar todas las propiedades de un objeto de otro objeto.</p>
  </section>
  <section id="8">
    <h2>6.8 Serialización de objetos</h2>
    <p>La <em>serialización de objetos</em> es el proceso de convertir el estado de un objeto en una cadena a partir de la cual puede restaurarse posteriormente. Las funciones <codeinline>JSON.stringify()</codeinline> y <codeinline>JSON.parse()</codeinline> serializan y restauran objetos JavaScript. Estas funciones utilizan el formato de intercambio de datos JSON. JSON significa "JavaScript Object Notation", y su sintaxis es muy similar a la de los literales de objetos y matrices de JavaScript:</p>
    <pre>
    <code class="language-js">let o = &lbrace;x: 1, y: &lbrace;z: [false, null, ""]}}; // Define una prueba de objeto
    let s = JSON.stringify(o); // s == '&lbrace;"x":1,"y":&lbrace;"z":[false,null,""]}}'
    let p = JSON.parse(s); // p == &lbrace;x: 1, y: &lbrace;z: [false, null, ""]}}</code></pre>
    <p>La sintaxis JSON es un <em>subconjunto</em> de la sintaxis JavaScript y no puede representar todos los valores JavaScript. Los objetos, las matrices, las cadenas, los números finitos, <codeinline>true</codeinline>, <codeinline>false</codeinline> y <codeinline>null</codeinline> son compatibles y se pueden serializar y restaurar. <codeinline>NaN</codeinline>, <codeinline>Infinity</codeinline> y <codeinline>-Infinity</codeinline> se serializan como <codeinline>null</codeinline>. Los objetos Date se serializan a cadenas de fecha con formato ISO (véase la función <codeinline>Date.toJSON()</codeinline>), pero <codeinline>JSON.parse()</codeinline> los deja en forma de cadena y no restaura el objeto Date original. Los objetos Function, RegExp y Error y el valor <codeinline>undefined</codeinline> no se pueden serializar ni restaurar. <codeinline>JSON.stringify()</codeinline> sólo serializa las propiedades propias enumerables de un objeto. Si el valor de una propiedad no se puede serializar, dicha propiedad simplemente se omite de la cadena de salida. Tanto <codeinline>JSON.stringify()</codeinline> como <codeinline>JSON.parse()</codeinline> aceptan segundos argumentos opcionales que pueden utilizarse para personalizar el proceso de serialización y/o restauración especificando una lista de propiedades a serializar, por ejemplo por ejemplo, o convirtiendo ciertos valores durante el proceso de serialización o stringificación. La documentación completa de estas funciones se encuentra en <a href="capitulo-11#6">§11.6</a>.</p>
  </section>
  <section id="9" class="py-4 xs:py-5 sm:py-6">
    <h2>6.9 Métodos Objeto</h2>
    <p>Como se ha comentado anteriormente, todos los objetos JavaScript (excepto los creados explícitamente sin prototipo) heredan propiedades de <codeinline>Object.prototype</codeinline>. Estas propiedades heredadas son principalmente métodos, y debido a que están disponibles universalmente, son de particular interés para los programadores de JavaScript. Ya hemos visto los métodos <codeinline>hasOwnProperty()</codeinline> y <codeinline>propertyIsEnumerable()</codeinline>, por ejemplo. (Y también hemos cubierto bastantes funciones estáticas definidas en el constructor <codeinline>Object</codeinline>, como <codeinline>Object.create()</codeinline> y <codeinline>Object.keys()</codeinline>.) Esta sección explica un puñado de métodos de objeto universales que están definidos en <codeinline>Object.prototype</codeinline>, pero que están pensados para ser reemplazados por otras implementaciones más especializadas. En las secciones siguientes, mostramos ejemplos de definición de estos métodos en un objeto individual. En el <a href="capitulo-9">Capítulo 9</a>, aprenderá a definir estos métodos de forma más general para toda una clase de objetos.</p>
  </section>
  <section id="9-1">
    <h2>6.9.1 El método toString()</h2>
    <p>El método <codeinline>toString()</codeinline> no toma argumentos; devuelve una cadena que representa de algún modo el valor del objeto sobre el que se invoca. JavaScript invoca este método de un objeto siempre que necesita convertir el objeto en una cadena. Esto ocurre, por ejemplo, cuando se utiliza el operador <codeinline>+</codeinline> para concatenar una cadena con un objeto o cuando se pasa un objeto a un método que espera una cadena.</p>
    <p>El método por defecto <codeinline>toString()</codeinline> no es muy informativo (aunque es útil para determinar la clase de un objeto, como veremos en <a href="capitulo-14#4-3">§14.4.3</a> ). Por ejemplo, la siguiente línea de código simplemente evalúa a la cadena "[objeto Objeto]":</p>
    <pre>
    <code class="language-js">let s = &lbrace; x: 1, y: 1 }.toString(); // s == "[object Object]"</code></pre>
    <p>Dado que este método por defecto no muestra mucha información útil, muchas clases definen sus propias versiones de <codeinline>toString()</codeinline>. Por ejemplo, cuando una matriz se convierte en una cadena, se obtiene una lista de los elementos de la matriz, cada uno convertido en una cadena, y cuando una función se convierte en una cadena, se obtiene el código fuente de la función. Puede definir su propio método <codeinline>toString()</codeinline> de la siguiente manera:</p>
    <pre>
    <code class="language-js">let point = &lbrace;
      x: 1,
      y: 2,
      toString: function() &lbrace; return `($&lbrace;this.x}, $&lbrace;this.y})`; }
    };
    String(point) // => "(1, 2)": toString() es usado para convertir en string</code></pre>
  </section>
  <section id="9-2" class="py-4 xs:py-5 sm:py-6">
    <h2>6.9.2 El método toLocaleString()</h2>
    <p>Además del método básico <codeinline>toString()</codeinline>, todos los objetos tienen un método <codeinline>toLocaleString()</codeinline>. El propósito de este método es devolver una representación de cadena localizada del objeto. El método por defecto <codeinline>toLocaleString()</codeinline> definido por Object no realiza ninguna localización por sí mismo: simplemente llama a <codeinline>toString()</codeinline> y devuelve ese valor. Las clases Date y Number definen versiones personalizadas de <codeinline>toLocaleString()</codeinline> que intentan formatear números, fechas y horas de acuerdo con las convenciones locales. Array define un método <codeinline>toLocaleString()</codeinline> que funciona como <codeinline>toString()</codeinline>, salvo que formatea los elementos del array llamando a sus métodos <codeinline>toLocaleString()</codeinline> en lugar de a sus métodos <codeinline>toString()</codeinline>. Se podría hacer lo mismo con un objeto punto de esta forma:</p>
    <pre>
    <code class="language-js">let point = &lbrace;
      x: 1000,
      y: 2000,
      toString: function() &lbrace; return `($&lbrace;this.x}, $&lbrace;this.y})`; },
      toLocaleString: function() &lbrace;
        return `($&lbrace;this.x.toLocaleString()}, $&lbrace;this.y.toLocaleString()})`;
      }
    };
    point.toString() // => "(1000, 2000)"
    point.toLocaleString() // => "(1,000, 2,000)": observe los separadores de miles</code></pre>
    <p>Las clases de internacionalización documentadas en <a href="capitulo-11#7">§11.7</a> pueden ser útiles a la hora de implementar un método <codeinline>toLocaleString()</codeinline>.</p>
  </section>
  <section id="9-3">
    <h2>6.9.3 El método valueOf()</h2>
    <p>El método <codeinline>valueOf()</codeinline> es muy parecido al método <codeinline>toString()</codeinline>, pero se ejecuta cuando JavaScript necesita convertir un objeto en un tipo primitivo distinto de una cadena, normalmente un número. JavaScript llama a este método automáticamente si se utiliza un objeto en un contexto en el que se requiere un valor primitivo. El método <codeinline>valueOf()</codeinline> por defecto no hace nada interesante, pero algunas de las clases incorporadas definen su propio método <codeinline>valueOf()</codeinline>. La clase Date define <codeinline>valueOf()</codeinline> para convertir fechas en números, y esto permite comparar cronológicamente los objetos Date con <codeinline>&lt;</codeinline> y <codeinline>&gt;</codeinline>. Se puede hacer algo parecido con un objeto punto, definiendo un método <codeinline>valueOf()</codeinline> que devuelva la distancia desde el origen al punto:</p>
    <pre>
    <code class="language-js">let point = &lbrace;
      x: 3,
      y: 4,
      valueOf: function() &lbrace; return Math.hypot(this.x, this.y); }
    };
    Number(point) // => 5: valueOf() es usado para convertir en número
    point > 4 // => true
    point > 5 // => false
    point &lt; 6 // => true</code></pre>
  </section>
  <section id="9-4" class="py-4 xs:py-5 sm:py-6">
    <h2>6.9.4 El método toJSON()</h2>
    <p>En realidad, <codeinline>Object.prototype</codeinline> no define un método <codeinline>toJSON()</codeinline>, pero el método <codeinline>JSON.stringify()</codeinline> (véase <a href="#8">§6.8</a>) busca un método <codeinline>toJSON()</codeinline> en cualquier objeto que se le pida serializar. Si este método existe en el objeto a serializar, se invoca, y se serializa el valor de retorno, en lugar del objeto original. La clase Date (<a href="capitulo-11#4">§11.4</a>) define un método <codeinline>toJSON()</codeinline> que devuelve una representación de cadena serializable de la fecha. Podríamos hacer lo mismo para nuestro objeto Point de esta forma:</p>
    <pre>
    <code class="language-js">let point = &lbrace;
      x: 1,
      y: 2,
      toString: function() &lbrace; return `($&lbrace;this.x}, $&lbrace;this.y})`; },
      toJSON: function() &lbrace; return this.toString(); }
    };
    JSON.stringify([point]) // => '["(1, 2)"]'</code></pre>
  </section>
  <section id="10">
    <h2>6.10 Sintaxis literal de objeto ampliada</h2>
    <p>Las versiones recientes de JavaScript han ampliado la sintaxis de los literales de objeto de varias formas útiles. Las siguientes subsecciones explican estas extensiones.</p>
  </section>
  <section id="10-1" class="py-4 xs:py-5 sm:py-6">
    <h2>6.10.1 Propiedades abreviadas</h2>
    <p>Supongamos que tienes valores almacenados en las variables <codeinline>x</codeinline> e <codeinline>y</codeinline> y quieres crear un objeto con propiedades llamadas <codeinline>x</codeinline> e <codeinline>y</codeinline> que contengan esos valores. Con la sintaxis literal de objeto básica, acabaría repitiendo cada identificador dos veces:</p>
    <pre>
    <code class="language-js">let x = 1, y = 2;
    let o = &lbrace;
      x: x,
      y: y
    };</code></pre>
    <p>En ES6 y posteriores, puedes eliminar los dos puntos y una copia del identificador y acabar con un código mucho más simple:</p>
    <pre>
    <code class="language-js">let x = 1, y = 2;
    let o = &lbrace; x, y };
    o.x + o.y // => 3</code></pre>
  </section>
</Layoutjavascript>