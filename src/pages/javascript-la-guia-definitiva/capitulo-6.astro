---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-5" capSiguiente="capitulo-7" />
  <section class="fadeIn">
    <h1>Objetos</h1>
    <p>Los objetos son el tipo de datos más fundamental de JavaScript, y ya los has visto
      muchas veces en los capítulos que preceden a éste. Debido a que los objetos son tan
      importantes para el lenguaje JavaScript, es importante que entiendas cómo funcionan
      en detalle, y este capítulo proporciona ese detalle. Comienza con una descripción
      formal de los objetos, y luego se sumerge en secciones prácticas sobre la creación de
      objetos y la consulta, configuración, eliminación, comprobación y enumeración de
      las propiedades de los objetos. Estas secciones centradas en las propiedades van
      seguidas de otras que explican cómo extender, serializar y definir métodos
      importantes en los objetos. Finalmente, el capítulo concluye con una larga sección
      sobre la nueva sintaxis literal de objetos en ES6 y versiones más recientes del lenguaje.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>6.1 Introducción a los objetos</h2>
    <p>Un objeto es un valor compuesto: agrega múltiples valores (valores primitivos u otros
      objetos) y permite almacenar y recuperar esos valores por su nombre. Un objeto es
      una colección desordenada de <em>propiedades</em>, cada una de las cuales tiene un nombre y
      un valor. Los nombres de las propiedades suelen ser cadenas (aunque, como veremos
      en <a href="#6-10-3">§6.10.3</a>, los nombres de las propiedades también pueden ser símbolos), por lo que
      podemos decir que los objetos convierten cadenas en valores. Este mapeo de cadena a
      valor recibe varios nombres, probablemente ya estés familiarizado con la estructura
      de datos fundamental bajo el nombre de "hash", "hashtable", "diccionario" o "array
      asociativo". Sin embargo, un objeto es más que un simple mapa cadena-valor.
      Además de mantener su propio conjunto de propiedades, un objeto JavaScript
      también hereda las propiedades de otro objeto, conocido como su "prototipo". Los
      métodos de un objeto suelen ser propiedades heredadas, y esta "herencia prototípica"
      es una característica clave de JavaScript.</p>
    <p>Los objetos JavaScript son dinámicos (normalmente se pueden añadir y eliminar
      propiedades), pero se pueden utilizar para simular los objetos estáticos y los "structs" de los lenguajes tipados estáticamente. También pueden utilizarse (ignorando la parte
      de valor del mapeo cadena-valor) para representar conjuntos de cadenas.</p>
    <p>Cualquier valor en JavaScript que no sea una cadena, un número, un Símbolo, o
      <codeinline>true</codeinline>, <codeinline>false</codeinline>, <codeinline>null</codeinline> o <codeinline>undefined</codeinline> es un objeto. Y aunque las cadenas, los
      números y los booleanos no son objetos, pueden comportarse como objetos
      inmutables.</p>
    <p>Recordemos de <a href="capitulo-3#8">§3.8</a> que los objetos son <em>mutables</em> y se manipulan por referencia en
      lugar de por valor. Si la variable <codeinline>x</codeinline> se refiere a un objeto y se ejecuta el código <codeinline>let y = x;</codeinline> la variable <codeinline>y</codeinline> contiene una referencia al mismo objeto, no una copia de ese objeto. Cualquier modificación hecha al objeto a través de la variable <codeinline>y</codeinline> es también visible a través de la variable <codeinline>x</codeinline>.</p>
    <p>Lo más habitual con los objetos es crearlos y establecer, consultar, borrar, comprobar
      y enumerar sus propiedades. Estas operaciones fundamentales se describen en las
      primeras secciones de este capítulo. Las secciones siguientes tratan temas más
      avanzados.</p>
    <p>Una <em>propiedad</em> tiene un nombre y un valor. El nombre de una propiedad puede ser
      cualquier cadena, incluida la cadena vacía (o cualquier Símbolo), pero ningún objeto
      puede tener dos propiedades con el mismo nombre. El valor puede ser cualquier
      valor JavaScript, o puede ser una función getter o setter (o ambas). Aprenderemos
      sobre las funciones getter y setter en <a href="#6-10-6">§6.10.6</a>.</p>
    <p>A veces es importante saber distinguir entre las propiedades definidas directamente
      en un objeto y las que se heredan de un objeto prototipo. JavaScript utiliza el término
      <em>propiedad propia</em> para referirse a las propiedades no heredadas.</p>
    <p>Además de su nombre y valor, cada propiedad tiene tres <em>atributos</em>:</p>
    <ul>
      <li class="font-normal">El atributo <em>writable</em> especifica si se puede establecer el valor de la propiedad.</li>
      <li class="font-normal">El atributo <em>enumerable</em> especifica si el nombre de la propiedad es devuelto por un bucle <codeinline>for/in</codeinline>.</li>
      <li class="font-normal">El atributo <em>configurable</em> especifica si la propiedad se puede eliminar y si se
        pueden modificar sus atributos.</li>
    </ul>
    <p>Muchos de los objetos incorporados de JavaScript tienen propiedades que son de sólo
      lectura, no enumerables o no configurables. Por defecto, sin embargo, todas las
      propiedades de los objetos que creas son escribibles, enumerables y configurables. En
      <a href="capitulo-14#1">§14.1</a> se explican técnicas para especificar valores de atributos de propiedades no
      predeterminados para los objetos.</p>
  </section>
  <section id="2">
    <h3>6.2 Creación de objetos</h3>
    <p>Los objetos pueden crearse con literales de objeto, con la palabra clave new y con la función <codeinline>Object.create()</codeinline>. Las subsecciones siguientes describen cada técnica.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h3>6.2.1 Literales de objeto</h3>
    <p>La forma más sencilla de crear un objeto es incluir un literal de objeto en el código
      JavaScript. En su forma más simple, un <em>literal de objeto</em> es una lista separada por
      comas de pares nombre:valor separados por dos puntos, encerrados entre llaves. Un
      nombre de propiedad es un identificador de Java Script o un literal de cadena (se
      permite la cadena vacía). Un valor de propiedad es cualquier expresión de JavaScript;
      el valor de la expresión (puede ser un valor primitivo o un valor de objeto) se
      convierte en el valor de la propiedad. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">let empty = &lbrace;}; // Un objeto sin propiedades
    let point = &lbrace; x: 0, y: 0 }; // Dos propiedades numéricas
    let p2 = &lbrace; x: point.x, y: point.y+1 }; // Valores mas complejos
    let book = &lbrace;
      "main title": "JavaScript", // Estas propiedades incluyen espacios
      "sub-title": "The Definitive Guide", // y guiones, asi que utilice literales de cadena.
      for: "all audiences", // para esta reservado, pero sin comillas
      author: &lbrace; // El valor de esta propiedad es
        firstname: "David", // un objeto por si mismo.
        surname: "Flanagan"
      }
    };</code></pre>
    <p>Una coma al final de la última propiedad en un objeto literal es legal, y algunos estilos
        de programación fomentan el uso de estas comas al final para que sea menos
        probable que se produzca un error de sintaxis si se añade una nueva propiedad al
        final del objeto literal en algún momento posterior.</p>
    <p>Un literal de objeto es una expresión que crea e inicializa un objeto nuevo y distinto
      cada vez que se evalúa. El valor de cada propiedad se evalúa cada vez que se evalúa el
      literal. Esto significa que un único literal de objeto puede crear muchos objetos
      nuevos si aparece dentro del cuerpo de un bucle o en una función que se llama
      repetidamente, y que los valores de las propiedades de estos objetos pueden diferir
      entre sí.</p>
    <p>Los literales de objeto mostrados aquí utilizan una sintaxis simple que ha sido legal
      desde las primeras versiones de JavaScript. Las versiones recientes del lenguaje han
      introducido una serie de nuevas características de literales de objeto, que se tratan en
      <a href="#6-10">§6.10</a>.</p>
  </section>
  <section id="2-2">
    <h2>6.2.2 Creación de objetos con new</h2>
    <p>El operador <codeinline>new</codeinline> crea e inicializa un nuevo objeto. La palabra clave <codeinline>new</codeinline> debe ir
      seguida de una invocación a una función. Una función utilizada de este modo se
      denomina <em>constructor</em> y sirve para inicializar un objeto recién creado. JavaScript
      incluye constructores para sus tipos incorporados. Por ejemplo:</p>
    <pre>
    <code class="language-js">let o = new Object(); // Crea un objeto vacio: igual a &lbrace;}.
    let a = new Array(); // Crea un array vacío: igual a [].
    let d = new Date(); // Crea un objeto Date representando la fecha actual.
    let r = new Map(); // Crea un objeto Map para mapeos clave-valor.</code></pre>
    <p>Además de estos constructores incorporados, es común definir sus propias funciones
      constructoras para inicializar los objetos recién creados. Esto se explica en el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>6.2.3 Prototipos</h2>
    <p>Antes de que podamos cubrir la tercera técnica de creación de objetos, debemos
      detenernos un momento para explicar los <em>prototipos</em>. Casi todos los objetos
      JavaScript tienen un segundo objeto JavaScript asociado. Este segundo objeto se
      conoce como prototipo, y el primer objeto hereda propiedades del prototipo.</p>
    <p>Todos los objetos creados por literales de objeto tienen el mismo objeto prototipo, y
      podemos referirnos a este objeto prototipo en código JavaScript como
      <codeinline>Object.prototype</codeinline>. Los objetos creados mediante la palabra clave <codeinline>new</codeinline> y la
      invocación de un constructor utilizan como prototipo el valor de la propiedad
      <codeinline>prototype</codeinline> de la función constructora. Así, el objeto creado por <codeinline>new Object()</codeinline>
      hereda de <codeinline>Object.prototype</codeinline>, al igual que el objeto creado por <codeinline>&lbrace;}</codeinline>. Del mismo modo,
      el objeto creado por <codeinline>new Array()</codeinline> utiliza <codeinline>Array.prototype</codeinline> como su prototipo, y el
      objeto creado por <codeinline>new Date()</codeinline> utiliza <codeinline>Date.prototype</codeinline> como su prototipo. Esto
      puede resultar confuso cuando se aprende JavaScript por primera vez. Recuerda: casi
      todos los objetos tienen un <em>prototipo</em>, pero sólo un número relativamente pequeño de
      objetos tienen una propiedad <codeline>prototype</codeline>. Son estos objetos con propiedades <codeinline>prototype</codeinline> los
      que definen los <em>prototipos</em> para todos los demás objetos.</p>
    <p><codeinline>Object.prototype</codeinline> es uno de los raros objetos que no tiene prototipo: no hereda
      ninguna propiedad. Otros objetos prototipo son objetos normales que sí tienen un
      prototipo. La mayoría de los constructores incorporados (y la mayoría de los
      constructores definidos por el usuario) tienen un prototipo que hereda de
      <codeinline>Object.prototype</codeinline>. Por ejemplo, <codeinline>Date.prototype</codeinline> hereda las propiedades de
      <codeinline>Object.prototype</codeinline>, por lo que un objeto Date creado por <codeinline>new Date()</codeinline> hereda las
      propiedades tanto de <codeinline>Date.prototype</codeinline> como de <codeinline>Object.prototype</codeinline>. Esta serie
      enlazada de objetos prototipo se conoce como <em>cadena prototipo</em>.</p>
    <p>En <a href="#6-3">§6.3.2</a> se explica cómo funciona la herencia de propiedades. El <a href="capitulo-9">capítulo 9</a> explica con más detalle la conexión entre prototipos y constructores: muestra cómo definirnuevas "clases" de objetos escribiendo una función constructora y estableciendo su propiedad proto type en el objeto prototipo que utilizarán las "instancias" creadas con ese constructor. Y aprenderemos cómo consultar (e incluso cambiar) el prototipo de un objeto en <a href="#14-3">§14.3</a>.</p>
  </section>
  <section id="2-4">
    <h2>6.2.4 Object.create()</h2>
    <p><codeinline>Object.create()</codeinline> crea un nuevo objeto, utilizando su primer argumento como el prototipo de dicho objeto:</p>
    <pre>
    <code class="language-js">let o1 = Object.create(&lbrace;x: 1, y: 2}); // o1 hereda las propiedades x e y.
    o1.x + o1.y                           // => 3</code></pre>
    <p>Puedes pasar <codeinline>null</codeinline> para crear un nuevo objeto que no tenga prototipo, pero si haces
      esto, el objeto recién creado no heredará nada, ni siquiera métodos básicos como <codeinline>toString()</codeinline> (lo que significa que tampoco funcionará con el operador <codeinline>+</codeinline>):</p>
    <pre>
    <code class="language-js">let o2 = Object.create(null); // o2 no hereda props ni metodos.</code></pre>
    <p>Si desea crear un objeto vacío ordinario (como el objeto devuelto por <codeinline>&lbrace;}</codeinline> o <codeinline>new Object()</codeinline>), pase <codeinline>Object.prototype</codeinline>:</p>
    <pre>
    <code class="language-js">let o3 = Object.create(Object.prototype); // o3 es como &lbrace;} o new Object().</code></pre>
    <p>La capacidad de crear un nuevo objeto con un prototipo arbitrario es muy poderosa,
      y utilizaremos <codeinline>Object.create()</codeinline> en varios lugares a lo largo de este capítulo.
      (<codeinline>Object.create()</codeinline> también toma un segundo argumento opcional que describe las
      propiedades del nuevo objeto. Este segundo argumento es una característica
      avanzada cubierta en <a href="capitulo-14#1">§14.1</a>.)</p>
    <p>Un uso de <codeinline>Object.create()</codeinline> es cuando se quiere evitar la modificación no
      intencionada (pero no maliciosa) de un objeto por una función de la biblioteca sobre
      la que no se tiene control. En lugar de pasar el objeto directamente a la función,
      puede pasar un objeto que herede de él. Si la función lee propiedades de ese objeto,
      verá los valores heredados. Sin embargo, si establece propiedades, esas escrituras no
      afectarán al objeto original.</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: "no cambies este valor" };
    library.function(Object.create(o)); // Protéjase contra modificaciones accidentales</code></pre>
    <p>Para entender por qué funciona esto, necesitas saber cómo se consultan y establecen
      las propiedades en JavaScript. Estos son los temas de la siguiente sección.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>6.3 Consulta y configuración de propiedades</h2>
    <p>Para obtener el valor de una propiedad, utilice los operadores punto (<codeinline>.</codeinline>) o corchete
      (<codeinline>[]</codeinline>) descritos en <a href="#4-4">§4.4</a>. El lado izquierdo debe ser una expresión cuyo valor sea un objeto. Si se utiliza el operador de punto, el lado derecho debe ser un identificador
      simple que nombre la propiedad. Si se utilizan corchetes, el valor dentro de los
      corchetes debe ser una expresión que se evalúe como una cadena que contenga el
      nombre de la propiedad deseada:</p>
    <pre>
    <code class="language-js">let author = book.author; // Obtener la propiedad "author" del libro.
    let name = author.surname; // Obtener la propiedad "surname" del autor.
    let title = book["main title"]; // Obtener la propiedad "main title" del libro.</code></pre>
    <p>Para crear o establecer una propiedad, utilice un punto o corchetes como lo haría
      para consultar la propiedad, pero póngalos en el lado izquierdo de una expresión de
      asignación:</p>
    <pre>
    <code class="language-js">book.edition = 7; // Crea una propiedad llamada "edition" en el libro.
    book["main title"] = "ECMAScript"; // Cambia el valor de la propiedad "main title".</code></pre>
    <p>Al utilizar la notación de corchetes, hemos dicho que la expresión dentro de los
      corchetes debe evaluarse a una cadena. Una afirmación más precisa es que la
      expresión debe evaluarse a una cadena o a un valor que pueda convertirse a una cadena o a un
      Símbolo (<a href="#10-3">§6.10.3</a>). En el <a href="capitulo-7">Capítulo 7</a>, por ejemplo, veremos que es habitual utilizar números dentro de los corchetes.</p>
  </section>
  <section id="3-1">
    <h2>6.3.1 Objetos como matrices asociativas</h2>
    <p>Como se ha explicado en la sección anterior, las dos expresiones JavaScript siguientes tienen el mismo valor:</p>
    <pre>
    <code class="language-js">object.property
    object["property"]</code></pre>
    <p>La primera sintaxis, que utiliza el punto y un identificador, es similar a la utilizada
      para acceder a un campo estático de una estructura o un objeto en C o Java. La
      segunda sintaxis, que utiliza corchetes y una cadena, se parece al acceso a un array,
      pero a un array indexado por cadenas en lugar de por números. Este tipo de matriz se
      conoce como <em>matriz asociativa</em> (o hash o mapa o diccionario). Los objetos JavaScript
      son arrays asociativos, y esta sección explica por qué es importante.</p>
    <p>En C, C++, Java y lenguajes de tipado fuerte similares, un objeto sólo puede tener un
      número fijo de propiedades, y los nombres de estas propiedades deben definirse de
      antemano. Dado que JavaScript es un lenguaje poco tipado, esta regla no se aplica: un
      programa puede crear cualquier número de propiedades en cualquier objeto. Sin
      embargo, cuando se utiliza el operador <codeinline>.</codeinline> para acceder a una propiedad de un objeto,
      el nombre de la propiedad se expresa como un identificador. Los identificadores
      deben escribirse literalmente en su programa JavaScript; no son un tipo de dato, por
      lo que no pueden ser manipulados por el programa.</p>
    <p>Por otro lado, cuando se accede a una propiedad de un objeto con la anotación de
      matriz <codeinline>[]</codeinline>, el nombre de la propiedad se expresa como una cadena. Las cadenas son
      tipos de datos de JavaScript, por lo que pueden manipularse y crearse mientras se
      ejecuta un programa. Así, por ejemplo, puede escribir el siguiente código en
      JavaScript:</p>
    <pre>
    <code class="language-js">let addr = "";
    for(let i = 0; i &lt; 4; i++) &lbrace;
      addr += customer[`address$&lbrace;i}`] + "\n";
    }</code></pre>
    <p>Este código lee y concatena la <codeinline>address0</codeinline>, <codeinline>address1</codeinline>,<codeinline>address2</codeinline> y <codeinline>address3</codeinline>
      del objeto <codeinline>customer</codeinline>.</p>
    <p>Este breve ejemplo demuestra la flexibilidad de utilizar la notación de matrices para
      acceder a las propiedades de un objeto con expresiones de cadena. Este código podría
      reescribirse utilizando la notación de puntos, pero hay casos en los que sólo la
      notación de matrices servirá. Supongamos, por ejemplo, que está escribiendo un
      programa que utiliza recursos de red para calcular el valor actual de las inversiones
      bursátiles del usuario. El programa permite al usuario escribir el nombre de cada
      acción que posee, así como el número de acciones de cada acción. Puede utilizar un objeto llamado <codeinline>portfolio</codeinline> para almacenar esta información. El objeto tiene una propiedad por cada acción. El nombre de la propiedad es el nombre de la acción, y el valor de la propiedad es el número de acciones de esa acción. Así, por ejemplo, si
      un usuario tiene 50 acciones de IBM, la propiedad <codeinline>portfolio.ibm</codeinline> tiene el valor <codeinline>50</codeinline>.</p>
    <p>Parte de este programa podría ser una función para añadir una nueva acción a la cartera:</p>
    <pre>
    <code class="language-js">function addstock(portfolio, stockname, shares) &lbrace;
      portfolio[stockname] = shares;
    }</code></pre>
    <p>Dado que el usuario introduce los nombres de las acciones en tiempo de ejecución,
      no hay forma de que pueda conocer los nombres de las propiedades de antemano.
      Como no puede conocer los nombres de las propiedades cuando escribe el programa,
      no hay forma de que pueda utilizar el operador <codeinline>.</codeinline> para acceder a las propiedades del
      objeto <codeinline>portfolio</codeinline>. Puede utilizar el operador <codeinline>[]</codeinline>, sin embargo, porque utiliza un valor de cadena (que es dinámico y puede cambiar en tiempo de ejecución) en lugar de un
      identificador (que es estático y debe ser codificado en el programa) para nombrar la
      propiedad.</p>
    <p>En el <a href="capitulo-5">Capítulo 5</a>, introdujimos el bucle <codeinline>for/in</codeinline> (y volveremos a verlo en breve, en <a href="#6-6">§6.6</a>). El poder de esta sentencia JavaScript se hace evidente cuando se considera su uso con matrices asociativas. Así es como se utilizaría para calcular el valor total de portfolio:</p>
    <pre>
    <code class="language-js">function computeValue(portfolio) &lbrace;
      let total = 0.0;
      for(let stock in portfolio) &lbrace;     // Por cada stock en el portfolio
        let shares = portfolio[stock];  // obtener el número de accione
        let price = getQuote(stock);    // buscar el precio de acción
        total += shares * price;        // agregar el valor de acción
      }
      return total; // Devolver el valor total
    }</code></pre>
    <p>Los objetos JavaScript se utilizan comúnmente como matrices asociativas, como se
      muestra aquí, y es importante entender cómo funciona. En ES6 y posteriores, sin
      embargo, la clase Map descrita en <a href="capitulo-11#1-2">§11.1.2</a> es a menudo una mejor opción que usar un
      objeto plano.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>6.3.2 Herencia</h2>
    <p>Los objetos JavaScript tienen un conjunto de "propiedades propias" y también
      heredan un conjunto de propiedades de su objeto prototipo. Para entender esto,
      debemos considerar el acceso a las propiedades con más detalle. Los ejemplos de esta
      sección utilizan la función <codeinline>Object.create()</codeinline> para crear objetos con prototipos
      específicos. Sin embargo, veremos en el <a href="capitulo-9">Capítulo 9</a> que cada vez que se crea una
      instancia de una clase con new, se está creando un objeto que hereda propiedades de
      un objeto prototipo.</p>
    <p>Supongamos que se consulta la propiedad <codeinline>x</codeinline> en el objeto <codeinline>o</codeinline>. Si <codeinline>o</codeinline> no tiene una propiedad propia con ese nombre, Se consulta el objeto prototipo de <codeinline>o</codeinline><sup>1</sup> para la propiedad <codeinline>x</codeinline>. Si el objeto prototipo no tiene una propiedad propia con ese nombre, pero tiene un prototipo, l a consulta se realiza en el prototipo del prototipo. Esto continúa hasta que se encuentra la propiedad <codeinline>x</codeinline> o hasta que se busca un objeto con un prototipo <codeinline>null</codeinline>. Como puede ver, el atributo <codeinline>prototype</codeinline> de un objeto crea una cadena o lista enlazada de la que se heredan propiedades:</p>
    <pre>
    <code class="language-js">let o = &lbrace;};               // o hereda los metodos de Object.prototype
    o.x = 1;                  // y ahora tiene una propiedad propia x.
    let p = Object.create(o); // p hereda las propiedades de o, y Object.prototype
    p.y = 2;                  // y tiene una propiedad propia y.
    let q = Object.create(p); // q hereda las propiedades de p, o y...
    q.z = 3;                  // ...Object.prototype tiene una propiedad propia z.
    let f = q.toString();     // toString se hereda de Object.prototype
    q.x + q.y                 // => 3; x e y se heredan de o y p</code></pre>
    <p>Supongamos ahora que asigna a la propiedad <codeinline>x</codeinline> del objeto <codeinline>o</codeinline>. Si <codeinline>o</codeinline> ya tiene una propiedad propia (no heredada) llamada <codeinline>x</codeinline>, entonces la asignación simplemente cambia el valor de esta propiedad existente. De lo contrario, la asignación crea una
      nueva propiedad llamada <codeinline>x</codeinline> en el objeto <codeinline>o</codeinline>. Si o heredó previamente la propiedad <codeinline>x</codeinline>, esa propiedad heredada está ahora oculta por la propiedad propia recién creada con el mismo nombre.</p>
    <p>La asignación de propiedades examina la cadena de prototipos sólo para determinar si la asignación está permitida. Si o hereda una propiedad de sólo lectura llamada <codeinline>x</codeinline>, por ejemplo, entonces la asignación no está permitida . (Los detalles sobre cuándo se puede asignar una propiedad se encuentran en <a href="#3-3">§6.3.3</a>.) Sin embargo, si la asignación está permitida, siempre crea o establece una propiedad en el objeto original y nunca modifica objetos en la cadena de prototipos. El hecho de que la herencia se produzca cuando se consultan propiedades pero no cuando se establecen es una característica clave de JavaScript porque nos permite anular selectivamente las propiedades heredadas:</p>
    <pre>
    <code class="language-js">let unitcircle = &lbrace; r: 1 };          // Un objeto para heredar de
    let c = Object.create(unitcircle);  // c hereda la propiedad r
    c.x = 1; c.y = 1;                   // c define dos propiedades propias
    c.r = 2;                            // c anula su propiedad heredada
    unitcircle.r                        // => 1: el prototipo no se ve afectada</code></pre>
    <p>Hay una excepción a la regla de que una asignación de propiedad falla o crea o establece una propiedad en el objeto original. Si <codeinline>o</codeinline> hereda la propiedad <codeinline>x</codeinline>, y esa propiedad es una propiedad accesoria con un método setter (véase <a href="#10-6">§6.10.6</a>), entonces se llama a ese método setter en lugar de crear una nueva propiedad <codeinline>x</codeinline> en <codeinline>o</codeinline>. Observe, sin embargo, que el método setter se llama en el objeto <codeinline>o</codeinline>, no en el objeto prototipo que define la propiedad por lo que si el método setter define alguna propiedad, lo hará en <codeinline>o</codeinline>, y volverá a dejar la cadena de prototipos sin modificar.</p>
  </section>
  <section id="3-3">
    <h2>6.3.3 Errores de acceso a la propiedad</h2>
    <p>Las expresiones de acceso a propiedades no siempre devuelven o establecen un valor.
      En esta sección se explican las cosas que pueden salir mal al consultar o establecer
      una propiedad.</p>
    <p>No es un error consultar una propiedad que no existe. Si la propiedad <codeinline>x</codeinline> no se
      encuentra como propiedad propia o heredada de <codeinline>o</codeinline>, la expresión de acceso a la propiedad <codeinline>o.x</codeinline> se evalúa como <codeinline>undefined</codeinline>. Recordemos que nuestro objeto libro tiene una propiedad "subtítulo", pero no una propiedad "subtítulo":</p>
    <pre>
    <code class="language-js">book.subtitle // => undefined: propiedad no existe</code></pre>
    <p>Sin embargo, es un error intentar consultar una propiedad de un objeto que no existe. Los valores <codeinline>null</codeinline> y <codeinline>undefined</codeinline> no tienen propiedades, y es un error consultar propiedades de estos valores. Continuando con el ejemplo anterior:</p>
    <pre>
    <code class="language-js">let len = book.subtitle.length; // !TypeError: indefinido no tiene propiedades</code></pre>
    <p>Las expresiones de acceso a propiedades fallarán si el lado izquierdo de <codeinline>.</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Por lo tanto, al escribir una expresión como <codeinline>book.author.surname</codeinline>, debe tener cuidado si no está seguro de que <codeinline>book</codeinline> y <codeinline>book.author</codeinline> están realmente definidos. He aquí dos formas de evitar este tipo de problemas:</p>
    <pre>
    <code class="language-js">// Una técnica verbosa y explicito
    let surname = undefined;
    if (book) &lbrace;
      if (book.author) &lbrace;
        surname = book.author.surname;
      }
    }
    // Una alternativa concisa e idiomatica para obtener surname o null o undefined
    surname = book && book.author && book.author.surname;</code></pre>
    <p>Para entender por qué esta expresión idiomática funciona para prevenir excepciones TypeError, puede que quiera revisar el comportamiento de cortocircuito del operador <codeinline>&amp;&amp;</codeinline> en <a href="capitulo-4#4-1">§4.10.1</a>.</p>
    <pre>
    <code class="language-js">let surname = book?.author?.surname;</code></pre>
    <p>Como se describe en <a href="capitulo-4#4-1">§4.4.1</a>, ES2020 admite el acceso condicional a propiedades con <codeinline>?.</codeinline>, lo que nos permite reescribir la expresión de asignación anterior como:</p>
    <p>Intentar establecer una propiedad en <codeinline>null</codeinline> o <codeinline>undefined</codeinline> también causa un TypeError. Los intentos de establecer propiedades sobre otros valores no siempre tienen éxito: algunas propiedades son de sólo lectura y no pueden establecerse, y algunos objetos no permiten la adición de nuevas propiedades. En modo estricto (<a href="capitulo-5#6-3">§5.6.3</a>), se lanza un TypeError cada vez que falla un intento de establecer una propiedad. Fuera del modo estricto, estos fallos suelen ser silenciosos.</p>
    <p>Las reglas que especifican cuándo una asignación de propiedad tiene éxito y cuándo falla son intuitivas pero difíciles de expresar de forma concisa. Un intento de establecer una propiedad <codeinline>p</codeinline> de un objeto <codeinline>o</codeinline> falla en estas circunstancias:</p>
    <ul>
      <li class="font-normal"><codeinline>o</codeinline> tiene una propiedad propia <codeinline>p</codeinline> que es de sólo lectura: no es posible establecer propiedades de sólo lectura.</li>
      <li class="font-normal"><codeinline>o</codeinline> tiene una propiedad heredada <codeinline>p</codeinline> que es de sólo lectura: no es posible ocultar una propiedad heredada de sólo lectura con una propiedad propia del mismo nombre.</li>
      <li class="font-normal"><codeinline>o</codeinline> no tiene una propiedad propia <codeinline>p</codeinline>; <codeinline>o</codeinline> no hereda una propiedad <codeinline>p</codeinline> con un método setter, y el atributo <em>extensible</em> de <codeinline>o</codeinline> (véase <a href="capitulo-14#2">§14.2</a>) es <codeinline>false</codeinline>. Como <codeinline>p</codeinline> no existe ya en <codeinline>o</codeinline>, y si no hay ningún método setter al que llamar, entonces <codeinline>p</codeinline> debe añadirse a <codeinline>o</codeinline>. Pero si <codeinline>o</codeinline> no es extensible, entonces no pueden definirse nuevas propiedades en él.</li>
    </ul>
  </section>
  <section id="4">
    <h2>6.4 Borrar propiedades</h2>
    <p>El operador <codeinline>delete</codeinline> (<a href="capitulo-4#13-4">§4.13.4</a>) elimina una propiedad de un objeto. Su único operando debe ser una expresión de acceso a una propiedad. Sorprendentemente, <codeinline>delete</codeinline> no opera sobre el valor de la propiedad, sino sobre la propiedad misma:</p>
    <pre>
    <code class="language-js">delete book.author;         // El objeto book ahora no tiene una propiedad "author".
    delete book["main title"];  // Ahora tampoco tiene una propiedad "main title".</code></pre>
    <p>El operador <codeinline>delete</codeinline> sólo borra las propiedades propias, no las heredadas. (Para borrar una propiedad heredada, debe borrarla del objeto prototipo en el que está definida. Hacer esto afecta a todos los objetos que hereden de ese prototipo).</p>
    <p>Una expresión <codeinline>delete</codeinline> se evalúa como <codeinline>true</codeinline> si el borrado se ha realizado correctamente o si no ha tenido ningún efecto (como borrar una propiedad inexistente). <codeinline>delete</codeinline> también se evalúa como <codeinline>true</codeinline> cuando se utiliza (sin sentido) con una expresión que no es una expresión de acceso a una propiedad:</p>
    <pre>
    <code class="language-js">let o = &lbrace;x: 1};   // o tiene propiedad propia x y hereda propiedad toString
    delete o.x        // => true: borra la propiedad x
    delete o.x        // => true: no hace nada (x no existe) pero true de todas formas
    delete o.toString // => true: no hace nada (toString no es una propiedad propia)
    delete 1          // => true: no hace nada pero true de todas formas.</code></pre>
    <p><codeinline>delete</codeinline> no elimina las propiedades cuyo atributo <em>configurable</em> sea <codeinline>false</codeinline>. Ciertas propiedades de los objetos incorporados no son configurables, al igual que las propiedades del objeto global creado por la declaración de variables y la declaración de funciones. En modo estricto, el intento de eliminar una propiedad no configurable provoca un TypeError. En modo no estricto, <codeinline>delete</codeinline> simplemente se evalúa como <codeinline>false</codeinline> en este caso:</p>
    <pre>
    <code class="language-js">// En modo estricto, todas estas eliminaciones lanzan TypeError en lugar de devolver false
    delete Object.prototype // => false: la propiedad no es configurable
    var x = 1;              // Declara una variable global
    delete globalThis.x     // => false: no se puede borrar esta propiedad
    function f() &lbrace;}         // Declara una función global
    delete globalThis.f     // => false: tampoco se puede borrar esta propiedad</code></pre>
    <p>Al eliminar propiedades configurables del objeto global en modo no estricto, puede omitir la referencia al objeto global y simplemente seguir el operador <codeinline>delete</codeinline> con el nombre de la propiedad:</p>
    <pre>
    <code class="language-js">globalThis.x = 1; // Crea una propiedad global configurable (no let o var)
    delete x          // => true: esta propiedad puede ser borrada</code></pre>
    <p>En modo estricto, sin embargo, <codeinline>delete</codeinline> genera un SyntaxError si su operando es un identificador no cualificado como <codeinline>x</codeinline>, y tienes que ser explícito sobre el acceso a la propiedad:</p>
    <pre>
    <code class="language-js">delete x; // SyntaxError en modo estricto
    delete globalThis.x; // Esto funciona</code></pre>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>6.5 Pruebas de propiedades</h2>
    <p>Los objetos JavaScript pueden considerarse como conjuntos de propiedades, y a menudo es útil poder comprobar la pertenencia al conjunto, es decir, comprobar si un objeto tiene una propiedad con un nombre determinado. Esto se puede hacer con el operador in, con los métodos <codeinline>hasOwnProperty()</codeinline> y <codeinline>propertyIsEnumerable()</codeinline>, o simplemente consultando la propiedad. Todos los ejemplos que se muestran aquí utilizan cadenas como nombres de propiedades, pero también funcionan con Symbols ( <a href="#10.3">§6.10.3</a>).</p>
    <p>El operador <codeinline>in</codeinline> espera un nombre de propiedad a la izquierda y un objeto a la derecha. Devuelve <codeinline>true</codeinline> si el objeto tiene una propiedad propia o heredada con ese nombre:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    "x" in o        // => true: o tiene una propiedad propia "x"
    "y" in o        // => false: o no tiene una propiedad "y"
    "toString" in o // => true: o hereda una propiedad toString</code></pre>
    <p>El método <codeinline>hasOwnProperty()</codeinline> de un objeto comprueba si ese objeto tiene una propiedad propia con el nombre dado. Devuelve <codeinline>false</codeinline> para las propiedades heredadas:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.hasOwnProperty("x")         // => true: o tiene una propiedad propia "x"
    o.hasOwnProperty("y")         // => false: o no tiene una propiedad "y"
    o.hasOwnProperty("toString")  // => false: toString es una propiedad heredada</code></pre>
    <p><codeinline>propertyIsEnumerable()</codeinline> refina la prueba <codeinline>hasOwnProperty()</codeinline>. Devuelve <codeinline>true</codeinline> sólo si la propiedad nombrada es una propiedad propia y su atributo <em>enumerable</em> es <codeinline>true</codeinline>. Algunas propiedades incorporadas no son enumerables. Las propiedades creadas por código Java Script normal son enumerables a menos que haya utilizado una de las técnicas mostradas en <a href="capitulo-14#1">§14.1</a> para hacerlas no enumerables.</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.propertyIsEnumerable("x")                       // => true: o tiene una propiedad propia enumerable "x"
    o.propertyIsEnumerable("toString")                // => false: no es una propiedad propia
    Object.prototype.propertyIsEnumerable("toString") // => false: no enumerable</code></pre>
    <p>En lugar de utilizar el operador <codeinline>in</codeinline>, a menudo basta con consultar la propiedad y utilizar <codeinline>!==</codeinline> para asegurarse de que no está indefinida:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1 };
    o.x !== undefined // => true: o tiene una propiedad propia "x"
    o.y !== undefined // => false: o no tiene una propiedad "y"
    o.toString !== undefined // => true: o hereda una propiedad "toString"</code></pre>
    <p>Hay una cosa que el operador <codeinline>in</codeinline> puede hacer que la simple técnica de acceso a propiedades mostrada aquí no puede hacer. <codeinline>in</codeinline> puede distinguir entre propiedades que no existen y propiedades que existen pero han sido establecidas a <codeinline>undefined</codeinline>. Considere este código:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: undefined }; // La propiedad se establece explicitamente a undefined
    o.x !== undefined         // => false: la propiedad existe pero no esta definida
    o.y !== undefined         // => false: la propiedad ni siquiera existe
    "x" in o                  // => true: la propiedad existe
    "y" in o                  // => false: la propiedad no existe
    delete o.x;               // Borra la propiedad x
    "x" in o                  // => false: ya no existe</code></pre>
  </section>
</Layoutjavascript>