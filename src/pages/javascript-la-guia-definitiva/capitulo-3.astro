---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";

---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-2" capSiguiente="capitulo-4" />
  <section class="fadeIn">
    <h1>Tipos, valores y variables</h1>
    <p>Los programas informáticos funcionan manipulando valores, como el número 3,14 o el texto "Hola Mundo". Los tipos de valores que pueden representarse y manipularse en un lenguaje de programación se conocen como tipos, y una de las características fundamentales de un lenguaje de programación es el conjunto de tipos que admite. Cuando un programa necesita retener un valor para utilizarlo en el futuro, asigna el valor a una variable (o lo "almacena" en ella). Las variables tienen nombres, y permiten utilizar esos nombres en nuestros programas para referirse a valores. El funcionamiento de las variables es otra característica fundamental de cualquier lenguaje de programación. Este capítulo explica los tipos, valores y variables en Java- Script. Comienza con una visión general y algunas definiciones.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>3.1 Visión general y definiciones</h2>
    <p>Los tipos de JavaScript pueden dividirse en dos categorías: <em>tipos primitivos</em> y <em>tipos objeto</em>. Los tipos primitivos de JavaScript incluyen números, cadenas de texto (conocidas como cadenas) y valores de verdad booleanos (conocidos como booleanos). Una parte importante de este capítulo está dedicada a una explicación detallada de los tipos numéricos (<a href="#2">§3.2</a>) y de cadena (<a href="#3">§3.3</a>) en JavaScript. Los booleanos se tratan en <a href="#4">§3.4</a>.</p>
    <p>Los valores especiales de JavaScript <codeinline>null</codeinline> y <codeinline>undefined</codeinline> son valores primitivos, pero no son números, cadenas ni booleanos. Cada valor se considera normalmente el único miembro de su propio tipo especial. En <a href="#5">§3.5</a> encontrará más información sobre <codeinline>null</codeinline> y <codeinline>undefined</codeinline>. ES6 añade un nuevo tipo especial, conocido como Symbol, que permite la definición de extensiones del lenguaje sin perjudicar la compatibilidad con versiones anteriores. Los símbolos se tratan brevemente en <a href="#6">§3.6</a>.</p>
    <p>Cualquier valor de JavaScript que no sea un número, un string,, un booleano, un símbolo, <codeinline>null</codeinline> o <codeinline>undefined</codeinline> es un objeto. Un objeto (es decir, un miembro del tipo <em>object</em>) es una colección de <em>propiedades</em> donde cada propiedad tiene un nombre y un valor (ya sea un valor primitivo o otro objeto). Un objeto muy especial, el <em>objeto global</em>, se trata en <a href="#6">§3.7</a>, pero una cobertura más general y detallada de los objetos se encuentra en el  <a href="capitulo-6">Capítulo 6</a>.</p>
    <p>Un objeto JavaScript normal es una colección desordenada de valores con nombre. El lenguaje también define un tipo especial de objeto, conocido como array, que representa una colección ordenada de valores numerados. El lenguaje JavaScript incluye sintaxis especial para trabajar con arrays, y los arrays tienen un comportamiento especial que los distingue de los objetos ordinarios. Los arrays son el tema del <a href="capitulo-7">Capítulo 7</a>.</p>
    <p>Además de los objetos básicos y las matrices, JavaScript define otros tipos de objetos útiles. Un objeto Set representa un conjunto de valores. Un objeto Map representa un mapeo de claves a valores. Varios tipos de "matrices tipadas" facilitan las operaciones con matrices de bytes y otros datos binarios. El tipo RegExp representa patrones textuales y permite realizar sofisticadas operaciones de correspondencia, búsqueda y sustitución de cadenas. El tipo Date representa fechas y horas y admite operaciones aritméticas rudimentarias con fechas. Error y sus subtipos representan errores que pueden producirse al ejecutar código JavaScript. Todos estos tipos se tratan en el <a href="capitulo-11">Capítulo 11</a>.</p>
    <p>JavaScript se diferencia de otros lenguajes más estáticos en que las funciones y clases no son sólo parte de la sintaxis del lenguaje: son en sí mismas valores que pueden ser manipulados por los programas JavaScript. Como cualquier valor de JavaScript que no sea un valor primitivo, las funciones y clases son un tipo especializado de objeto. Se tratan en detalle en los capítulos <a href="capitulo-8">8</a> y <a href="capitulo-9">9</a>.</p>
    <p>El intérprete de JavaScript realiza la recolección automática de basura para la gestión de la memoria. Esto significa que, por lo general, un programador de JavaScript no tiene que preocuparse por la destrucción o desasignación de objetos u otros valores. Cuando un valor ya no es accesible -cuando un programa ya no tiene forma de referirse a él- el intérprete sabe que ya no puede volver a utilizarse y recupera automáticamente la memoria que estaba ocupando. (Los programadores de JavaScript a veces tienen que tener cuidado para asegurarse de que los valores no permanezcan inadvertidamente accesibles -y por lo tanto no recuperables- más tiempo del necesario).</p>
    <p>JavaScript admite un estilo de programación orientado a objetos. En términos generales, esto significa que en lugar de tener funciones definidas globalmente para operar con valores de varios tipos, los propios tipos definen métodos para trabajar con valores. Para ordenar los elementos de un array a, por ejemplo, no pasamos a una función <codeinline>sort()</codeinline>. En su lugar, invocamos el método <codeinline>sort()</codeinline> de <codeinline>a</codeinline>:</p>
    <pre>
    <code class="language-js">a.sort(); // La versión orientada a objetos de sort(a).</code></pre>
    <p>La definición de métodos se trata en el <a href="capitulo-9">Capítulo 9</a>. Técnicamente, sólo los objetos JavaScript tienen métodos. Pero los números, las cadenas, los valores booleanos y los símbolos se comportan como si tuvieran métodos. En JavaScript, <codeinline>null</codeinline> y <codeinline>undefined</codeinline> son los únicos valores sobre los que no se pueden invocar métodos.</p>
    <p>Los tipos de objeto de JavaScript son <em>mutables</em> y sus tipos primitivos son <em>inmutables</em>. Un valor de un tipo mutable puede cambiar: un programa JavaScript puede cambiar los valores de las propiedades de los objetos y los elementos de las matrices. Los números, los booleanos, los símbolos, <codeinline>null</codeinline> y <codeinline>undefined</codeinline> son inmutables: ni siquiera tiene sentido hablar de cambiar el valor de un número, por ejemplo. Las cadenas se pueden considerar matrices de caracteres, por lo que cabría esperar que fueran mutables. En JavaScript, sin embargo, las cadenas son inmutables: se puede acceder al texto en cualquier índice de una cadena, pero JavaScript no proporciona ninguna forma de alterar el texto de una cadena existente. Las diferencias entre valores mutables e inmutables se analizan con más detalle en <a href="#8">§3.8</a>.</p>
    <p>JavaScript convierte libremente valores de un tipo a otro. Si un programa espera una cadena, por ejemplo, y le das un número, convertirá automáticamente el número en una cadena. Y si utiliza un valor no booleano donde se espera un booleano, JavaScript lo convertirá. Las reglas de conversión de valores se explican en <a href="#9">§3.9</a>. Las reglas liberales de conversión de valores de JavaScript afectan a su definición de igualdad, y el operador de igualdad <codeinline>==</codeinline> realiza conversiones de tipo como se describe en <a href="#9-1">§3.9.1</a>. (En la práctica, sin embargo, el operador de igualdad <codeinline>==</codeinline> está obsoleto en favor del operador de igualdad estricta <codeinline>===</codeinline>, que no realiza conversiones de tipo. Véase <a href="capitulo-4#9-1">§4.9.1</a> para más información sobre ambos operadores).</p>
    <p>Las constantes y variables permiten utilizar nombres para referirse a valores en los programas. Las constantes se declaran con <codeinline>const</codeinline> y las variables con <codeinline>let</codeinline> (o con <codeinline>var</codeinline> en el código JavaScript más antiguo). Las constantes y variables de JavaScript son <em>no tipadas</em>: las declaraciones no especifican qué tipo de valores se asignarán. La declaración y asignación de variables se tratan en <a href="#10">§3.10</a>.</p>
    <p>Como puedes ver en esta larga introducción, éste es un capítulo muy amplio que explica muchos detalles fundamentales sobre cómo se representan y manipulan los datos en JavaScript. Empezaremos sumergiéndonos de lleno en los detalles de los números y el texto en JavaScript.</p>
  </section>
  <section id="2">
    <h2>3.2 Números</h2>
    <p>El tipo numérico principal de JavaScript, Number, se utiliza para representar números enteros y aproximar números reales. JavaScript representa números utilizando el formato de coma flotante de 64 bits definido por el estándar IEEE 754,1<sup><span>?</span><info>Este es el formato de los números de tipo <codeinline class="md:text-base">double</codeinline> en Java, C++ y la mayoría de los lenguajes de programación modernos.</info></sup> lo que significa que puede representar números tan grandes como ±1.7976931348623157 × 10<sup class="bg-inherit px-0 m-0">308</sup> y tan pequeños como ±5 × 10<sup class="bg-inherit px-0 m-0">-324</sup>-.</p>
    <p>El formato numérico de JavaScript permite representar exactamente todos los números enteros comprendidos entre -9 007'199 254'740 992 (-2<sup class="bg-inherit px-0 m-0">53</sup>) y 9 007'199 254'740 992 (2<sup class="bg-inherit px-0 m-0">53</sup>), ambos inclusive. Si utiliza valores enteros mayores que éste, puede perder precisión en los dígitos finales. Tenga en cuenta, sin embargo, que ciertas operaciones en JavaScript (como la indexación de matrices y el método bitwise descritos en el <a href="capitulo-4">Capítulo 4</a>) se realizan con enteros de 32 bits. Si necesita representar exactamente enteros mayores, consulte <a href="#2-5">§3.2.5</a>.</p>
    <p>Cuando un número aparece directamente en un programa JavaScript, se denomina <em>literal numérico</em>. JavaScript admite literales numéricos en varios formatos, como se describe en las secciones siguientes. Tenga en cuenta que cualquier literal numérico puede ir precedido de un signo menos (<codeinline>-</codeinline>) para que el número sea negativo.</p>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.2.1 Literales enteros</h3>
    <p>En un programa JavaScript, un número entero de base-10 se escribe como una secuencia de dígitos. Por ejemplo:</p>
    <pre>
    <code class="language-js">0
    3
    10000000</code></pre>
    <p>Además de los literales enteros en base-10, JavaScript reconoce valores hexadecimales (base-16). Un literal hexadecimal comienza con <codeinline>0x</codeinline> o <codeinline>0X</codeinline>, seguido de una cadena de dígitos hexadecimales. Un dígito hexadecimal es uno de los dígitos 0 a 9 o las letras a (o A) a f (o F), que representan los valores 10 a 15. He aquí algunos ejemplos de literales enteros hexadecimales:</p>
    <pre>
    <code class="language-js">0xff      // => 255: (15*16 + 15)
    0xBADCAFE // => 195939070</code></pre>
    <p>En ES6 y posteriores, también se pueden expresar enteros en binario (base 2) u octal (base 8) utilizando los prefijos <codeinline>0b</codeinline> y <codeinline>0o</codeinline> (o <codeinline>0B</codeinline> y <codeinline>0O</codeinline>) en lugar de <codeinline>0x</codeinline>:</p>
    <pre>
    <code class="language-js">0b10101   // => 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
    0o377     // => 255: (3*64 + 7*8 + 7*1)</code></pre>
  </section>
  <section>
    <h3>3.2.2 Literales en coma flotante</h3>
    <p>Los literales de coma flotante pueden tener punto decimal; utilizan la sintaxis tradicional de los números reales. Un valor real se representa como la parte integral del número, seguida de un punto decimal y la parte fraccionaria del número.</p>
    <p>Los literales de coma flotante también pueden representarse mediante notación exponencial: un número real seguido de la letra e (o E), seguido de un signo más o menos opcional, seguido de un exponente entero. Esta notación representa el número real multiplicado por 10 a la potencia del exponente.</p>
    <p>Más sucintamente, la sintaxis es:</p>
    <pre>
    <code class="language-js">[digits][.digits][(E|e)[( + | - )]digits]</code></pre>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js">3.14
    2345.6789
    .333333333333333333
    6.02e23 // 6.02 × 10^23
    1.4738223E-32 // 1.4738223 × 10^−32</code></pre>
    <article>
      <p class="title-article">Separadores en literales numéricos</p>
      <p>Puede utilizar guiones bajos en los literales numéricos para dividir los literales largos en trozos más fáciles de leer:</p>
    <pre>
    <code class="language-js">let billion = 1_000_000_000; // Subguion como separador de miles.
    let bytes = 0x89_AB_CD_EF; // Como separador de bytes.
    let bits = 0b0001_1101_0111; // Como separador de nibble.
    let fraction = 0.123_456_789; // Funciona también en la parte fraccionaria.</code></pre>
      <p>En el momento de escribir este artículo, a principios de 2020, los guiones bajos en literales numéricos aún no están formalmente estandarizados como parte de JavaScript. Pero se encuentran en fases avanzadas del proceso de estandarización y están implementados por los principales navegadores y por Node.</p>
    </article>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.2.3 Aritmética en JavaScript</h3>
    <p>Los programas JavaScript trabajan con números utilizando los operadores aritméticos que proporciona el lenguaje. Estos incluyen <codeinline>+</codeinline> para la suma, <codeinline>-</codeinline> para la resta, <codeinline>*</codeinline> para la multiplicación, <codeinline>/</codeinline> para la división y <codeinline>%</codeinline> para el módulo (resto después de la división). ES2016 añade <codeinline>**</codeinline> para la expo- nenciación. Para más información sobre estos y otros operadores, véase el <a href="capitulo-4">Capítulo 4</a>.</p>
    <p>Además de estos operadores aritméticos básicos, JavaScript admite operaciones matemáticas más complejas mediante un conjunto de funciones y constantes definidas como propiedades del objeto <codeinline>Math</codeinline>:</p>
    <pre>
    <code class="language-js">Math.pow(2,53)          // => 9007199254740992: 2 elevado a la potencia 53
    Math.round(.6)          // => 1.0: redondear al entero más cercano
    Math.ceil(.6)           // => 1.0: redondea al entero más alto
    Math.floor(.6)          // => 0.0: redondea al entero más bajo
    Math.abs(-5)            // => 5: valor absoluto
    Math.max(x,y,z)         // Devuelve el argumento mayor
    Math.min(x,y,z)         // Devuelve el argumento menor
    Math.random()           // Devuelve un numero aleatorio entre 0 e inferior a 1.0
    Math.PI                 // π: circunferencia de un círculo / diámetro
    Math.E                  // e: La base del algoritmo natural
    Math.sqrt(3)            // => 3**0.5: la raíz cuadrada de 3
    Math.pow(3, 1/3)        // => 3**(1/3): la raíz cúbica de 3
    Math.sin(0)             // Trigonometria: tambien Math.cos, Math.atan, etc.
    Math.log(10)            // Logaritmo Natural de 10
    Math.log(100)/Math.LN10 // Logaritmo base 10 de 100
    Math.log(512)/Math.LN2  // Logaritmo base 2 de 512
    Math.exp(3)             // Math.E al cubo</code></pre>
    <p>ES6 define más funciones sobre el objeto Math:</p>
    <pre>
    <code class="language-js">Math.cbrt(27)     // => 3: Raíz cúbica
    Math.hypot(3, 4)  // => 5: raíz cuadrada de la suma de los cuadrados de todos los argumentos
    Math.log10(100)   // => 2: Logaritmo base 10
    Math.log2(1024)   // => 10: Logaritmo base 2
    Math.log1p(x)     // Logaritmo natural de (1+x); preciso para x muy pequeño
    Math.expm1(x)     // Math.exp(x)-1; el inverso de Math.log1p()
    Math.sign(x)      // -1, 0, o 1 para argumentos &lt; ==, o > 0
    Math.imul(2,3)    // => 6: multiplicación optimizada de enteros de 32-bit
    Math.clz32(0xf)   // => 28: número de ceros a la izquierda en un entero de 32-bit
    Math.trunc(3.9)   // => 3: convertir a entero truncando la parte fraccionaria
    Math.fround(x)    // Redondea al número flotante de 32 bits más cercano
    Math.sinh(x)      // Seno hiperbólico. También Math.cosh(), Math.tanh()
    Math.asinh(x)     // Arcoseno hiperbólico. También Math.acosh(), Math.atanh()</code></pre>
    <p>La aritmética en JavaScript no produce errores en los casos de desbordamiento, subdesbordamiento o división por cero. Cuando el resultado de una operación numérica es mayor que el mayor número representable (desbordamiento), el resultado es un valor infinito especial, <codeinline>Infinity</codeinline>. Del mismo modo, cuando el valor absoluto de un valor negativo es mayor que el valor absoluto del mayor número negativo representable, el resultado es infinito negativo, <codeinline>-Infinity</codeinline>. Los valores infinitos se comportan como cabría esperar: sumarlos, restarlos, multiplicarlos o dividirlos por cualquier cosa da como resultado un valor infinito (posiblemente con el signo invertido).</p>
    <p>El desbordamiento por defecto se produce cuando el resultado de una operación numérica está más cerca de cero que el menor número representable. En este caso, JavaScript devuelve 0. Si el desbordamiento por defecto se produce a partir de un número negativo, JavaScript devuelve un valor especial conocido como "cero negativo". Este valor es casi completamente indistinguible del cero normal y los programadores de JavaScript rara vez necesitan detectarlo.</p>
    <p>La división por cero no es un error en JavaScript: simplemente devuelve infinito o infinito negativo. Sin embargo, hay una excepción: cero dividido por cero no tiene un valor bien definido, y el resultado de esta operación es el valor especial no numérico, <codeinline>NAN</codeinline>. <codeinline>NAN</codeinline> también aparece si se intenta dividir infinito por infinito, sacar la raíz cuadrada de un número negativo o utilizar operadores aritméticos con operandos no numéricos que no pueden convertirse en números.</p>
    <p>JavaScript predefine las constantes globales <codeinline>Infinity</codeinline> y <codeinline>NAN</codeinline> para mantener el infinito positivo y el valor no numérico, y estos valores también están disponibles como propiedades del objeto <codeinline>Number</codeinline>:</p>
    <pre>
    <code class="language-js">Infinity                  // Un número positivo demasiado grande para representarlo
    Number.POSITIVE_INFINITY  // Mismo valor
    1/0                       // => Infinito
    Number.MAX_VALUE * 2      // => Infinito; desbordamiento
    -Infinity                 // Un número negativo demasiado grande para representarlo
    Number.NEGATIVE_INFINITY  // El mismo valor
    -1/0                      // => -Infinito
    -Number.MAX_VALUE * 2     // => -Infinito

    NaN                       // El valor no numérico
    Number.NaN                // El mismo valor, escrito de otra forma
    0/0                       // => NaN
    Infinity/Infinity         // => NaN

    Number.MIN_VALUE/2        // => 0: underflow
    -Number.MIN_VALUE/2       // => -0: cero negativo
    -1/Infinity               // -> -0: también 0 negativo
    -0

    // Las siguientes propiedades Number están definidas en ES6
    Number.parseInt()         // Igual que la función global parseInt()
    Number.parseFloat()       // Igual que la función global parseFloat()
    Number.isNaN(x)           // ¿Es x un valor NaN?
    Number.isFinite(x)        // ¿Es x un numero finito?
    Number.isInteger(x)       // ¿Es x un entero?
    Number.isSafeInteger(x)   // ¿Es x un entero entre -(2**53) y 2**53?
    Number.MIN_SAFE_INTEGER   // => -(2**53 - 1)
    Number.MAX_SAFE_INTEGER   // => 2**53 - 1
    Number.EPSILON            // => 2**-52: diferencia mínima entre números</code></pre>
    <p>El valor no numérico tiene una característica inusual en JavaScript: no se compara igual a ningún otro valor, incluido él mismo. Esto significa que no puedes escribir <codeinline>x === NaN</codeinline> para determinar si el valor de una variable <codeinline>x</codeinline> es <codeinline>NAN</codeinline>. En su lugar, debes escribir <codeinline>x != x</codeinline> o <codeinline>Number.isNaN(x)</codeinline>. Estas expresiones serán verdaderas si, y sólo si, <codeinline>x</codeinline> tiene el mismo valor que la constante global <codeinline>NaN</codeinline>.</p>
    <p>La función global <codeinline>isNaN()</codeinline> es similar a <codeinline>Number.isNaN()</codeinline>. Devuelve <codeinline>true</codeinline> si su argumento es <codeinline>NaN</codeinline>, o si ese argumento es un valor no numérico que no puede convertirse en un número. La función relacionada <codeinline>Number.isFinite()</codeinline> devuelve <codeinline>true</codeinline> si su argumento es un número distinto de <codeinline>NaN</codeinline>, <codeinline>Infinito</codeinline> o <codeinline>-Infinito</codeinline>. La función global <codeinline>isFinite()</codeinline> devuelve <codeinline>true</codeinline> si su argumento es,o puede convertirse en, un número finito.</p>
    <p>El valor cero negativo también es algo inusual. Se compara igual (incluso utilizando la prueba de igualdad estricta de Jav- aScript) a cero positivo, lo que significa que los dos valores son casi indistinguibles, excepto cuando se utiliza como un divisor:</p>
    <pre>
    <code class="language-js">let zero = 0; // Cero Normal
    let negz = -0; // Cero Negativo
    zero === negz // => true: cero y cero negativo son iguales
    1/zero === 1/negz // => false: Infinity y -Infinity no son iguales</code></pre>
  </section>
  <section>
    <h3>3.2.4 Errores de redondeo y de Punto flotante binaria</h3>
    <p>Existen infinitos números reales, pero sólo un número finito de ellos (18'437 736'874 454'810 627, para ser exactos) pueden representarse exactamente con el formato de coma flotante de JavaScript. Esto significa que cuando se trabaja con números reales en JavaScript, la representación del número será a menudo una aproximación del número real.</p>
    <p>La representación en coma flotante IEEE-754 que utiliza JavaScript (y casi todos los demás lenguajes de programación modernos) es una representación binaria, que puede representar exactamente fracciones como <codeinline>1/2</codeinline>, <codeinline>1/8</codeinline> y <codeinline>1/1024</codeinline>. Por desgracia, las fracciones que utilizamos con más frecuencia (sobre todo al realizar cálculos financieros) son fracciones decimales. Por desgracia, las fracciones que utilizamos con más frecuencia (sobre todo al realizar cálculos financieros) son fracciones decimales: <codeinline>1/10</codeinline>, <codeinline>1/100</codeinline>, etc. Las representaciones binarias en coma flotante no pueden representar exactamente números tan sencillos como <codeinline>0.1</codeinline>.</p>
    <p>Los números JavaScript tienen mucha precisión y pueden aproximarse a <codeinline>0.1</codeinline> con mucha exactitud. Pero el hecho de que este número no pueda representarse exactamente puede acarrear problemas. Considere este código:</p>
    <pre>
    <code class="language-js">let x = .3 - .2; // treinta céntimos menos 20 céntimos
    let y = .2 - .1; // veinte céntimos menos 10 céntimos
    x === y          // => false: los dos valores no son iguales!
    x === .1         // => false: .3-.2 no es igual a .1
    y === .1         // => true: .2-.1 is es igual a .1</code></pre>
    <p>Debido al error de redondeo, la diferencia entre las aproximaciones de .3 y .2 no es exactamente la misma que la diferencia entre las aproximaciones de .2 y .1. Es importante comprender que este problema no es específico de JavaScript: afecta a cualquier lenguaje de programación que utilice números binarios en coma flotante. Además, observe que los valores <codeinline>x</codeinline> e <codeinline>y</codeinline> en el código mostrado aquí están <em>muy</em> próximos entre sí y al valor correcto. Los valores calculados son adecuados para casi cualquier propósito; el problema sólo surge cuando intentamos comparar valores para la igualdad.</p>
    <p>Si estas aproximaciones en coma flotante resultan problemáticas para sus programas, considere la posibilidad de utilizar enteros escalados. Por ejemplo, puede manipular valores monetarios como céntimos enteros en lugar de dólares fraccionarios.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h3>3.2.5 Enteros de precisión arbitraria con BigInt</h3>
    <p>Una de las características más recientes de JavaScript, definida en ES2020, es un nuevo tipo numérico conocido como BigInt. A principios de 2020, se ha implementado en Chrome, Firefox, Edge y Node, y hay una implementación en curso en Safari. Como su nombre indica, BigInt es un tipo numérico cuyos valores son números enteros. El tipo se añadió a JavaScript principalmente para permitir la representación de enteros de 64 bits, necesarios para la compatibilidad con muchos otros lenguajes de programación y API. Sin embargo, los valores BigInt pueden tener miles o incluso millones de dígitos, por si necesita trabajar con números tan grande. (Tenga en cuenta, sin embargo, que las implementaciones de BigInt no son adecuadas para la criptog- rafía porque no intentan evitar los ataques de temporización).
    </p>
    <p>Los literales BigInt se escriben como una cadena de dígitos seguida de una letra <codeinline>n</codeinline> minúscula. Por defecto, están en base 10, pero puede utilizar los prefijos <codeinline>0b</codeinline>, <codeinline>0b</codeinline> y <codeinline>0x</codeinline> para BigInts binarios, octales y hexadecimales:</p>
    <pre>
    <code class="language-js">1234n                 // Un literal BigInt no tan grande
    0b111111n           // Un BigInt binario
    0o7777n             // Un BigInt octal
    0x8000000000000000n // => 2n**63n: Un entero de 64-bit</code></pre>
    <p>Puede utilizar <codeinline>BigInt()</codeinline> como función para convertir números o cadenas normales de JavaScript en valores BigInt:
    </p>
    <pre>
    <code class="language-js">BigInt(Number.MAX_SAFE_INTEGER)   // => 9007199254740991n
    let string = "1" + "0".repeat(100); // 1 seguido por 100 ceros.
    BigInt(string)                      // => 10n**100n: one googol</code></pre>
    <p>La aritmética con valores BigInt funciona como la aritmética con números normales de JavaScript, excepto que la división elimina cualquier resto y redondea hacia abajo (hacia cero):</p>
    <pre>
    <code class="language-js">1000n + 2000n         // => 3000n
    3000n - 2000n         // => 1000n
    2000n * 3000n         // => 6000000n
    3000n / 997n          // => 3n: the quotient is 3
    3000n % 997n          // => 9n: and the remainder is 9
    (2n ** 131071n) - 1n  // A Mersenne prime with 39457 decimal digits</code></pre>
    <p>Aunque los operadores estándar <codeinline>+</codeinline>, <codeinline>-</codeinline>, <codeinline>*</codeinline>, <codeinline>/</codeinline>, <codeinline>%</codeinline> y <codeinline>**</codeinline> funcionan con BigInt, es importante entender que no se pueden mezclar operandos de tipo BigInt con operandos numéricos normales. Esto puede parecer confuso al principio, pero hay una buena razón para ello. Si un tipo numérico fuera más general que el otro, sería fácil definir la aritmética sobre operandos mezclados para devolver simplemente un valor del tipo más general. Pero ninguno de los dos tipos es más general que el otro: BigInt puede representar valores extraordinariamente grandes, por lo que es más general que los números normales. Pero BigInt sólo puede representar números enteros, por lo que el tipo de número normal de JavaScript es más general. No hay forma de evitar este problema, por lo que JavaScript lo esquiva simplemente no permitiendo operandos mixtos a los operadores aritméticos.</p>
    <p>En cambio, los operadores de comparación sí funcionan con tipos numéricos mixtos (pero véase <a href="#9-1">§3.9.1</a> para más información sobre la diferencia entre <codeinline>==</codeinline> y <codeinline>===</codeinline>):</p>
    <pre>
    <code class="language-js">1 &lt 2n    // => true
    2 > 1n    // => true
    0 == 0n   // => true
    0 === 0n  // => false: el === comprueba también la igualdad de tipos</code></pre>
    <p>Los operadores bit a bit (descritos en <a href="capitulo-4#8-3">§4.8.3</a>) funcionan generalmente con operandos BigInt. Sin embargo, ninguna de las funciones del objeto <codeinline>Math</codeinline> acepta operandos BigInt.</p>
  </section>
  <section>
    <h3>3.2.6 Fechas y horarios</h3>
    <p>JavaScript define una clase Date sencilla para representar y manipular los números que representan fechas y horas. Las fechas de JavaScript son objetos, pero también tienen una representación numérica como marca de <em>timestamp</em> el número de milisegundos transcurridos desde el 1 de enero de 1970:</p>
    <pre>
    <code class="language-js">let timestamp = Date.now();   // La hora actual como timestamp (un número).
    let now = new Date();         // La hora actual como objeto Date.
    let ms = now.getTime();       // Convertir timestamp en milisegundos.
    let iso = now.toISOString();  // Convertir a un string en formato estándar.</code></pre>
    <p>La clase Date y sus métodos se tratan en detalle en <a href="capitulo-11#4">§11.4</a>. Pero volveremos a ver objetos Date en <a href="#9-3">§3.9.3</a> cuando examinemos los detalles de las conversiones de tipo de JavaScript.
    </p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>3.3 Texto</h2>
    <p>El tipo de JavaScript para representar texto es la <em>string</em>. Una cadena es una secuencia ordenada e inmutable de valores de 16 bits, cada uno de los cuales representa normalmente un carácter Unicode. La <em>longitud</em> de una cadena es el número de valores de 16 bits que contiene. Las cadenas de JavaScript (y sus matrices) utilizan una indexación basada en cero: el primer valor de 16 bits está en la posición 0, el segundo en la posición 1, y así sucesivamente. El <em>string vacio</em> es la cadena de longitud 0. Java Script no tiene un tipo especial que represente un único elemento de una cadena. Para representar un único valor de 16 bits, basta con utilizar una cadena de longitud 1.</p>
    <article>
      <p class="title-article">Caracteres, puntos de código y cadenas JavaScript</p>
      <p>JavaScript utiliza la codificación UTF-16 del conjunto de caracteres Unicode, y las cadenas de JavaScript son secuencias de valores de 16 bits sin signo. Los caracteres Unicode más utilizados (los del "plano multilingüe básico") tienen puntos de código que caben en 16 bits y pueden representarse mediante un elemento de una cadena. Los caracteres Unicode cuyos puntos de código no caben en 16 bits se codifican utilizando las reglas de UTF-16 como una secuencia (conocida como "par sustituto") de dos valores de 16 bits. Esto significa que una cadena JavaScript de longitud 2 (dos valores de 16 bits) podría representar un único carácter Unicode:</p>
    <pre>
    <code class="language-js">let euro = "€";
    let love = "❤";
    euro.length   // => 1: Este caracter tiene elementos de 16-bit
    love.length   // => 2: La Codificación UTF-16 de ❤ is "\ud83d\udc99"</code></pre>
      <p>La mayoría de los métodos de manipulación de cadenas definidos por JavaScript operan con valores de 16 bits, no con caracteres. No tratan los pares sustitutos de forma especial, no realizan ninguna normalización de la cadena y ni siquiera garantizan que una cadena esté bien formada UTF-16.</p>
      <p>Sin embargo, en ES6, las string son <em>iterables</em> y si utiliza el bucle <codeinline>for/of</codeinline> o el operador <codeinline>...</codeinline> con una cadena, iterará los caracteres reales de la cadena, no los valores de 16 bits.</p>
    </article>
  </section>
  <section>
    <h3>3.3.1 Literales de cadena</h3>
    <p>Para incluir un string en un programa JavaScript, basta con encerrar los caracteres de la cadena dentro de un par coincidente de comillas simples o dobles o de puntos suspensivos (<codeinline>'</codeinline> o <codeinline>"</codeinline> o <codeinline>`</codeinline>). Las comillas dobles y los puntos suspensivos pueden incluirse en cadenas delimitadas por comillas simples, y lo mismo ocurre con las cadenas delimitadas por comillas dobles y puntos suspensivos. He aquí algunos ejemplos de literales de cadena:</p>
    <pre>
    <code class="language-js">"" // El string vacio: tiene cero caracteres
    'testing'
    "3.14"
    'name="miformulario"'
    "¿Te gusta la web?"
    "τ es la relación entre la circunferencia y el radio de un círculo"
    `"Ella dijo 'hola'", dijo.`</code></pre>
    <p>Las cadenas delimitadas con barras invertidas son una característica de ES6, y permiten que las expresiones de JavaScript se incrusten (o interpolen) dentro de la cadena literal. Esta sintaxis de <em>interpolación</em> de expresiones se trata en <a href="#3-4">§3.3.4</a>.</p>
    <p>Las versiones originales de JavaScript requerían que los literales de cadena se escribieran en una sola línea, y es común ver código JavaScript que crea cadenas largas concatenando cadenas de una sola línea con el operador +. Sin embargo, a partir de ES5, puedes dividir una cadena literal en varias líneas terminando cada línea excepto la última con una barra invertida (<codeinline>\</codeinline>). Ni la barra invertida ni el terminador de línea que le sigue forman parte de la cadena literal. Si necesita incluir un carácter de nueva línea en un literal de cadena entre comillas simples o dobles, utilice la secuencia de caracteres <codeinline>\n</codeinline> (documentada en la siguiente sección). La sintaxis backtick de ES6 permite dividir cadenas en varias líneas y, en este caso, los terminadores de línea forman parte del literal de cadena:</p>
    <pre>
    <code class="language-js">// Un string que representa 2 líneas escritas en una línea:
    'dos\nlineas'
    // Un string de una línea escrita en 3 líneas:
    "una\
    linea\
    larga"
    // Un string de dos líneas escrita en dos líneas:
    `the newline character at the end of this line
    is included literally in this string`</code></pre>
    <p>Tenga en cuenta que cuando utilice comillas simples para delimitar sus cadenas, debe tener cuidado con las contracciones y posesivos ingleses, como <em>can't</em> y <em>O'Reilly's</em>. Dado que el apos- trofo es el mismo que el carácter de comilla simple, debe utilizar el carácter de barra invertida (<codeinline>\</codeinline>) para "escapar" de cualquier apóstrofo que aparezca en cadenas entre comillas simples (los escapes se explican en la siguiente sección).</p>
    <p>En la programación JavaScript del lado del cliente, el código JavaScript puede contener cadenas de código HTML, y el código HTML puede contener cadenas de código JavaScript. Al igual que JavaScript, HTML utiliza comillas simples o dobles para delimitar sus cadenas. Por lo tanto, al combinar Java-Script y HTML, es una buena idea utilizar un estilo de comillas para JavaScript y el otro estilo para HTML. En el siguiente ejemplo, la cadena "Gracias" aparece entre comillas simples dentro de una expresión JavaScript, que a su vez aparece entre comillas dobles dentro de un atributo HTML event-handler:</p>
    <pre>
    <code class="language-js">&lt;button onclick="alert('Gracias')">Cliquear Aqui&lt;/button></code></pre>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.3.2 Secuencias de escape en literales de cadena</h3>
    <p>El carácter de barra invertida (<codeinline>\</codeinline>) tiene un propósito especial en las cadenas de JavaScript. Combinado con el carácter que le sigue, representa un carácter que no es representable de otro modo dentro de la cadena. Por ejemplo, <codeinline>\n</codeinline> es una <em>secuencia de escape</em> que representa un carácter de nueva línea.</p>
    <p>Otro ejemplo, mencionado anteriormente, es el escape <codeinline>\'</codeinline>, que representa el carácter de comilla simple (o apóstrofo). Esta secuencia de escape es útil cuando se necesita incluir un apóstrofo en una cadena literal que está contenida entre comillas simples. Puede entender por qué se llaman secuencias de escape: la barra invertida le permite escapar de la interpretación habitual del carácter de comilla simple. En lugar de utilizarla para marcar el final de la cadena, se utiliza como apóstrofe:</p>
    <pre>
    <code class="language-js">'You\'re right, it can\'t be a quote'</code></pre>
    <p>La <a href="#tabla3-1">Tabla 3-1</a> enumera las secuencias de escape de JavaScript y los caracteres que representan. Tres secuencias de escape son genéricas y pueden utilizarse para representar cualquier carácter especificando su código de carácter Unicode como un número hexadecimal. Por ejemplo, la secuencia <codeinline>\xA9</codeinline> representa el símbolo copyright, que tiene la codificación Unicode dada por el número hexadecimal A9. Del mismo modo, el escape <codeinline>\u</codeinline> representa un carácter Unicode arbitrario especificado por cuatro dígitos hexadecimales o de uno a cinco dígitos cuando los dígitos están encerrados entre llaves: <codeinline>\u03c0</codeinline> representa el carácter π, por ejemplo, y <codeinline>\u&lbrace;1f600}</codeinline> representa el emoji "cara sonriente".</p>
    <div id="tabla3-1" class="flex flex-col items-center">
      <p><em>Tabla 3-1. Secuencias de escape de JavaScript</em></p>
      <table class="text-md leading-6 sm:text-lg md:text-xl border-b-2 border-amber-900">
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="w-24 text-center">Secuencia</td>
            <td class="max-w-lg pl-4">Carácter representado</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\0</codeinline></td>
              <td class="max-w-lg pl-4">El carácter NUL (<codeinline class="md:text-base bg-transparent">\u0000</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\b</codeinline></td>
              <td class="max-w-lg pl-4">Retroceso (<codeinline class="md:text-base bg-transparent">\u0008</codeinline>)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\t</codeinline></td>
              <td class="max-w-lg pl-4">Pestaña horizontal (<codeinline class="md:text-base bg-transparent">\u0009</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\n</codeinline></td>
              <td class="max-w-lg pl-4">Nueva línea (<codeinline class="md:text-base bg-transparent">\u000A</codeinline>)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\v</codeinline></td>
              <td class="max-w-lg pl-4">Pestaña vertical (<codeinline class="md:text-base bg-transparent">\u000B</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\f</codeinline></td>
              <td class="max-w-lg pl-4">Alimentación del formulario (<codeinline class="md:text-base bg-transparent">\u000C</codeinline>)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\r</codeinline></td>
              <td class="max-w-lg pl-4">Retorno de carro (<codeinline class="md:text-base bg-transparent">\u000D</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\"</codeinline></td>
              <td class="max-w-lg pl-4">Comillas dobles (<codeinline class="md:text-base bg-transparent">\u0022</codeinline>)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\'</codeinline></td>
              <td class="max-w-lg pl-4">Apóstrofe o comilla simple (<codeinline class="md:text-base bg-transparent">\u0027</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent">\\</codeinline></td>
              <td class="max-w-lg pl-4">Barra diagonal inversa (<codeinline class="md:text-base bg-transparent">\u005C</codeinline>)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent pr-0">\x</codeinline><em class="text-amber-700">nn</em></td>
              <td class="max-w-lg pl-4">El carácter Unicode especificado por los dos dígitos hexadecimales <em>nn</em></td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent pr-0">\u</codeinline><em class="text-amber-700">nnnn</em></td>
              <td class="max-w-lg pl-4">El carácter Unicode especificado por los cuatro dígitos hexadecimales <em>nnnn</em></td>
            </tr>
            <tr>
              <td class="w-24 pl-4"><codeinline class="md:text-base bg-transparent pr-0">\u&lbrace;</codeinline><em class="font-khand px-0 text-amber-700">n</em><codeinline class="md:text-base bg-transparent pl-0">}</codeinline></td>
              <td class="max-w-lg pl-4">El carácter Unicode especificado por el punto de código <em>n</em>, donde <em>n</em> es de uno a seis dígitos hexadecimales entre 0 y 10FFFF (ES6)</td>
            </tr>
        </tbody>
      </table>
    </div>
    <p>Si el carácter <codeinline>\</codeinline> precede a cualquier carácter distinto de los mostrados en la <a href="#tabla3-1">Tabla 3-1</a>, la barra invertida simplemente se ignora (aunque futuras versiones del lenguaje pueden, por supuesto, definir nuevas secuencias de escape). Por ejemplo, <codeinline>\#</codeinline> es lo mismo que <codeinline>#</codeinline>. Por último, como se señaló anteriormente, ES5 permite una barra invertida antes de un salto de línea para romper una cadena literal a través de múltiples líneas.</p>
  </section>
  <section>
    <h3>3.3.3 Trabajar con cuerdas</h3>
    <p>Una de las funciones integradas de JavaScript es la posibilidad de concatenar cadenas. Si utiliza el operador + con números, los suma. Pero si utiliza este operador con cadenas, las une añadiendo la segunda a la primera. Por ejemplo:</p>
    <p>Las cadenas pueden compararse con los operadores estándar de igualdad === y desigualdad !==: dos cadenas son iguales si y sólo si están formadas exactamente por la misma secuencia de valores de 16 bits. Las cadenas también pueden compararse con los operadores &minusb;, &minus;=, > y >=. La comparación de cadenas se realiza simplemente comparando los valores de 16 bits. (Para obtener información más detallada sobre la comparación y ordenación de cadenas según la configuración regional, véase §11.7.3).</p>
    <p>Para determinar la longitud de una cadena -el número de valores de 16 bits que contiene- utilice la función propiedad de longitud de la cadena:</p>
    <p>Además de esta propiedad de longitud, JavaScript proporciona una rica API para trabajar con cadenas:</p>
    <p>Recuerde que las cadenas son inmutables en JavaScript. Métodos como replace() y toUpperCase() devuelven nuevas cadenas: no modifican la cadena sobre la que se invocan.</p>
    <p>Las cadenas también pueden tratarse como matrices de sólo lectura, y puede acceder a caracteres individuales (valores de 16 bits) desde una cadena utilizando corchetes en lugar del método charAt():</p>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.3.4 Literales de plantilla</h3>
    <p>En ES6 y versiones posteriores, los literales de cadena pueden delimitarse con barras invertidas:</p>
    <p>Sin embargo, se trata de algo más que otra sintaxis de literales de cadena, ya que estos literales de plantilla pueden incluir expresiones JavaScript arbitrarias. El valor final de un literal de cadena entre comillas se calcula evaluando cualquier expresión incluida, convirtiendo los valores de esas expresiones en cadenas y combinando esas cadenas calculadas con los caracteres literales dentro de las comillas:</p>
    <p>Todo lo que se encuentra entre $&lbrace; y } se interpreta como una expresión de JavaScript. Todo lo que queda fuera de las llaves es texto literal de cadena normal. La expresión dentro de las llaves se evalúa y luego se convierte en una cadena y se inserta en la plantilla, reemplazando el signo de dólar, las llaves y todo lo que hay entre ellos.</p>
    <p>Un literal de plantilla puede incluir cualquier número de expresiones. Puede utilizar cualquiera de los caracteres de escape de las cadenas normales, y puede abarcar cualquier número de líneas, sin necesidad de escapes especiales. El siguiente literal de plantilla incluye cuatro expresiones JavaScript, una secuencia de escape Unicode y al menos cuatro nuevas líneas (los valores de expresión también pueden incluir nuevas líneas):</p>
    <p>La barra invertida al final de la primera línea escapa de la nueva línea inicial para que la cadena resultante comience con el carácter Unicode ✘ (\u2718) en lugar de con una nueva línea.</p>
    <p>Literales de plantilla con etiqueta</p>
    <p>Una característica potente pero menos utilizada de los literales de plantilla es que, si el nombre de una función (o "etiqueta") aparece justo antes de la marca de apertura, el texto y los valores de las expresiones dentro del literal de plantilla se pasan a la función. El valor de este "literal de plantilla etiquetado" es el valor de retorno de la función. Esto podría utilizarse, por ejemplo, para aplicar un escape HTML o SQL a los valores antes de sustituirlos en el texto.</p>
    <p>ES6 tiene una función de etiqueta incorporada: String.raw(). Devuelve el texto entre comillas sin procesar las barras invertidas:</p>
    <p>Observe que aunque la parte de la etiqueta de un literal de plantilla etiquetado es una función, no se utilizan paréntesis en su invocación. En este caso muy específico, los caracteres de marca sustituyen a los paréntesis de apertura y cierre.</p>
    <p>La capacidad de definir sus propias funciones de etiqueta de plantilla es una característica poderosa de Java-Script. Estas funciones no necesitan devolver cadenas, y pueden utilizarse como con- estructores, como si se definiera una nueva sintaxis literal para el lenguaje. Veremos un ejemplo en §14.5.</p>
  </section>
  <section>
    <h3>3.3.5 Coincidencia de patrones</h3>
    <p>JavaScript define un tipo de datos conocido como expresión regular (o RegExp) para describir y comparar patrones en cadenas de texto. Las RegExp no son uno de los tipos de datos fundamentales de JavaScript, pero tienen una sintaxis literal como los números y las cadenas, por lo que a veces parecen fundamentales. La gramática de las expresiones regulares literales es compleja y la API que definen no es trivial. Se documentan en detalle en §11.3. Debido a que las RegExps son poderosas y comúnmente usadas para el procesamiento de texto, esta sección proporciona una breve visión general.</p>
    <p>El texto entre un par de barras constituye un literal de expresión regular. La segunda barra del par también puede ir seguida de una o varias letras, que modifican el significado del patrón. Por ejemplo:</p>
    <p>Los objetos RegExp definen una serie de métodos útiles, y las cadenas también tienen métodos que aceptan argumentos RegExp. Por ejemplo:</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>3.4 Valores booleanos</h2>
    <p>Un valor booleano representa verdad o falsedad, encendido o apagado, sí o no. Sólo hay dos valores posibles de este tipo. Las palabras reservadas true y false evalúan estos dos valores.</p>
    <p>Los valores booleanos son generalmente el resultado de comparaciones que realizas en tus programas JavaScript. Por ejemplo:</p>
    <p>Este código comprueba si el valor de la variable a es igual al número 4. Si lo es, el resultado de esta comparación es el valor booleano true. Si lo es, el resultado de esta comparación es el valor booleano true. Si a no es igual a 4, el resultado de la comparación es falso.</p>
    <p>Los valores booleanos se utilizan habitualmente en las estructuras de control de JavaScript. Por ejemplo, la sentencia if/else en JavaScript realiza una acción si un valor booleano es verdadero y otra acción si el valor es falso. Normalmente se combina una comparación que crea directamente un valor booleano con una sentencia que lo utiliza. El resultado es el siguiente</p>
    <p>Este código comprueba si a es igual a 4. En caso afirmativo, suma 1 a b; en caso contrario, suma 1 a a.</p>
    <p>Como veremos en §3.9, cualquier valor JavaScript puede convertirse en un valor booleano. Los siguientes valores se convierten a, y por lo tanto funcionan como, false:</p>
    <p>Todos los demás valores, incluidos todos los objetos (y matrices) se convierten y funcionan como true. false, y los seis valores que se convierten a él, se denominan a veces valores falsos, y todos los demás valores se denominan truthy. Cada vez que JavaScript espera un valor booleano, un valor falso funciona como false y un valor verdadero funciona como true.
    </p>
    <p>Por ejemplo, supongamos que la variable o contiene un objeto o el valor null. Puede comprobar explícitamente sio no es nulo con una sentencia if como ésta:</p>
    <p>El operador no-igual !== compara o con null y se evalúa como verdadero o falso. Pero puede omitir la comparación y confiar en el hecho de que null es falso y los objetos son verdaderos:</p>
    <p>En el primer caso, el cuerpo del if se ejecutará sólo si o no es null. El segundo caso es menos estricto: ejecutará el cuerpo del if sólo si o no es falso o cualquier valor falso (como null o undefined). Qué sentencia if es apropiada para su programa depende realmente de qué valores espera que se asignen a o. Si necesita distinguir entre null, 0 y "", debe utilizar una comparación explícita.</p>
    <p>Los valores booleanos tienen un método toString() que puede utilizar para convertirlos en las cadenas "verdadero" o "falso", pero no tienen ningún otro método útil. A pesar de la trivialidad de la API, existen tres operadores booleanos importantes.</p>
    <p>El operador && realiza la operación booleana AND. Obtiene un valor verdadero sólo si ambos operandos son verdaderos; en caso contrario, obtiene un valor falso. El operador || es la operación booleana OR: se evalúa con un valor verdadero si uno (o ambos) de sus operandos es verdadero y se evalúa con un valor falso si ambos operandos son falsos. Por último, el operador unario ! realiza la operación booleana NOT: se evalúa como verdadero si su operando es falso y como falso si su operando es verdadero. Por ejemplo:</p>
    <p>Encontrará más información sobre estos operadores en §4.10.</p>
  </section>
  <section>
    <h2>3.5 null e undefined</h2>
    <p>null es una palabra clave del lenguaje que se evalúa a un valor especial que se utiliza normalmente para indicar la ausencia de un valor. Al utilizar el operador typeof en null se obtiene la cadena "object", lo que indica que null puede considerarse un valor especial de objeto que indica "no object". En la práctica, sin embargo, null suele considerarse el único miembro de su propio tipo, y puede utilizarse para indicar "sin valor" tanto para números y cadenas como para objetos. La mayoría de los lenguajes de programación tienen un equivalente a null en JavaScript: es posible que lo conozca como NULL, nil o None.</p>
    <p>JavaScript también tiene un segundo valor que indica ausencia de valor. El valor indefinido representa un tipo más profundo de ausencia. Es el valor de las variables que no se han inicializado y el valor que se obtiene al consultar el valor de una propiedad de objeto o un elemento de matriz que no existe. El valor indefinido es también el valor de retorno de las funciones que no devuelven explícitamente un valor y el valor de los parámetros de función para los que no se pasa ningún argumento. undefined es una constante global predefinida (no una palabra clave del lenguaje como null, aunque esto no es una distinción importante en la práctica) que se inicializa al valor indefinido. Si aplica el operador typeof al valor undefinido, devuelve "undefined", indicando que este valor es el único miembro de un tipo especial.</p>
    <p>A pesar de estas diferencias, tanto null como undefined indican una ausencia de valor y a menudo pueden utilizarse indistintamente. El operador de igualdad == los considera iguales. (Utilice el operador de igualdad estricta === para distinguirlos.) Ambos son valores falsos: se comportan como false cuando se requiere un valor booleano.Ninull niundefined tienen propiedades o métodos. De hecho, utilizar . o [] para acceder a una propiedad o método de estos valores provoca un TypeError.</p>
    <p>Considero que undefined representa una ausencia de valor a nivel de sistema, inesperada o similar a un error, y null representa una ausencia de valor a nivel de programa, normal o esperada. Evito usar null e indefinido cuando puedo, pero si necesito asignar uno de estos valores a una variable o propiedad o pasar o devolver uno de estos valores a o desde una función, normalmente uso null. Algunos programadores se esfuerzan por evitar null por completo y utilizan undefined en su lugar siempre que pueden.</p>
  </section>
  <section id="6" class="py-4 xs:py-5 sm:py-6">
    <h2>3.6 Symbols</h2>
    <p>Los símbolos se introdujeron en ES6 para servir como nombres de propiedades sin cadena. Para entender Symbols, necesitas saber que el tipo fundamental Object de JavaScript es una colección desordenada de propiedades, donde cada propiedad tiene un nombre y un valor. Los nombres de las propiedades suelen ser (y hasta ES6, eran exclusivamente) cadenas. Pero en ES6 y posteriores, Symbols también puede servir para este propósito:</p>
    <p>El tipo Symbol no tiene una sintaxis literal. Para obtener un valor Symbol, se llama a la función Symbol(). Esta función nunca devuelve el mismo valor dos veces, incluso cuando se llama con el mismo argumento. Esto significa que si llama a Symbol() para obtener un valor Symbol, puede utilizar con seguridad ese valor como nombre de propiedad para añadir una nueva propiedad a un objeto y no tiene que preocuparse de que pueda estar sobrescribiendo una propiedad existente con el mismo nombre. Del mismo modo, si utiliza nombres de propiedad simbólicos y no comparte esos símbolos, puede estar seguro de que otros módulos de código de su programa no sobrescribirán accidentalmente sus propiedades.</p>
    <p>En la práctica, Symbols sirve como mecanismo de extensión del lenguaje. Cuando ES6 introdujo el bucle for/of (§5.4.4) y los objetos iterables (Capítulo 12), necesitó definir un método estándar que las clases pudieran implementar para hacerse iterables. Pero estandarizar cualquier nombre de cadena particular para este método iterador habría roto el código existente, así que en su lugar se utilizó un nombre simbólico. Como veremos en el Capítulo 12, Symbol.itera tor es un valor Symbol que puede usarse como nombre de método para hacer iterable un objeto.</p>
    <p>La función Symbol() toma un argumento de cadena opcional y devuelve un valor Sym- bol único. Si proporciona un argumento de cadena, esa cadena se incluirá en la salida. del método toString() del Symbol. Tenga en cuenta, sin embargo, que llamar a Symbol() dos veces con la misma cadena produce dos valores Symbol completamente diferentes.</p>
    <p>toString() es el único método interesante de las instancias de Symbol. Sin embargo, hay otras dos funciones relacionadas con Symbol que deberías conocer. A veces, cuando se utilizan Symbols, se desea mantenerlos privados a su propio código para tener la garantía de que sus propiedades nunca entrarán en conflicto con las propiedades utilizadas por otro código. Otras veces, sin embargo, es posible que desee definir un valor Symbol y compartirlo ampliamente con otro código. Este sería el caso, por ejemplo, si estuvieras definiendo algún tipo de extensión en la que quisieras que otro código pudiera participar, como con el mecanismo Symbol.iterator descrito anteriormente.</p>
    <p>Para servir a este último caso de uso, JavaScript define un registro Symbol global. La función Symbol.for() toma como argumento una cadena y devuelve un valor Symbol asociado a la cadena que se le pasa. Si no hay ningún símbolo asociado a esa cadena, se crea uno nuevo y se devuelve; en caso contrario, se devuelve el símbolo ya existente. Es decir, la función Symbol.for() es completamente diferente de la función Sym bol(): Symbol() nunca devuelve el mismo valor dos veces, pero Symbol.for() siempre devuelve el mismo valor cuando se llama con la misma cadena. La cadena pasada a Symbol.for() aparece en la salida de toString() para el Symbol devuelto, y también puede recuperarse llamando a Symbol.keyFor() sobre el Symbol devuelto.</p>
  </section>
  <section id="7">
    <h2>3.7 El objeto global</h2>
    <p>En las secciones anteriores se han explicado los tipos y valores primitivos de JavaScript. Los tipos de objeto-objetos, arrays y funciones-son tratados en capítulos propios más adelante en este libro. Pero hay un valor de objeto muy importante que debemos cubrir ahora. El objeto global es un objeto normal de JavaScript que sirve a un propósito muy importante: las propiedades de este objeto son los identificadores definidos globalmente que están disponibles para un programa Java Script. Cuando se inicia el intérprete de JavaScript (o cada vez que un navegador web carga una nueva página), crea un nuevo objeto global y le da un conjunto inicial de propiedades que definen:</p>
    <ul>
      <li>Constantes globales como undefined, Infinity y NaN</li>
      <li>Funciones globales como isNaN(), parseInt() (§3.9.2), y eval() (§4.12)</li>
      <li>Funciones constructoras como Date(), RegExp(), String(), Object() y Array() (§3.9.2)</li>
      <li>Objetos globales como Math y JSON (§6.8)</li>
    </ul>
    <p>Las propiedades iniciales del objeto global no son palabras reservadas, pero merecen ser tratadas como si lo fueran. En este capítulo ya se han descrito algunas de estas propiedades globales. La mayoría de las demás se tratarán en otras partes de este libro</p>
    <p>En Node, el objeto global tiene una propiedad llamada global cuyo valor es el propio objeto global, por lo que siempre puedes referirte al objeto global por el nombreglobal enlosprogramasNode.</p>
    <p>En los navegadores web, el objeto Window sirve como objeto global para todo el código JavaScript contenido en la ventana del navegador que representa. Este objeto Window global tiene una propiedad window autorreferencial que puede utilizarse para referirse al objeto global. El objeto Window define las propiedades globales principales, pero también define otras propiedades globales específicas de los navegadores web y de JavaScript del lado del cliente. Los subprocesos del Web worker (§15.13) tienen un objeto global diferente al de la ventana con la que están asociados. El código en un worker puede referirse a su objeto global como self.</p>
    <p>ES2020 define finalmente globalThis como la forma estándar de referirse al objeto global en cualquier contexto. A principios de 2020, esta característica ha sido implementada por todos los navegadores modernos y por Node.</p>
  </section>
  <section id="8" class="py-4 xs:py-5 sm:py-6">
    <h2>3.8 Valores primitivos inmutables y referencias a objetos mutables</h2>
    <p>En JavaScript existe una diferencia fundamental entre los valores primitivos (indefinidos, nulos, booleanos, números y cadenas) y los objetos (incluidas las matrices y las funciones). Los valores primitivos son inmutables: no hay forma de cambiar (o "mutar") un valor primitivo. Esto es obvio en el caso de los números y los booleanos: ni siquiera tiene sentido cambiar el valor de un número. Sin embargo, no es tan obvio en el caso de las cadenas. Dado que las cadenas son como matrices de caracteres, cabría esperar poder modificar el carácter en cualquier índice especificado. De hecho, JavaScript no lo permite, y todos los métodos de cadena que parecen devolver una cadena modificada están, de hecho, devolviendo un nuevo valor de cadena. Por ejemplo:</p>
    <p>Las primitivas también se comparan por valor: dos valores son iguales sólo si tienen el mismo valor. Esto suena circular para números, booleanos, nulos e indefinidos: no hay otra forma de compararlos. Sin embargo, no es tan obvio en el caso de las cadenas. Si se comparan dos valores de cadena distintos, JavaScript los considera iguales si, y sólo si, tienen la misma longitud y si el carácter de cada índice es el mismo.</p>
    <p>Los objetos son diferentes de las primitivas. En primer lugar, son mutables: sus valores pueden cambiar:</p>
    <p>Los objetos no se comparan por su valor: dos objetos distintos no son iguales aunque tengan las mismas propiedades y valores. Y dos matrices distintas no son iguales aunque tengan los mismos elementos en el mismo orden:</p>
    <p>Los objetos se denominan a veces tipos de referencia para distinguirlos de los tipos primitivos de JavaScript. Utilizando esta terminología, los valores de objeto son referencias, y decimos que los objetos se comparan por referencia: dos valores de objeto son iguales si y sólo si se refieren al mismo objeto subyacente.</p>
    <p>Como puedes ver en este código, asignar un objeto (o array) a una variable simplemente asigna la referencia: no crea una nueva copia del objeto. Si quieres hacer una nueva copia de un objeto o array, debes copiar explícitamente las propiedades del objeto o los elementos del array. Este ejemplo muestra el uso de un bucle for (§5.4.3):</p>
    <p>Del mismo modo, si queremos comparar dos objetos o matrices distintos, debemos comparar sus propiedades o elementos. Este código define una función para comparar dos matrices:</p>
  </section>
  <section id="9">
    <h2>3.9 Conversiones de tipo</h2>
    <p>JavaScript es muy flexible en cuanto a los tipos de valores que requiere. Lo hemos visto con los booleanos: cuando JavaScript espera un valor booleano, puede proporcionar un valor de cualquier tipo y JavaScript lo convertirá según sea necesario. Algunos valores (valores "verdaderos") se convierten en verdaderos y otros (valores "falsos") se convierten en falsos. Lo mismo ocurre con otros tipos: si JavaScript quiere una cadena, convertirá cualquier valor que le proporcione en una cadena. Si JavaScript quiere un número, intentará convertir el valor que le des en un número (o en NaN si no puede realizar una conversión significativa).</p>
    <p>Algunos ejemplos:</p>
    <p>La Tabla 3-2 resume cómo se convierten los valores de un tipo a otro en JavaScript. Las entradas en negrita de la tabla resaltan conversiones que pueden resultarle sorprendentes. Las celdas vacías indican que no es necesaria ninguna conversión y que no se realiza ninguna.</p>
    <p><em>Tabla 3-2. Conversiones de tipos de JavaScript</em></p>
    <p>Las conversiones de primitivo a primitivo que se muestran en la tabla son relativamente sencillas. La conversión a booleano ya se trató en §3.4. La conversión a cadenas está bien definida para todos los valores primitivos. La conversión a números es un poco más complicada. Las cadenas que pueden analizarse como números se convierten a esos números. Se permiten espacios iniciales y finales, pero cualquier carácter sin espacio inicial o final que no forme parte de un literal numérico provoca que la conversión de cadena a número produzca NaN. Algunas conversiones numéricas pueden parecer sorprendentes: verdadero se convierte en 1, y falso y la cadena vacía se convierten en 0.</p>
    <p>La conversión de objeto a primitivo es algo más complicada, y es el tema de §3.9.3.</p>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h3>3.9.1 Conversiones e igualdad</h3>
    <p>JavaScript tiene dos operadores que comprueban si dos valores son iguales. El "operador de igualdad estricta", ===, no considera que sus operandos sean iguales si no son del mismo tipo, y casi siempre es el operador que hay que utilizar al codificar. Pero como JavaScript es tan flexible con las conversiones de tipo, también define el operador == con una definición flexible de igualdad. Por ejemplo, todas las comparaciones siguientes son verdaderas:</p>
    <p>§4.9.1 explica exactamente qué conversiones realiza el operador == para determinar si dos valores deben considerarse iguales.</p>
    <p>Tenga en cuenta que la convertibilidad de un valor en otro no implica la igualdad de esos dos valores. Si se utiliza undefined donde se espera un valor booleano, por ejemplo, se convertirá a false. Pero esto no significa que undefined == false. Los operadores y sentencias de JavaScript esperan valores de varios tipos y realizan conversiones a esos tipos. La sentencia if convierte undefined en false, pero el operador == nunca intenta convertir sus operandos en booleanos.</p>
  </section>
  <section>
    <h3>3.9.2 Conversiones explícitas</h3>
    <p>Aunque JavaScript realiza muchas conversiones de tipo de forma automática, puede que a veces necesite realizar una conversión explícita, o puede que prefiera hacer las conversiones explícitas para que su código sea más claro.</p>
    <p>La forma más sencilla de realizar una conversión de tipo explícita es utilizar las funcionesBoolean(),Num ber() yString():</p>
    <p>Cualquier valor distinto de null o undefined tiene un método toString(), y el resultado de este método suele ser el mismo que el devuelto por la función String().</p>
    <p>Por otra parte, las funciones Boolean(), Number() y String() también pueden invocarse con new como constructor. Si las usas de esta manera, obtendrás un objeto "envoltorio" que se comporta igual que un valor booleano, numérico o de cadena primitivo. Estos objetos envolventes son un resto histórico de los primeros días de JavaScript, y nunca hay realmente ninguna buena razón para utilizarlos.</p>
    <p>Ciertos operadores de JavaScript realizan conversiones de tipo implícitas y a veces se utilizan explícitamente con el propósito de convertir tipos. Si uno de los operandos del operador + es una cadena, convierte el otro en una cadena. El operador unario + convierte su operando en un número. Y el operador unario ! convierte su operando en un booleano y lo niega. Estos hechos llevan a los siguientes modismos de conversión de tipos que puedes ver en algún código:</p>
    <p>El formateo y el análisis sintáctico de números son tareas habituales en los programas informáticos, y Java Script dispone de funciones y métodos especializados que proporcionan un control más preciso sobre las conversiones de número a cadena y de cadena a número.</p>
    <p>El método toString() definido por la clase Number acepta un argumento opcional que especifica un radix, o base, para la conversión. Si no se especifica el argumento, la conversión se realiza en base 10. Sin embargo, también puede convertir números en otras bases (entre 2 y 36). Por ejemplo:</p>
    <p>Al trabajar con datos financieros o científicos, es posible que desee convertir números en cadenas de manera que pueda controlar el número de decimales o el número de dígitos significativos de la salida, o que desee controlar si se utiliza la notación exponencial. La clase Number define tres métodos para este tipo de conversiones de número a cadena. toFixed() convierte un número en una cadena con un número especificado de dígitos después del punto decimal. Nunca utiliza la notación exponencial. toExponential() convierte un número en una cadena utilizando la notación exponencial, con una dígito antes del punto decimal y un número especificado de dígitos después del punto decimal (lo que significa que el número de dígitos significativos es uno mayor que el valor especificado). toPrecision() convierte un número en una cadena con el número de dígitos significativos especificado. Utiliza la notación exponencial si el número de dígitos significativos no es lo suficientemente grande como para mostrar toda la parte entera del número. Tenga en cuenta que los tres métodos redondean los dígitos finales o los rellenan con ceros, según convenga. Considere los siguientes ejemplos:</p>
    <p>Además de los métodos de formato numérico mostrados aquí, la clase Intl.NumberFormat define un método de formato numérico más general e internacionalizado. Véase §11.7.1 para más detalles.</p>
    <p>Si pasa una cadena de caracteres a la función de conversión Number(), ésta intentará interpretarla como un literal entero o de coma flotante. Esta función sólo funciona con enteros de base 10 y no admite caracteres finales que no formen parte del literal. Las funciones parseInt() y parseFloat() (éstas son funciones globales, no métodos de ninguna clase) son más flexibles. parseInt() analiza sólo números enteros, mientras que parseFloat() analiza tanto números enteros como de coma flotante. Si una cadena empieza por "0x" o "0X", parseInt() la interpreta como un número hexadecimal. Tanto parseInt() como parse Float() omiten los espacios en blanco iniciales, analizan tantos caracteres numéricos como pueden e ignoran todo lo que sigue. Si el primer carácter sin espacio no forma parte de un literal numérico válido, devuelven NaN:</p>
    <p>parseInt() acepta un segundo argumento opcional que especifica el radix (base) del número que se va a analizar. Los valores legales están comprendidos entre 2 y 36. Por ejemplo:</p>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.9.3 Conversiones de objeto a primitivo</h3>
    <p>Las secciones anteriores han explicado cómo se pueden convertir explícitamente valores de un tipo a otro tipo y han explicado las conversiones implícitas de JavaScript de valores de un tipo primitivo a otro tipo primitivo. Esta sección cubre las reglas que JavaScript utiliza para convertir objetos en valores primitivos. Es larga y oscura, por lo que si es la primera vez que lee este capítulo, no dude en saltar a §3.10.</p>
    <p>Una de las razones de la complejidad de las conversiones de objetos a primitivas de JavaScript es que algunos tipos de objetos tienen más de una representación primitiva. Los objetos de fecha, por ejemplo, pueden representarse como cadenas o como marcas de tiempo numéricas. La especificación de JavaScript define tres algoritmos fundamentales para convertir objetos en valores primitivos:</p>
    <div class="">
      <p><em>prefer-string</em></p>
      <p>Este algoritmo devuelve un valor primitivo, prefiriendo un valor de cadena, si es posible una conversión a cadena.</p>
    </div>
    <div class="">
      <p><em>número preferente</em></p>
      <p>Este algoritmo devuelve un valor primitivo, prefiriendo un número, si tal conver- sión es posible.</p>
    </div>
    <div class="">
      <p><em>sin preferencia</em></p>
      <p>EEste algoritmo no expresa ninguna preferencia sobre qué tipo de valor primitivo se desea, y las clases pueden definir sus propias conversiones. De los tipos JavaScript incorporados, todos excepto Date implementan este algoritmo como prefer-number. La clase Date implementa este algoritmo como prefer-string.</p>
    </div>
    <p>La implementación de estos algoritmos de conversión de objeto a primitivo se explica al final de esta sección. Antes, sin embargo, explicamos cómo se utilizan los algoritmos en JavaScript.</p>
    <p>Conversiones de objeto a booleano</p>
    <p>Las conversiones de objeto a booleano son triviales: todos los objetos se convierten a verdadero. Observe que esta conversión no requiere el uso de los algoritmos objeto- a-primitivo descritos, y que se aplica literalmente a todos los objetos, incluyendo matrices vacías e incluso el objeto envoltorio new Boolean(false).</p>
    <p>Conversiones de objeto a cadena</p>
    <p>Cuando es necesario convertir un objeto en una cadena, JavaScript lo convierte primero en una primitiva mediante el algoritmo prefer-string y, a continuación, convierte el valor de la primitiva resultante en una cadena, si es necesario, siguiendo las reglas de la Tabla 3-2.</p>
    <p>Este tipo de conversión se produce, por ejemplo, si se pasa un objeto a una función incorporada que espera un argumento de cadena, si se llama a String() como función de conversión y cuando se interpolan objetos en literales de plantilla (§3.3.4).</p>
    <p>Conversión de objetos en números</p>
    <p>Cuando es necesario convertir un objeto en un número, JavaScript lo convierte primero en un valor primitivo mediante el algoritmo prefer-number y, a continuación, convierte el valor primitivo resultante en un número, si es necesario, siguiendo las reglas de la Tabla 3-2.</p>
    <p>Las funciones y métodos integrados de JavaScript que esperan argumentos numéricos convierten los argumentos de objetos en números de esta forma, y la mayoría (véanse las excepciones siguientes) de los operadores de JavaScript que esperan operandos numéricos convierten los objetos en números también de esta forma.</p>
    <p>Conversiones de operadores en casos especiales</p>
    <p>Los operadores se tratan en detalle en el Capítulo 4. Aquí explicamos los casos especiales de operadores que no utilizan las conversiones básicas de objeto a cadena y de objeto a número descritas anteriormente.</p>
    <p>El operador + de JavaScript realiza la suma numérica y la concatenación de cadenas. Si cualquiera de sus operandos es un objeto, JavaScript los convierte en valores primitivos mediante el algoritmo de no preferencia. Una vez que tiene dos valores primitivos, comprueba sus tipos. Si alguno de los argumentos es una cadena, convierte el otro en una cadena y concatena las cadenas. En caso contrario, convierte ambos argumentos en números y los suma.</p>
    <p>Los operadores == y != realizan pruebas de igualdad y desigualdad de una forma flexible que permite conversiones de tipo. Si un operando es un objeto y el otro es un valor primitivo, estos operadores convierten el objeto en primitivo utilizando el algoritmo de no preferencia y luego comparan los dos valores primitivos.</p>
    <p>Por último, los operadores relacionales &minus;, &minus;=, > y >= comparan el orden de sus operandos y pueden utilizarse para comparar tanto números como cadenas. Si alguno de los operandos es un objeto, se convierte en un valor primitivo mediante el algoritmo preferir-número. Tenga en cuenta, sin embargo, que a diferencia de la conversión de objeto a número, los valores primitivos devueltos por la conversión prefer-número no se convierten en números.</p>
    <p>Tenga en cuenta que la representación numérica de los objetos Date es significativamente comparable con &GreaterEqual; y >, pero la representación de cadena no lo es. Para los objetos Date, el algoritmo no-preference convierte a una cadena, por lo que el hecho de que JavaScript utilice el algoritmo prefer-number de estos operadores significa que podemos utilizarlos para comparar el orden de dos objetos Date.</p>
    <p>Los métodos toString() y valueOf()</p>
    <p>Todos los objetos heredan dos métodos de conversión que se utilizan en las versiones de objeto a primitivo, y antes de que podamos explicar los algoritmos de conversión prefer-string, prefer-number y no-preference, tenemos que explicar estos dos métodos.</p>
    <p>El primer método es toString(), y su trabajo consiste en devolver una representación en forma de cadena del objeto. El método por defecto toString() no devuelve un valor muy interesante (aunque lo encontraremos útil en §14.4.3):</p>
    <p>Muchas clases definen versiones más específicas del método toString(). El método toString() de la clase Array, por ejemplo, convierte cada elemento de la matriz en una cadena y une las cadenas resultantes con comas entre ellas. El método toString() de la clase Function convierte las funciones definidas por el usuario en cadenas de código fuente JavaScript. La clase Date define un método toString() que devuelve una cadena de fecha y hora legible por humanos (y por JavaScript). La clase RegExp define un método toString() que convierte los objetos RegExp en una cadena parecida a u n literal RegExp:</p>
    <p>La otra función de conversión de objetos se llama valueOf(). El trabajo de este método está menos definido: se supone que convierte un objeto en un valor primitivo que representa el objeto, si existe tal valor primitivo. Los objetos son valores compuestos, y la mayoría de los objetos no pueden ser representados por un único valor primitivo, por lo que el método por defecto valueOf() simplemente devuelve el objeto en sí en lugar de devolver un valor primitivo. Las clases envolventes como String, Number y Boolean definen métodos valueOf() que simplemente devuelven el valor primitivo envuelto. Las matrices, funciones y expresiones regulares simplemente heredan el método por defecto. Al llamar a valueOf() para instancias de estos tipos, simplemente se devuelve el objeto en sí. La clase Date define un método valueOf() que devuelve la fecha en su representación interna: el número de milisegundos transcurridos desde el 1 de enero de 1970:</p>
    <p>Algoritmos de conversión de objetos a primitivos</p>
    <p>Una vez explicados los métodos toString() y valueOf(), podemos explicar aproximadamente cómo funcionan los tres algoritmos de conversión de objeto a primitiva (los detalles completos se posponen hasta §14.4.7):</p>
    <ul>
      <li>El algoritmo prefer-string prueba primero el método toString(). Si el método está definido y devuelve un valor primitivo, JavaScript utiliza ese valor primitivo (¡aunque no sea una cadena!). Si toString() no existe o devuelve un objeto, JavaScript prueba con el método valueOf(). Si ese método existe y devuelve un valor primitivo, JavaScript utiliza ese valor. En caso contrario, la conversión falla con un TypeError.</li>
      <li>El algoritmo prefer-number funciona como el algoritmo prefer-string, con la diferencia de que primero prueba con valueOf() y después con toString().</li>
      <li>El algoritmo de no preferencia depende de la clase del objeto que se está convirtiendo. Si se trata de un objeto Date, JavaScript utiliza el algoritmo prefer- string. Para cualquier otro objeto, JavaScript utiliza el algoritmo prefer-number.</li>
    </ul>
    <p>Las reglas descritas aquí son válidas para todos los tipos JavaScript incorporados y son las reglas por defecto para cualquier clase que defina usted mismo. §14.4.7 explica cómo puede definir sus propios algoritmos de conversión de objeto a primitivo para las clases que defina.</p>
    <p>Antes de dejar este tema, vale la pena señalar que los detalles de la con- versión de preferir números explican por qué las matrices vacías se convierten en el número 0 y las matrices de un solo elemento también pueden convertirse en números:</p>
    <p>La conversión de objeto a número convierte primero el objeto en una primitiva mediante el algoritmo prefer-number y, a continuación, convierte el valor primitivo resultante en un número. El algoritmo prefer-number intenta primero con valueOf() y luego recurre a toString(). Pero la clase Array hereda el método por defecto valueOf(), que no devuelve un valor primitivo. Así que cuando intentamos convertir un array en un número, acabamos invocando el método toString() del array. Las matrices vacías se convierten en la cadena vacía. Y la cadena vacía se convierte en el número 0. Un array con un único elemento se convierte en la misma cadena que ese único elemento. Si un array contiene un único número, ese número se convierte en una cadena y luego de nuevo en un número.</p>
  </section>
  <section id="10">
    <h2>3.10 Declaración y asignación de variables</h2>
    <p>Una de las técnicas más fundamentales de la programación informática es el uso de nombres (o identificadores) para representar valores. Asociar un nombre a un valor nos permite referirnos a ese valor y utilizarlo en los programas que escribimos. Cuando hacemos esto, normalmente decimos que estamos asignando un valor a una variable. El término "variable" implica que se pueden asignar nuevos valores: que el valor asociado a la variable puede variar a medida que se ejecuta el programa. Si asignamos permanentemente un valor a un nombre, entonces llamamos a ese nombre una constante en lugar de una variable.
    </p>
    <p>Antes de poder utilizar una variable o constante en un programa JavaScript, hay que declararla. En ES6 y posteriores, esto se hace con las palabras clave let y const, que explicamos a continuación. Antes de ES6, las variables se declaraban con var, que es más idiosincrásico y se explica más adelante en esta sección.</p>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.10.1 Declaraciones con let y const</h3>
    <p>En el JavaScript moderno (ES6 y posteriores), las variables se declaran con la palabra clave let, así:</p>
    <p>También puede declarar múltiples variables en una sola sentencia let:</p>
    <p>Es una buena práctica de programación asignar un valor inicial a las variables en el momento de declararlas, siempre que sea posible:</p>
    <p>Si no se especifica un valor inicial para una variable con la sentencia let, la variable se declara, pero su valor es indefinido hasta que el código le asigne un valor.</p>
    <p>Para declarar una constante en lugar de una variable, utilice const en lugar de let. const funciona igual que let, salvo que debe inicializar la constante al declararla:</p>
    <p>Como su nombre indica, no se pueden cambiar los valores de las constantes, y cualquier intento de hacerlo provoca un error de tipo TypeError.</p>
    <p>Es una convención común (pero no universal) declarar constantes utilizando nombres con todas las letras mayúsculas como H0 o HTTP_NOT_FOUND como una forma de distinguirlas de las variables.</p>
    <p>Cuándo utilizar const</p>
    <p>Hay dos escuelas de pensamiento sobre el uso de la palabra clave const. Un enfoque es utilizar const sólo para valores que son fundamentalmente inmutables, como las constantes físicas mostradas, o los números de versión del programa, o las secuencias de bytes utilizadas para identificar los tipos de archivo, por ejemplo. Otro enfoque reconoce que muchas de las llamadas variables en nuestro programa en realidad nunca cambian a medida que nuestro programa se ejecuta. En este enfoque, declaramos todo con const, y luego si encontramos que realmente queremos permitir que el valor varíe, cambiamos la declaración a let. Esto puede ayudar a prevenir errores al descartar cambios accidentales a variables que no pretendíamos.</p>
    <p>En uno de los enfoques, utilizamos const sólo para valores que no deben cambiar. En el otro, usamos const para cualquier valor que no deba cambiar. Yo prefiero el primer enfoque en mi propio código.</p>
    <p>En el Capítulo 5, aprenderemos sobre las sentencias de bucle for, for/in y for/of en Java-Script. Cada uno de estos bucles incluye una variable de bucle a la que se asigna un nuevo valor en cada iteración del bucle. JavaScript nos permite declarar la variable de bucle como parte de la propia sintaxis del bucle, y ésta es otra forma común de usar let:</p>
    <p>Puede parecer sorprendente, pero también puedes usar const para declarar las "variables" de bucle para los bucles for/in y for/of, siempre que el cuerpo del bucle no reasigne un nuevo valor. En este caso, la declaración const sólo está diciendo que el valor es constante para la duración de una iteración del bucle:</p>
    <p>Ámbito variable y constante</p>
    <p>El ámbito de una variable es la región del código fuente del programa en la que está definida. Las variables y constantes declaradas con let y const tienen ámbito de bloque. Esto significa que sólo se definen dentro del bloque de código en el que aparece la sentencia let o const. Las definiciones de clases y funciones de JavaScript son bloques, al igual que los cuerpos de las sentencias if/else, los bucles while, los bucles for, etc. En términos generales, si una variable o constante se declara dentro de un conjunto de llaves, entonces esas llaves delimitan la región de código en la que se define la variable o constante (aunque, por supuesto, no es legal hacer referencia a una variable o constante desde líneas de código que se ejecutan antes de la sentencia let o const que declara la variable). Variables y constantes declarados como parte de un bucle for, for/in, o for/of tienen como ámbito el cuerpo del bucle, aunque técnicamente aparezcan fuera de las llaves.</p>
    <p>Cuando una declaración aparece en el nivel superior, fuera de cualquier bloque de código, decimos que es una variable o constante global y que tiene ámbito global. En Node y en los módulos JavaScript del lado del cliente (ver Capítulo 10), el ámbito de una variable global es el archivo en el que está definida. En el JavaScript tradicional del lado del cliente, sin embargo, el ámbito de una variable global es el documento HTML en el que está definida. Es decir: si un &minus;script> declara una variable o constante global, esa variable o constante se define en todos los elementos &minus;script> de ese documento (o al menos en todos los scripts que se ejecuten después de que se ejecute la sentencia let o const).</p>
    <p>Declaraciones repetidas</p>
    <p>Es un error sintáctico utilizar el mismo nombre con más de una declaración let o const en el mismo ámbito. Es legal (aunque es mejor evitarlo) declarar una nueva variable con el mismo nombre en un ámbito anidado:</p>
    <p>Declaraciones y tipos</p>
    <p>Si está acostumbrado a lenguajes de tipado estático como C o Java, puede pensar que el propósito principal de las declaraciones de variables es especificar el tipo de valores que pueden asignarse a una variable. Pero, como ha visto, no hay ningún tipo asociado a las declaraciones de variables de JavaScript.2 Una variable de JavaScript puede contener un valor de cualquier tipo. Por ejemplo, en JavaScript es perfectamente legal (aunque generalmente de mal estilo de programación) asignar un número a una variable y más tarde asignar una cadena a esa variable:</p>
  </section>
  <section>
    <h3>3.10.2 Declaraciones de variables con var</h3>
    <p>En las versiones de JavaScript anteriores a ES6, la única forma de declarar una variable es con la palabra clave var, y no hay forma de declarar constantes. La sintaxis de var es igual que la sintaxis de let:</p>
    <p>Aunque var y let tienen la misma sintaxis, existen diferencias importantes en su funcionamiento:</p>
    <ul>
      <li>Las variables declaradas con var no tienen ámbito de bloque. En su lugar, tienen ámbito en el cuerpo de la función que las contiene, independientemente de la profundidad a la que estén anidadas dentro de esa función.</li>
      <li>Si se utiliza var fuera del cuerpo de una función, se declara una variable global. Pero las variables globales declaradas con var difieren de las globales declaradas con let en un aspecto importante. Las variables globales declaradas con var se implementan como propiedades del objeto global (§3.7). El objeto global puede ser referenciado como globalThis. Así, si escribes var x = 2; fuera de una función, es como si hubieras escrito globalEsta.x = 2;. Nótese, sin embargo, que la analogía no es perfecta: las propiedades creadas con declaraciones de variables globales no pueden borrarse con el operador delete (§4.13.4). Las variables y constantes globales declaradas con let y const no son propiedades del objeto global.</li>
      <li>A diferencia de las variables declaradas con let, es legal declarar la misma variable múltiples veces con var. Y como las variables var tienen ámbito de función en lugar de ámbito de bloque, es realmente común hacer este tipo de redeclaración. La variable i se utiliza frecuentemente para valores enteros, y especialmente como variable índice de los bucles for. En una función con múltiples bucles for, es típico que cada uno de ellos comience for(var i = 0; Dado que var no tiene alcance de estas variables para el bucle cada uno de estos bucles está (inofensivamente) redeclarando y reinicializando la misma variable.</li>
      <li>Una de las características más inusuales de las declaraciones var se conoce como elevación. Cuando se declara una variable con var, la declaración se eleva a la parte superior de la función que la contiene. La inicialización de la variable permanece donde la escribiste, pero la definición de la variable se mueve a la parte superior de la función. Así, las variables declaradas con var pueden utilizarse, sin error, en cualquier parte de la función que las encierra. Si el código de inicialización aún no se ha ejecutado, entonces el valor de la variable puede estar indefinido, pero no obtendrá un error si utiliza la variable antes de que se inicialice. (Esto puede ser una fuente de errores y es uno de los errores importantes que let corrige: si declaras una variable con let pero intentas usarla antes de que se ejecute la sentencia let, obtendrás un error real en lugar de ver simplemente un valor indefinido).</li>
    </ul>
    <p>Uso de variables no declaradas</p>
    <p>En modo estricto (§5.6.3), si intentas usar una variable no declarada, obtendrás un error de referencia cuando ejecutes tu código. Sin embargo, fuera del modo estricto, si asignas un valor a un nombre que no ha sido declarado con let, const o var, acabarás creando una nueva variable global. Será una global sin importar lo profundamente anidado que esté tu código dentro de funciones y bloques, lo que casi con toda seguridad no es lo que quieres, es propenso a errores, ¡y es una de las mejores razones para usar el modo estricto!</p>
    <p>Las variables globales creadas de esta forma accidental son como las declaradas con var: definen propiedades del objeto global. Pero a diferencia de las propiedades definidas por declaraciones var adecuadas, estas propiedades pueden borrarse con el operador delete (§4.13.4).</p>
  </section>
  <section class="py-4 xs:py-5 sm:py-6">
    <h3>3.10.3 Desestructuración Asignación</h3>
    <p>ES6 implementa un tipo de declaración compuesta y una sintaxis de asignación conocida como asignación desestructurada. En una asignación de desestructuración, el valor situado a la derecha del signo igual es una matriz o un objeto (un valor "estructurado"), y el lado izquierdo especifica uno o más nombres de variables utilizando una sintaxis que imita la sintaxis literal de matrices y objetos. Cuando se produce una asignación de desestructuración, se extraen ("desestructuran") uno o más valores del valor de la derecha y se almacenan en las variables nombradas a la izquierda. La asignación desestructurante es quizás la más utilizada para ini- tializar variables como parte de una declaración const, let o var, pero también puede hacerse en expresiones de asignación regulares (con variables que ya han sido declaradas). Y, como veremos en §8.3.5, la desestructuración también puede utilizarse al definir los parámetros de una función.</p>
    <p>A continuación se presentan asignaciones de desestructuración sencillas utilizando matrices de valores:</p>
    <p>Observe cómo la asignación de desestructuración facilita el trabajo con funciones que devuelven matrices de valores:</p>
    <p>Hemos visto que las variables y constantes pueden declararse como parte de los distintos bucles for de JavaScript. También es posible utilizar la desestructuración de variables en este contexto. He aquí un código que recorre los pares nombre/valor de todas las propiedades de un objeto y utiliza la asignación desestructurante para convertir esos pares de matrices de dos elementos en variables individuales:</p>
    <p>El número de variables a la izquierda de una asignación de desestructuración no tiene por qué coincidir con el número de elementos del array a la derecha. Las variables extra a la izquierda se definen como indefinidas, y los valores extra a la derecha se ignoran. La lista de variables de la izquierda puede incluir comas adicionales para omitir ciertos valores de la derecha:</p>
    <p>Si desea reunir todos los valores no utilizados o restantes en una sola variable al desestructurar una matriz, utilice tres puntos (...) antes del último nombre de variable del lado izquierdo:</p>
    <p>Volveremos a ver tres puntos utilizados de esta forma en §8.3.2, donde se utilizan para indicar que todos los argumentos restantes de la función deben reunirse en una única matriz.</p>
    <p>La asignación de desestructuración puede utilizarse con matrices anidadas. En este caso, el lado izquierdo de la asignación debe parecerse a un literal de matriz anidada:</p>
    <p>Una característica importante de la desestructuración de arrays es que no requiere un array. Puede utilizar cualquier objeto iterable (Capítulo 12) en el lado derecho de la asignación; también puede desestructurarse cualquier objeto que pueda utilizarse con unbuclefor/of (§5.4.4):</p>
    <p>La asignación de desestructuración también puede realizarse cuando el lado derecho es un valor de objeto. En este caso, el lado izquierdo de la asignación se parece a un literal de objeto: una lista separada por comas de nombres de variables entre llaves:</p>
    <p>El siguiente ejemplo copia funciones globales del objeto Math en variables, lo que podría simplificar el código que hace mucha trigonometría:</p>
    <p>Observe en el código que el objeto Math tiene muchas propiedades además de las tres que están desestructuradas en variables individuales. Aquellas que no son nombradas son simplemente ignoradas. Si el lado izquierdo de esta asignación hubiera incluido una variable cuyo nombre no fuera una propiedad de Math, esa variable simplemente se asignaría como indefinida.</p>
    <p>En cada uno de estos ejemplos de desestructuración de objetos, hemos elegido nombres de variables que coinciden con los nombres de las propiedades del objeto que estamos desestructurando. Esto mantiene la sintaxis simple y fácil de entender, pero no es obligatorio. Cada uno de los identificadores de la parte izquierda de una asignación de desestructuración de objetos también puede ser un par de identificadores separados por dos puntos, donde el primero es el nombre de la propiedad cuyo valor se va a asignar y el segundo es el nombre de la variable a la que se va a asignar:</p>
    <p>Encuentro que la sintaxis de desestructuración de objetos se vuelve demasiado complicada para ser útil cuando los nombres de las variables y los nombres de las propiedades no son los mismos, y tiendo a evitar la mano corta en este caso. Si decide utilizarla, recuerde que los nombres de las propiedades van siempre a la izquierda de los dos puntos, tanto en los literales de objeto como a la izquierda de una asignación de desestructuración de objeto.</p>
    <p>La asignación desestructurada se complica aún más cuando se utiliza con objetos nes- tados, o matrices de objetos, u objetos de matrices, pero es legal:</p>
    <p>O, en lugar de desestructurar un array de objetos, podríamos desestructurar un objeto de arrays:</p>
    <p>Una sintaxis de desestructuración compleja como ésta puede ser difícil de escribir y de leer, y puede que sea mejor escribir las asignaciones explícitamente con código tradicionalcomolet x1 = points.p1[0];.</p>
    <article>
      <p>Comprender la desestructuración compleja</p>
      <p>Si se encuentra trabajando con código que utiliza asignaciones de desestructuración complejas, existe una regularidad útil que puede ayudarle a dar sentido a los casos complejos. Piense primero en una asignación normal (de un solo valor). Una vez realizada la asignación, puede tomar el nombre de la variable del lado izquierdo de la asignación y utilizarlo como una expresión en su código, donde se evaluará al valor que le haya asignado. Lo mismo ocurre con las asignaciones desestructuradas. El lado izquierdo de una asignación de desestructuración se parece a un literal de matriz o a un literal de objeto (§6.2.1 y §6.10). Una vez realizada la asignación, la parte izquierda funcionará como un literal de array o de objeto válido en cualquier otra parte del código. Puede comprobar que ha escrito correctamente una asignación destructiva intentando usar el lado izquierdo en el lado derecho de otra expresión de asignación:</p>
    </article>
  </section>
  <section id="11" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>3.11 Resumen</h2>
    <p>Algunos puntos clave que conviene recordar sobre este capítulo:</p>
    <ul>
      <li>Cómo escribir y manipular números y cadenas de texto en JavaScript.</li>
      <li>CómotrabajarconotrostiposprimitivosdeJavaScript:booleanos,símbolos,
        null eindefinido.</li>
      <li>Diferencias entre tipos primitivos inmutables y tipos de referencia mutables.</li>
      <li>Cómo JavaScript convierte valores implícitamente de un tipo a otro y cómo puede hacerlo explícitamente en sus programas.</li>
      <li>Cómodeclarareinicializarconstantesyvariables(inclusoconasignación desestructurante) y el ámbito léxico de las variables y constantes que se declaran.</li>
    </ul>
  </section>
</Layoutjavascript>