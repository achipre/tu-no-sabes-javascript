---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-14" capSiguiente="capitulo-16" />
  <section class="fadeIn">
    <h1 class="text-right">JavaScript en los navegadores web</h1>
    <p>El lenguaje JavaScript se creó en 1994 con el propósito expreso de permitir el comportamiento dinámico de en los documentos mostrados por los navegadores web. Desde entonces, el lenguaje ha evolucionado significativamente y, al mismo tiempo, el alcance y las capacidades de la plataforma web han crecido de forma explosiva. Hoy en día, los programadores de JavaScript pueden considerar la web como una plataforma completa para el desarrollo de aplicaciones. Los navegadores web están especializados en la visualización de texto formateado e imágenes, pero, al igual que los sistemas operativos nativos, los navegadores también proporcionan otros servicios, como gráficos, vídeo, audio, redes, almacenamiento y subprocesos. JavaScript es el lenguaje que permite a las aplicaciones web utilizar los servicios proporcionados por la plataforma web, y este capítulo muestra cómo utilizar los más importantes de estos servicios.</p>
    <p>El capítulo comienza con el modelo de programación de la plataforma web, explicando cómo se incrustan los scripts en las páginas HTML (<a href="#1">§15.1</a>) y cómo el código JavaScript se activa de forma asíncrona mediante eventos (<a href="#2">§15.2</a>). Las secciones que siguen a este material introductorio documentan las principales API de JavaScript que permiten a las aplicaciones web:</p>
    <p>Los temas de metaprogramación tratados en este capítulo incluyen:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Controlar el contenido del documento (<a href="#3">§15.3</a>) y el estilo (<a href="#4">§15.4</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Determinar la posición en pantalla de los elementos del documento (<a href="#5">§15.5</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Crear componentes de interfaz de usuario reutilizables (<a href="#6">§15.6</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Dibujar gráficos (<a href="#7">§15.7</a> y <a href="#8">§15.8</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Reproducir y generar sonidos (<a href="#9">§15.9</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Gestionar la navegación y el historial del navegador (<a href="#10">§15.10</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Intercambiar datos a través de la red (<a href="#11">§15.11</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Almacenar datos en el ordenador del usuario (<a href="#12">§15.12</a>)
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Realizar cálculos concurrentes con hilos (<a href="#13">§15.13</a>)
        </p>
      </li>
    </ul>
    <article>
      <p class="title-article">JavaScript del lado del cliente</p>
      <p>En este libro, y en la web, verás el término "JavaScript del lado del cliente". El término es simplemente un sinónimo de JavaScript escrito para ejecutarse en un navegador web, y se contrapone al código "del lado del servidor", que se ejecuta en servidores web.</p>
      <p>Los dos "lados" se refieren a los dos extremos de la conexión de red que separan el servidor web y el navegador web, y el desarrollo de software para la web suele requerir que el código se escriba en ambos "lados". El lado del cliente y el lado del servidor también suelen llamarse "frontend" y "backend".</p>
    </article>
    <p>Las ediciones anteriores de este libro intentaban cubrir de forma exhaustiva todas las API de JavaScript definidas por los navegadores web y, como resultado, este libro era demasiado largo hace una década. El número y la complejidad de las API web no han dejado de crecer, y ya no creo que tenga sentido intentar abarcarlas todas en un solo libro. A partir de la séptima edición, mi objetivo es cubrir definitivamente el lenguaje JavaScript y proporcionar una introducción en profundidad al uso del lenguaje con Node y con los navegadores web. Este capítulo no puede cubrir todas las API web, pero presenta las más importantes con suficiente detalle como para que puedas empezar a usarlas de inmediato. Y, habiendo aprendido sobre las APIs principales cubiertas aquí, deberías ser capaz de coger nuevas APIs (como las resumidas en <a href="#15">§15.15</a>) cuando y si los necesita.</p>
    <p>Node tiene una única implementación y una única fuente autorizada de documentación. En cambio, las API web se definen por consenso entre los principales proveedores de navegadores web, y la documentación autorizada adopta la forma de una especificación destinada a los programadores de C++ que implementan la API, no a los programadores de JavaScript que la utilizarán. Afortunadamente, el proyecto "MDN web docs" de Mozilla es una fuente<sup>1</sup> fiable y completa de documentación sobre API web.</p>
    <article>
      <p class="title-article">API heredadas</p>
      <p>En los 25 años transcurridos desde el lanzamiento de JavaScript, los fabricantes de navegadores han ido añadiendo funciones y API para uso de los programadores. Muchas de esas API han quedado obsoletas. Entre ellas están:</p>
      <ul>
        <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
          <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
          <p>
            API propietarias que nunca se estandarizaron y/o nunca fueron implementadas por otros proveedores de navegadores. Internet Explorer de Microsoft definió muchas de estas API. Algunas (como la propiedad <codeinline>innerHTML</codeinline>) resultaron útiles y acabaron estandarizándose. Otros (como el método <codeinline>attachEvent()</codeinline>) llevan años obsoletos.
          </p>
        </li>
        <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
          <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
          <p>
            APIs ineficientes (como el método <codeinline>document.write()</codeinline>) que tienen un impacto tan severo en el rendimiento que su uso ya no se considera aceptable.
          </p>
        </li>
        <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
          <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
          <p>
            APIs obsoletas que hace tiempo que han sido sustituidas por nuevas APIs para conseguir lo mismo. Un ejemplo es <codeinline>document.bgColor</codeinline>, que se definió para permitir a Java Script establecer el color de fondo de un documento. Con la llegada de CSS, <codeinline>document.bgColor</codeinline> se convirtió en un pintoresco caso especial sin ningún propósito real.
          </p>
        </li>
        <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
          <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
          <p>
            API mal diseñadas que han sido sustituidas por otras mejores. En los inicios de la web, los comités de normalización definieron la API clave del Modelo de Objetos de Documento de forma agnóstica al lenguaje, de modo que la misma API pudiera utilizarse en programas Java para trabajar con documentos XML y en programas JavaScript para trabajar con documentos HTML. El resultado fue una API que no se adaptaba bien al lenguaje JavaScript y que tenía características que no interesaban especialmente a los programadores web. Se tardó décadas en recuperarse de aquellos primeros errores de diseño, pero los navegadores web actuales soportan un Modelo de Objetos de Documento muy mejorado.
          </p>
        </li>
      </ul>
      <p>Los vendedores de navegadores pueden necesitar dar soporte a estas APIs heredadas en un futuro previsible para asegurar la compatibilidad con versiones anteriores, pero ya no hay necesidad de que este libro las documente o de que tú aprendas sobre ellas. La plataforma web ha madurado y se ha estabilizado, y si eres un desarrollador web experimentado que recuerda la cuarta o quinta edición de este libro, entonces puede que tengas tanto conocimiento obsoleto que olvidar como nuevo material que aprender.</p>
    </article>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1 Conceptos básicos de programación web</h2>
    <p>Esta sección explica cómo se estructuran los programas JavaScript para la web, cómo se cargan en un navegador web, cómo obtienen la entrada, cómo producen la salida y cómo se ejecutan de forma asíncrona respondiendo a eventos.</p>
  </section>
  <section id="1-1">
    <h2>15.1.1 JavaScript en etiquetas HTML &lt;script></h2>
    <p>Los navegadores web muestran documentos HTML. Si desea que un navegador web ejecute código Java-Script, debe incluir (o hacer referencia a) ese código desde un documento HTML, y esto es lo que hace la etiqueta HTML <codeinline>&lt;script></codeinline>.</p>
    <p>El código JavaScript puede aparecer en línea dentro de un archivo HTML entre <codeinline>&lt;script></codeinline> y <codeinline>&lt;/script></codeinline>. He aquí, por ejemplo, un archivo HTML que incluye una etiqueta script con código JavaScript que actualiza dinámicamente un elemento del documento para que se comporte como un reloj digital:</p>
    <pre class="language-js">
    <code class="language-js">&lt;!DOCTYPE html>               &lt;!-- This is an HTML5 file -->
    &lt;html>                        &lt;!-- The root element -->
    &lt;head>                        &lt;!-- Title, scripts & styles can go here -->
    &lt;title>Digital Clock</title>
    &lt;style>                       /* Una hoja de estilos CSS para el reloj */
    #clock &lbrace;                      /*Los estilos se aplican al elemento con id="clock" */
      font: bold 24px sans-serif; /* Utilice una fuente grande y en negrita */
      background: #ddf;           /* sobre un fondo gris azulado claro. */
      padding: 15px;              /* Rodéalo con algo de espacio. */
      border: solid black 2px;    /* y un borde negro sólido */
      border-radius: 10px;        /* con esquinas redondeadas. */
    }
    &lt;/style>
    &lt;/head>
    &lt;body>             &lt;!-- El cuerpo contiene el contenido del documento. -->
    &lt;h1>Digital Clock</h1>  &lt;!-- Mostrar un título. -->
    &lt;span id="clock"></span>  &lt;!-- Insertaremos la hora en este elemento. -->
    &lt;script>
    // Define a function to display the current time
    function displayTime() &lbrace;
      let clock = document.querySelector("#clock"); // Obtener elemento con id="clock"
      let now = new Date();                         // Obtener la hora actual
      clock.textContent = now.toLocaleTimeString(); // Mostrar la hora en el reloj
    }
    displayTime()                   // Muestra la hora inmediatamente
    setInterval(displayTime, 1000); // Y luego actualízalo cada segundo.
    &lt;/script>
    &lt;/body>
    &lt;/html></code></pre>
    <p>Aunque el código JavaScript puede incrustarse directamente dentro de una etiqueta <codeinline>&lt;script></codeinline>, es más habitual utilizar el atributo <codeinline>src</codeinline> de la etiqueta <codeinline>&lt;script></codeinline> para especificar la URL (una URL absoluta o una URL relativa a la URL del archivo HTML que se muestra) de un archivo que contiene código JavaScript. Si sacáramos el código JavaScript de este archivo HTML y lo almacenáramos en su propio archivo <em>scripts/digital_clock.js</em>, entonces la etiqueta <codeinline>&lt;script></codeinline> podría hacer referencia a ese archivo de código de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">&lt;script src="scripts/digital_clock.js">&lt;/script></code></pre>
    <p>Un archivo JavaScript contiene JavaScript puro, sin etiquetas <codeinline>&lt;script></codeinline> ni ningún otro HTML. Por convención, los archivos de código JavaScript tienen nombres que terminan en <em>.js</em>.</p>
    <p>Una etiqueta <codeinline>&lt;script></codeinline> con el atributo <codeinline>src</codeinline> se comporta exactamente igual que si el contenido del archivo JavaScript especificado apareciera directamente entre las etiquetas <codeinline>&lt;script></codeinline> y <codeinline>&lt;/script></codeinline>. Tenga en cuenta que la etiqueta <codeinline>&lt;/script></codeinline> de cierre es necesaria en los documentos HTML incluso cuando se especifica el atributo <codeinline>src</codeinline>: HTML no admite la etiqueta <codeinline>&lt;script/></codeinline>.</p>
    <p>Utilizar el atributo <codeinline>src</codeinline> tiene una serie de ventajas:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Simplifica sus archivos HTML al permitirle eliminar de ellos grandes bloques de código Java-Script, es decir, ayuda a mantener separados el contenido y el comportamiento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando varias páginas web comparten el mismo código JavaScript, el uso del atributo <codeinline>src</codeinline> permite mantener una sola copia de ese código, en lugar de tener que editar cada archivo HTML cuando cambia el código.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si más de una página comparte un archivo de código JavaScript, sólo tendrá que descargarlo una vez la primera página que lo utilice; las siguientes podrán recuperarlo de la caché del navegador.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Dado que el atributo <codeinline>src</codeinline> toma como valor una URL arbitraria, un programa JavaScript o una página web de un servidor web pueden emplear código exportado por otros servidores web. Gran parte de la publicidad en Internet se basa en este hecho.
        </p>
      </li>
    </ul>
    <p class="title-article text-left">Módulos</p>
    <p><a href="capitulo-10#3">§10.3</a> documenta los módulos JavaScript y cubre sus directivas <codeinline>import</codeinline> y <codeinline>export</codeinline>. Si ha escrito su programa JavaScript utilizando módulos (y no ha utilizado una herramienta de agrupación de código para combinar todos sus módulos en un único archivo JavaScript no modular), debe cargar el módulo de nivel superior de su programa con una directiva <codeinline>&lt;script></codeinline> que tenga un atributo <codeinline>type="module"</codeinline>. Si haces esto, el módulo que especifiques se cargará, y todos los módulos que importe se cargarán, y (recursivamente) todos los módulos que importen se cargarán. Para más información, véase <a href="capitulo-10#3-5">§10.3.5</a>.</p>
    <p class="title-article text-left">Especificación del tipo de script</p>
    <p>En los primeros días de la web, se pensaba que los navegadores podrían implementar algún día lenguajes distintos de JavaScript, y los programadores añadían atributos como <codeinline>language="javascript"</codeinline> y <codeinline>type="application/javascript"</codeinline> a sus etiquetas <codeinline>&lt;script></codeinline>. Esto es completamente innecesario. JavaScript es el lenguaje por defecto (y el único) de la web. El atributo language está obsoleto, y sólo hay dos razones para usar un atributo <codeinline>type</codeinline> en una etiqueta <codeinline>&lt;script></codeinline>:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Para especificar que el script es un módulo
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Para incrustar datos en una página web sin mostrarlos (véase <a href="#3-4">§15.3.4</a>)
        </p>
      </li>
    </ul>
    <p class="title-article text-left">Cuándo se ejecutan los scripts: async y diferido</p>
    <p>Cuando JavaScript se incorporó por primera vez a los navegadores web, no existía una API para recorrer y manipular la estructura y el contenido de un documento ya renderizado. La única forma en que el código JavaScript podía afectar al contenido de un documento era generando ese contenido sobre la marcha mientras el documento estaba en proceso de carga. Para ello utilizando el método <codeinline>document.write()</codeinline> para inyectar texto HTML en el documento en la ubicación del script.</p>
    <p>El uso de <codeinline>document.write()</codeinline> ya no se considera un buen estilo, pero el hecho de que sea posible significa que cuando el analizador HTML encuentra un elemento <codeinline>&lt;script></codeinline>, debe, por defecto, ejecutar el script sólo para asegurarse de que no produce ninguna salida HTML antes de que pueda reanudar el análisis y la representación del documento. Esto puede ralentizar drásticamente el análisis y la representación de la página web.</p>
    <p>Afortunadamente, este modo de ejecución de scripts <em>síncrono</em> o de <em>bloqueo</em> por defecto no es la única opción. La etiqueta <codeinline>&lt;script></codeinline> puede tener atributos <codeinline>defer</codeinline> y <codeinline>async</codeinline>, que hacen que los scripts se ejecuten de forma diferente. Se trata de atributos booleanos: no tienen valor; sólo tienen que estar presentes en la etiqueta <codeinline>&lt;script></codeinline>. Ten en cuenta que estos atributos sólo son significativos cuando se utilizan junto con el atributo <codeinline>src</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">&lt;script defer src="deferred.js">&lt;/script>
    &lt;script async src="async.js">&lt;/script></code></pre>
    <p>Tanto el atributo <codeinline>defer</codeinline> como el <codeinline>async</codeinline> son formas de indicar al navegador que el script enlazado no utiliza <codeinline>document.write()</codeinline> para generar la salida HTML, y que el navegador, por lo tanto, puede continuar analizando y renderizando el documento mientras descarga el script. El atributo <codeinline>defer</codeinline> hace que el navegador aplace la ejecución del script hasta que el documento haya sido completamente cargado y analizado y esté listo para ser manipulado. El atributo <codeinline>async</codeinline> hace que el navegador ejecute el script lo antes posible, pero no bloquea el análisis del documento mientras se descarga el script. Si una etiqueta <codeinline>&lt;script></codeinline> tiene ambos atributos, el atributo <codeinline>async</codeinline> tiene preferencia.</p>
    <p>Tenga en cuenta que los scripts diferidos se ejecutan en el orden en que aparecen en el documento. Los scripts asíncronos se ejecutan a medida que se cargan, lo que significa que pueden ejecutarse fuera de orden.</p>
    <p>Los scripts con el atributo <codeinline>type="module"</codeinline> se ejecutan, por defecto, después de que el documento se haya cargado, como si tuvieran el atributo <codeinline>defer</codeinline>. Puedes anular este valor por defecto con el atributo <codeinline>async</codeinline>, que hará que el código se ejecute tan pronto como el módulo y todas sus dependencias se hayan cargado.</p>
    <p>Una alternativa sencilla a los atributos <codeinline>async</codeinline> y <codeinline>defer</codeinline> -especialmente para el código que se incluye directamente en el HTML- es simplemente colocar tus scripts al final del archivo HTML. De esta forma, el script puede ejecutarse sabiendo que el contenido del documento que le precede ha sido analizado y está listo para ser manipulado.</p>
    <p class="title-article text-left">Carga de guiones a petición</p>
    <p>A veces, puede tener código JavaScript que no se utiliza cuando un documento se carga por primera vez y sólo se necesita si el usuario realiza alguna acción como pulsar un botón o abrir un menú. Si está desarrollando su código utilizando módulos, puede cargar un módulo bajo demanda con <codeinline>import()</codeinline>, como se describe en <a href="capitulo-10#3-6">§10.3.6</a>.</p>
    <p>Si no utiliza módulos, puede cargar un archivo de JavaScript bajo demanda simplemente añadiendo una etiqueta <codeinline>&lt;script></codeinline> a su documento cuando desee que se cargue el script:</p>
    <pre class="language-js">
    <code class="language-js">// Cargar y ejecutar de forma asincrónica un script desde una URL específica
    // Devuelve una promesa que se resuelve cuando se ha cargado el script.
    function importScript(url) &lbrace;
      return new Promise((resolve, reject) => &lbrace;
        let s = document.createElement("script"); // Create a &lt;script> element
        s.onload = () => &lbrace; resolve(); };          // Resolver la promesa cuando se carga
        s.onerror = (e) => &lbrace; reject(e); };        // Rechazar en caso de fallo
        s.src = url;                              // Establecer la URL del script
        document.head.append(s);                  // Agregar &lt;script> al documento
      });
    }</code></pre>
    <p>Esta función <codeinline>importScript()</codeinline> utiliza las API del DOM (<a href="#3">§15.3</a>) para crear una nueva etiqueta <codeinline>&lt;script></codeinline> y añadirla al documento <codeinline>&lbrace;head></codeinline>. Y utiliza manejadores de eventos (<a href="#2">§15.2</a>) para determinar cuando el script se ha cargado correctamente o cuando la carga ha fallado.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.2 El modelo de objetos del documento</h2>
    <p>Uno de los objetos más importantes en la programación JavaScript del lado del cliente es el objeto Document, que representa el documento HTML que se muestra en una ventana o pestaña del navegador. La API para trabajar con documentos HTML se conoce como el Modelo de Objetos de Documento, o DOM, y se cubre en detalle en <a href="#3">§15.3</a>. Pero el DOM es tan importante para la programación JavaScript del lado del cliente que merece ser introducido aquí.</p>
    <p>Los documentos HTML contienen elementos HTML anidados unos dentro de otros, formando un árbol. Considere el siguiente documento HTML sencillo:</p>
    <pre class="language-js">
    <code class="language-js">&lt;html>
      &lt;head>
        &lt;title>Sample Document&lt;/title>
      &lt;/head>
      &lt;body>
        &lt;h1>An HTML Document&lt;/h1>
        &lt;p>This is a &lt;i>simple&lt;/i> document.
      &lt;/body>
    &lt;/html></code></pre>
    <p>La etiqueta <codeinline>&lt;html></codeinline> de nivel superior contiene las etiquetas <codeinline>&lt;head></codeinline> y <codeinline>&lt;body></codeinline>. La etiqueta <codeinline>&lt;head></codeinline> contiene un <codeinline>&lt;title></codeinline>. Y la etiqueta <codeinline>&lt;body></codeinline> contiene las etiquetas <codeinline>&lt;h1></codeinline> y <codeinline>&lt;p></codeinline>. Las etiquetas <codeinline>&lt;title></codeinline> y <codeinline>&lt;h1></codeinline> contienen cadenas de texto, y la etiqueta <codeinline>&lt;p></codeinline> contiene dos cadenas de texto con una etiqueta <codeinline>&lt;i></codeinline> entre ellas.</p>
    <p>La API DOM refleja la estructura de árbol de un documento HTML. A cada etiqueta HTML del documento le corresponde un objeto Elemento de JavaScript, y a cada segmento de texto del documento le corresponde un objeto Texto. Los objetos Element y las clases de texto, así como la propia clase Document, son todas subclases de la clase más general Node, y los objetos Node están organizados en una estructura de árbol que JavaScript puede consultar y recorrer utilizando la API DOM. La representación DOM de este documento es el árbol que se muestra en la <a href="#figure15-1">Figura 15-1</a>.</p>
    <figure id="figure15-1">
      <img src="/public/javascript/capitulo-15/figure15-1.avif" alt="imagen de consola">
      <figcaption>Figura 15-1. Representación en árbol de un documento HTML</figcaption>
    </figure>
    <p>Si aún no está familiarizado con las estructuras de árbol en programación informática, es útil saber que toman prestada la terminología de los árboles genealógicos. El nodo situado justo encima de un nodo es su <em>parent</em>. Los nodos situados un nivel por debajo de otro nodo son sus <em>children</em>. Los nodos del mismo nivel y con el mismo padre son <em>hermanos</em>. El conjunto de nodos situados cualquier número de niveles por debajo de otro nodo son los <em>descendientes</em> de ese nodo. Y el padre, el abuelo y todos los demás nodos situados por encima de un nodo son los <em>antepasados</em> de ese nodo.</p>
    <p>La API DOM incluye métodos para crear nuevos nodos Element y Text, y para insertarlos en el documento como hijos de otros objetos Element. También hay métodos para mover elementos dentro del documento y para eliminarlos por completo. Mientras que una aplicación del lado del servidor puede producir una salida de texto plano escribiendo cadenas con <codeinline>console.log()</codeinline>, una aplicación JavaScript del lado del cliente puede producir una salida HTML formateada construyendo o manipulando el documento del árbol de documentos utilizando la API DOM.</p>
    <p>Hay una clase de JavaScript que corresponde a cada tipo de etiqueta HTML, y cada aparición de la etiqueta en un documento está representada por una instancia de la clase. La etiqueta <codeinline>&lt;body></codeinline>, por ejemplo, está representada por una instancia de HTMLBodyElement, y una etiqueta <codeinline>&lt;table></codeinline> está representada por una instancia de HTMLTableElement. Los objetos elemento de JavaScript tienen propiedades que corresponden a los atributos HTML de las etiquetas. En</p>
    <p>Por ejemplo, las instancias de HTMLImageElement, que representan etiquetas <codeinline>&lt;img></codeinline>, tienen una propiedad <codeinline>src</codeinline> que corresponde al atributo <codeinline>src</codeinline> de la etiqueta. El valor inicial de la propiedad <codeinline>src</codeinline> es el valor del atributo que aparece en la etiqueta HTML, y establecer esta propiedad con JavaScript cambia el valor del atributo HTML (y hace que el navegador cargue y muestre una nueva imagen). La mayoría de las clases de elementos de JavaScript se limitan a reflejar los atributos de una etiqueta HTML, pero algunas definen métodos adicionales. Las clases HTMLAu- dioElement y HTMLVideoElement, por ejemplo, definen métodos como <codeinline>play()</codeinline> y <codeinline>pause()</codeinline> para controlar la reproducción de archivos de audio y vídeo.</p>
  </section>
  <section id="1-3">
    <h2>15.1.3 El objeto global en los navegadores web</h2>
    <p>Existe un objeto global por cada ventana o pestaña del navegador (<a href="capitulo-3#7">§3.7</a>). Todo el código JavaScript (excepto el código que se ejecuta en hilos de trabajo; véase <a href="#13">§15.13</a>) que se ejecuta en esa ventana comparte este único objeto global. Esto es así independientemente de cuántos scripts o módulos haya en el documento: todos los scripts y módulos de un documento comparten un único objeto global; si un script define una propiedad en ese objeto, esa propiedad es visible también para todos los demás scripts.</p>
    <p>El objeto global es donde se define la biblioteca estándar de JavaScript: la función <codeinline>parseInt()</codeinline>, el objeto Math, la clase Set, etc. En los navegadores web, el objeto global también contiene los principales puntos de entrada de varias API web. Por ejemplo, la propiedad <codeinline>document</codeinline> representa el documento mostrado actualmente, el método <codeinline>fetch()</codeinline> realiza peticiones de red HTTP y el constructor <codeinline>Audio()</codeinline> permite a los programas JavaScript reproducir sonidos.</p>
    <p>En los navegadores web, el objeto global tiene una doble función: además de definir tipos y funciones incorporadas, también representa la ventana actual del navegador web y define propiedades como <codeinline>history</codeinline> (<a href="capitulo-15#10-2">§15.10.2</a>), que representa el historial de navegación de la ventana, e <codeinline>innerWidth</codeinline>, que contiene el ancho de la ventana en píxeles. Una de las propiedades de este objeto global se llama <codeinline>window</codeinline>, y su valor es el propio objeto global. Esto significa que puedes simplemente escribir <codeinline>window</codeinline> para referirte al objeto global en tu código del lado del cliente. Cuando se utilizan características específicas de la ventana, a menudo es una buena idea incluir un prefijo <codeinline>window.</codeinline>: <codeinline>window.innerWidth</codeinline> es más claro que <codeinline>innerWidth</codeinline>, por ejemplo.</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.4 Los scripts comparten un espacio de nombres</h2>
    <p>Con los módulos, las constantes, variables, funciones y clases definidas en el nivel superior (es decir, fuera de cualquier definición de función o clase) del módulo son privadas para el módulo a menos que se exporten explícitamente, en cuyo caso, pueden ser importadas selectivamente por otros módulos. (Tenga en cuenta que esta propiedad de los módulos también es respetada por las herramientas de agrupación de código).</p>
    <p>Sin embargo, con los scripts que no son módulos, la situación es completamente diferente. Si el código de nivel superior de un script define una constante, variable, función o clase, esa declaración será visible para todos los demás scripts del mismo documento. Si un script define una función <codeinline>f()</codeinline> y otro script define una clase <codeinline>c</codeinline>, entonces un tercer script puede invocar la función e instanciar la clase sin tener que realizar ninguna acción para importarlos. Por lo tanto, si no utiliza módulos, los scripts independientes de su documento comparten un único espacio de nombres y se comportan como si formaran parte de un único script mayor. Esto puede ser conveniente para programas pequeños, pero la necesidad de evitar conflictos de nombres puede volverse problemática para programas más grandes, especialmente cuando algunos de los scripts son bibliotecas de terceros.</p>
    <p>Las declaraciones <codeinline>var</codeinline> y <codeinline>function</codeinline> en el nivel superior crean propiedades en el objeto global compartido. Si un script define una función de nivel superior <codeinline>f()</codeinline>, entonces otro script en el mismo documento puede invocar esa función como <codeinline>f()</codeinline> o como <codeinline>window.f()</codeinline>. Por otro lado, las declaraciones <codeinline>const</codeinline>, <codeinline>let</codeinline> y <codeinline>class</codeinline> de ES6, cuando se utilizan en el nivel superior, no crean propiedades en el objeto global. Sin embargo, siguen estando definidas en un espacio de nombres compartido: si un script define una clase <codeinline>C</codeinline>, otros scripts podrán crear instancias de esa clase con <codeinline>new C()</codeinline>, pero no con <codeinline>new window.C()</codeinline>.</p>
    <p>En resumen: en los módulos, las declaraciones de nivel superior se aplican al módulo y pueden exportarse explícitamente. En los scripts que no son módulos, sin embargo, las declaraciones de nivel superior se refieren al documento que los contiene, y las declaraciones son compartidas por todos los scripts del documento. Las declaraciones <codeinline>var</codeinline> y <codeinline>function</codeinline> más antiguas se comparten a través de las propiedades del objeto global. Las declaraciones <codeinline>const</codeinline>, <codeinline>let</codeinline> y <codeinline>class</codeinline> más recientes también se comparten y tienen el mismo ámbito de documento, pero no existen como propiedades de ningún objeto al que tenga acceso el código JavaScript.</p>
  </section>
  <section id="1-5">
    <h2>15.1.5 Ejecución de programas JavaScript</h2>
    <p>No existe una definición formal de <em>programa</em> en JavaScript del lado del cliente, pero podemos decir que un programa JavaScript consiste en todo el código JavaScript de un documento o al que se hace referencia desde él. Estas partes separadas de código comparten un único objeto Window global, que les da acceso al mismo objeto Document subyacente que representa el documento HTML. Los scripts que no son módulos comparten además un espacio de nombres de nivel superior.</p>
    <p>Si una página web incluye un marco incrustado (utilizando el elemento <codeinline>&lt;iframe></codeinline>), el código Java-Script en el documento incrustado tiene un objeto global y un objeto Documento diferentes del código en el documento incrustado, y puede considerarse un programa JavaScript independiente. Recuerde, sin embargo, que no existe una definición formal de cuáles son los límites de un programa JavaScript. Si el documento contenedor y el documento contenido se cargan desde el mismo servidor, el código en un documento puede interactuar con el código en el otro, y puede tratarlos como dos partes interactuantes de un único programa, si lo desea. En <a href="capitulo-15#13-6">§15.13.6</a> se explica cómo un programa JavaScript puede enviar y recibir mensajes hacia y desde el código JavaScript que se ejecuta en un <codeinline>&lt;iframe></codeinline>.</p>
    <p>La ejecución de un programa JavaScript puede dividirse en dos fases. En la primera fase, se carga el contenido del documento y se ejecuta el código de los elementos <codeinline>&lt;script></codeinline> (tanto scripts en línea como scripts externos). Por lo general, los scripts se ejecutan en el orden en que aparecen en el documento, aunque este orden predeterminado puede modificarse mediante los atributos <codeinline>async</codeinline> y <codeinline>defer</codeinline> que hemos descrito. El código JavaScript de cualquier script se ejecuta de arriba abajo, sujeto, por supuesto, a los condicionales, bucles y otras sentencias de control de JavaScript. Algunos scripts no <em>hacen</em> realmente nada durante esta primera fase y se limitan a definir funciones y clases para su uso en la segunda fase. Otros scripts pueden realizar un trabajo importante durante la primera fase y no hacer nada en la segunda. Imagina un script al final de un documento que encuentra todas las etiquetas <codeinline>&lt;h1></codeinline> y <codeinline>&lt;h2></codeinline> en el documento y modifica el documento generando e insertando una tabla de contenidos al principio del documento. Esto podría hacerse completamente en la primera fase. (Véase en <a href="#3-6">§15.3.6</a> un ejemplo que hace exactamente esto).</p>
    <p>Una vez cargado el documento y ejecutados todos los scripts, la ejecución de JavaScript entra en su segunda fase. Esta fase es asíncrona y dirigida por eventos. Si un script va a participar en esta segunda fase, entonces una de las cosas que debe haber hecho durante la primera fase es registrar al menos un manejador de eventos u otra función callback que será invocada de forma asíncrona. Durante esta segunda fase dirigida por eventos, el navegador web invoca funciones manejadoras de eventos y otras retrollamadas en respuesta a eventos que ocurren asincrónicamente. Los manejadores de eventos se invocan más comúnmente en respuesta a la entrada del usuario (clics del ratón, pulsaciones de teclas, etc.), pero también pueden ser activados por la actividad de la red, la carga de documentos y recursos, el tiempo transcurrido, o errores en el código JavaScript. Los eventos y los controladores de eventos se describen con detalle en <a href="#2">§15.2</a>.</p>
    <p>Algunos de los primeros eventos que se producen durante la fase dirigida por eventos son los eventos "DOMCon- tentLoaded" y "load". "DOMContentLoaded" se activa cuando el documento HTML ha sido completamente cargado y analizado. El evento "load" se activa cuando todos los recursos externos del documento -como las imágenes- también se han cargado por completo. Los programas Java Script a menudo utilizan uno de estos eventos como disparador o señal de inicio. Es común ver programas cuyos scripts definen funciones pero no realizan otra acción que registrar una función manejadora de eventos para ser activada por el evento "load" al comienzo de la fase de ejecución dirigida por eventos. Es este manejador de eventos "load" el que manipula el documento y hace lo que se supone que debe hacer el programa. Tenga en cuenta que es común en la programación JavaScript que una función manejadora de eventos como el manejador de eventos "load" descrito aquí registre otros manejadores de eventos.</p>
    <p>La fase de carga de un programa JavaScript es relativamente corta: idealmente menos de un segundo. Una vez cargado el documento, la fase basada en eventos dura mientras el navegador muestra el documento. Dado que esta fase es asíncrona y basada en eventos, puede haber largos periodos de inactividad en los que no se ejecute JavaScript, interrumpidos por ráfagas de actividad provocadas por eventos del usuario o de la red. A continuación trataremos estas dos fases con más detalle.</p>
    <p class="title-article text-left">Modelo de subprocesamiento de JavaScript en el cliente</p>
    <p>JavaScript es un lenguaje monohilo, y la ejecución monohilo simplifica mucho la programación: puede escribir código con la seguridad de que nunca se ejecutarán dos controladores de eventos al mismo tiempo. Puedes manipular el contenido de un documento sabiendo que ningún otro hilo está intentando modificarlo al mismo tiempo, y nunca tendrás que preocuparte por bloqueos, puntos muertos o condiciones de carrera al escribir código Java-Script.</p>
    <p>La ejecución monohilo significa que los navegadores dejan de responder a las entradas del usuario mientras se ejecutan los scripts y los controladores de eventos. Esto supone una carga para los programadores de JavaScript: significa que los scripts de JavaScript y los controladores de eventos no deben ejecutarse durante demasiado tiempo. Si un script realiza una tarea de cálculo intensivo, provocará un retraso en la carga del documento, y el usuario no verá el contenido del documento hasta que el script finalice. Si un manejador de eventos realiza una tarea computacionalmente intensiva, el navegador puede dejar de responder, posiblemente haciendo que el usuario piense que se ha bloqueado.</p>
    <p>La plataforma web define una forma controlada de concurrencia llamada "web worker". Un web worker es un hilo en segundo plano para realizar tareas de cálculo intensivo sin congelar la interfaz de usuario. El código que se ejecuta en un hilo web worker no tiene acceso al contenido del documento, no comparte ningún estado con el hilo principal o con otros workers, y sólo puede comunicarse con el hilo principal y con otros workers de a través de eventos de mensajes asíncronos, por lo que la concurrencia no es detectable para el hilo principal, y los web workers no alteran el modelo básico de ejecución de un solo hilo de los programas JavaScript. Véase <a href="capitulo-15#13">§15.13</a> para más detalles sobre el mecanismo de threading seguro de la web.</p>
    <p id="javascritp-cliente" class="title-article text-left">Línea de tiempo JavaScript del lado del cliente</p>
    <p>Ya hemos visto que los programas JavaScript comienzan en una fase de ejecución de secuencias de comandos y luego pasan a una fase de gestión de eventos. Estas dos fases pueden dividirse en los siguientes pasos:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El navegador web crea un objeto Document y comienza a analizar la página web, añadiendo objetos Element y nodos Text al documento a medida que analiza los elementos HTML y su contenido textual. La propiedad <codeinline>document.readyState</codeinline> tiene el valor "loading" en esta etapa.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando el analizador HTML encuentra una etiqueta <codeinline>&lt;script></codeinline> que no tiene ninguno de los atributos <codeinline>async</codeinline>, <codeinline>defer</codeinline> o <codeinline>type="module"</codeinline>, añade esa etiqueta script al documento y, a continuación, ejecuta el script. El script se ejecuta de forma sincrónica, y el analizador HTML hace una pausa mientras el script se descarga (si es necesario) y se ejecuta. Un script como este puede usar <codeinline>document.write()</codeinline> para insertar texto en el flujo de entrada, y ese texto se convertirá en parte del documento cuando el analizador se reanude. Un script a menudo simplemente define funciones y registra manejadores de eventos para su uso posterior, pero puede recorrer y manipular el árbol del documento tal y como existe en ese momento. Es decir, los scripts no modulares que no tienen un atributo <codeinline>async</codeinline> o <codeinline>defer</codeinline> pueden ver su propia etiqueta <codeinline>&lt;script></codeinline> y el contenido del documento que le precede.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando el analizador encuentra un elemento <codeinline>&lt;script></codeinline> con el atributo <codeinline>async</codeinline> activado, comienza a descargar el texto del script (y si el script es un módulo, también descarga de forma recurrente todas las dependencias del script) y continúa analizando el documento. El script se ejecutará lo antes posible una vez descargado, pero el analizador no se detiene a esperar a que se descargue. Los scripts asíncronos no deben utilizar el método <codeinline>document.write()</codeinline>. Pueden ver su propio <codeinline>&lt;script></codeinline> y todo el contenido del documento que le precede, y puede o no tener acceso a contenido adicional del documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando el documento está completamente analizado, la propiedad <codeinline>document.readyState</codeinline> cambia a "interactive".
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cualquier script que tenga el atributo <codeinline>defer</codeinline> (junto con cualquier script de módulo que no tenga un atributo async) se ejecuta en el orden en el que aparece en el documento. Los scripts asíncronos también pueden ejecutarse en este momento. Los scripts diferidos tienen acceso al documento completo y no deben utilizar el método <codeinline>document.write()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El navegador lanza un evento "DOMContentLoaded" sobre el objeto Document. Esto marca la transición de la fase síncrona de ejecución de scripts a la fase asíncrona, dirigida por eventos, de ejecución del programa. Tenga en cuenta, sin embargo, que todavía puede haber scripts <codeinline>async</codeinline> que aún no se han ejecutado en este punto.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El documento está completamente analizado en este punto, pero el navegador aún puede estar esperando a que se cargue contenido adicional, como imágenes. Cuando todo ese contenido termina de cargarse, y cuando todos los scripts <codeinline>async</codeinline> se han cargado y ejecutado, la propiedad <codeinline>document.readyState</codeinline> cambia a "complete" y el navegador web lanza un evento "load" en el objeto Window.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          A partir de este punto, los manejadores de eventos se invocan de forma asíncrona en respuesta a eventos de entrada de usuario, eventos de red, vencimiento de temporizadores, etc.
        </p>
      </li>
    </ul>
  </section>
  <section id="1-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.6 Entrada y salida de programas</h2>
    <p>Como cualquier programa, los programas JavaScript del lado del cliente procesan datos de entrada para producir datos de salida. Hay una gran variedad de entradas disponibles:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El contenido del propio documento, al que el código JavaScript puede acceder con la API DOM (<a href="#3">§15.3</a>).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Entradas del usuario, en forma de eventos, como clics del ratón (o toques en la pantalla táctil) en elementos HTML <codeinline>&lt;button></codeinline>, o texto introducido en elementos HTML <codeinline>&lt;textarea></codeinline>, por ejemplo. En <a href="#2">§15.2</a> se muestra cómo los programas JavaScript pueden responder a este tipo de eventos de usuario.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La URL del documento que se muestra está disponible para JavaScript del lado del cliente como <codeinline>document.URL</codeinline>. Si pasas esta cadena al constructor <codeinline>URL()</codeinline> (<a href="capitulo-11#9">§11.9</a>), puedes acceder fácilmente a las secciones path, query y fragment de la URL.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El contenido de la cabecera de petición HTTP "Cookie" está disponible para el código del cliente como <codeinline>document.cookie</codeinline>. Las cookies suelen ser utilizadas por el código del servidor para mantener las sesiones de usuario, pero el código del cliente también puede leerlas (y escribirlas) si es necesario. Véase <a href="#12-2">§15.12.2</a> para más detalles.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La propiedad global <codeinline>navigator</codeinline> proporciona acceso a información sobre el navegador web, el sistema operativo sobre el que se ejecuta y las capacidades de cada uno. Por ejemplo, <codeinline>navigator.userAgent</codeinline> es una cadena que identifica al navegador web, <codeinline>navigator.language</codeinline> es el idioma preferido del usuario, y <codeinline>navigator.hardwareConcurrency</codeinline> devuelve el número de CPUs lógicas disponibles para el navegador web. Del mismo modo, la propiedad global <codeinline>screen</codeinline> proporciona acceso al tamaño de la pantalla del usuario a través de las propiedades <codeinline>screen.width</codeinline> y <codeinline>screen.height</codeinline>. En cierto sentido, estos objetos <codeinline>navigator</codeinline> y <codeinline>screen</codeinline> son para los navegadores web lo que las variables de entorno son para los programas Node.
        </p>
      </li>
    </ul>
    <p>El JavaScript del lado del cliente normalmente produce resultados, cuando es necesario, manipulando el documento HTML con la API DOM (<a href="#3">§15.3</a>) o usando un framework de alto nivel como React o Angular para manipular el documento. El código del lado del cliente también puede usar <codeinline>console.log()</codeinline> y métodos relacionados (<a href="capitulo-11#8">§11.8</a>) para producir salida. Pero esta salida sólo es visible en la consola del desarrollador web, por lo que es útil cuando se depura, pero no para la salida visible por el usuario.</p>
  </section>
  <section id="1-7">
    <h2>15.1.7 Errores del programa</h2>
    <p>A diferencia de las aplicaciones (como las aplicaciones Node) que se ejecutan directamente sobre el sistema operativo, los programas JavaScript en un navegador web no pueden realmente "bloquearse". Si se produce una excepción mientras se ejecuta su programa JavaScript, y si no tiene una sentencia <codeinline>catch</codeinline> para manejarla, se mostrará un mensaje de error en la consola del desarrollador, pero cualquier manejador de eventos que se haya registrado seguirá ejecutándose y respondiendo a los eventos.</p>
    <p>Si desea definir un manejador de errores de último recurso que se invoque cuando se produzca este tipo de excepción no capturada, establezca la propiedad <codeinline>onerror</codeinline> del objeto Window en una función manejadora de errores. Cuando una excepción no detectada se propaga por toda la cadena y se va a mostrar un mensaje de error en la consola del desarrollador, se invocará a la función <codeinline>window.onerror</codeinline> con tres argumentos de cadena. El primer argumento de <codeinline>window.onerror</codeinline> es un mensaje que describe el error. El segundo argumento es una cadena que contiene la URL del código JavaScript que causó el error. El tercer argumento es el número de línea del documento en el que se ha producido el error. Si el manejador <codeinline>onerror</codeinline> devuelve <codeinline>true</codeinline>, le dice al navegador que el manejador ha manejado el error y que no es necesaria ninguna otra acción-en otras palabras, el navegador no debe mostrar su propio mensaje de error.</p>
    <p>Cuando una Promise es rechazada y no hay una función <codeinline>.catch()</codeinline> para manejarla, esa es una situación muy parecida a una excepción no manejada: un error no anticipado o un error lógico en tu programa. Puedes detectar esto definiendo una función <codeinline>window.onunhandledrejection</codeinline> o usando <codeinline>window.addEventListener()</codeinline> para registrar un manejador de eventos "unhandledrejection". El objeto de evento pasado a este manejador tendrá una propiedad <codeinline>promise</codeinline> cuyo valor es el objeto Promise que rechazó y una propiedad <codeinline>reason</codeinline> cuyo valor es lo que se habría pasado a una función <codeinline>.catch()</codeinline>. Al igual que con los manejadores de error descritos anteriormente, si se llama a <codeinline>preventDefault()</codeinline> en el objeto de evento de rechazo no manejado, se considerará manejado y no causará un mensaje de error en la consola del desarrollador.</p>
    <p>A menudo no es necesario definir manejadores <codeinline>onerror</codeinline> o <codeinline>onunhandledrejection</codeinline>, pero puede ser bastante útil como mecanismo de telemetría si quieres informar de errores del lado del cliente al servidor (usando la función <codeinline>fetch()</codeinline> para hacer una petición HTTP POST, por ejemplo) para que puedas obtener información sobre errores inesperados que ocurren en los navegadores de tus usuarios.</p>
  </section>
  <section id="1-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.8 El modelo de seguridad web</h2>
    <p>El hecho de que las páginas web puedan ejecutar código JavaScript arbitrario en su dispositivo personal tiene claras implicaciones de seguridad, y los proveedores de navegadores han trabajado duro para equilibrar dos objetivos contrapuestos:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Definición de potentes API del lado del cliente para crear aplicaciones web útiles
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Evitar que códigos maliciosos lean o alteren sus datos, comprometan su privacidad, le estafen o le hagan perder el tiempo.
        </p>
      </li>
    </ul>
    <p>Las subsecciones siguientes ofrecen una rápida visión general de las restricciones y problemas de seguridad que, como programador de JavaScript, debe conocer.</p>
    <p class="title-article text-left">Lo que JavaScript no puede hacer</p>
    <p>La primera línea de defensa de los navegadores web contra el código malicioso es que simplemente no admiten ciertas capacidades. Por ejemplo, JavaScript del lado del cliente no proporciona ninguna forma de escribir o eliminar archivos arbitrarios o listar directorios arbitrarios en el ordenador cliente. Esto significa que un programa JavaScript no puede borrar datos ni plantar virus.</p>
    <p>Del mismo modo, JavaScript del lado del cliente no tiene capacidades de red de propósito general. Un programa JavaScript del lado del cliente puede hacer peticiones HTTP (<a href="#11-1">§15.11.1</a>). Y otro estándar, conocido como WebSockets (<a href="#11-3">§15.11.3</a>), define una API tipo socket para comunicarse con servidores especializados. Pero ninguna de estas API permite el acceso sin intermediarios a la red. Los clientes y servidores de Internet de propósito general no pueden escribirse en JavaScript del lado del cliente.</p>
    <p id="politica-del-mismo-origen" class="title-article text-left">La política del mismo origen</p>
    <p>La <em>política del mismo</em> origen es una restricción de seguridad radical sobre el contenido web con el que puede interactuar el código Java-Script. Normalmente entra en juego cuando una página web incluye <codeinline>&lt;iframe></codeinline>. En este caso, la política del mismo origen rige las interacciones del código JavaScript de un marco con el contenido de otros marcos. En concreto, un script sólo puede leer las propiedades de ventanas y documentos que tengan el mismo origen que el documento que contiene el script.</p>
    <p>El origen de un documento se define como el protocolo, el host y el puerto de la URL desde la que se ha cargado el documento. Los documentos cargados desde distintos servidores web tienen orígenes diferentes. Los documentos cargados a través de diferentes puertos del mismo host tienen orígenes diferentes. Y un documento cargado con el protocolo <codeinline>http:</codeinline> tiene un origen distinto que uno cargado con el protocolo <codeinline>https:</codeinline>, aunque procedan del mismo servidor web. Los navegadores suelen tratar cada <codeinline>file:</codeinline> URL como un origen separado, lo que significa que si está trabajando en un programa que muestra más de un documento del mismo servidor, es posible que no pueda probarlo localmente utilizando <codeinline>file:</codeinline> URL y tendrás que ejecutar un servidor web estático durante el desarrollo.</p>
    <p>Es importante entender que el origen del script en sí no es relevante para la política del mismo origen: lo que importa es el origen del documento en el que está incrustado el script. Supongamos, por ejemplo, que un script alojado en el host A se incluye (utilizando la propiedad <codeinline>src</codeinline> de un elemento <codeinline>&lt;script></codeinline>) en una página web servida por el host B. El origen de ese script es el host B, y el script tiene pleno acceso al contenido del documento que lo contiene. Si el documento contiene un <codeinline>&lt;iframe></codeinline> que contiene un segundo documento del host B, entonces el script también tiene acceso completo al contenido de ese segundo documento. Pero si el documento de nivel superior contiene otro <codeinline>&lt;iframe></codeinline> que muestra un documento del host C (o incluso uno del host A), entonces la política del mismo origen entra en vigor e impide que el script acceda a este documento anidado.</p>
    <p>La política del mismo origen también se aplica a las peticiones HTTP con scripts (véase <a href="#11-1">§15.11.1</a> ). El código Java Script puede hacer peticiones HTTP arbitrarias al servidor web desde el que se cargó el documento contenedor, pero no permite que los scripts se comuniquen con otros servidores web (a menos que esos servidores web opten por CORS, como describimos a continuación).</p>
    <p>La política del mismo origen plantea problemas en sitios web de gran tamaño que utilizan múltiples subdominios. Por ejemplo, los scripts con origen <em>orders.ejemplo.com</em> pueden necesitar leer propiedades de documentos en <em>ejemplo.com</em>. Para soportar sitios web multidominio de este tipo, los scripts pueden alterar su origen estableciendo <codeinline>document.domain</codeinline> a un sufijo de dominio. Así, un script con origen <a href="https://orders.example.com">https://orders.example.com</a> puede cambiar su origen a <a href="https://example.com">https://example.com</a> estableciendo <codeinline>document.domain</codeinline> como "ejemplo.com". Pero ese script no puede establecer <codeinline>document.domain</codeinline> a "pedidos.ejemplo", "amplio.com", o "com".</p>
    <p>La segunda técnica para relajar la política del mismo origen es el uso compartido de recursos entre orígenes, o CORS (Cross-Origin Resource Sharing), que permite a los servidores decidir qué orígenes están dispuestos a servir. CORS amplía HTTP con una nueva cabecera de petición <codeinline>Origin:</codeinline> y una nueva cabecera de respuesta <codeinline>Access-Control-Allow-Origin</codeinline>. Permite a los servidores utilizar una cabecera para enumerar explícitamente los orígenes que pueden solicitar un archivo o utilizar un comodín y permitir que un archivo sea solicitado por cualquier sitio. Los navegadores respetan estas cabeceras CORS y no relajan las restricciones del mismo origen a menos que estén presentes.</p>
    <p id="cross-site" class="title-article text-left">Secuencias de comandos en sitios cruzados</p>
    <p><em>Cross-site scripting</em>, o XSS, es una categoría de problemas de seguridad en los que un atacante inyecta etiquetas HTML o scripts en un sitio web. Los programadores de JavaScript del lado del cliente deben conocer y defenderse contra el cross-site scripting.</p>
    <p>Una página web es vulnerable al cross-site scripting si genera dinámicamente el contenido de un documento y basa ese contenido en datos enviados por el usuario sin haber "saneado" previamente esos datos eliminando de ellos cualquier etiqueta HTML incrustada. Como ejemplo trivial, considere la siguiente página web que utiliza JavaScript para saludar al usuario por su nombre:</p>
    <pre class="language-js">
    <code class="language-js">&lt;script>
    let name = new URL(document.URL).searchParams.get("name");
    document.querySelector('h1').innerHTML = "Hello " + name;
    &lt;/script></code></pre>
    <p>Este script de dos líneas extrae la entrada del parámetro de consulta "nombre" de la URL del documento. A continuación, utiliza la API DOM para inyectar una cadena HTML en la primera etiqueta <codeinline>&lt;h1></codeinline> del documento. Esta página está pensada para ser invocada con una URL como esta:</p>
    <pre class="language-js">
    http://www.example.com/greet.html?name=David</pre>
    <p>Cuando se utiliza así, muestra el texto "Hola David". Pero considere lo que ocurre cuando se invoca con este parámetro de consulta:</p>
    <pre class="language-js">
    name=%3Cimg%20src=%22x.png%22%20onload=%22alert(%27hacked%27)%22/%3E</pre>
    <p>Cuando se decodifican los parámetros de la URL, esta URL provoca que se inyecte el siguiente HTML en el documento:</p>
    <pre class="language-js">
    <code class="language-js">Hello &lt;img src="x.png" onload="alert('hacked')"/></code></pre>
    <p>Una vez cargada la imagen, se ejecuta la cadena de JavaScript del atributo <codeinline>onload</codeinline>. La función global <codeinline>alert()</codeinline> muestra un cuadro de diálogo modal. Un solo cuadro de diálogo es relativamente benigno, pero demuestra que la ejecución de código arbitrario es posible en este sitio porque muestra HTML sin desinfectar.</p>
    <p>Los ataques de secuencias de comandos entre sitios se llaman así porque hay más de un sitio implicado. El sitio B incluye un enlace especialmente diseñado (como el del ejemplo anterior) al sitio A. Si el sitio B puede convencer a los usuarios para que hagan clic en el enlace, serán conducidos al sitio A, pero ese sitio estará ejecutando código del sitio B. Ese código podría desfigurar la página o hacer que funcione mal. Y lo que es más peligroso, el código malicioso podría leer las cookies almacenadas por el sitio A (quizás números de cuenta u otra información de identificación personal) y enviar esos datos de vuelta al sitio B. El código inyectado podría incluso rastrear las pulsaciones de teclado del usuario y enviar esos datos de vuelta al sitio B.</p>
    <p>En general, la forma de prevenir los ataques XSS es eliminar las etiquetas HTML de cualquier dato no fiable antes de utilizarlo para crear contenido de documentos dinámicos. Puede corregir el archivo <em>greet.html</em> mostrado anteriormente sustituyendo los caracteres HTML especiales de la cadena de entrada no fiable por sus entidades HTML equivalentes:</p>
    <pre class="language-js">
    <code class="language-js">name = name
      .replace(/&/g, "&amp;amp;")
      .replace(/&lt;/g, "&amp;lt;")
      .replace(/>/g, "&amp;gt;")
      .replace(/"/g, "&amp;quot;")
      .replace(/'/g, "&amp;#x27;")
      .replace(/\//g, "&amp;#x2F;")</code></pre>
    <p>Otra forma de abordar el problema del XSS es estructurar las aplicaciones web de modo que el contenido que no sea de confianza se muestre siempre en un <codeinline>&lt;iframe></codeinline> con el atributo <codeinline>sandbox</codeinline> configurado para desactivar el scripting y otras capacidades.</p>
    <p>Cross-site scripting es una vulnerabilidad perniciosa cuyas raíces se hunden en lo más profundo de la arquitectura de la web. Merece la pena conocer esta vulnerabilidad en profundidad, pero su análisis va más allá del alcance de este libro. Hay muchos recursos en línea para ayudar a a defenderse contra el cross-site scripting.</p>
  </section>
  <section id="2">
    <h2>15.2 Eventos</h2>
    <p>Los programas JavaScript del lado del cliente utilizan un modelo de programación asíncrono basado en eventos. En este estilo de programación, el navegador web genera un <em>evento</em> cada vez que ocurre algo interesante en el documento o navegador o en algún elemento u objeto asociado a él. Por ejemplo, el navegador genera un evento cuando termina de cargar un documento, cuando el usuario mueve el ratón sobre un hipervínculo o cuando pulsa una tecla del teclado. Si una aplicación JavaScript se preocupa por un tipo particular de evento, puede registrar una o más funciones para que sean invocadas cuando se produzcan eventos de ese tipo. Tenga en cuenta que esto no es exclusivo de la programación web: todas las aplicaciones con interfaces gráficas de usuario están diseñadas de esta manera: se sientan a esperar a que se interactúe con ellas (es decir, esperan a que se produzcan eventos) y luego responden.</p>
    <p>En JavaScript del lado del cliente, los eventos pueden ocurrir en cualquier elemento dentro de un documento HTML, y este hecho hace que el modelo de eventos de los navegadores web sea significativamente más complejo que el modelo de eventos de Node. Comenzamos esta sección con algunas definiciones importantes que ayudan a explicar ese modelo de eventos:</p>
    <p><em>tipo de evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta cadena especifica qué tipo de evento se ha producido. El tipo "mousemove", por ejemplo, significa que el usuario movió el ratón. El tipo "keydown" significa que el usuario pulsó una tecla del teclado hacia abajo. Y el tipo "load" significa que un documento (o algún otro recurso) ha terminado de cargarse desde la red. Como el tipo de un evento es sólo una cadena, a veces se le llama <em>nombre del evento</em>, y de hecho, usamos este nombre para identificar el tipo de evento del que estamos hablando.</p>
    <p><em>objetivo del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Es el objeto en el que se ha producido el suceso o al que está asociado. Cuando hablamos de un evento, debemos especificar tanto el tipo como el destino. Un evento de carga en una ventana, por ejemplo, o un evento de clic en un elemento <codeinline>&lt;button></codeinline>. Los objetos Window, Document y Element son los destinos de eventos más comunes en las aplicaciones JavaScript del lado del cliente, pero algunos eventos se activan en otros tipos de objetos. Por ejemplo, un objeto Worker (un tipo de hilo, cubierto en <a href="#13">§15.13</a>) es un objetivo para eventos "mensaje" que ocurren cuando el hilo worker envía un mensaje al hilo principal.</p>
    <p><em>controlador de eventos o receptor de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función maneja o responde a un evento.<sup>2</sup> Las aplicaciones registran sus funciones manejadoras de eventos con el navegador web, especificando un tipo de evento y un objetivo de evento. Cuando se produce un evento del tipo especificado en el objetivo especificado, el navegador invoca la función manejadora. Cuando los manejadores de eventos son invocados para un objeto, decimos que el navegador ha "disparado" o "despachado" el evento. Hay varias maneras de registrar manejadores de eventos, y los detalles del registro y la invocación de manejadores se explican en <a href="#2-2">§15.2.2</a> y <a href="#2-3">§15.2.3</a>.</p>
    <p><em>objeto del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este objeto está asociado a un evento concreto y contiene detalles sobre ese evento. Los objetos evento se pasan como argumento a la función manejadora de eventos. Todos los objetos de evento tienen una propiedad <codeinline>type</codeinline> que especifica el tipo de evento y una propiedad <codeinline>target</codeinline> que especifica el objetivo del evento. Cada tipo de evento define un conjunto de propiedades para su objeto de evento asociado. El objeto asociado a un evento de ratón incluye las coordenadas del puntero del ratón, por ejemplo, y el objeto asociado a un evento de teclado contiene detalles sobre la tecla que se pulsó y las teclas modificadoras que se mantuvieron pulsadas. Muchos tipos de eventos sólo definen algunas propiedades estándar -como el <codeinline>type</codeinline> y el <codeinline>target</codeinline>- y no contienen mucha más información útil. Para esos eventos, lo que importa es la simple ocurrencia del evento, no los detalles del mismo.</p>
    <p><em>propagación de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este es el proceso por el cual el navegador decide qué objetos activan los manejadores de eventos. Para los eventos que son específicos de un único objeto -como el evento "load" en el objeto Window o un evento "message" en un objeto Worker- no se requiere ningún proceso. Sin embargo, cuando ciertos tipos de eventos ocurren en elementos dentro del documento HTML, se propagan o "burbujean" hacia arriba en el árbol del documento. Si el usuario mueve el ratón sobre un hipervínculo, el evento mousemove se dispara primero en el elemento <codeinline>&lt;a></codeinline> que define ese enlace. Luego se dispara sobre los elementos que lo contienen: quizás un elemento <codeinline>&lt;p></codeinline>, un elemento <codeinline>&lt;section></codeinline>, y el propio objeto Documento. A veces es más conveniente registrar un único manejador de eventos en un Documento u otro elemento contenedor que registrar manejadores en cada elemento individual en el que estés interesado. Un manejador de eventos puede detener la propagación de un evento para que no continúe burbujeando y no active manejadores en los elementos que lo contienen. Los manejadores hacen esto invocando un método del objeto del evento. En otra forma de <em>propagación de eventos</em>, conocida como captura de eventos, los manejadores especialmente registrados en elementos contenedores tienen la oportunidad de interceptar (o "capturar") eventos antes de que sean enviados a su destino real. El burbujeo y la captura de eventos se tratan en detalle en <a href="#2-4">§15.2.4</a>.</p>
    <p>Algunos eventos tienen asociadas <em>acciones por defecto</em>. Cuando se produce un evento de clic en un hipervínculo, por ejemplo, la acción por defecto es que el navegador siga el enlace y cargue una nueva página. Los manejadores de eventos pueden evitar esta acción por defecto invocando un método del objeto del evento. Esto a veces se llama "cancelar" el evento y se trata en <a href="#2-5">§15.2.5</a>.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.1 Categorías de eventos</h2>
    <p>JavaScript del lado del cliente soporta un número tan grande de tipos de eventos que no hay forma de que este capítulo pueda cubrirlos todos. Puede ser útil, sin embargo, agrupar los eventos en algunas categorías generales, para ilustrar el alcance y la amplia variedad de eventos soportados:</p>
    <p><em>Eventos de entrada dependientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos están directamente vinculados a un dispositivo de entrada específico, como el ratón o el teclado. Incluyen tipos de eventos como "mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "keydown" y "keyup".</p>
    <p><em>Eventos de entrada independientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos de entrada no están directamente vinculados a un dispositivo de entrada específico. El evento "clic", por ejemplo, indica que se ha activado un enlace o un botón (u otro elemento del documento). Esto suele hacerse mediante un clic del ratón, pero también puede hacerse con el teclado o (en dispositivos táctiles) con un toque. El evento "input" es una alternativa independiente del dispositivo al evento "keydown" y admite la entrada por teclado, así como alternativas como cortar y pegar y métodos de entrada utilizados para scripts ideográficos. Los eventos "pointerdown", "pointermove" y "pointerup" son alternativas independientes del dispositivo a los eventos de ratón y táctiles. Funcionan con punteros de tipo ratón, con pantallas táctiles y también con entradas de tipo lápiz o bolígrafo.</p>
    <p><em>Eventos de la interfaz de usuario</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los eventos de interfaz de usuario son eventos de nivel superior, a menudo en elementos de formulario HTML que definen una interfaz de usuario para una aplicación web. Incluyen el evento "focus" (cuando un campo de entrada de texto obtiene el foco del teclado), el evento "change" (cuando el usuario cambia el valor mostrado por un elemento de formulario) y el evento "submit" (cuando el usuario hace clic en un botón Enviar de un formulario).</p>
    <p><em>Cambios de estado</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Algunos eventos no se desencadenan directamente por la actividad del usuario, sino por la actividad de la red o del navegador, e indican algún tipo de cambio relacionado con el ciclo de vida o el estado. Los eventos "load" y "DOMContentLoaded" -provocados en los objetos Window y Document, respectivamente, al final de la carga del documento- son probablemente los más utilizados de estos eventos (ver <a href="#javascritp-cliente">"Línea de tiempo JavaScript del lado del cliente"</a>). Los navegadores disparan eventos "online" y "offline" en el objeto Window cuando la conectividad de la red cambia. El mecanismo de gestión del historial del navegador (<a href="#10-4">§15.10.4</a>) dispara el evento "popstate" en respuesta al botón Atrás del navegador.</p>
    <p><em>Eventos específicos de la API</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Varias API web definidas por HTML y especificaciones relacionadas incluyen sus propios tipos de eventos. Los elementos HTML <codeinline>&lt;video></codeinline> y <codeinline>&lt;audio></codeinline> definen una larga lista de tipos de eventos asociados, como "espera", "reproducción", "búsqueda", "cambio de volumen", etc., y puedes utilizarlos para personalizar la reproducción multimedia. En términos generales, las API de plataformas web que son asíncronas y se desarrollaron antes de que se añadieran las promesas a JavaScript se basan en eventos y definen eventos específicos de la API. La API IndexedDB, por ejemplo (<a href="#12-3">§15.12.3</a>), dispara eventos de "éxito" y "error" cuando las peticiones a la base de datos tienen éxito o fallan. Y aunque la nueva API <codeinline>fetch()</codeinline> (<a href="#11-1">§15.11.1</a>) para realizar peticiones HTTP está basada en promesas, la API XMLHttpRequest a la que sustituye define una serie de tipos de eventos específicos de la API.</p>
  </section>
  <section id="2-2">
    <h2>15.2.2 Registro de controladores de eventos</h2>
    <p>Hay dos formas básicas de registrar manejadores de eventos. La primera, desde los primeros días de la web, es establecer una propiedad en el objeto o elemento del documento que es el tar- minador del evento. La segunda técnica (más reciente y general) consiste en pasar el controlador al método <codeinline>addEventListener()</codeinline> del objeto o elemento.</p>
    <p class="title-article text-left">Configuración de las propiedades de los controladores de eventos</p>
    <p>La forma más sencilla de registrar un manejador de eventos es estableciendo una propiedad del tar- gador de eventos en la función deseada del manejador de eventos. Por convención, las propiedades de los manejadores de eventos tienen nombres que consisten en la palabra "on" seguida del nombre del evento: <codeinline>onclick</codeinline>, <codeinline>onchange</codeinline>, <codeinline>onload</codeinline>, <codeinline>onmouseover</codeinline>, etcétera. Tenga en cuenta que los nombres de estas propiedades distinguen entre mayúsculas y minúsculas,<sup>3</sup> incluso cuando el tipo de evento (como "mouse- down") consta de varias palabras. El siguiente código incluye dos registros de manejadores de eventos de este tipo:</p>
    <pre class="language-js">
    <code class="language-js">// Establezca la propiedad onload del objeto Window en una función.
    // La función es el controlador de eventos: se invoca cuando se carga el documento.
    window.onload = function() &lbrace;
      // Busque un elemento &lt;form>
      let form = document.querySelector("form#shipping");
      // Registra una función de controlador de eventos en el formulario 
      // que se invocará antes de enviar el formulario. Supongamos que 
      // isFormValid() está definido en otra parte.
      form.onsubmit = function(event) &lbrace; // Cuando el usuario envía el formulario.
        if (!isFormValid(this)) &lbrace;       // comprobar si las entradas del formulario son válidas
          event.preventDefault();       // y en caso contrario, impedir el envío del formulario.
        }
      };
    };</code></pre>
    <p>El defecto de las propiedades de los manejadores de eventos es que están diseñadas bajo la suposición de que los objetivos de eventos tendrán como máximo un manejador para cada tipo de evento. En a menudo es mejor registrar manejadores de eventos usando <codeinline>addEventListener()</codeinline> porque esa técnica no sobreescribe ningún manejador previamente registrado.</p>
    <p class="title-article text-left">Establecer atributos del manejador de eventos</p>
    <p>Las propiedades de los manejadores de eventos de los elementos del documento también pueden definirse directamente en el archivo HTML como atributos en la etiqueta HTML correspondiente. (Los manejadores que se registrarían en el elemento Window con JavaScript pueden definirse con atributos en la etiqueta <codeinline>&lt;body></codeinline> en HTML). Esta técnica es generalmente mal vista en el desarrollo web moderno, pero es posible, y se documenta aquí porque todavía se puede ver en el código existente.</p>
    <p>Cuando se define un manejador de eventos como un atributo HTML, el valor del atributo debe ser una cadena de código JavaScript. Ese código debe ser el <em>body</em> de la función del manejador de eventos, no una declaración de función completa. Es decir, el código HTML del controlador de eventos no debe estar rodeado de llaves y precedido de la palabra clave <codeinline>function</codeinline>. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">&lt;button onclick="console.log('Thank you');">Please Click&lt;/button></code></pre>
    <p>Si un atributo de controlador de eventos HTML contiene varias sentencias JavaScript, no olvide separarlas con punto y coma o dividir el valor del atributo en varias líneas.</p>
    <p>Cuando se especifica una cadena de código JavaScript como valor de un atributo HTML manejador de eventos, el navegador convierte la cadena en una función que funciona de forma parecida a ésta:</p>
    <pre class="language-js">
    <code class="language-js">function(event) &lbrace;
      with(document) &lbrace;
        with(this.form || &lbrace;}) &lbrace;
          with(this) &lbrace;
            /* tu código aquí */
          }
        }
      }
    }</code></pre>
    <p>El argumento <codeinline>event</codeinline> significa que el código de su manejador puede referirse al objeto de evento actual como <codeinline>event</codeinline>. Las sentencias <codeinline>with</codeinline> significan que el código de tu manejador puede referirse a las propiedades del objeto destino, al <codeinline>&lt;form></codeinline> contenedor (si lo hay), y al objeto Documento contenedor directamente, como si fueran variables en scope. La sentencia <codeinline>with</codeinline> está prohibida en modo estricto (<a href="capitulo-5#6-3">§5.6.3</a>), pero el código JavaScript en atributos HTML nunca es estricto. Los manejadores de eventos definidos de esta forma se ejecutan en un entorno en el que se definen variables inesperadas. Esto puede ser una fuente de errores confusos y es una buena razón para evitar escribir manejadores de eventos en HTML.</p>
    <p class="title-article text-left">addEventListener()</p>
    <p>Cualquier objeto que pueda ser objetivo de un evento -esto incluye los objetos Window y Document y todos los Elementos del documento- define un método llamado <codeinline>addEventListener()</codeinline> que puede utilizar para registrar un controlador de eventos para ese objetivo. <codeinline>addEventListener()</codeinline> toma tres argumentos. El primero es el tipo de evento para el que se está registrando el controlador. El tipo de evento (o nombre) es una cadena que no incluye el prefijo "on" utilizado al establecer las propiedades del manejador de eventos. El segundo argumento de <codeinline>addEventListener()</codeinline> es la función que se invocará cuando se produzca el tipo de evento especificado. El tercer argumento es opcional y se explica a continuación.</p>
    <p>El siguiente código registra dos manejadores para el evento "click" en un elemento <codeinline>&lt;button></codeinline>. Observe las diferencias entre las dos técnicas utilizadas:</p>
    <pre class="language-js">
    <code class="language-js">&lt;button id="mybutton">Click me&lt;/button>
    &lt;script>
    let b = document.querySelector("#mybutton");
    b.onclick = function() &lbrace; console.log("Thanks for clicking me!"); };
    b.addEventListener("click", () => &lbrace; console.log("Thanks again!"); });
    &lt;/script></code></pre>
    <p>Llamar a <codeinline>addEventListener()</codeinline> con "click" como primer argumento no afecta al valor de la propiedad <codeinline>onclick</codeinline>. En este código, un clic de botón registrará dos mensajes en la consola del desarrollador. Y si llamáramos primero a <codeinline>addEventListener()</codeinline> y luego estableciéramos <codeinline>onclick</codeinline>, seguiríamos registrando dos mensajes, sólo que en el orden inverso. Más importante aún, puedes llamar a <codeinline>addEventListener()</codeinline> varias veces para registrar más de una función manejadora para el mismo tipo de evento en el mismo objeto. Cuando ocurre un evento en un objeto, todos los manejadores registrados para ese tipo de evento son invocados en el orden en que fueron registrados. Invocar <codeinline>addEventListener()</codeinline> más de una vez sobre el mismo objeto con los mismos argumentos no tiene ningún efecto - la función manejadora permanece registrada sólo una vez, y la invocación repetida no altera el orden en que los manejadores son invocados.</p>
    <p><codeinline>addEventListener()</codeinline> está emparejado con un método <codeinline>removeEventListener()</codeinline> que espera los mismos dos argumentos (más un tercero opcional) pero elimina una función manejadora de eventos de un objeto en lugar de añadirla. A menudo es útil registrar temporalmente un controlador de eventos y eliminarlo poco después. Por ejemplo, cuando recibes un evento "mousedown", puedes registrar temporalmente manejadores de eventos "mousemove" y "mouseup" para ver si el usuario arrastra el ratón. A continuación, anularías el registro de estos manejadores cuando llegue el evento "mouseup". En tal situación, tu código de eliminación de manejadores de eventos podría verse así:</p>
    <pre class="language-js">
    <code class="language-js">document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);</code></pre>
    <p>El tercer argumento opcional de <codeinline>addEventListener()</codeinline> es un valor booleano o un objeto. Si pasa <codeinline>true</codeinline>, entonces su función manejadora se registra como un manejador de eventos de <em>captura</em> y se invoca en una fase diferente del envío de eventos. Cubriremos la captura de eventos en <a href="#2-4">§15.2.4</a>. Si pasas un tercer argumento de <codeinline>true</codeinline> cuando registras un receptor de eventos, entonces también debes pasar true como tercer argumento a <codeinline>removeEventListener()</codeinline> si quieres eliminar el manejador.</p>
    <p>Registrar un controlador de eventos de captura es sólo una de las tres opciones que admite <codeinline>addEventListener()</codeinline>, y en lugar de pasar un único valor booleano, también puede pasar un objeto que especifique explícitamente las opciones que desea:</p>
    <pre class="language-js">
    <code class="language-js">document.addEventListener("click", handleClick, &lbrace;
      capture: true,
      once: true,
      passive: true
    });</code></pre>
    <p>Si el objeto Options tiene una propiedad de <codeinline>capture</codeinline> establecida a <codeinline>true</codeinline>, entonces el manejador de eventos será registrado como un manejador de captura. Si esa propiedad es <codeinline>false</codeinline> o se omite, entonces el manejador será no capturador.</p>
    <p>Si el objeto Options tiene la propiedad <codeinline>once</codeinline> establecida a <codeinline>true</codeinline>, entonces el manejador de eventos se eliminará automáticamente después de que se active una vez. Si esta propiedad es <codeinline>false</codeinline> o se omite, el controlador nunca se eliminará automáticamente.</p>
    <p>Si el objeto Options tiene una propiedad <codeinline>passive</codeinline> establecida a <codeinline>true</codeinline>, indica que el manejador de eventos nunca llamará a <codeinline>preventDefault()</codeinline> para cancelar la acción por defecto (ver <a href="#2-5">§15.2.5</a>). Esto es particularmente importante para eventos táctiles en dispositivos móviles - si los manejadores de eventos "touchmove" pueden prevenir la acción de desplazamiento por defecto del navegador, entonces el navegador no puede implementar un desplazamiento suave. Esta propiedad <codeinline>passive</codeinline> proporciona una forma de registrar un controlador de eventos potencialmente perjudicial de este tipo, pero permite que el navegador web sepa que puede iniciar de forma segura su comportamiento predeterminado -como el desplazamiento- mientras se ejecuta el controlador de eventos. El desplazamiento suave es tan importante para una buena experiencia de usuario que Firefox y Chrome hacen que los eventos "touchmove" y "mousewheel" sean pasivos por defecto. Así que si quieres registrar un manejador que llame a <codeinline>preventDefault()</codeinline> para uno de estos eventos, debes establecer explícitamente la propiedad <codeinline>passive</codeinline> a <codeinline>false</codeinline>.</p>
    <p>También puede pasar un objeto Options a <codeinline>removeEventListener()</codeinline>, pero la propiedad <codeinline>capture</codeinline> es la única relevante. No es necesario especificar <codeinline>once</codeinline> o <codeinline>passive</codeinline> al eliminar un listener, y estas propiedades se ignoran.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.3 Invocación del manejador de eventos</h2>
    <p>Una vez que hayas registrado un manejador de eventos, el navegador web lo invocará automáticamente cuando se produzca un evento del tipo especificado en el objeto especificado. Esta sección describe la invocación de manejadores de eventos en detalle, explicando los argumentos de los manejadores de eventos, el contexto de invocación (el valor <codeinline>this</codeinline>), y el significado del valor de retorno de un manejador de eventos.</p>
    <p class="title-article text-left">Argumento del controlador de eventos</p>
    <p>Los controladores de eventos se invocan con un objeto Evento como único argumento. Las propiedades del objeto Evento proporcionan detalles sobre el evento:</p>
    <p><codeinline>type</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Tipo de suceso ocurrido.</p>
    <p><codeinline>target</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El objeto en el que se ha producido el suceso.</p>
    <p><codeinline>currentTarget</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Para los eventos que se propagan, esta propiedad es el objeto en el que se registró el manejador del evento actual.</p>
    <p><codeinline>timeStamp</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una marca de tiempo (en milisegundos) que representa cuándo ocurrió el evento pero que no representa un tiempo absoluto. Puedes determinar el tiempo transcurrido entre dos eventos restando la marca de tiempo del primer evento de la marca de tiempo del segundo.</p>
    <p><codeinline>isTrusted</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad será <codeinline>true</codeinline> si el evento fue enviado por el propio navegador web y <codeinline>false</codeinline> si el evento fue enviado por código JavaScript.</p>
    <p>Determinados tipos de eventos tienen propiedades adicionales. Los eventos de ratón y puntero, por ejemplo, tienen propiedades <codeinline>clientX</codeinline> y <codeinline>clientY</codeinline> que especifican las coordenadas de la ventana en la que se produjo el evento.</p>
    <p class="title-article text-left">Contexto del controlador de eventos</p>
    <p>Cuando se registra un manejador de eventos estableciendo una propiedad, parece como si se estuviera definiendo un nuevo método en el objeto de destino:</p>
    <pre class="language-js">
    <code class="language-js">target.onclick = function() &lbrace; /* código del controlador */ };</code></pre>
    <p>No es sorprendente, por tanto, que los manejadores de eventos sean invocados como métodos del objeto sobre el que están definidos. Es decir, dentro del cuerpo de un manejador de eventos, la palabra clave <codeinline>this</codeinline> se refiere al objeto sobre el que se registró el manejador de eventos.</p>
    <p>Los manejadores se invocan con el objetivo como su valor <codeinline>this</codeinline>, incluso cuando se registran usando <codeinline>addEventListener()</codeinline>. Sin embargo, esto no funciona para los manejadores definidos como funciones de flecha: las funciones de flecha siempre tienen el mismo valor this que el ámbito en el que se definen.</p>
    <p class="title-article text-left">Valor de retorno del manipulador</p>
    <p>En el JavaScript moderno, los manejadores de eventos no deberían devolver nada. Puedes ver manejadores de eventos que devuelven valores en código antiguo, y el valor devuelto es típicamente una señal al navegador de que no debe realizar la acción por defecto asociada con el evento. Si el manejador <codeinline>onclick</codeinline> de un botón Enviar en un formulario devuelve <codeinline>false</codeinline>, por ejemplo, entonces el navegador web no enviará el formulario (normalmente porque el manejador de eventos determinó que la entrada del usuario falla la validación del lado del cliente).</p>
    <p>La forma estándar y preferida de evitar que el navegador realice una acción por defecto es llamar al método <codeinline>preventDefault()</codeinline> ( <a href="#2-5">§15.2.5</a> ) en el objeto Evento.</p>
    <p class="title-article text-left">Orden de invocación</p>
    <p>Un objetivo de evento puede tener más de un manejador de evento registrado para un tipo particular de evento. Cuando ocurre un evento de ese tipo, el navegador invoca todos los manejadores en el orden en que fueron registrados. Curiosamente, esto es cierto incluso si se mezclan manejadores de eventos registrados con <codeinline>addEventListener()</codeinline> con un manejador de eventos registrado en una propiedad de objeto como <codeinline>onclick</codeinline>.</p>
  </section>
  <section id="2-4">
    <h2>15.2.4 Propagación de eventos</h2>
    <p>Cuando el objetivo de un evento es el objeto Window o algún otro objeto independiente, el navegador responde a un evento simplemente invocando los manejadores apropiados en ese objeto. Sin embargo, cuando el objetivo del evento es un Documento o un Elemento del documento, la situación es más complicada.</p>
    <p>Una vez invocados los manejadores de eventos registrados en el elemento de destino, la mayoría de los eventos "burbujean" hacia arriba en el árbol DOM. Se invocan los manejadores de eventos del padre del objetivo. Luego se invocan los manejadores registrados en el abuelo del objetivo. Esto continúa hasta el objeto Documento, y luego más allá hasta el objeto Ventana. El burbujeo de eventos proporciona una alternativa al registro de manejadores en muchos elementos individuales del documento: en su lugar, puedes registrar un único manejador en un elemento ancestro común y manejar los eventos allí. Por ejemplo, puede registrar un controlador de "cambio" en un elemento <codeinline>&lt;form></codeinline>, en lugar de registrar un controlador de "cambio" para cada elemento del formulario.</p>
    <p>La mayoría de los eventos que se producen en los elementos del documento burbujean. Excepciones notables son los eventos "focus", "blur" y "scroll". El evento "load" de los elementos del documento burbujea, pero deja de burbujear en el objeto Documento y no se propaga al objeto Ventana. (Los manejadores de eventos "load" del objeto Window se disparan sólo cuando todo el documento se ha cargado).</p>
    <p>El burbujeo de eventos es la tercera "fase" de la propagación de eventos. La invocación de los manejadores de eventos del propio objeto de destino es la segunda fase. La primera fase, que ocurre incluso antes de que se invoquen los manejadores de destino, se denomina fase de "captura". Recordemos que <codeinline>addEventListener()</codeinline> toma un tercer argumento opcional. Si ese argumento es verdadero o <codeinline>&lbrace;capture:true}</codeinline>, entonces el manejador de eventos es registrado como un manejador de eventos de captura para invocación durante esta primera fase de propagación de eventos. La fase de captura de la propagación de eventos es como la fase de burbujeo a la inversa. Los manejadores de captura del objeto Window son invocados primero, luego los manejadores de captura del objeto Document, luego del objeto body, y así sucesivamente hacia abajo en el árbol DOM hasta que los manejadores de captura de eventos del padre del objetivo del evento son invocados. Los manejadores de captura de eventos registrados en el propio objetivo del evento no son invocados.</p>
    <p>La captura de eventos proporciona una oportunidad para echar un vistazo a los eventos antes de que sean entregados a su objetivo. Un manejador de eventos de captura puede ser usado para depuración, o puede ser usado junto con la técnica de cancelación de eventos descrita en la siguiente sección para filtrar eventos de manera que los manejadores de eventos de destino nunca sean invocados. Un uso común para la captura de eventos es el manejo de arrastres del ratón, donde los eventos de movimiento del ratón necesitan ser manejados por el objeto que está siendo arrastrado, no por los elementos del documento sobre los que se arrastra.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.5 Cancelación de eventos</h2>
    <p>Los navegadores responden a muchos eventos del usuario, aunque tu código no lo haga: cuando el usuario hace clic con el ratón en un hipervínculo, el navegador sigue el enlace. Si un elemento HTML de entrada de texto tiene el foco en el teclado y el usuario teclea una tecla, el navegador introducirá la entrada del usuario. Si el usuario mueve el dedo por un dispositivo de pantalla táctil, el navegador se desplaza. Si registras un manejador de eventos para eventos como estos, puedes evitar que el navegador realice su acción por defecto invocando el método <codeinline>preventDefault()</codeinline> del objeto evento. (A menos que hayas registrado el manejador con la opción <codeinline>passive</codeinline>, lo que hace que <codeinline>preventDefault()</codeinline> sea ineficaz).</p>
    <p>Cancelar la acción por defecto asociada a un evento es sólo un tipo de cancelación de eventos. También podemos cancelar la propagación de eventos llamando al método <codeinline>stopPropagation()</codeinline> del objeto evento. Si hay otros manejadores definidos en el mismo objeto, el resto de esos manejadores seguirán siendo invocados, pero ningún manejador de evento en cualquier otro objeto será invocado después de llamar a <codeinline>stopPropagation()</codeinline>. <codeinline>stopPropagation()</codeinline> funciona durante la fase de captura, en el propio objetivo del evento, y durante la fase de burbujeo. stopImmediatePropagation() funciona como <codeinline>stopPropagation()</codeinline>, pero también previene la invocación de cualquier manejador de evento posterior registrado en el mismo objeto.</p>
  </section>
  <section id="2-6">
    <h2>15.2.6 Envío de eventos personalizados</h2>
    <p>La API de eventos de JavaScript del lado del cliente es relativamente potente, y puedes utilizarla para definir y enviar tus propios eventos. Supongamos, por ejemplo, que tu programa necesita peri-ódicamente realizar un cálculo largo o hacer una petición a la red y que, mientras esta operación está pendiente, otras operaciones no son posibles. Usted quiere que el usuario lo sepa mostrando "spinners" para indicar que la aplicación está ocupada. Pero el módulo que está ocupado no necesita saber dónde deben estar los mostrado. En su lugar, ese módulo podría enviar un evento para anunciar que está ocupado y luego enviar otro evento cuando ya no lo esté. Entonces, el módulo de interfaz de usuario puede registrar manejadores de eventos para esos eventos y tomar cualquier acción de interfaz de usuario que sea apropiada para notificar al usuario.</p>
    <p>Si un objeto JavaScript tiene un método <codeinline>addEventListener()</codeinline>, entonces es un "objetivo de evento", y esto significa que también tiene un método <codeinline>dispatchEvent()</codeinline>. Puede crear su propio objeto de evento con el constructor <codeinline>CustomEvent()</codeinline> y pasarlo a <codeinline>dispatchEvent()</codeinline>. El primer argumento de <codeinline>CustomEvent()</codeinline> es una cadena que especifica el tipo de tu evento, y el segundo argumento es un objeto que especifica las propiedades del objeto evento. Establezca la propiedad <codeinline>detail</codeinline> de este objeto a una cadena, objeto u otro valor que represente el contenido de su evento. Si planeas enviar tu evento sobre un elemento del documento y quiere que se burbujee hacia arriba en el árbol del documento, añade <codeinline>bubbles:true</codeinline> al segundo argumento:</p>
    <pre class="language-js">
    <code class="language-js">// Envía un evento personalizado para que la interfaz de 
    // usuario sepa que estamos ocupados
    document.dispatchEvent(new CustomEvent("busy", &lbrace; detail: true }));

    // Realizar una operación de red
    fetch(url)
      .then(handleNetworkResponse)
      .catch(handleNetworkError)
      .finally(() => &lbrace;
        // Después de que la solicitud de red haya tenido éxito o haya fallado,
        // envíe otro evento para informar a la UI que ya no estamos ocupados.
        document.dispatchEvent(new CustomEvent("busy", &lbrace; detail: false }));
      });

    // En otra parte, en su programa puede registrar un controlador para eventos 
    // "busy" y usarlo para mostrar u ocultar el indicador para avisarle al usuario.
    document.addEventListener("busy", (e) => &lbrace;
      if (e.detail) &lbrace;
        showSpinner();
      } else &lbrace;
        hideSpinner();
      }
    });</code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3 Documentos de secuencias de comandos</h2>
    <p>JavaScript del lado del cliente existe para convertir documentos HTML estáticos en aplicaciones web interactivas. El objetivo principal de JavaScript es crear scripts para el contenido de las páginas web.</p>
    <p>Todo objeto Ventana tiene una propiedad <codeinline>document</codeinline> que hace referencia a un objeto Documento. El objeto Documento representa el contenido de la ventana, y es el tema de esta sección. Sin embargo, el objeto Document no es el único. Es el objeto central del DOM para representar y manipular el contenido de los documentos.</p>
    <p>El DOM se introdujo en <a href="#1-2">§15.1.2</a>. Esta sección explica la API en detalle. Abarca:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo consultar o <em>seleccionar</em> elementos individuales de un documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo <em>recorrer</em> un documento y cómo encontrar los ancestros, hermanos y descendientes de cualquier elemento del documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo consultar y establecer los atributos de los elementos del documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo consultar, fijar y modificar el contenido de un documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo modificar la estructura de un documento creando, insertando y eliminando nodos.
        </p>
      </li>
    </ul>
  </section>
  <section id="3-1">
    <h2>15.3.1 Selección de elementos del documento</h2>
    <p>Los programas JavaScript del lado del cliente a menudo necesitan manipular uno o más elementos dentro del documento. La propiedad global <codeinline>document</codeinline> se refiere al objeto Document, y el objeto Document tiene propiedades <codeinline>head</codeinline> y <codeinline>body</codeinline> que se refieren a los objetos Element para las etiquetas <codeinline>&lt;head></codeinline> y <codeinline>&lt;body></codeinline>, respectivamente. Pero un programa que quiera manipular un elemento incrustado más profundamente en el documento debe de alguna manera obtener o <em>seleccionar</em> los objetos Element que se refieren a esos elementos del documento.</p>
    <p class="title-article text-left">Seleccionar elementos con selectores CSS</p>
    <p>Las hojas de estilo CSS tienen una sintaxis muy potente, conocida como <em>selectores</em>, para describir elementos o conjuntos de elementos dentro de un documento. Los métodos DOM <codeinline>querySelector()</codeinline> y <codeinline>querySelectorAll()</codeinline> nos permiten encontrar el elemento o elementos dentro de un documento que coinciden con un selector CSS especificado. Antes de cubrir los métodos, comenzaremos con un rápido tutorial sobre la sintaxis de los selectores CSS.</p>
    <p>Los selectores CSS pueden describir elementos por el nombre de la etiqueta, el valor de su atributo <codeinline>id</codeinline> o las palabras de su atributo <codeinline>class</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">div       // Cualquier elemento &lt;div>
    #nav      // El elemento con id="nav"
    .warning  // Cualquier elemento con "warning" en su atributo de clase</code></pre>
    <p>El carácter <codeinline>#</codeinline> se utiliza para hacer coincidencias basadas en el atributo <codeinline>id</codeinline>, y el carácter <codeinline>.</codeinline> se utiliza para hacer coincidencias basadas en el atributo <codeinline>class</codeinline>. Los elementos también pueden seleccionarse en función de valores de atributo más generales:</p>
    <pre class="language-js">
    <code class="language-js">p[lang="fr"] // Un párrafo escrito en francés: &lt;p lang="fr">
    *[name="x"]  // Cualquier elemento con un atributo name="x"</code></pre>
    <p>Observe que estos ejemplos combinan un selector de nombre de etiqueta (o el comodín <codeinline>*</codeinline> de nombre de etiqueta) con un selector de atributo. También son posibles combinaciones más complejas:</p>
    <pre class="language-js">
    <code class="language-js">span.fatal.error        // Cualquier &lt;span> con "fatal" y "error" en su clase
    span[lang="fr"].warning // Cualquier &lt;span> en francés con la clase "warning"</code></pre>
    <p>Los selectores también pueden especificar la estructura del documento:</p>
    <pre class="language-js">
    <code class="language-js">#log span           // Cualquier descendiente &lt;span> del elemento con id="log"
    #log>span           // Cualquier hijo &lt;span> del elemento con id="log"
    body>h1:first-child // El primer &lt;h1> hijo del &lt;body>
    img + p.caption     // Una &lt;p> con la clase "caption" inmediatamente después de una &lt;img>
    h2 ~ p              // Cualquier &lt;p> que siga a un &lt;h2> y sea hermano de este</code></pre>
    <p>Si dos selectores están separados por una coma, significa que hemos seleccionado elementos que coinciden con cualquiera de los selectores:</p>
    <pre class="language-js">
    <code class="language-js">button, input[type="button"] // Todos los elementos &lt;button> y &lt;input type="button"></code></pre>
    <p>Como puedes ver, los selectores CSS nos permiten referirnos a elementos dentro de un documento por tipo, ID, clase, atributos y posición dentro del documento. El método <codeinline>querySelector()</codeinline> toma una cadena de selector CSS como argumento y devuelve el primer elemento coincidente que encuentra en el documento, o devuelve <codeinline>null</codeinline> si no coincide ninguno:</p>
    <pre class="language-js">
    <code class="language-js">// Busque el elemento del documento para la etiqueta HTML con el atributo id="spinner"
    let spinner = document.querySelector("#spinner");</code></pre>
    <p><codeinline>querySelectorAll()</codeinline> es similar, pero devuelve todos los elementos coincidentes del documento en lugar de devolver sólo el primero:</p>
    <pre class="language-js">
    <code class="language-js">// Encuentra todos los objetos Element para &lt;h1>, &lt;h2>, y &lt;h3> etiquetas
    let titles = document.querySelectorAll("h1, h2, h3");</code></pre>
    <p>El valor devuelto por <codeinline>querySelectorAll()</codeinline> no es un array de objetos Element. En su lugar, es un objeto tipo array conocido como NodeList. Los objetos NodeList tienen una propiedad de <codeinline>length</codeinline> y pueden ser indexados como arrays, por lo que se puede hacer un bucle sobre ellos con un bucle <codeinline>for</codeinline> tradicional. Los NodeLists también son iterables, por lo que también puedes usarlos con bucles <codeinline>for/of</codeinline>. Si desea convertir un NodeList en un verdadero array, simplemente páselo a <codeinline>Array.from()</codeinline>.</p>
    <p>La NodeList devuelta por <codeinline>querySelectorAll()</codeinline> tendrá una propiedad <codeinline>length</codeinline> establecida a 0 si no hay ningún elemento en el documento que coincida con el selector especificado.</p>
    <p><codeinline>querySelector()</codeinline> y <codeinline>querySelectorAll()</codeinline> son implementados tanto por la clase Element como por la clase Document. Cuando se invocan sobre un elemento, estos métodos sólo devolverán elementos que sean descendientes de ese elemento.</p>
    <p>Tenga en cuenta que CSS define los pseudoelementos <codeinline>::first-line</codeinline> y <codeinline>::first-letter</codeinline>. En CSS, coinciden con partes de nodos de texto y no con elementos reales. No coincidirán si se utilizan con <codeinline>querySelectorAll()</codeinline> o <codeinline>querySelector()</codeinline>. Además, muchos navegadores se negarán a devolver coincidencias para las pseudoclases <codeinline>:link</codeinline> y <codeinline>:visited</codeinline>, ya que esto podría exponer información sobre el historial de navegación del usuario.</p>
    <p>Otro método de selección de elementos basado en CSS es <codeinline>closest()</codeinline>. Este método está definido por la clase Element y toma un selector como único argumento. Si el selector coincide con el elemento sobre el que se invoca, devuelve ese elemento. En caso contrario, devuelve el elemento antecesor más cercano con el que coincida el selector, o devuelve <codeinline>null</codeinline> si no coincide ninguno. En cierto sentido, <codeinline>closest()</codeinline> es lo contrario de <codeinline>querySelector(): closest()</codeinline> comienza en un elemento y busca una coincidencia por encima de él en el árbol, mientras que <codeinline>querySelector()</codeinline> comienza con un elemento y busca una coincidencia por debajo de él en el árbol. <codeinline>closest()</codeinline> puede ser útil cuando se ha registrado un controlador de eventos en un nivel alto en el árbol del documento. Si está manejando un evento "clic", por ejemplo, es posible que desee saber si se trata de un clic en un hipervínculo. El objeto de evento le dirá cuál era el objetivo, pero ese objetivo podría ser el texto dentro de un enlace en lugar de la propia etiqueta <codeinline>&lt;a></codeinline> del hipervínculo. Tu manejador de eventos podría buscar el hipervínculo contenedor más cercano así:</p>
    <pre class="language-js">
    <code class="language-js">// Encuentre la etiqueta &lt;a> más cercana que tenga un atributo href.
    let hyperlink = event.target.closest("a[href]");</code></pre>
    <p>Esta es otra forma de utilizar <codeinline>closest()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Devuelve verdadero si el elemento e está dentro de un elemento de lista HTML
    function insideList(e) &lbrace;
      return e.closest("ul,ol,dl") !== null;
    }</code></pre>
    <p>El método relacionado <codeinline>matches()</codeinline> no devuelve ancestros ni descendientes: simplemente comprueba si un elemento coincide con un selector CSS y devuelve <codeinline>true</codeinline> en caso afirmativo y <codeinline>false</codeinline> en caso contrario:</p>
    <pre class="language-js">
    <code class="language-js">// Devuelve verdadero si e es un elemento de encabezado HTML
    function isHeading(e) &lbrace;
      return e.matches("h1,h2,h3,h4,h5,h6");
    }</code></pre>
    <p class="title-article text-left">Otros métodos de selección de elementos</p>
    <p>Además de <codeinline>querySelector()</codeinline> y <codeinline>querySelectorAll()</codeinline>, el DOM también define una serie de métodos de selección de elementos más antiguos que ahora están más o menos obsoletos. Sin embargo, es posible que aún se utilicen algunos de estos métodos (especialmente <codeinline>getElementById()</codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">// Busque un elemento por id. El argumento es solo el id, sin el 
    // prefijo # del selector CSS . Similar a document.querySelector("#sect1")
    let sect1 = document.getElementById("sect1");

    // Busque todos los elementos (como las casillas de verificación 
    // de formularios) que tengan un atributo name="color". 
    // Similar a document.querySelectorAll('*[name="color"]');
    let colors = document.getElementsByName("color");
    
    // Busque todos los elementos &lt;h1> en el documento.
    // Similar a document.querySelectorAll("h1")
    let headings = document.getElementsByTagName("h1");
    
    // getElementsByTagName() También se define en elementos.
    // Obtener todos los elementos &lt;h2> dentro del elemento sect1.
    let subheads = sect1.getElementsByTagName("h2");
    
    // Busque todos los elementos que tengan la clase "tooltip".
    // Similar a document.querySelectorAll(".tooltip")
    let tooltips = document.getElementsByClassName("tooltip");
    
    // Busque todos los descendientes de sect1 que tengan la clase "sidebar"
    // Similar a sect1.querySelectorAll(".sidebar")
    let sidebars = sect1.getElementsByClassName("sidebar");</code></pre>
    <p>Al igual que <codeinline>querySelectorAll()</codeinline>, los métodos de este código devuelven un NodeList (excepto <codeinline>getElementById()</codeinline>, que devuelve un único objeto Element). Sin embargo, a diferencia de <codeinline>querySelectorAll()</codeinline>, los NodeLists devueltos por estos métodos de selección más antiguos son "vivos", lo que significa que la longitud y el contenido de la lista pueden cambiar si cambia el contenido o la estructura del documento.</p>
    <p class="title-article text-left">Elementos preseleccionados</p>
    <p>Por razones históricas, la clase Document define propiedades de acceso directo para acceder a ciertos tipos de nodos. Las propiedades <codeinline>images</codeinline>, <codeinline>forms</codeinline> y <codeinline>links</codeinline>, por ejemplo, facilitan el acceso a los elementos <codeinline>&lt;img></codeinline>, <codeinline>&lt;form></codeinline> y <codeinline>&lt;a></codeinline> (pero sólo a las etiquetas <codeinline>&lt;a></codeinline> que tienen un atributo <codeinline>href</codeinline>) de un documento. Estas propiedades hacen referencia a objetos HTMLCollection, que son muy parecidos a los objetos NodeList, pero además pueden indexarse por ID o nombre de elemento. Con la propiedad <codeinline>document.forms</codeinline>, por ejemplo, puede acceder a la etiqueta <codeinline>&lt;form id="address"></codeinline> como:</p>
    <pre class="language-js">
    <code class="language-js">document.forms.address;</code></pre>
    <p>Una API aún más anticuada para seleccionar elementos es la propiedad <codeinline>document.all</codeinline>, que es como una HTMLCollection para todos los elementos del documento. <codeinline>document.all</codeinline> está obsoleta, y ya no deberías usarla.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.2 Estructura y desplazamiento de documentos</h2>
    <p>Una vez seleccionado un elemento de un documento, a veces es necesario encontrar partes del documento relacionadas estructuralmente (padre, hermanos, hijos). Cuando nos interesan principalmente los Elementos de un documento en lugar del texto que contienen (y los espacios en blanco entre ellos, que también son texto), existe una API de navegación que nos permite tratar un documento como un árbol de objetos Elemento, ignorando los nodos de Texto que también forman parte del documento. Esta API de navegación no implica ningún método; es simplemente un conjunto de propiedades de los objetos Elemento que nos permiten referirnos a los padres, hijos y hermanos de un elemento dado:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad de un elemento se refiere al padre del elemento, que será otro Elemento o un objeto Documento.</p>
    <p><codeinline>children</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta NodeList contiene los elementos hijos de un elemento, pero excluye los que no lo son, como los nodos de texto (y los nodos de comentario).</p>
    <p><codeinline>childElementCount</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Número de elementos hijos. Devuelve el mismo valor que <codeinline>children.length</codeinline>.</p>
    <p><codeinline>firstElementChild</codeinline>, <codeinline>lastElementChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren al primer y último elemento hijo de un elemento. Son <codeinline>null</codeinline> si el elemento no tiene elementos hijos.</p>
    <p><codeinline>nextElementSibling</codeinline>, <codeinline>previousElementSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren a los elementos hermanos inmediatamente anteriores o posteriores a un elemento, o a <codeinline>null</codeinline> si no hay ningún elemento hermano.</p>
    <p>Utilizando estas propiedades de Elemento, se puede hacer referencia al segundo Elemento hijo del primer Elemento hijo del Documento con cualquiera de estas expresiones:</p>
    <pre class="language-js">
    <code class="language-js">document.children[0].children[1]
    document.firstElementChild.firstElementChild.nextElementSibling</code></pre>
    <p>(En un documento HTML estándar, ambas expresiones se refieren a la etiqueta <codeinline>&lt;body></codeinline> del documento).</p>
    <p>A continuación se muestran dos funciones que demuestran cómo se pueden utilizar estas propiedades para realizar de forma recurrente un recorrido en profundidad de un documento invocando una función específica para cada elemento del documento:</p>
    <pre class="language-js">
    <code class="language-js">// Recorrer recursivamente el Documento o Elemento e, invocando la 
    // función f en e y en cada uno de sus descendientes
    function traverse(e, f) &lbrace;
      f(e);                            // Invocar f() en e
      for(let child of e.children) &lbrace;   // Iterar sobre los children
        traverse(child, f);            // Y recurre a cada uno
      }
    }
    function traverse2(e, f) &lbrace;
      f(e);                            // Invocar f() en e
      let child = e.firstElementChild; // Iterar el estilo de lista enlazada de niños
      while(child !== null) &lbrace;
        traverse2(child, f);           // Y recursar
        child = child.nextElementSibling;
      }
    }</code></pre>
    <p class="title-article text-left">Documentos como árboles de nodos</p>
    <p>Si desea recorrer un documento o alguna parte del mismo y no quiere ignorar los nodos de Texto, puede utilizar un conjunto diferente de propiedades definidas en todos los objetos Nodo. Esto le permitirá ver Elementos, nodos de Texto e incluso nodos de Comentario (que representan comentarios HTML en el documento).</p>
    <p>Todos los objetos Nodo definen las siguientes propiedades:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nodo que es el padre de éste, o <codeinline>null</codeinline> para nodos como el objeto Documento que no tienen padre.</p>
    <p><codeinline>childNodes</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una NodeList de sólo lectura que contiene todos los hijos (no sólo los hijos del Elemento) del nodo.</p>
    <p><codeinline>firstChild</codeinline>, <codeinline>lastChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El primer y último nodo hijo de un nodo, o <codeinline>null</codeinline> si el nodo no tiene hijos.</p>
    <p><codeinline>nextSibling</codeinline>, <codeinline>previousSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los nodos hermanos siguiente y anterior de un nodo. Estas propiedades conectan nodos en una lista doblemente enlazada.</p>
    <p><codeinline>nodeType</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Un número que especifica de qué tipo de nodo se trata. Los nodos documento tienen valor 9. Los nodos Elemento tienen valor 1. Los nodos de texto tienen valor 3. Los nodos de comentario tienen valor 8.</p>
    <p><codeinline>nodeValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El contenido textual de un nodo Texto o Comentario.</p>
    <p><codeinline>nodeName</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nombre de etiqueta HTML de un elemento, convertido a mayúsculas.</p>
    <p>Utilizando estas propiedades de Nodo, se puede hacer referencia al segundo nodo hijo del primer hijo del Documento con expresiones como estas:</p>
    <pre class="language-js">
    <code class="language-js">document.childNodes[0].childNodes[1]
    document.firstChild.firstChild.nextSibling</code></pre>
    <p>Supongamos que el documento en cuestión es el siguiente:</p>
    <pre class="language-js">
    <code class="language-js">&lt;html>&lt;head>&lt;title>Test&lt;/title>&lt;/head>&lt;body>Hello World!&lt;/body>&lt;/html></code></pre>
    <p>El segundo hijo del primer hijo es el elemento <codeinline>&lt;body></codeinline>. Tiene un <codeinline>nodeType</codeinline> de 1 y un <codeinline>nodeName</codeinline> de "BODY".</p>
    <p>Tenga en cuenta, sin embargo, que esta API es extremadamente sensible a las variaciones en el texto del documento. Si se modifica el documento insertando una sola nueva línea entre el <codeinline>&lt;html></codeinline> y la etiqueta <codeinline>&lt;head></codeinline>, por ejemplo, el nodo Text que representa esa nueva línea se convierte en el primer hijo del primer hijo, y el segundo hijo es el elemento <codeinline>&lt;head></codeinline> en lugar del elemento <codeinline>&lt;body></codeinline>.</p>
    <p>Para demostrar esta API de navegación basada en nodos, he aquí una función que devuelve todo el texto de un elemento o documento:</p>
    <pre class="language-js">
    <code class="language-js">// Devuelve el contenido de texto simple del elemento e, 
    // recurriendo a los elementos secundarios.
    // Este método funciona como la propiedad textContent
    function textContent(e) &lbrace;
      let s = "";                  // Acumula el texto aquí
      for(let child = e.firstChild; child !== null; child = child.nextSibling) &lbrace;
        let type = child.nodeType;
        if (type === 3) &lbrace;          // Si es un nodo de texto
          s += child.nodeValue;    // Añade el contenido de texto a nuestra cadena.
        } else if (type === 1) &lbrace;   // Y si es un nodo Elemento
          s += textContent(child); // luego recurre.
        }
      }
      return s;
    }</code></pre>
    <p>Esta función es sólo una demostración-en la práctica, usted simplemente escribiría <codeinline>e.textContent</codeinline> para obtener el contenido textual del elemento <codeinline>e</codeinline>.</p>
  </section>
  <section id="3-3">
    <h2>15.3.3 Atributos</h2>
    <p>Los elementos HTML constan de un nombre de etiqueta y un conjunto de pares nombre/valor conocidos como <em>atributos</em>. El elemento <codeinline>&lt;a></codeinline> que define un hipervínculo, por ejemplo, utiliza el valor de su atributo <codeinline>href</codeinline> como destino del enlace.</p>
    <p>La clase Element define métodos generales <codeinline>getAttribute()</codeinline>, <codeinline>setAttribute()</codeinline>, <codeinline>hasAttribute()</codeinline> y <codeinline>removeAttribute()</codeinline> para consultar, establecer, comprobar y eliminar los atributos de un elemento. Pero los valores de los atributos de los elementos HTML (para todos los atributos estándar de los elementos HTML estándar) están disponibles como propiedades de los objetos HTMLElement que representan esos elementos, y normalmente es mucho más fácil trabajar con ellos como propiedades de JavaScript que llamar a <codeinline>getAttribute()</codeinline> y métodos relacionados.</p>
    <p class="title-article text-left">Atributos HTML como propiedades de elementos</p>
    <p>Los objetos Element que representan los elementos de un documento HTML suelen definir propiedades de lectura/escritura que reflejan los atributos HTML de los elementos. Elemento define propiedades para los atributos HTML universales como <codeinline>id</codeinline>, <codeinline>title</codeinline>, <codeinline>lang</codeinline> y <codeinline>dir</codeinline> y propiedades de manejador de eventos como <codeinline>onclick</codeinline>. Los subtipos específicos de elementos definen atributos específicos de esos elementos. Para consultar la URL de una imagen, por ejemplo, puede utilizar la propiedad <codeinline>src</codeinline> del HTMLElement que representa al elemento <codeinline>&lt;img></codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let image = document.querySelector("#main_image");
    let url = image.src;      // El atributo src es la URL de la imagen.
    image.id === "main_image" // => true; Nosotros buscamos la imagen por id</code></pre>
    <p>De forma similar, podrías establecer los atributos de envío de formulario de un elemento <codeinline>&lt;form></codeinline> con código como este:</p>
    <pre class="language-js">
    <code class="language-js">let f = document.querySelector("form"); // Primer &lt;form> en el documento
    f.action = "https://www.example.com/submit"; // Establezca la URL a la que enviarlo.
    f.method = "POST";                      // Establezca el tipo de solicitud HTTP.</code></pre>
    <p>Para algunos elementos, como el elemento <codeinline>&lt;input></codeinline>, algunos nombres de atributos HTML corresponden a propiedades con nombres diferentes. El atributo HTML value de un <codeinline>&lt;input></codeinline>, por ejemplo, se refleja en la propiedad JavaScript <codeinline>defaultValue</codeinline>. La propiedad JavaScript <codeinline>value</codeinline> del elemento <codeinline>&lt;input></codeinline> contiene la entrada actual del usuario, pero los cambios en la propiedad <codeinline>value</codeinline> no afectan a la propiedad <codeinline>defaultValue</codeinline> ni al atributo <codeinline>value</codeinline>.</p>
    <p>Los atributos HTML no distinguen entre mayúsculas y minúsculas, pero los nombres de propiedades JavaScript sí. Para convertir un nombre de atributo en una propiedad JavaScript, escríbalo en minúsculas. Sin embargo, si el atributo tiene más de una palabra, ponga la primera letra de cada palabra después de la primera en mayúsculas: <codeinline>defaultChecked</codeinline> y <codeinline>tabIndex</codeinline>, por ejemplo. Sin embargo, las propiedades de controlador de eventos como <codeinline>onclick</codeinline> son una excepción y se escriben en minúsculas.</p>
    <p>Algunos nombres de atributos HTML son palabras reservadas en JavaScript. Para ellos, la regla general es anteponer "html" al nombre de la propiedad. El atributo HTML for (del tipo <codeinline>&lt;label></codeinline>), por ejemplo, se convierte en la propiedad <codeinline>htmlFor</codeinline> de JavaScript. "class" es una palabra reservada en JavaScript, y el importantísimo atributo HTML <codeinline>class</codeinline> es una excepción a la regla: se convierte en <codeinline>className</codeinline> en código JavaScript.</p>
    <p>Las propiedades que representan atributos HTML suelen tener valores de cadena. Pero cuando el atributo es un valor booleano o numérico (los atributos <codeinline>defaultChecked</codeinline> y <codeinline>maxLength</codeinline> de un elemento <codeinline>&lt;input></codeinline>, por ejemplo), las propiedades son booleanas o numéricas en lugar de cadenas. Los atributos de manejador de eventos siempre tienen funciones (o <codeinline>null</codeinline>) como valores.</p>
    <p>Tenga en cuenta que esta API basada en propiedades para obtener y establecer valores de atributos no define ninguna forma de eliminar un atributo de un elemento. En particular, el operador <codeinline>delete</codeinline> no puede utilizarse para este propósito. Si necesita eliminar un atributo, utilice el método <codeinline>removeAttribute()</codeinline>.</p>
    <p id="atributo-class" class="title-article text-left">El atributo de clase</p>
    <p>El atributo <codeinline>class</codeinline> de un elemento HTML es especialmente importante. Su valor es una lista separada por espacios de clases CSS que se aplican al elemento y afectan a su estilo con CSS. Como <codeinline>class</codeinline> es una palabra reservada en JavaScript, el valor de este atributo está disponible a través de la propiedad <codeinline>className</codeinline> en los objetos Element. La propiedad <codeinline>className</codeinline> puede establecer y devolver el valor del atributo <codeinline>class</codeinline> como una cadena. Pero la propiedad <codeinline>class</codeinline> está mal nombrado: su valor es una lista de clases CSS, no una sola clase, y es común en la programación JavaScript del lado del cliente querer añadir y eliminar nombres de clases individuales de esta lista en lugar de trabajar con la lista como una sola cadena.</p>
    <p>Por esta razón, los objetos Element definen una propiedad <codeinline>classList</codeinline> que permite tratar el atributo <codeinline>class</codeinline> como una lista. El valor de la propiedad <codeinline>classList</codeinline> es un objeto iterable tipo Array. Aunque el nombre de la propiedad es <codeinline>classList</codeinline>, se comporta más como un conjunto de clases, y define los métodos <codeinline>add()</codeinline>, <codeinline>remove()</codeinline>, <codeinline>contains()</codeinline> y <codeinline>toggle()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Cuando queremos avisar al usuario de que estamos ocupados,
    // mostramos un indicador. Para ello, debemos eliminar la clase 
    // "hidden" y añadir la clase "animated" (suponiendo que las
    // hojas de estilo estén configuradas correctamente).
    let spinner = document.querySelector("#spinner");
    spinner.classList.remove("hidden");
    spinner.classList.add("animated");</code></pre>
    <p class="title-article text-left">Atributos del conjunto de datos</p>
    <p>A veces resulta útil adjuntar información adicional a elementos HTML, normalmente cuando el código JavaScript va a seleccionar esos elementos y manipularlos de alguna manera. En HTML, cualquier atributo cuyo nombre esté en minúsculas y empiece por el prefijo "data-" se considera válido, y puedes utilizarlos para cualquier propósito. Estos "atributos de conjunto de datos" no afectarán a la presentación de los elementos en los que aparecen, y definen una forma estándar de adjuntar datos adicionales sin comprometer la validez del documento.</p>
    <p>En el DOM, los objetos Element tienen una propiedad <codeinline>dataset</codeinline> que hace referencia a un objeto que tiene propiedades que corresponden a los atributos <codeinline>data-</codeinline> con su prefijo eliminado. Así, <codeinline>dataset.x</codeinline> contendría el valor del atributo <codeinline>data-x</codeinline>. Los atributos con guión se asignan a nombres de propiedad en camelCase: el atributo <codeinline>data-section-number</codeinline> se convierte en la propiedad <codeinline>dataset.sectionNumber</codeinline>.</p>
    <p>Supongamos que un documento HTML contiene este texto:</p>
    <pre class="language-js">
    <code class="language-js">&lt;h2 id="title" data-section-number="16.1">Attributes&lt;/h2></code></pre>
    <p>Entonces podrías escribir JavaScript como este para acceder a ese número de sección:</p>
    <pre class="language-js">
    <code class="language-js">let number = document.querySelector("#title").dataset.sectionNumber;</code></pre>
  </section>
  <section id="3-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.4 Elemento Contenido</h2>
    <p>Observe de nuevo el árbol de documentos de la <a href="#figure15-1">Figura 15-1</a> y pregúntese cuál es el "contenido" del elemento <codeinline>&lt;p></codeinline>. Hay dos formas de responder a esta pregunta:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El contenido es la cadena HTML "Este es un documento &lt;i>simple&lt;/i>".
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El contenido es la cadena de texto plano "This is a simple document".
        </p>
      </li>
    </ul>
    <p>Ambas respuestas son válidas, y cada una de ellas es útil a su manera. Las secciones siguientes explican cómo trabajar con la representación HTML y la representación en texto plano del contenido de un elemento.</p>
    <p class="title-article text-left">Contenido del elemento como HTML</p>
    <p>La lectura de la propiedad <codeinline>innerHTML</codeinline> de un elemento devuelve el contenido de ese elemento como una cadena de marcado. Al establecer esta propiedad en un elemento, se invoca el analizador del navegador web y se sustituye el contenido actual del elemento por una representación analizada de la nueva cadena. Puedes probarlo abriendo la consola de desarrollo y escribiendo:</p>
    <pre class="language-js">
    <code class="language-js">document.body.innerHTML = "&lt;h1>Oops&lt;/h1>";</code></pre>
    <p>Verá que toda la página web desaparece y es sustituida por el encabezado "Oops". Los navegadores web son muy buenos analizando HTML, y establecer <codeinline>innerHTML</codeinline> suele ser bastante eficiente. Tenga en cuenta, sin embargo, que añadir texto a la propiedad <codeinline>innerHTML</codeinline> con el operador <codeinline>+=</codeinline> no es eficiente porque requiere un paso de serialización para convertir el contenido del elemento en una cadena y luego un paso de análisis para convertir la nueva cadena de nuevo en contenido del elemento.</p>
    <nota>
      <img class="self-start" src="/public/javascript/nota_warning.svg" alt="Nota de la warning">
      <div class="">
        <p>Cuando utilices estas API HTML, es muy importante que nunca introduzcas datos del usuario en el documento. Si lo hace, permitirá que usuarios malintencionados inyecten sus propios scripts en su aplicación. Consulte <a href="#cross-site">"Cross-site scripting"</a> para más detalles.</p>
      </div>
    </nota>
    <p>La propiedad <codeinline>outerHTML</codeinline> de un elemento es como <codeinline>innerHTML</codeinline>, salvo que su valor incluye el propio elemento. Cuando se consulta <codeinline>outerHTML</codeinline>, el valor incluye las etiquetas de apertura y cierre del elemento. Y cuando estableces <codeinline>outerHTML</codeinline> en un elemento, el nuevo contenido sustituye al propio elemento.</p>
    <p>Un método relacionado con Element es <codeinline>insertAdjacentHTML()</codeinline>, que permite insertar una cadena de código HTML arbitraria "adyacente" al elemento especificado. La marca se pasa como segundo argumento a este método, y el significado exacto de "adyacente" depende del valor del primer argumento. Este primer argumento debe ser una cadena con uno de los valores "beforebegin", "afterbegin", "beforeend" o "afterend". Estos valores corresponden a los puntos de inserción que se ilustran en la <a href="#figure15-2">Figura 15-2</a>.</p>
    <figure id="figure15-2">
      <img src="/public/javascript/capitulo-15/figure15-2.avif" alt="imagen de consola">
      <figcaption>Figura 15-2. Puntos de inserción para insertAdjacentHTML()</figcaption>
    </figure>
    <p class="title-article text-left">Contenido del elemento como texto sin formato</p>
    <p>A veces se desea consultar el contenido de un elemento como texto sin formato o insertar texto sin formato en un documento (sin tener que escapar los corchetes angulares y los ampersands utilizados en el marcado HTML). La forma estándar de hacerlo es con la propiedad <codeinline>textContent</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let para = document.querySelector("p"); // Primero &lt;p> en el documento
    let text = para.textContent;            // Obtener el texto del párrafo
    para.textContent = "Hello World!";      // Alterar el texto del párrafo</code></pre>
    <p>La propiedad <codeinline>textContent</codeinline> está definida por la clase Node, por lo que funciona tanto para nodos Text como para nodos Element. Para los nodos Elemento, encuentra y devuelve todo el texto en todos los descendientes del elemento.</p>
    <p>La clase Element define una propiedad <codeinline>innerText</codeinline> que es similar a <codeinline>textContent</codeinline>. <codeinline>innerText</codeinline> tiene algunos comportamientos inusuales y complejos, como intentar preservar el formato de tabla. Sin embargo, no está bien especificada ni implementada de forma compatible entre navegadores, por lo que no debería seguir utilizándose.</p>
    <article>
      <p class="title-article">Texto en elementos &lt;script></p>
      <p>Los elementos <codeinline>&lt;script></codeinline> en línea (es decir, los que no tienen un atributo <codeinline>src</codeinline>) tienen una propiedad <codeinline>text</codeinline> que puede utilizarse para recuperar su texto. El navegador nunca muestra el contenido de un elemento <codeinline>&lt;script></codeinline>, y el analizador HTML ignora los corchetes angulares y los ampersands dentro de un script. Esto hace que un elemento <codeinline>&lt;script></codeinline> sea un lugar ideal para incrustar datos textuales arbitrarios para su uso en la aplicación. Basta con establecer el atributo <codeinline>type</codeinline> del elemento en algún valor (como "text/x-custom-data") que deje claro que el script no es código JavaScript ejecutable. Si hace esto, el intérprete de JavaScript ignorará el script, pero el elemento existirá en el árbol del documento, y su propiedad <codeinline>text</codeinline> le devolverá los datos.</p>
    </article>
  </section>
  <section id="3-5">
    <h2>15.3.5 Creación, inserción y supresión de nodos</h2>
    <p>Hemos visto cómo consultar y alterar el contenido de un documento utilizando cadenas de HTML y de texto plano. Y también hemos visto que podemos recorrer un documento para examinar los nodos individuales de Elemento y Texto que lo componen. También es posible alterar un documento a nivel de nodos individuales. La clase Document define métodos para crear objetos Element, y los objetos Element y Text tienen métodos para insertar, borrar y reemplazar nodos en el árbol.</p>
    <p>Crea un nuevo elemento con el método <codeinline>createElement()</codeinline> de la clase Document y añádele cadenas de texto u otros elementos con sus métodos <codeinline>append()</codeinline> y <codeinline>prepend()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let paragraph = document.createElement("p"); // Crear un elemento &lt;p> vacío
    let emphasis = document.createElement("em"); // Crear un elemento &lt;em> vacío
    emphasis.append("World");                    // Agregar texto al elemento &lt;em>
    paragraph.append("Hello ", emphasis, "!");   // Añade texto y &lt;em> a &lt;p>
    paragraph.prepend("¡");                      // Añadir más texto al inicio de &lt;p>
    paragraph.innerHTML                          // => "¡Hello &lt;em>World&lt;/em>!"</code></pre>
    <p><codeinline>append()</codeinline> y <codeinline>prepend()</codeinline> toman cualquier número de argumentos, que pueden ser objetos Nodo o cadenas. Los argumentos de cadena se convierten automáticamente en nodos de texto. (Se pueden crear nodos de texto explícitamente con <codeinline>document.createTextNode()</codeinline>, pero rara vez hay razón para hacerlo). <codeinline>append()</codeinline> añade los argumentos al elemento al final de la lista hija. <codeinline>prepend()</codeinline> añade los argumentos al principio de la lista hija.</p>
    <p>Si desea insertar un nodo Elemento o Texto en medio de la lista de hijos del elemento contenedor, ni <codeinline>append()</codeinline> ni <codeinline>prepend()</codeinline> funcionarán. En este caso, debe obtener una referencia a un nodo hermano y llamar a <codeinline>before()</codeinline> para insertar el nuevo contenido antes de ese hermano o <codeinline>after()</codeinline> para insertarlo después de ese hermano. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// Encuentra el elemento de encabezado con clase="greetings"
    let greetings = document.querySelector("h2.greetings");
    // Ahora inserte el nuevo párrafo y una regla horizontal después de ese encabezado.
    greetings.after(paragraph, document.createElement("hr"));</code></pre>
    <p>Al igual que <codeinline>append()</codeinline> y <codeinline>prepend()</codeinline>, <codeinline>after()</codeinline> y <codeinline>before()</codeinline> toman cualquier número de argumentos de cadena y elemento y los insertan todos en el documento después de convertir las cadenas en nodos de Texto. <codeinline>append()</codeinline> y <codeinline>prepend()</codeinline> sólo se definen en objetos Elemento, pero <codeinline>after()</codeinline> y <codeinline>before()</codeinline> funcionan tanto en nodos Elemento como Texto: puede utilizarlas para insertar contenido relativo a un nodo Texto.</p>
    <p>Tenga en cuenta que los elementos sólo pueden insertarse en un punto del documento. Si un elemento ya está en el documento y lo insertas en otro lugar, se moverá a la nueva ubicación, no se copiará:</p>
    <pre class="language-js">
    <code class="language-js">// Insertamos el párrafo después de este elemento, pero ahora 
    // lo movemos para que aparezca antes del elemento.
    greetings.before(paragraph);</code></pre>
    <p>Si desea hacer una copia de un elemento, utilice el método <codeinline>cloneNode()</codeinline>, pasando <codeinline>true</codeinline> para copiar todo su contenido:</p>
    <pre class="language-js">
    <code class="language-js">// Haz una copia del párrafo e insértalo después del elemento de saludos.
    greetings.after(paragraph.cloneNode(true));</code></pre>
    <p>Puede eliminar un nodo Elemento o Texto del documento llamando a su método <codeinline>remove()</codeinline>, o puede reemplazarlo llamando a <codeinline>replaceWith()</codeinline> en su lugar. <codeinline>remove()</codeinline> no toma argumentos, y <codeinline>replaceWith()</codeinline> toma cualquier número de cadenas y elementos al igual que <codeinline>before()</codeinline> y <codeinline>after()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Elimina el elemento de saludos del documento y reemplázalo con el 
    // elemento de párrafo (moviendo el párrafo de su ubicación 
    // actual si ya está insertado en el documento).
    greetings.replaceWith(paragraph);
    // And now remove the paragraph.
    paragraph.remove();</code></pre>
    <p>La API DOM también define una generación anterior de métodos para insertar y eliminar contenido. <codeinline>appendChild()</codeinline>, <codeinline>insertBefore()</codeinline>, <codeinline>replaceChild()</codeinline> y <codeinline>removeChild()</codeinline> son más difíciles de usar que los métodos mostrados aquí y nunca deberían ser necesarios.</p>
  </section>
  <section id="3-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.6 Ejemplo: Generación de un índice</h2>
    <p>El <a href="#ejemplo15-1">Ejemplo 15-1</a> muestra cómo crear dinámicamente una tabla de contenidos para un documento. Demuestra muchas de las técnicas de scripting de documentos descritas en las secciones anteriores. El ejemplo está bien comentado, y no debería tener problemas para seguir el código.</p>
    <p id="ejemplo15-1"><em>Ejemplo 15-1. Generación de una tabla de contenidos con la API DOM</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * TOC.js: crear una tabla de contenido para un documento.
    *
    * Este script se ejecuta cuando se activa el evento DOMContentLoaded 
    * y genera automáticamente una tabla de contenidos para el documento.
    * No define ningún símbolo global, por lo que no debería entrar en
    * conflicto con otros scripts.
    *
    * Cuando se ejecuta este script, primero busca un elemento de documento
    * con un id de "TOC". Si no existe dicho elemento, crea uno al comienzo
    * del documento. A continuación, la función encuentra todas las
    * etiquetas de &lt;h2> a &lt;h6>, las trata como títulos de sección y
    * crea una tabla de contenidos dentro del elemento TOC. La función
    * agrega números de sección a cada encabezado de sección y envuelve los
    * encabezados en anclas con nombre para que la tabla de contenidos
    * pueda vincularse a ellos. Las anclas generadas tienen nombres que
    * comienzan con "TOC", por lo que debe evitar este prefijo en su propio
    * HTML.
    *
    * Las entradas de la TOC se pueden estilizar con CSS. Todas las entradas
    * tienen una clase "TOCEntry". Las entradas también tienen una clase que
    * corresponde al nivel del encabezado de la sección. Las etiquetas &lt;h1>
    * generan entradas de la clase "TOCLevel1", las etiquetas &lt;h2> generan
    * entradas de la clase "TOCLevel2", y así sucesivamente. Los números de
    * sección insertados en los encabezados tienen la clase "TOCSectNum".
    *
    * Puedes usar este script con una hoja de estilo como esta:
    *
    * #TOC &lbrace; border: solid black 1px; margin: 10px; padding: 10px; }
    * .TOCEntry &lbrace; margin: 5px 0px; }
    * .TOCEntry a &lbrace; text-decoration: none; }
    * .TOCLevel1 &lbrace; font-size: 16pt; font-weight: bold; }
    * .TOCLevel2 &lbrace; font-size: 14pt; margin-left: .25in; }
    * .TOCLevel3 &lbrace; font-size: 12pt; margin-left: .5in; }
    * .TOCSectNum:after &lbrace; content: ": "; }
    *
    * Para ocultar los números de sección, use esto:
    *
    * .TOCSectNum &lbrace; display: none }
    **/
    document.addEventListener("DOMContentLoaded", () => &lbrace;
      // Encuentre el elemento contenedor de TOC.
      // Si no hay uno, cree uno al comienzo del documento.
      let toc = document.querySelector("#TOC");
      if (!toc) &lbrace;
        toc = document.createElement("div");
        toc.id = "TOC";
        document.body.prepend(toc);
      }

      // Encuentra todos los elementos de encabezado de sección. Suponemos 
      // que el título del documento utiliza &lt;h1> y que las secciones
      // dentro del documento están marcadas con &lt;h2> a &lt;h6>.
      let headings = document.querySelectorAll("h2,h3,h4,h5,h6");

      // Inicializar una matriz que realiza un seguimiento de los números de sección.
      let sectionNumbers = [0,0,0,0,0];

      // Ahora recorra los elementos del encabezado de sección que encontramos.
      for(let heading of headings) &lbrace;
        // Omita el encabezado si está dentro del contenedor TOC.
        if (heading.parentNode === toc) &lbrace;
          continue;
        }

        // Averigua en qué nivel se encuentra el título.
        // Restar 1 porque &lt;h2> es un encabezado de nivel 1.
        let level = parseInt(heading.tagName.charAt(1)) - 1;

        // Incrementa el número de sección para este nivel de encabezado
        // y restablece todos los números de niveles de encabezado inferiores a cero.
        sectionNumbers[level-1]++;
        for(let i = level; i &lt; sectionNumbers.length; i++) &lbrace;
          sectionNumbers[i] = 0;
        }

        // Ahora combine los números de sección para todos los niveles
        // de encabezado para producir un número de sección como 2.3.1.
        let sectionNumber = sectionNumbers.slice(0, level).join(".");

        // Agregamos el número de sección al título del encabezado
        // de sección. Colocamos el número entre paréntesis para
        // que se pueda modificar su estilo.
        let span = document.createElement("span");
        span.className = "TOCSectNum";
        span.textContent = sectionNumber;
        heading.prepend(span);

        // Envuelva el encabezado en un ancla con nombre para que
        // podamos vincularlo.
        let anchor = document.createElement("a");
        let fragmentName = `TOC$&lbrace;sectionNumber}`;
        anchor.name = fragmentName;
        heading.before(anchor);         // Insertar ancla antes de dirigirse
        anchor.append(heading);         // y mover el rumbo dentro del ancla

        // Ahora crea un enlace a esta sección.
        let link = document.createElement("a");
        link.href = `#$&lbrace;fragmentName}`; // Destino del enlace

        // Copia el texto del encabezado en el enlace. Este es
        // un uso seguro de innerHTML porque no estamos
        // insertando cadenas que no sean de confianza.
        link.innerHTML = heading.innerHTML;

        // Coloque el enlace en un div que se pueda diseñar según el nivel.
        let entry = document.createElement("div");
        entry.classList.add("TOCEntry", `TOCLevel$&lbrace;level}`);
        entry.append(link);

        // Y agrega el div al contenedor TOC.
        toc.append(entry);
      }
    });</code></pre>
  </section>
  <section id="4">
    <h2>15.4 Secuencias de comandos CSS</h2>
    <p>Hemos visto que JavaScript puede controlar la estructura lógica y el contenido de los documentos HTML. También puede controlar la apariencia visual y el diseño de esos documentos mediante scripts CSS. Las siguientes subsecciones explican algunas técnicas diferentes que el código JavaScript puede utilizar para trabajar con CSS.</p>
    <p>Este es un libro sobre JavaScript, no sobre CSS, y esta sección asume que ya tienes un conocimiento práctico de cómo se usa CSS para dar estilo al contenido HTML. Pero vale la pena mencionar algunos de los estilos CSS que comúnmente se escriben desde JavaScript:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Al establecer el estilo de <codeinline>display</codeinline> en "none" se oculta un elemento. Más adelante podrá mostrar el elemento asignando a <codeinline>display</codeinline> otro valor.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede posicionar elementos dinámicamente estableciendo el estilo de <codeinline>position</codeinline> en "absoluto", "relativo" o "fijo" y, a continuación, estableciendo los estilos <codeinline>top</codeinline> e <codeinline>left</codeinline> en las coordenadas deseadas. Esto es importante cuando se utiliza JavaScript para mostrar contenido dinámico, como diálogos modales y descripciones emergentes.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede desplazar, escalar y rotar elementos con el estilo de <codeinline>transform</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede animar los cambios de otros estilos CSS con el estilo de transición. Estas animaciones son manejadas automáticamente por el navegador web y no requieren JavaScript, pero puede utilizar JavaScript para iniciar las animaciones.
        </p>
      </li>
    </ul>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.1 Clases de CSS</h2>
    <p>La forma más sencilla de utilizar JavaScript para afectar al estilo del contenido del documento es añadir y eliminar nombres de clases CSS del atributo <codeinline>class</codeinline> de las etiquetas HTML. Esto es fácil de hacer con la propiedad <codeinline>classList</codeinline> de los objetos Element, como se explica en <a href="#atributo-class">"El atributo class"</a>.</p>
    <p>Supongamos, por ejemplo, que la hoja de estilo de su documento incluye una definición para una clase "oculta":</p>
    <pre class="language-js">
    <code class="language-js">.hidden &lbrace;
      display:none;
    }</code></pre>
    <p>Con este estilo definido, puede ocultar (y luego mostrar) un elemento con código como este:</p>
    <pre class="language-js">
    <code class="language-js">// Supongamos que este elemento "tooltip" tiene clase="hidden" en el archivo HTML.
    // Podemos hacerlo visible así:
    document.querySelector("#tooltip").classList.remove("hidden");

    // Y podemos volver a ocultarlo así:
    document.querySelector("#tooltip").classList.add("hidden");</code></pre>
  </section>
  <section id="4-2">
    <h2>15.4.2 Estilos en línea</h2>
    <p>Siguiendo con el ejemplo anterior, supongamos que el documento está estructurado con un único elemento tooltip y queremos posicionarlo dinámicamente antes de mostrarlo. En general, no podemos crear una clase de hoja de estilo diferente para cada posición posible de la información sobre herramientas, por lo que la propiedad <codeinline>classList</codeinline> no nos ayudará con el posicionamiento.</p>
    <p>En este caso, necesitamos programar el atributo <codeinline>style</codeinline> del elemento tooltip para establecer estilos en línea específicos para ese elemento. El DOM define una propiedad <codeinline>style</codeinline> en todos los objetos Element que corresponde al atributo <codeinline>style</codeinline>. Sin embargo, a diferencia de la mayoría de estas propiedades, , la propiedad <codeinline>style</codeinline> no es una cadena. En su lugar, es un objeto CSSStyleDeclaration: una representación analizada de los estilos CSS que aparecen en forma textual en el atributo <codeinline>style</codeinline>. Para mostrar y establecer la posición de nuestro hipotético tooltip con Java-Script, podríamos utilizar código como este:</p>
    <pre class="language-js">
    <code class="language-js">function displayAt(tooltip, x, y) &lbrace;
      tooltip.style.display = "block";
      tooltip.style.position = "absolute";
      tooltip.style.left = `$&lbrace;x}px`;
      tooltip.style.top = `$&lbrace;y}px`;
    }</code></pre>
    <article>
      <p class="title-article"></p>
      <p>Muchas propiedades de estilo CSS, como <codeinline>font-size</codeinline>, contienen guiones en sus nombres. En JavaScript, un guión se interpreta como un signo menos y no está permitido en nombres de propiedades u otros identificadores. Por lo tanto, los nombres de las propiedades del objeto CSSStyleDeclaration son ligeramente diferentes de los nombres de las propiedades CSS reales. Si el nombre de una propiedad CSS contiene uno o más guiones, el nombre de la propiedad CSSStyleDeclaration se forma eliminando los guiones y poniendo en mayúscula la letra que sigue inmediatamente a cada guión. Por ejemplo, se accede a la propiedad CSS <codeinline>border-left-width</codeinline> a través de la propiedad JavaScript borderLeftWidth, y la propiedad CSS <codeinline>font-family</codeinline> se escribe como <codeinline>fontFamily</codeinline> en JavaScript.</p>
    </article>
    <p>Cuando trabaje con las propiedades de estilo del objeto CSSStyleDeclaration, recuerde que todos los valores deben especificarse como cadenas. En una hoja de estilo o atributo de <codeinline>style</codeinline>, puede escribir:</p>
    <pre class="language-js">
    <code class="language-js">display: block; font-family: sans-serif; background-color: #ffffff;</code></pre>
    <p>Para conseguir lo mismo para un elemento e con JavaScript, hay que citar todos los valores:</p>
    <pre class="language-js">
    <code class="language-js">e.style.display = "block";
    e.style.fontFamily = "sans-serif";
    e.style.backgroundColor = "#ffffff";</code></pre>
    <p>Tenga en cuenta que los puntos y coma van fuera de las cadenas. Se trata de puntos y comas normales de JavaScript; los puntos y comas que se utilizan en las hojas de estilo CSS no son necesarios como parte de los valores de cadena que se establecen con JavaScript.</p>
    <p>Además, recuerde que muchas propiedades CSS requieren unidades como "px" para píxeles o "pt" para puntos. Por lo tanto, no es correcto establecer la propiedad <codeinline>marginLeft</codeinline> así:</p>
    <pre class="language-js">
    <code class="language-js">e.style.marginLeft = 300;   // Incorrect: Esto es un número, no un string.
    e.style.marginLeft = "300"; // Incorrect: Faltan las unidades</code></pre>
    <p>Las unidades son necesarias cuando se establecen propiedades de estilo en JavaScript, al igual que cuando se establecen propiedades de estilo en hojas de estilo. La forma correcta de establecer el valor de la propiedad <codeinline>marginLeft</codeinline> de un elemento e a 300 píxeles es:</p>
    <pre class="language-js">
    <code class="language-js">e.style.marginLeft = "300px";</code></pre>
    <p>Si desea establecer una propiedad CSS en un valor calculado, asegúrese de añadir las unidades al final del cálculo:</p>
    <pre class="language-js">
    <code class="language-js">e.style.left = `$&lbrace;x0 + left_border + left_padding}px`;</code></pre>
    <p>Recuerde que algunas propiedades CSS, como <codeinline>margin</codeinline>, son atajos para otras propiedades, como <codeinline>margin-top</codeinline>, <codeinline>margin-right</codeinline>, <codeinline>margin-bottom</codeinline> y <codeinline>margin-left</codeinline>. El objeto CSSStyleDeclaration tiene propiedades que corresponden a estas propiedades de acceso directo. Por ejemplo, puede establecer la propiedad <codeinline>margin</codeinline> de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">e.style.margin = `$&lbrace;top}px $&lbrace;right}px $&lbrace;bottom}px $&lbrace;left}px`;</code></pre>
    <p>A veces, puede resultar más fácil establecer o consultar el estilo en línea de un elemento como un único valor de cadena en lugar de como un objeto CSSStyleDeclaration. Para ello, puede utilizar los métodos <codeinline>getAttribute()</codeinline> y <codeinline>setAttribute()</codeinline> de Element, o puede utilizar la propiedad <codeinline>cssText</codeinline> del objeto CSSStyleDeclaration:</p>
    <pre class="language-js">
    <code class="language-js">// Copiar los estilos en línea del elemento e al elemento f:
    f.setAttribute("style", e.getAttribute("style"));

    // O hazlo así:
    f.style.cssText = e.style.cssText;</code></pre>
    <p>Cuando consultes la propiedad <codeinline>style</codeinline> de un elemento, ten en cuenta que sólo representa los estilos en línea de un elemento y que la mayoría de los estilos de la mayoría de los elementos se especifican en hojas de estilo en lugar de en línea. Además, los valores que obtenga al consultar la propiedad <codeinline>style</codeinline> utilizarán las unidades y el formato de propiedad abreviada que se utilicen en el atributo HTML, y es posible que el código tenga que realizar un análisis sintáctico sofisticado para interpretarlos. En general, si quieres consultar los estilos de un elemento, probablemente quieras el <em>estilo computado</em>, que se discute a continuación.</p>
  </section>
  <section id="4-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.3 Estilos calculados</h2>
    <p>El estilo calculado para un elemento es el conjunto de valores de propiedad que el navegador deriva (o calcula) a partir del estilo en línea del elemento más todas las reglas de estilo aplicables en todas las hojas de estilo: es el conjunto de propiedades realmente utilizadas para mostrar el elemento. Al igual que los estilos en línea, los estilos calculados se representan con un objeto CSSStyleDeclaration. Sin embargo, a diferencia de los estilos en línea, los estilos computados son de sólo lectura. No puedes establecer estos estilos, pero el objeto CSSStyleDeclaration computado para un elemento te permite determinar qué valores de propiedades de estilo utilizó el navegador al renderizar ese elemento.</p>
    <p>Obtenga el estilo calculado para un elemento con el método <codeinline>getComputedStyle()</codeinline> del objeto Window. El primer argumento de este método es el elemento cuyo estilo calculado se desea obtener. El segundo argumento opcional se utiliza para especificar un pseudoelemento CSS, como "::before" o "::after":</p>
    <pre class="language-js">
    <code class="language-js">let title = document.querySelector("#section1title");
    let styles = window.getComputedStyle(title);
    let beforeStyles = window.getComputedStyle(title, "::before");</code></pre>
    <p>El valor de retorno de <codeinline>getComputedStyle()</codeinline> es un objeto CSSStyleDeclaration que representa todos los estilos que se aplican al elemento (o pseudoelemento) especificado. Hay varias diferencias importantes entre un objeto CSSStyleDeclaration que representa estilos en línea y uno que representa estilos calculados:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las propiedades de estilo calculadas son de sólo lectura.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las propiedades de estilo calculadas son <em>absolutas</em>: las unidades relativas como porcentajes y puntos se convierten en valores absolutos. Cualquier propiedad que especifique un tamaño (como un tamaño de margen o un tamaño de fuente) tendrá un valor medido en píxeles. Este valor será una cadena con un sufijo "px", por lo que tendrá que analizarlo, pero no tendrá que preocuparse de analizar o convertir otras unidades. Las propiedades cuyos valores sean colores se devolverán en formato "rgb()" o "rgba()"
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las propiedades de acceso directo no se calculan, sólo las propiedades fundamentales en las que se basan. Por ejemplo, no consulte la propiedad <codeinline>margin</codeinline>, sino <codeinline>marginLeft</codeinline>, <codeinline>marginTop</codeinline>, etc. Del mismo modo, no consulte <codeinline>border</codeinline> ni siquiera <codeinline>borderWidth</codeinline>. En su lugar, utilice <codeinline>borderLeftWidth</codeinline>, <codeinline>borderTopWidth</codeinline>, etc.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La propiedad <codeinline>cssText</codeinline> del estilo calculado no está definida.
        </p>
      </li>
    </ul>
    <p>Un objeto CSSStyleDeclaration devuelto por <codeinline>getComputedStyle()</codeinline> generalmente contiene mucha más información sobre un elemento que la CSSStyleDeclaration obtenida de la propiedad de <codeinline>style</codeinline> en línea de ese elemento. Pero los estilos calculados pueden ser complicados, y su consulta no siempre proporciona la información que cabría esperar. Considere el atributo <codeinline>font-family</codeinline>: acepta una lista separada por comas de las familias de fuentes deseadas para la portabilidad entre plataformas. Cuando se consulta la propiedad <codeinline>fontFamily</codeinline> de un estilo calculado, simplemente se obtiene el valor del estilo <codeinline>font-family</codeinline> más específico que se aplica al elemento. Esto puede devolver un valor como "arial,helvetica,sans-serif", que no le dice qué tipo de letra está realmente en uso. Del mismo modo, si un elemento no tiene una posición absoluta, al intentar consultar su posición y tamaño a través de las propiedades <codeinline>top</codeinline> y <codeinline>left</codeinline> de su estilo calculado, a menudo se obtiene el valor <codeinline>auto</codeinline>. Este es un valor CSS perfectamente legal, pero probablemente no es lo que estabas buscando.</p>
    <p>Aunque CSS puede utilizarse para especificar con precisión la posición y el tamaño de los elementos del documento, consultar el estilo calculado de un elemento no es la forma preferida de determinar el tamaño y la posición del elemento. Véase <a href="#5-2">§15.5.2</a> para una alternativa más sencilla y portable.</p>
  </section>
  <section id="4-4">
    <h2>15.4.4 Hojas de estilo de secuencias de comandos</h2>
    <p>Además de programar atributos de clase y estilos en línea, JavaScript también puede manipular las propias hojas de estilo. Las hojas de estilo se asocian a un documento HTML con un atributo <codeinline>&lt;style></codeinline> o con una etiqueta <codeinline>&lt;link rel="stylesheet"></codeinline>. Ambas son etiquetas HTML normales, por lo que puedes darles ambos atributos <codeinline>id</codeinline> y luego buscarlas con <codeinline>document.querySelector()</codeinline>.</p>
    <p>Los objetos Element para las etiquetas <codeinline>&lt;style></codeinline> y <codeinline>&lt;link></codeinline> tienen una propiedad <codeinline>disabled</codeinline> que puedes usar para desactivar toda la hoja de estilos. Podrías usarla con código como este:</p>
    <pre class="language-js">
    <code class="language-js">// Esta función cambia entre los temas "claro" y "oscuro".
    function toggleTheme() &lbrace;
      let lightTheme = document.querySelector("#light-theme");
      let darkTheme = document.querySelector("#dark-theme");
      if (darkTheme.disabled) &lbrace; // Actualmente claro, cambiar a oscuro
        lightTheme.disabled = true;
        darkTheme.disabled = false;
      } else &lbrace;                  // Actualmente oscuro, cambiar a claro
        lightTheme.disabled = false;
        darkTheme.disabled = true;
      }
    }</code></pre>
    <p>Otra forma sencilla de programar hojas de <codeinline>style</codeinline> es insertar otras nuevas en el documento utilizando las técnicas de manipulación del DOM que ya hemos visto. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">function setTheme(name) &lbrace;
      // Cree un nuevo elemento &lt;link rel="stylesheet"> para cargar la hoja de estilo nombrada
      let link = document.createElement("link");
      link.id = "theme";
      link.rel = "stylesheet";
      link.href = `themes/$&lbrace;name}.css`;
      
      // Busque un enlace existente con id "theme"
      let currentTheme = document.querySelector("#theme");
      if (currentTheme) &lbrace;
        // Si hay un tema existente, reemplácelo por el nuevo.
        currentTheme.replaceWith(link);
      } else &lbrace;
        // De lo contrario, simplemente inserte el enlace a la hoja de estilos del tema.
        document.head.append(link);
      }
    }</code></pre>
    <p>De forma menos sutil, también puedes simplemente insertar una cadena de HTML que contenga una etiqueta <codeinline>&lt;style></codeinline> en tu documento. Este es un truco divertido, por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">document.head.insertAdjacentHTML(
      "beforeend",
      "&lt;style>body&lbrace;transform:rotate(180deg)}&lt;/style>"
    );</code></pre> 
    <p>Los navegadores definen una API que permite a JavaScript mirar dentro de las hojas de estilo para consultar, modificar, insertar y eliminar reglas de estilo en esa hoja de estilo. Esta API es tan especializada que no está documentada aquí. Puedes leer sobre ella en MDN buscando "CSSStyleSheet" y "CSS Object Model".</p>
  </section>
  <section id="4-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.5 Animaciones y eventos CSS</h2>
    <p>Suponga que tiene las dos clases CSS siguientes definidas en una hoja de estilos:</p>
    <pre class="language-js">
    <code class="language-js">.transparent &lbrace; opacity: 0; }
    .fadeable &lbrace; transition: opacity .5s ease-in }</code></pre>
    <p>Si aplicas el primer estilo a un elemento, será totalmente transparente y, por tanto, invisible. Pero si aplicas el segundo estilo que indica al navegador que cuando la opacidad del elemento cambie, ese cambio debe ser animado durante un periodo de 0,5 segundos, "ease-in" especifica que la animación del cambio de opacidad debe empezar lentamente y luego acelerarse.</p>
    <p>Suponga ahora que su documento HTML contiene un elemento con la clase "fadeable":</p>
    <pre class="language-js">
    <code class="language-js">&lt;div id="subscribe" class="fadeable notification">...&lt;/div></code></pre>
    <p>En JavaScript, puede añadir la clase "transparente":</p>
    <pre class="language-js">
    <code class="language-js">document.querySelector("#subscribe").classList.add("transparent");</code></pre>
    <p>Este elemento está configurado para animar los cambios de opacidad. Al añadir la clase "transparent", cambia la opacidad y se activa una animación: el navegador "desvanece" el elemento para que se vuelva totalmente transparente en un periodo de medio segundo.</p>
    <p>Esto también funciona a la inversa: si elimina la clase "transparente" de un elemento "atenuable", también se produce un cambio de opacidad, y el elemento se atenúa y vuelve a ser visible.</p>
    <p>JavaScript no tiene que hacer ningún trabajo para que se produzcan estas animaciones: son un efecto CSS puro. Pero JavaScript puede utilizarse para activarlas.</p>
    <p>JavaScript también puede utilizarse para controlar el progreso de una transición CSS, ya que el navegador web dispara eventos al inicio y al final de una transición. El evento "transitionrun" se envía cuando la transición se activa por primera vez. Esto puede ocurrir antes de que comiencen los cambios visuales, cuando se ha especificado el estilo <codeinline>transition-delay</codeinline>. Una vez que comienzan los cambios visuales, se envía un evento "transitionstart", y cuando la animación ha terminado, se envía un evento "transitionend". El objetivo de todos estos eventos es, por supuesto, el elemento animado. El objeto que se pasa a los manejadores de estos eventos es un objeto TransitionEvent. Tiene una propiedad <codeinline>propertyName</codeinline> que especifica la propiedad CSS que se está animando y una propiedad <codeinline>elapsedTime</codeinline> que para los eventos "transitionend" especifica cuántos segundos han pasado desde el evento "transitionstart".</p>
    <p>Además de las transiciones, CSS también admite una forma más compleja de animación conocida simplemente como "Animaciones CSS". Éstas utilizan propiedades CSS como <codeinline>animation-name</codeinline> y <codeinline>animation-duration</codeinline> y una regla especial <codeinline>@keyframes</codeinline> para definir los detalles de la animación. Los detalles de cómo funcionan las animaciones CSS están más allá del alcance de este libro, pero una vez más, si defines todas las propiedades de animación en una clase CSS, entonces puedes utilizar JavaScript para activar la animación simplemente añadiendo la clase al elemento que se va a animar.</p>
    <p>Al igual que las transiciones CSS, las animaciones CSS también activan eventos que tu código JavaScript puede escuchar. El evento "animationstart" se envía cuando comienza la animación, y el evento "animationend" se envía cuando finaliza. Si la animación se repite más de una vez, se envía un evento "animationiteration" después de cada repetición excepto la última. El objetivo del evento es el elemento animado, y el objeto del evento que se pasa a las funciones de control es un objeto AnimationEvent. Estos eventos incluyen una propiedad <codeinline>animationName</codeinline> que especifica la propiedad <codeinline>animation-name</codeinline> que define la animación y una propiedad <codeinline>elapsedTime</codeinline> que especifica cuántos segundos han pasado desde que comenzó la ani- mación.</p>
  </section>
  <section id="5">
    <h2>15.5 Geometría del documento y desplazamiento</h2>
    <p>Hasta ahora, en este capítulo hemos pensado en los documentos como árboles abstractos de elementos y nodos de texto. Pero cuando un navegador renderiza un documento dentro de una ventana, crea una representación visual del documento en la que cada elemento tiene una posición y un tamaño. A menudo, las aplicaciones web pueden tratar los documentos como árboles de elementos y no tener que pensar nunca en cómo se representan esos elementos en pantalla. A veces, sin embargo, es necesario determinar la geometría precisa de un elemento. Si, por ejemplo, quieres usar CSS para posicionar dinámicamente un elemento (como un tooltip) junto a algún elemento posicionado por el navegador, necesitas ser capaz de determinar la localización de ese elemento.</p>
    <p>Las siguientes subsecciones explican cómo se puede ir y venir entre el <em>modelo</em> abstracto, basado en árboles, de un documento y la vista geométrica, basada en coordenadas, del documento tal y como se presenta en una <em>ventana</em> del navegador.</p>
  </section>
  <section id="5-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.1 Coordenadas del documento y coordenadas de la ventana gráfica</h2>
    <p>La posición de un elemento del documento se mide en píxeles CSS, con la coordenada <em>x</em> aumentando hacia la derecha y la coordenada y aumentando a medida que bajamos. Sin embargo, hay dos puntos diferentes que podemos utilizar como origen del sistema de coordenadas: las coordenadas <em>x</em> e <em>y</em> de un elemento pueden ser relativas a la esquina superior izquierda del documento o relativas a la esquina superior izquierda de la <em>ventana</em> gráfica en la que se muestra el documento. En ventanas de nivel superior y pestañas, la "ventana gráfica" es la porción del navegador que realmente muestra el contenido del documento: excluye el "cromo" del navegador, como menús, barras de herramientas, y pestañas. Para los documentos mostrados en etiquetas <codeinline>&lt;iframe></codeinline>, es el elemento iframe en el DOM el que define la ventana gráfica para el documento anidado. En cualquier caso, cuando hablamos de la posición de un elemento, debemos tener claro si estamos utilizando las coordenadas del documento o las coordenadas de la ventana gráfica. (Ten en cuenta que las coordenadas de la ventana gráfica a veces se denominan "coordenadas de ventana").</p>
    <p>Si el documento es más pequeño que la ventana gráfica, o si no se ha desplazado, la esquina superior izquierda del documento se encuentra en la esquina superior izquierda de la ventana gráfica y los sistemas de coordenadas del documento y de la ventana gráfica coinciden. En general, sin embargo, para convertir entre los dos sistemas de coordenadas, debemos sumar o restar los <em>desplazamientos</em>. Por ejemplo, si un elemento tiene una coordenada <em>y</em> de 200 píxeles en las coordenadas del documento <em>y</em> el usuario se ha desplazado 75 píxeles hacia abajo, ese elemento tiene una coordenada <em>y</em> de 125 píxeles en las coordenadas de la ventana gráfica. Del mismo modo, si un elemento tiene una coordenada <em>x</em> de 400 en las coordenadas de la ventana gráfica después de que el usuario haya desplazado la ventana 200 píxeles horizontalmente, entonces la coordenada <em>x</em> del elemento en las coordenadas del documento es 600.</p>
    <p>Si utilizamos el modelo mental de los documentos impresos en papel, es lógico suponer que cada elemento de un documento debe tener una posición única en las coordenadas del documento, independientemente de cuánto se haya desplazado el usuario por el documento. Esta es una propiedad atractiva de los documentos en papel, y se aplica a los documentos web simples, pero en general, las coordenadas del documento no funcionan realmente en la web. El problema es que la propiedad CSS <codeinline>overflow</codeinline> permite que los elementos de un documento contengan más contenido del que pueden mostrar. Los elementos pueden tener sus propias barras de desplazamiento y servir como ventanas para el contenido que contienen. El hecho de que la Web permita el desplazamiento de elementos dentro de un documento desplazable significa que simplemente no es posible describir la posición de un elemento dentro del documento utilizando un único punto (x,y).</p>
    <p>Dado que las coordenadas del documento no funcionan realmente, el JavaScript del lado del cliente tiende a utilizar coordenadas de la ventana gráfica. Los métodos <codeinline>getBoundingClientRect()</codeinline> y <codeinline>elementFromPoint()</codeinline> que se describen a continuación utilizan coordenadas de la ventana gráfica, por ejemplo, y las propiedades <codeinline>clientX</codeinline> y <codeinline>clientY</codeinline> de los objetos de eventos de ratón y puntero también utilizan este sistema de coordenadas.</p>
    <p>Cuando se posiciona explícitamente un elemento utilizando CSS <codeinline>position:fixed</codeinline>, las propiedades <codeinline>top</codeinline> e <codeinline>left</codeinline> se interpretan en coordenadas de la ventana gráfica. Si utiliza <codeinline>position:relative</codeinline>, el elemento se posiciona en relación a donde habría estado si no tuviera la propiedad <codeinline>position</codeinline> establecida. Si utiliza <codeinline>position:absolute</codeinline>, las coordenadas <codeinline>top</codeinline> e <codeinline>left</codeinline> son relativas al documento o al elemento posicionado más cercano. Esto significa, por ejemplo, que un elemento posicionado absolutamente dentro de un elemento posicionado relativamente se posiciona en relación al elemento contenedor, no en relación al documento en general. A veces es muy útil crear un contenedor relativamente posicionado con las coordenadas <codeinline>top</codeinline> e <codeinline>left</codeinline> a 0 (para que el contenedor se disponga normalmente) con el fin de establecer un nuevo origen del sistema de coordenadas para los elementos absolutamente posicionados que contiene. Podemos referirnos a este nuevo sistema de coordenadas como "coordenadas del contenedor" para distinguirlo de las coordenadas del documento y de las coordenadas de la ventana gráfica.</p>
    <article>
      <p class="title-article">Píxeles CSS</p>
      <p>Si, como yo, eres lo bastante mayor como para recordar monitores de ordenador con resoluciones de 1024 × 768 y teléfonos con pantalla táctil con resoluciones de 320 × 480, es posible que sigas pensando que la palabra "píxel" se refiere a un único "elemento de imagen" en el <em>hardware</em>. Los monitores 4K y las pantallas "retina" actuales tienen una resolución tan alta que los píxeles de software se han desvinculado de los píxeles de hardware. Un píxel CSS -y, por tanto, un píxel Java-Script del lado del cliente- puede, de hecho, estar formado por varios píxeles de dispositivo. La propiedad <codeinline>devicePixelRatio</codeinline> del objeto Window especifica cuántos píxeles de dispositivo se utilizan para cada píxel de software. Un "dpr" de 2, por ejemplo, significa que cada píxel de software es en realidad un píxel de 2 × 2 de píxeles de hardware. El valor de <codeinline>devicePixelRatio</codeinline> depende del tamaño físico del dispositivo. la resolución de su hardware, la configuración de su sistema operativo y el nivel de zoom de su navegador.</p>
      <p><codeinline>devicePixelRatio</codeinline> no tiene que ser un número entero. Si está utilizando un tamaño de fuente CSS de "12px" y la relación de píxeles del dispositivo es 2,5, entonces el tamaño real de la fuente, en píxeles del dispositivo, es 30. Dado que los valores de píxel que utilizamos en CSS ya no corresponden directamente a píxeles individuales en la pantalla, las coordenadas de píxel ya no necesitan ser números enteros. Si el <codeinline>devicePixelRatio</codeinline> es 3, entonces una coordenada de 3.33 tiene perfecto sentido. Y si el ratio es en realidad 2, entonces una coordenada de 3.33 se redondeará a 3.5.</p>
    </article>
  </section>
  <section id="5-2">
    <h2>15.5.2 Consulta de la geometría de un elemento</h2>
    <p>Puede determinar el tamaño (incluidos el borde y el relleno CSS, pero no el margen) y la posición (en coordenadas de la ventana gráfica) de un elemento llamando a su método <codeinline>getBoundingClientRect()</codeinline>. No toma argumentos y devuelve un objeto con las propiedades <codeinline>left</codeinline>, <codeinline>right</codeinline>, <codeinline>top</codeinline>, <codeinline>bottom</codeinline>, <codeinline>width</codeinline> y <codeinline>height</codeinline>. Las propiedades <codeinline>left</codeinline> y <codeinline>top</codeinline> dan las coordenadas <em>x</em> e <em>y</em> de la esquina superior izquierda del elemento, y las propiedades <codeinline>right</codeinline> y <codeinline>bottom</codeinline> dan las coordenadas de la esquina inferior derecha. Las diferencias entre estos valores son las propiedades de <codeinline>width</codeinline> y <codeinline>height</codeinline>.</p>
    <p>Los elementos en bloque, como las imágenes, los párrafos y los elementos <codeinline>&lt;div></codeinline> son siempre rectangulares cuando el navegador los presenta. Sin embargo, los elementos en línea, como <codeinline>&lt;span></codeinline>, <codeinline>&lt;code></codeinline> y <codeinline>&lt;b></codeinline>, pueden abarcar varias líneas y, por tanto, estar formados por varios recuadros. Imagine, por ejemplo, un texto dentro de las etiquetas <codeinline>&lt;em></codeinline> y <codeinline>&lt;/em></codeinline> que se muestra de forma que se extiende a lo largo de dos líneas. Sus rectángulos son el final de la primera línea y el principio de la segunda. Si se llama a <codeinline>getBoundingClientRect()</codeinline> en este elemento, el rectángulo delimitador incluiría toda la anchura de ambas líneas. Si desea consultar los rectángulos individuales de los elementos en línea, llame al método <codeinline>getClientRects()</codeinline> para obtener un objeto de sólo lectura, tipo matriz, cuyos elementos son objetos rectángulos como los devueltos por <codeinline>getBoundingClientRect()</codeinline>.</p>
  </section>
  <section id="5-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.3 Determinación del elemento en un punto</h2>
    <p>El método <codeinline>getBoundingClientRect()</codeinline> nos permite determinar la posición actual de un elemento en una ventana gráfica. A veces queremos ir en la otra dirección y determinar qué elemento está en una posición dada en la ventana gráfica. Puedes determinar esto con el método <codeinline>elementFromPoint()</codeinline> del objeto Document. Llame a este método con las coordenadas <em>x</em> e <em>y</em> de un punto (usando las coordenadas de la ventana gráfica, no las coordenadas del documento: las coordenadas <codeinline>clientX</codeinline> y <codeinline>clientY</codeinline> de un evento de ratón funcionan, por ejemplo). <codeinline>elementFromPoint()</codeinline> devuelve un objeto Elemento que está en la posición especificada. El algoritmo de <em>detección de aciertos</em> para seleccionar el elemento no se especifica con precisión, pero la intención de este método es que devuelva el elemento más interno (anidado más profundamente) y más superior (atributo CSS <codeinline>z-index</codeinline> más alto) en ese punto.</p>
  </section>
  <section id="5-4">
    <h2>15.5.4 Desplazamiento</h2>
    <p>El método <codeinline>scrollTo()</codeinline> del objeto Window toma las coordenadas <em>x</em> e <em>y</em> de un punto (en coordenadas del documento) y las establece como desplazamientos de la barra de desplazamiento. Es decir, desplaza la ventana de modo que el punto especificado se encuentre en la esquina superior izquierda de la ventana. Si especifica un punto que está demasiado cerca de la parte inferior o demasiado cerca del borde derecho del documento, el navegador lo moverá tan cerca como sea posible de la esquina superior izquierda, pero no será capaz de llegar hasta allí. El siguiente código desplaza el navegador para que sea visible la página más inferior del documento:</p>
    <pre class="language-js">
    <code class="language-js">// Establezca las alturas del documento y la ventana gráfica.
    let documentHeight = document.documentElement.offsetHeight;
    let viewportHeight = window.innerHeight;
    // Y desplácese para que la última "página" se muestre en la ventana gráfica.
    window.scrollTo(0, documentHeight - viewportHeight);</code></pre>
    <p>El método <codeinline>scrollBy()</codeinline> de Window es similar a <codeinline>scrollTo()</codeinline>, pero sus argumentos son relativos y se añaden a la posición de desplazamiento actual:</p>
    <pre class="language-js">
    <code class="language-js">// Desplácese 50 píxeles hacia abajo cada 500 ms. ¡Tenga en cuenta que
    // no hay forma de desactivar esta función!
    setInterval(() => &lbrace; scrollBy(0,50)}, 500);</code></pre>
    <p>Si desea desplazarse suavemente con <codeinline>scrollTo()</codeinline> o <codeinline>scrollBy()</codeinline>, pase un único argumento objeto en lugar de dos números, de esta forma:</p>
    <pre class="language-js">
    <code class="language-js">window.scrollTo(&lbrace;
      left: 0,
      top: documentHeight - viewportHeight,
      behavior: "smooth"
    });</code></pre>
    <p>A menudo, en lugar de desplazarnos a una ubicación numérica en un documento, sólo queremos desplazarnos para que un determinado elemento del documento sea visible. Puede hacerlo con el método <codeinline>scrollIntoView()</codeinline> en el elemento HTML deseado. Este método asegura que el elemento sobre el que se invoca es visible en la ventana gráfica. Por defecto, intenta poner el elemento borde superior del elemento en o cerca de la parte superior de la ventana gráfica. Si se pasa <codeinline>false</codeinline> como único argumento, se intentará situar el borde inferior del elemento en la parte inferior de la ventana gráfica. El navegador también desplazará la ventana horizontalmente según sea necesario para hacer visible el elemento.</p>
    <p>También puede pasar un objeto a <codeinline>scrollIntoView()</codeinline>, estableciendo la propiedad <codeinline>behavior: "smooth"</codeinline> para un desplazamiento suave. Puede establecer la propiedad <codeinline>block</codeinline> para especificar dónde debe posicionarse el elemento verticalmente y la propiedad <codeinline>inline</codeinline> para especificar cómo debe posicionarse horizontalmente si se necesita desplazamiento horizontal. Los valores legales para ambas propiedades son <codeinline>start</codeinline>, <codeinline>end</codeinline>, <codeinline>nearest</codeinline> y <codeinline>center</codeinline>.</p>
  </section>
  <section id="5-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.5 Tamaño de la ventana, tamaño del contenido y posición de desplazamiento</h2>
    <p>Como ya hemos comentado, las ventanas del navegador y otros elementos HTML pueden mostrar contenido desplazable. Cuando este es el caso, a veces necesitamos conocer el tamaño de la ventana gráfica, el tamaño del contenido y los desplazamientos del contenido dentro de la ventana gráfica. Esta sección cubre estos detalles.</p>
    <p>Para las ventanas del navegador, el tamaño de la ventana gráfica viene dado por las propiedades <codeinline>window.innerWidth</codeinline> y <codeinline>window.innerHeight</codeinline>. (Las páginas web optimizadas para dispositivos móviles suelen utilizar una propiedad <codeinline>&lt;meta name="viewport"></codeinline> en su <codeinline>&lt;head></codeinline> para establecer el ancho de ventana deseado para la página). El tamaño total del documento es el mismo que el tamaño del elemento <codeinline>&lt;html></codeinline>, <codeinline>document.documentElement</codeinline>. Puede llamar a <codeinline>getBoundingClientRect()</codeinline> en <codeinline>document.documentElement</codeinline> para obtener la anchura y la altura del documento, o puede utilizar las propiedades <codeinline>offsetWidth</codeinline> y <codeinline>offsetHeight</codeinline> de <codeinline>document.documentElement</codeinline>. Los desplazamientos del documento dentro de su ventana gráfica están disponibles como <codeinline>window.scrollX</codeinline> y <codeinline>window.scrollY</codeinline>. Se trata de propiedades de sólo lectura, por lo que no puede establecerlas para desplazar el documento: utilice <codeinline>window.scrollTo()</codeinline> en su lugar.</p>
    <p>Las cosas son un poco más complicadas para los elementos. Cada objeto Elemento define los siguientes tres grupos de propiedades:</p>
    <pre class="language-js">
    offsetWidth     clientWidth   scrollWidth
    offsetHeight    clientHeight  scrollHeight
    offsetLeft      clientLeft    scrollLeft
    offsetTop       clientTop     scrollTop
    offsetParent</pre>
    <p>Las propiedades <codeinline>offsetWidth</codeinline> y <codeinline>offsetHeight</codeinline> de un elemento devuelven su tamaño en pantalla en píxeles CSS. Los tamaños devueltos incluyen el borde y el relleno del elemento, pero no los márgenes. Las propiedades <codeinline>offsetLeft</codeinline> y <codeinline>offsetTop</codeinline> devuelven las coordenadas <em>x</em> e <em>y</em> del elemento. Para muchos elementos, estos valores son coordenadas del documento. Pero para los descendientes de elementos posicionados y para algunos otros elementos, como las celdas de tabla, estas propiedades devuelven coordenadas que son relativas a un elemento ancestro en lugar de coordenadas relativas a un elemento ancestro. que el propio documento. La propiedad <codeinline>offsetParent</codeinline> especifica a qué elemento son relativas las propiedades. Estas propiedades offset son todas de sólo lectura.</p>
    <p><codeinline>clientWidth</codeinline> y <codeinline>clientHeight</codeinline> son como <codeinline>offsetWidth</codeinline> y <codeinline>offsetHeight</codeinline>, salvo que no incluyen el tamaño del borde, sólo el área de contenido y su relleno. Las propiedades <codeinline>clientLeft</codeinline> y <codeinline>clientTop</codeinline> no son muy útiles: devuelven la distancia horizontal y vertical entre el exterior del relleno de un elemento y el exterior de su borde. Normalmente, estos valores son sólo la anchura de los bordes izquierdo y superior. Todas estas propiedades son de sólo lectura. Para elementos en línea como <codeinline>&lt;i></codeinline>, <codeinline>&lt;code></codeinline> y <codeinline>&lt;span></codeinline>, todas devuelven 0.</p>
    <p><codeinline>scrollWidth</codeinline> y <codeinline>scrollHeight</codeinline> devuelven el tamaño del área de contenido de un elemento más su relleno más cualquier contenido que desborde. Cuando el contenido cabe en el área de contenido sin desbordamiento, estas propiedades son las mismas que <codeinline>clientWidth</codeinline> y <codeinline>clientHeight</codeinline>. Pero cuando hay desbordamiento, incluyen el contenido desbordado y devuelven valores mayores que <codeinline>clientWidth</codeinline> y <codeinline>clientHeight</codeinline>. <codeinline>scrollLeft</codeinline> y <codeinline>scrollTop</codeinline> dan el desplazamiento del contenido del elemento dentro de la ventana gráfica del elemento. A diferencia del resto de propiedades descritas aquí, scrollLeft y scrollTop son propiedades escribibles, y puedes establecerlas para desplazar el contenido dentro de un elemento. (En la mayoría de los navegadores, los objetos Element también tienen métodos <codeinline>scrollTo()</codeinline> y <codeinline>scrollBy()</codeinline> como lo hace el objeto Window, pero estos aún no son soportados universalmente).</p>
  </section>
  <section id="6">
    <h2>15.6 Componentes web</h2>
    <p>HTML es un lenguaje de marcado de documentos que define un rico conjunto de etiquetas con ese fin. En las últimas tres décadas, se ha convertido en un lenguaje que se utiliza para describir las interfaces de usuario de las aplicaciones web, pero las etiquetas HTML básicas como <codeinline>&lt;input></codeinline> y <codeinline>&lt;button></codeinline> son inadecuadas para los diseños de interfaz de usuario modernos. Los desarrolladores web son capaces de hacer que funcione, pero sólo mediante el uso de CSS y JavaScript para aumentar la apariencia y el comportamiento de las etiquetas HTML básicas. Considere un componente típico de interfaz de usuario, como el cuadro de búsqueda que se muestra en la <a href="#figure15-3">Figura 15-3</a>.</p>
    <figure id="figure15-3">
      <img src="/public/javascript/capitulo-15/figure15-3.avif" alt="imagen de consola">
      <figcaption>Figura 15-3. Componente de la interfaz de usuario de un cuadro de búsqueda</figcaption>
    </figure>
    <p>El elemento HTML <codeinline>&lt;input></codeinline> puede utilizarse para aceptar una sola línea de entrada del usuario, pero no tiene ninguna forma de mostrar iconos como la lupa a la izquierda y la X de cancelación a la derecha. Para implementar un elemento de interfaz de usuario moderno como éste para la web, necesitamos utilizar al menos cuatro elementos HTML: un elemento <codeinline>&lt;input></codeinline>.para aceptar y mostrar la entrada del usuario, dos elementos <codeinline>&lt;img></codeinline> (o en este caso, dos elementos <codeinline>&lt;span></codeinline> que muestran glifos Unicode), y un elemento contenedor <codeinline>&lt;div></codeinline> para alojar a esos tres hijos. Además, tenemos que utilizar CSS para ocultar el borde predeterminado del elemento <codeinline>&lt;input></codeinline> y definir un borde para el contenedor. Y necesitamos usar JavaScript para hacer que todos los elementos HTML funcionen juntos. Cuando el usuario hace clic en el icono X, necesitamos un controlador de eventos para borrar la entrada del elemento <codeinline>&lt;input></codeinline>, por ejemplo.</p>
    <p>Eso es mucho trabajo para hacer cada vez que desee mostrar un cuadro de búsqueda en una aplicación web, y la mayoría de las aplicaciones web de hoy no están escritas usando HTML "crudo". En su lugar, muchos desarrolladores web utilizan frameworks como React y Angular que soportan la creación de componentes de interfaz de usuario reutilizables como el cuadro de búsqueda que se muestra aquí. Web Components es una alternativa nativa del navegador a esos marcos basada en tres adiciones relativamente recientes a los estándares web que permiten a JavaScript ampliar HTML con nuevas etiquetas que funcionan como componentes de interfaz de usuario autónomos y reutilizables.</p>
    <p>Las subsecciones siguientes explican cómo utilizar componentes web definidos por otros desarrolladores en sus propias páginas web, luego explican cada una de las tres tecnologías en las que se basan los componentes web y, finalmente, unen las tres en un ejemplo que implementa el elemento de la caja de búsqueda que se muestra en la <a href="#figure15-3">Figura 15-3</a>.</p>
  </section>
  <section id="6-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.1 Uso de componentes web</h2>
    <p>Los componentes web se definen en JavaScript, por lo que para utilizar un componente web en su archivo HTML, debe incluir el archivo JavaScript que define el componente. Dado que los componentes web son una tecnología relativamente nueva, a menudo se escriben como módulos de JavaScript, por lo que podría incluir uno en su HTML de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">&lt;script type="module" src="components/search-box.js">&lt;/script></code></pre>
    <p>Los componentes web definen sus propios nombres de etiquetas HTML, con la importante restricción de que esos nombres de etiquetas deben incluir un guión. (Esto significa que las futuras versiones de HTML pueden introducir nuevas etiquetas sin guiones, y no hay posibilidad de que las etiquetas entren en conflicto con el componente web de nadie). Para utilizar un componente web, basta con utilizar su etiqueta en el archivo HTML:</p>
    <p>Los Web Components pueden tener atributos igual que las etiquetas HTML normales; la documentación del componente que utilice le indicará qué atributos admite. Los Web Components no pueden definirse con etiquetas de cierreautomático. No puede escribir <codeinline>&lt;search-box/></codeinline>, por ejemplo. Su archivo HTML debe incluir tanto la etiqueta de apertura como la de cierre.</p>
    <pre class="language-js">
    <code class="language-js">&lt;search-box placeholder="Search...">&lt;/search-box></code></pre>
    <p>Al igual que los elementos HTML normales, algunos componentes web se escriben de forma que esperen hijos y otros se escriben de forma que no esperen (y no muestren) hijos. Algunos componentes web se escriben de forma que puedan aceptar opcionalmente hijos especialmente etiquetados que aparecerán en "ranuras" nombradas. El componente <codeinline>&lt;search-box></codeinline> representado en la <a href="#figure15-3">Figura 15-3</a> e implementado en el <a href="#ejemplo15-3">Ejemplo 15-3</a> utiliza "ranuras" para los dos iconos que muestra. Si desea utilizar un <codeinline>&lt;search-box></codeinline> con iconos diferentes, puede utilizar HTML como el siguiente:</p>
    <pre class="language-js">
    <code class="language-js">&lt;search-box>
      &lt;img src="images/search-icon.png" slot="left"/>
      &lt;img src="images/cancel-icon.png" slot="right"/>
    &lt;/search-box></code></pre>
    <p>El atributo <codeinline>slot</codeinline> es una extensión de HTML que se utiliza para especificar qué hijos deben ir dónde. Los nombres de las ranuras - "izquierda" y "derecha" en este ejemplo- los define el componente web. Si el componente que está utilizando admite ranuras, este hecho debe incluirse en su documentación.</p>
    <p>Anteriormente señalé que los componentes web a menudo se implementan como módulos JavaScript y pueden cargarse en archivos HTML con una etiqueta <codeinline>&lt;script type="module"></codeinline>. Puede que recuerdes del principio de este capítulo que los módulos se cargan después de analizar el contenido del documento, como si tuvieran una etiqueta <codeinline>deferred</codeinline>. Esto significa que un navegador web normalmente analizará y mostrará etiquetas como <codeinline>&lt;script type="module"></codeinline> antes de haber ejecutado el código que le dirá qué es un <codeinline>&lt;script type="module"></codeinline>. Esto es normal cuando se utilizan componentes web. Los analizadores HTML de los navegadores web son flexibles y muy indulgentes con las entradas que no entienden. Cuando encuentran una etiqueta de componente web antes de que se haya definido el componente, añaden un HTMLElement genérico al árbol DOM aunque no sepan qué hacer con él. Más tarde, cuando se define el elemento personalizado, el elemento genérico se "actualiza" para que tenga el aspecto y el comportamiento deseados.</p>
    <p>Si un componente web tiene hijos, es probable que éstos se muestren incorrectamente antes de que se defina el componente. Puede utilizar este CSS para mantener ocultos los componentes web hasta que estén definidos:</p>
    <pre class="language-js">
    <code class="language-js">/*
      * Haga que el componente &lt;search-box> sea invisible antes de
      * definirlo. Y trate de duplicar su diseño y tamaño final para que
      * el contenido cercano no se mueva cuando se defina.
      */
      search-box:not(:defined) &lbrace;
        opacity:0;
        display: inline-block;
        width: 300px;
        height: 50px;
    }</code></pre>
    <p>Al igual que los elementos HTML normales, los componentes web pueden utilizarse en JavaScript. Si incluyes una etiqueta <codeinline>&lt;search-box></codeinline> en tu página web, puedes obtener una referencia a ella con <codeinline>querySelector()</codeinline> y un selector CSS apropiado, igual que harías con cualquier otra etiqueta HTML. Generalmente, sólo tiene sentido hacer esto después de que el módulo que define el componente se haya ejecutado, así que tenga cuidado cuando consulte componentes web que no lo haga demasiado pronto. Las implementaciones de componentes web suelen (aunque no es un requisito) definir una propiedad JavaScript para cada atributo HTML que soportan. Y, al igual que los elementos HTML, también pueden definir métodos útiles. Una vez más, la documentación del componente web que esté utilizando debe especificar qué propiedades y métodos están disponibles para su código JavaScript.</p>
    <p>Ahora que ya sabes cómo utilizar los componentes web, las tres secciones siguientes cubren las tres características del navegador web que nos permiten implementarlos.</p>
    <article>
      <p class="title-article">Nodos de DocumentFragment</p>
      <p>Antes de que podamos cubrir las APIs de componentes web, necesitamos volver brevemente a la API DOM para explicar qué es un DocumentFragment. La API DOM organiza un documento en un árbol de objetos Nodo, donde un Nodo puede ser un Documento, un Elemento, un Nodo de Texto, o incluso un Comentario. Ninguno de estos tipos de nodo permite representar un fragmento de un documento que consista en un conjunto de nodos hermanos sin su padre. Aquí es donde entra DocumentFragment: es otro tipo de Nodo que sirve como padre temporal cuando se desea manipular un grupo de nodos hermanos como una sola unidad. Puedes crear un nodo DocumentFragment con <codeinline>document.createDocumentFragment()</codeinline>. Una vez que tenga un DocumentFragment, puede usarlo como un Elemento y <codeinline>append()</codeinline> contenido. Un DocumentFragment es diferente de un Elemento porque no tiene un padre. Pero lo que es más importante, cuando insertas un nodo DocumentFragment en el documento, el DocumentFragment en sí no se inserta. En su lugar, se insertan todos sus hijos.</p>
    </article>
  </section>
  <section id="6-2">
    <h2>15.6.2 Plantillas HTML</h2>
    <p>La etiqueta <codeinline>&lt;template></codeinline> de HTML sólo está relacionada de forma imprecisa con los componentes web, pero permite una optimización útil de los componentes que aparecen con frecuencia en las páginas web.</p>
    <p>Las etiquetas <codeinline>&lt;template></codeinline> y sus hijas nunca son renderizadas por un navegador web y sólo son útiles en páginas web que utilizan JavaScript. La idea detrás de esta etiqueta es que cuando una página web contiene múltiples repeticiones de la misma estructura HTML básica (como las filas de una tabla o la implementación interna de un componente web), entonces podemos utilizar una <codeinline>&lt;template></codeinline> para definir esa estructura de elementos una vez, y luego utilizar JavaScript para duplicar la estructura tantas veces como sea necesario.</p>
    <p>En JavaScript, una etiqueta <codeinline>&lt;template></codeinline> está representada por un objeto HTMLTemplateElement. Este objeto define una única propiedad de contenido, cuyo valor es un Doc-umentFragment de todos los nodos hijos de <codeinline>&lt;template></codeinline>. Puede clonar este Docu- mentFragment y luego insertar la copia clonada en su documento según sea necesario. El fragmento en sí no se insertará, pero sí sus hijos. Supongamos que está trabajando con un documento que incluye una etiqueta <codeinline>&lt;table></codeinline> y <codeinline>&lt;template id="row"></codeinline> y que la etiqueta define la estructura de las filas de esa tabla. Puede utilizar la plantilla de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">let tableBody = document.querySelector("tbody");
    let template = document.querySelector("#row");
    let clone = template.content.cloneNode(true); // clon profundo
    // ... Utilice el DOM para insertar contenido en los elementos &lt;td> del clon...
    // Ahora agregue la fila clonada e inicializada a la tabla
    tableBody.append(clone);</code></pre>
    <p>Los elementos de plantilla no tienen por qué aparecer literalmente en un documento HTML para ser útiles. Puedes crear una plantilla en tu código JavaScript, crear sus hijos con <codeinline>innerHTML</codeinline>, y luego hacer tantos clones como necesites sin la sobrecarga de análisis de <codeinline>innerHTML</codeinline>. Así es como las plantillas HTML se usan típicamente en componentes web, y el <a href="#ejemplo15-3">Ejemplo 15-3</a> demuestra esta técnica.</p>
  </section>
  <section id="6-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.3 Elementos personalizados</h2>
    <p>La segunda característica del navegador web que habilita los componentes web son los "elementos personalizados": la capacidad de asociar una clase JavaScript con un nombre de etiqueta HTML para que cualquiera de esas etiquetas en el documento se convierta automáticamente en instancias de la clase en el árbol DOM. El método <codeinline>customElements.define()</codeinline> toma como primer argumento el nombre de una etiqueta del componente web (recuerde que el nombre de la etiqueta debe incluir un guión) y como segundo argumento una subclase de HTMLElement. Cualquier elemento existente en el documento con ese nombre de etiqueta se "actualiza" a instancias recién creadas de la clase. Y si el navegador analiza cualquier HTML en el futuro, creará automáticamente una instancia de la clase para cada una de las etiquetas que encuentre.</p>
    <p>La clase pasada a <codeinline>customElements.define()</codeinline> debe extender HTMLElement y no un tipo más específico como HTMLButtonElement.<sup>4</sup> Recuerde del <a href="capitulo-9">Capítulo 9</a> que cuando una clase JavaScript extiende otra clase, la función constructora debe llamar a <codeinline>super()</codeinline> antes de usar la palabra clave this, así que si la clase del elemento personalizado tiene un constructor, debe llamar a <codeinline>super()</codeinline> (sin argumentos) antes de hacer cualquier otra cosa.</p>
    <p>El navegador invocará automáticamente ciertos "métodos del ciclo de vida" de una clase de elemento personalizado. El método <codeinline>connectedCallback()</codeinline> se invoca cuando una instancia del elemento personalizado se inserta en el documento, y muchos elementos utilizan este método para realizar la inicialización. También hay un método <codeinline>disconnectedCallback()</codeinline> que se invoca cuando (y si) el elemento se elimina del documento, aunque se utiliza con menos frecuencia.</p>
    <p>Si una clase de elemento personalizado define una propiedad estática <codeinline>observedAttributes</codeinline> cuyo valor es una matriz de nombres de atributos, y si cualquiera de los atributos nombrados se establece (o cambia) en una instancia del elemento personalizado, el navegador invocará el método <codeinline>attributeChangedCallback()</codeinline>, pasando el nombre del atributo, su valor antiguo y su nuevo valor. Esta llamada de retorno puede tomar los pasos necesarios para actualizar el componente basándose en los valores de sus atributos.</p>
    <p>Las clases de elementos personalizados también pueden definir otras propiedades y métodos que deseen. Normalmente, definirán métodos getter y setter que harán que los atributos del elemento estén disponibles como propiedades JavaScript.</p>
    <p>Como ejemplo de elemento personalizado, supongamos que queremos mostrar círculos dentro de párrafos de texto normal. Nos gustaría poder escribir HTML como éste para representar problemas de historias matemáticas como el que se muestra en la <a href="#figure15-4">Figura 15-4</a>:</p>
    <pre class="language-js">
    <code class="language-js">&lt;p>
      The document has one marble: &lt;inline-circle>&lt;/inline-circle>.
      The HTML parser instantiates two more marbles:
      &lt;inline-circle diameter="1.2em" color="blue">&lt;/inline-circle>
      &lt;inline-circle diameter=".6em" color="gold">&lt;/inline-circle>.
      How many marbles does the document contain now?
    &lt;/p></code></pre>
    <figure id="figure15-4">
      <img src="/public/javascript/capitulo-15/figure15-4.avif" alt="imagen de consola">
      <figcaption>Figura 15-4. Elemento personalizado circular en línea</figcaption>
    </figure>
    <p>Podemos implementar este elemento personalizado <codeinline>&lt;inline-circle></codeinline> que se muestra en el <a href="#ejemplo15-4">Ejemplo 15-2</a>:</p>
    <p><em>Ejemplo 15-2. El elemento personalizado &lt;inline-circle>.</em></p>
    <pre class="language-js">
    <code class="language-js">customElements.define("inline-circle", class InlineCircle extends HTMLElement &lbrace;
      // El navegador llama a este método cuando se inserta un elemento
      // &lt;inline-circle> en el documento. También hay una función
      // disconnectedCallback() que no necesitamos en este ejemplo.
      connectedCallback() &lbrace;
        // Establezca los estilos necesarios para crear círculos.
        this.style.display = "inline-block";
        this.style.borderRadius = "50%";
        this.style.border = "solid black 1px";
        this.style.transform = "translateY(10%)";
        // Si aún no hay un tamaño definido, establezca un tamaño
        // predeterminado que se base en el tamaño de fuente actual.
        if (!this.style.width) &lbrace;
          this.style.width = "0.8em";
          this.style.height = "0.8em";
        }
      }

      // La propiedad estática observadaAttributes especifica qué atributos
      // queremos que se nos notifiquen sobre los cambios. (Aquí usamos un
      // captador, ya que solo podemos usar "static" con métodos).
      static get observedAttributes() &lbrace; return ["diameter", "color"]; }

      // Esta devolución de llamada se invoca cuando uno de los atributos
      // enumerados anteriormente cambia, ya sea cuando se analiza por
      // primera vez el elemento personalizado o más tarde.
      attributeChangedCallback(name, oldValue, newValue) &lbrace;
        switch(name) &lbrace;
        case "diameter":
          // Si cambia el atributo de diámetro, actualice los estilos de tamaño
          this.style.width = newValue;
          this.style.height = newValue;
          break;
        case "color":
          // Si el atributo de color cambia, actualice los estilos de color
          this.style.backgroundColor = newValue;
          break;
        }
      }

      // Define las propiedades de JavaScript que corresponden a los atributos
      // del elemento. Estos métodos de obtención y definición solo obtienen y
      // definen los atributos subyacentes. Si se define una propiedad de
      // JavaScript, se establece el atributo que activa una llamada a
      // attributeChangedCallback() que actualiza los estilos del elemento.
      get diameter() &lbrace; return this.getAttribute("diameter"); }
      set diameter(diameter) &lbrace; this.setAttribute("diameter", diameter); }
      get color() &lbrace; return this.getAttribute("color"); }
      set color(color) &lbrace; this.setAttribute("color", color); }
    });</code></pre>
  </section>
  <section id="6-4">
    <h2>15.6.4 DOM en la sombra</h2>
    <p>El elemento personalizado mostrado en el <a href="#ejemplo15-4">Ejemplo 15-2</a> no está bien encapsulado. Cuando estableces sus atributos de <codeinline>diameter</codeinline> o <codeinline>color</codeinline>, responde alterando su propio atributo de <codeinline>style</codeinline>, que no es el comportamiento que esperaríamos de un elemento HTML real. Para convertir un elemento personalizado en un verdadero componente web, debería utilizar el potente mecanismo de encapsulación conocido como <em>shadow DOM</em>.</p>
    <p>Shadow DOM permite adjuntar una "raíz sombra" a un elemento personalizado (y también a un <codeinline>&lt;div></codeinline>, <codeinline>&lt;span></codeinline>, <codeinline>&lt;body></codeinline>, <codeinline>&lt;article></codeinline>, <codeinline>&lt;main></codeinline>, <codeinline>&lt;nav></codeinline>, <codeinline>&lt;header></codeinline>, <codeinline>&lt;footer></codeinline>, <codeinline>&lt;section></codeinline>,<codeinline>&lt;p></codeinline>, <codeinline>&lt;blockquote></codeinline>, <codeinline>&lt;aside></codeinline>, o <codeinline>&lt;h1></codeinline> hasta <codeinline>&lt;h6></codeinline> elemento) conocido como un "shadow host". Los elementos host sombra, como todos los elementos HTML, ya son la raíz de un árbol DOM normal de elementos descendientes y nodos de texto. Una raíz sombra es la raíz de otro árbol, más privado, de elementos descendientes que brota del shadow host y puede considerarse como un minidocumento distinto.</p>
    <p>La palabra "sombra" en "shadow DOM" se refiere al hecho de que los elementos que descienden de una raíz sombra se "esconden en las sombras": no forman parte del árbol DOM normal, no aparecen en la matriz de <codeinline>children</codeinline> de su elemento anfitrión y no son visitados por los métodos normales de recorrido del DOM, como <codeinline>querySelector()</codeinline>. Por contraste, los hijos normales y regulares del DOM de un anfitrión en la sombra a veces se denominan "DOM claro".</p>
    <p>Para entender el propósito de la sombra DOM, imagen del HTML <codeinline>&lt;audio></codeinline> y <codeinline>&lt;video></codeinline>: muestran una interfaz de usuario no trivial para controlar la reproducción multimedia, pero los botones de reproducción y pausa y otros elementos de la interfaz de usuario no forman parte del árbol DOM y no pueden manipularse con JavaScript. Dado que los navegadores están diseñados para mostrar HTML, es natural que los proveedores de navegadores quieran mostrar interfaces de usuario como éstas utilizando HTML. De hecho, la mayoría de los navegadores llevan mucho tiempo haciendo algo así, y el shadow DOM lo convierte en una parte estándar de la plataforma web.</p>
    <p class="title-article text-left">Encapsulación DOM en la sombra</p>
    <p>La característica clave del shadow DOM es la encapsulación que proporciona. Los descendientes de una raíz sombra están ocultos -e independientes- del árbol DOM normal, casi como si estuvieran en un documento independiente. Hay tres tipos muy importantes de encapsulación que proporciona el shadow DOM:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Como ya se ha mencionado, los elementos en el shadow DOM están ocultos a los métodos regulares del DOM como <codeinline>querySelectorAll()</codeinline>. Cuando se crea un shadow root y se adjunta a su shadow host, puede crearse en modo "abierto" o "cerrado". Una raíz sombra cerrada está completamente sellada y es inaccesible. Sin embargo, lo más común es que las raíces sombra se creen en modo "abierto", lo que significa que el shadow host tiene una propiedad <codeinline>shadowRoot</codeinline> que JavaScript puede utilizar para acceder a los elementos de la raíz sombra, si tiene alguna razón para hacerlo.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los estilos definidos bajo una raíz sombra son privados para ese árbol y nunca afectarán a los elementos DOM ligeros del exterior. (Una raíz de sombra puede definir estilos predeterminados para su elemento anfitrión, pero éstos serán anulados por los estilos DOM ligeros). Del mismo modo, los estilos DOM ligeros que se aplican al elemento anfitrión de la sombra no afectan a los descendientes de la raíz de la sombra. Los elementos en el DOM de sombra heredarán cosas como el tamaño de la fuente y el color de fondo del DOM de luz, y los estilos en el DOM de sombra pueden optar por utilizar variables CSS definidas en el DOM de luz. Sin embargo, en su mayor parte , los estilos del DOM claro y los estilos del DOM sombreado DOM son completamente independientes: el autor de un componente web y el usuario de un componente web no tienen que preocuparse por colisiones o conflictos entre sus hojas de estilo. Poder "abarcar" CSS de esta manera es quizá la característica más importante del shadow DOM.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Algunos eventos (como "load") que ocurren dentro del shadow DOM se limitan al shadow DOM. Otros, como los eventos de foco, ratón y teclado, se propagan hacia arriba y hacia afuera. Cuando un evento que se origina en el DOM sombra cruza el límite y comienza a propagarse en el DOM luz, su propiedad de <codeinline>target</codeinline> se cambia al elemento anfitrión sombra, por lo que parece haberse originado directamente en ese elemento.
        </p>
      </li>
    </ul>
    <p class="title-article text-left">Ranuras DOM de sombra e hijos DOM de luz</p>
    <p>Un elemento HTML que es un shadow host tiene dos árboles de descendientes. Uno es la matriz <codeinline>children[]</codeinline> -los descendientes DOM normales y claros del elemento anfitrión- y el otro es la raíz sombra y todos sus descendientes, y puede que te estés preguntando cómo pueden mostrarse dos árboles de contenido distintos dentro del mismo elemento anfitrión. Así es como funciona:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los descendientes de la raíz sombra siempre se muestran dentro del host sombra.
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si esos descendientes incluyen un elemento <codeinline>&lt;slot></codeinline>, entonces los hijos regulares light DOM del elemento host se muestran como si fueran hijos de ese <codeinline>&lt;slot></codeinline>, reemplazando cualquier contenido shadow DOM en el slot. Si el shadow DOM no incluye un elemento <codeinline>&lt;slot></codeinline>, no se mostrará ningún contenido light DOM del host. Si el shadow DOM tiene una <codeinline>&lt;slot></codeinline>, pero el shadow host no tiene hijos light DOM, entonces el contenido shadow DOM de la ranura se muestra por defecto.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando el contenido light DOM se muestra dentro de un espacio shadow DOM, decimos que esos elementos han sido "distribuidos", pero es importante entender que los elementos no se convierten realmente en parte del shadow DOM. Aún pueden consultarse con <codeinline>querySelector()</codeinline> y siguen apareciendo en el DOM claro como hijos o descendientes del elemento anfitrión.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si el shadow DOM define más de una <codeinline>&lt;slot></codeinline> y <codeinline>name</codeinline> esas ranuras con un atributo name, los hijos del shadow host pueden especificar en qué ranura les gustaría aparecer especificando un atributo <codeinline>slot="slotname"</codeinline>. Vimos un ejemplo de este uso en <a href="#6-1">§15.6.1</a> cuando demostramos cómo personalizar los iconos que muestra el componente <codeinline>&lt;search-box></codeinline>.
        </p>
      </li>
    </ul>
    <p class="title-article text-left">API DOM en la sombra</p>
    <p>A pesar de toda su potencia, Shadow DOM no dispone de una API JavaScript. Para convertir un elemento DOM claro en un host de sombra, basta con llamar a su método <codeinline>attachShadow()</codeinline>, pasando <codeinline>&lbrace;mode: "open"}</codeinline> como único argumento. Este método devuelve un objeto shadow root y también establece ese objeto como valor de la propiedad <codeinline>shadowRoot</codeinline> del anfitrión. El objeto shadow root es un DocumentFragment, y puedes usar métodos DOM para añadirle contenido o simplemente establecer su propiedad <codeinline>innerHTML</codeinline> a una cadena HTML.</p>
    <p>Si su componente web necesita saber cuándo ha cambiado el contenido DOM de luz de una <codeinline>&lt;slot></codeinline> DOM de sombra, puede registrar un oyente para eventos "slotchanged" directamente en el elemento <codeinline>&lt;slot></codeinline>.</p>
  </section>
  <section id="6-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.5 Ejemplo: un componente web &lt;search-box>.</h2>
    <p>La <a href="#figure15-3">Figura 15-3</a> ilustra un componente web <codeinline>&lt;search-box></codeinline>. El <a href="#ejemplo15-3">ejemplo 15-3</a> muestra las tres tecnologías que definen los componentes web: implementa la tecnología El componente <codeinline>&lt;search-box></codeinline> es un elemento personalizado que utiliza una etiqueta <codeinline>&lt;template></codeinline> para mayor eficien- cia y una raíz sombra para la encapsulación.</p>
    <p>Este ejemplo muestra cómo utilizar directamente las API de bajo nivel de los componentes web. En la práctica, muchos componentes web desarrollados hoy en día los crean utilizando bibliotecas de alto nivel como "lit-element". Una de las razones para usar una librería es que crear componentes reutilizables y personalizables es bastante difícil de hacer bien, y hay muchos detalles que corregir. El <a href="#ejemplo15-3">ejemplo 15-3</a> demuestra componentes web y hace algunos manejos básicos de enfoque de teclado, pero por lo demás ignora la accesibilidad y no hace ningún intento de usar atributos ARIA apropiados para hacer que el componente funcione con lectores de pantalla y otra tecnología de asistencia.</p>
    <p id="ejemplo15-3"><em>Ejemplo 15-3. Implementación de un componente web</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * Esta clase define un elemento HTML personalizado &lt;search-box> que muestra
    * un campo de entrada de texto &lt;input> más dos iconos o emojis. De forma
    * predeterminada, muestra un emoji de lupa (que indica búsqueda) a la izquierda
    * del campo de texto y un emoji de X (que indica cancelación) a la derecha del
    * campo de texto. Oculta el borde del campo de entrada y muestra un borde a su
    * alrededor, lo que crea la apariencia de que los dos emojis están dentro del
    * campo de entrada. De manera similar, cuando el campo de entrada interno está
    * enfocado, el anillo de enfoque se muestra alrededor de &lt;search-box>.
    *
    * Puede anular los íconos predeterminados incluyendo &lt;span> o &lt;img> como
    * hijos de &lt;search-box> con los atributos slot="left" y slot="right".
    *
    * &lt;search-box> admite los atributos HTML normales deshabilitados y ocultos
    * y también los atributos de tamaño y marcador de posición, que tienen el
    * mismo significado para este elemento que para el elemento &lt;input>.
    *
    * Los eventos de entrada del elemento interno &lt;input> aparecen con su
    * campo de destino establecido en el elemento &lt;search-box>.
    *
    * El elemento activa un evento de "search" con la propiedad detail
    * establecida en la cadena de entrada actual cuando el usuario hace clic
    * en el emoji izquierdo (la lupa). El evento de "search" también se envía
    * cuando el campo de texto interno genera un evento de "change"
    * (cuando el texto ha cambiado y el usuario presiona la tecla Intro o Tab).
    *
    * El elemento activa un evento "clear" cuando el usuario hace clic en el
    * emoji correcto (la X). Si ningún controlador llama a preventDefault()
    * en el evento, el elemento borra la entrada del usuario una vez que se
    * completa el envío del evento.
    *
    * Tenga en cuenta que no hay propiedades o atributos onsearch y onclear:
    * los controladores para los eventos "search" y "clear" solo se pueden
    * registrar con addEventListener().
    */
    class SearchBox extends HTMLElement &lbrace;
      constructor() &lbrace;
        super(); // Invocar el constructor de la superclase; debe ser el primero.

        // Crea un árbol DOM de sombra y adjúntalo a este elemento,
        // estableciendo el valor de this.shadowRoot.
        this.attachShadow(&lbrace;mode: "open"});

        // Clone la plantilla que define los descendientes y la hoja de estilos
        // para este componente personalizado y agregue ese contenido a la raíz de sombra.
        this.shadowRoot.append(SearchBox.template.content.cloneNode(true));

        // Obtener referencias a los elementos importantes en el shadow DOM
        this.input = this.shadowRoot.querySelector("#input");
        let leftSlot = this.shadowRoot.querySelector('slot[name="left"]');
        let rightSlot = this.shadowRoot.querySelector('slot[name="right"]');

        // Cuando el campo de entrada interno obtiene o pierde el foco,
        // configure o elimine el atributo "focused", lo que hará que nuestra
        // hoja de estilo interna muestre u oculte un anillo de enfoque
        // falso en todo el componente. No es que los eventos "blur" y "focus"
        // aparezcan y parezcan originarse en el &lt;search-box>.
        this.input.onfocus = () => &lbrace; this.setAttribute("focused", ""); };
        this.input.onblur = () => &lbrace; this.removeAttribute("focused");};

        // Si el usuario hace clic en la lupa, se activa un evento de "search".
        // También se activa si el campo de entrada activa un evento de "change".
        // (El evento de "change" no aparece en el Shadow DOM).
        leftSlot.onclick = this.input.onchange = (event) => &lbrace;
          event.stopPropagation(); // Evitar que los eventos de clic se reproduzcan
          if (this.disabled) return; // No hacer nada cuando está deshabilitado
          this.dispatchEvent(new CustomEvent("search", &lbrace;
            detail: this.input.value
          }));&lt;
        };

        // Si el usuario hace clic en la X, se activa un evento "borrar".
        // Si no se llama a preventDefault() en el evento, borra la entrada.
        rightSlot.onclick = (event) => &lbrace;
          event.stopPropagation(); // No dejes que el clic se haga más fuerte
          if (this.disabled) return; // No hagas nada si está deshabilitado
          let e = new CustomEvent("clear", &lbrace; cancelable: true });
          this.dispatchEvent(e);
          if (!e.defaultPrevented) &lbrace; // Si el evento no fue "cancelled"
            this.input.value = ""; // Luego borre el campo de entrada
        }
      };
    }
    // Cuando se configuran o modifican algunos de nuestros atributos,
    // debemos configurar el valor correspondiente en el elemento interno
    // &lt;input>. Este método de ciclo de vida, junto con la propiedad estática
    // observationAttributes que aparece a continuación, se encarga de eso.
    attributeChangedCallback(name, oldValue, newValue) &lbrace;
      if (name === "disabled") &lbrace;
        this.input.disabled = newValue !== null;
      } else if (name === "placeholder") &lbrace;
        this.input.placeholder = newValue;
      } else if (name === "size") &lbrace;
        this.input.size = newValue;
      } else if (name === "value") &lbrace;
        this.input.value = newValue;
      }
    }

    // Por último, definimos los métodos de obtención y establecimiento de
    // propiedades que corresponden a los atributos HTML que admitimos. Los
    // métodos de obtención simplemente devuelven el valor (o la presencia)
    // del atributo, y los métodos de establecimiento simplemente establecen
    // el valor (o la presencia) del atributo. Cuando un método de
    // establecimiento cambia un atributo, el navegador invocará
    // automáticamente el attributeChangedCallback mencionado anteriormente.
    get placeholder() &lbrace; return this.getAttribute("placeholder"); }
    get size() &lbrace; return this.getAttribute("size"); }
    get value() &lbrace; return this.getAttribute("value"); }
    get disabled() &lbrace; return this.hasAttribute("disabled"); }
    get hidden() &lbrace; return this.hasAttribute("hidden"); }

    set placeholder(value) &lbrace; this.setAttribute("placeholder", value); }
    set size(value) &lbrace; this.setAttribute("size", value); }
    set value(text) &lbrace; this.setAttribute("value", text); }
    set disabled(value) &lbrace;
      if (value) this.setAttribute("disabled", "");
      else this.removeAttribute("disabled");
    }
    set hidden(value) &lbrace;
      if (value) this.setAttribute("hidden", "");
      else this.removeAttribute("hidden");
    }
  }
  // Este campo estático es obligatorio para el método attributeChangedCallback.
  // Sólo los atributos nombrados en esta matriz activarán llamadas a ese método.
  SearchBox.observedAttributes = ["disabled", "placeholder", "size", "value"];

  // Cree un elemento &lt;template> para almacenar la hoja de estilos y el
  // árbol de elementos que usaremos para cada instancia del elemento SearchBox.
  SearchBox.template = document.createElement("template");

  // Inicializamos la plantilla analizando esta cadena de HTML. Sin embargo,
  // tenga en cuenta que cuando creamos una instancia de SearchBox, podemos
  // clonar los nodos en la plantilla y no tenemos que analizar el HTML nuevamente.
  SearchBox.template.innerHTML = `
  &lt;style>
  /*
  * El selector :host hace referencia al elemento &lt;search-box> en el DOM
  * ligero. Estos estilos son predeterminados y el usuario del &lt;search-box>
  * puede anularlos con estilos en el DOM ligero.
  */
  :host &lbrace;
    display: inline-block; /* El valor predeterminado es la visualización en línea. */
    border: solid black 1px; /* Un borde redondeado alrededor de la &lt;input> y &lt;slots> */
    border-radius: 5px;
    padding: 4px 6px; /* Y algo de espacio dentro de la frontera. */
  }
  :host([hidden]) &lbrace; /* Tenga en cuenta los paréntesis: cuando el host ha ocultado... */
    display:none; /* ...el conjunto de atributos no lo muestra */
  }
  :host([disabled]) &lbrace; /* Cuando el host tiene el atributo deshabilitado... */
    opacity: 0.5; /* ...ponlo en gris */
  }
  :host([focused]) &lbrace; /* Cuando el host tiene el atributo enfocado... */
    box-shadow: 0 0 2px 2px #6AE; /* Muestra este anillo de enfoque falso. */
  }

  /* El resto de la hoja de estilos solo se aplica a los elementos en el Shadow DOM. */
  input &lbrace;
    border-width: 0; /* Ocultar el borde del campo de entrada interno. */
    outline: none; /* Oculta también el anillo de enfoque. */
    font: inherit; /* &lt;input> Los elementos no heredan la fuente por defecto */
    background: inherit; /* Lo mismo para el color de fondo. */
  }
  slot &lbrace;
    cursor: default; /* Un cursor con forma de flecha sobre los botones */
    user-select: none; /* No dejes que el usuario seleccione el texto emoji. */
  }
  &lt;/style>
    &lt;div>&lt;slot name="left">\u&lbrace;1f50d}&lt;/slot> &lt;!-- U+1F50D es una lupa -->
    &lt;input type="text" id="input" /> &lt;!-- El elemento de entrada real -->
    &lt;slot name="right">\u&lbrace;2573}&lt;/slot> &lt;!-- U+2573 es una X -->
  &lt;/div>
  `;

  // Por último, llamamos a customElement.define() para registrar el elemento
  // SearchBox como la implementación de la etiqueta &lt;search-box>. Los
  // elementos personalizados deben tener un nombre de etiqueta que contenga un guion.
  customElements.define("search-box", SearchBox);</code></pre>
  </section>
  <section id="7">
    <h2>15.7 SVG: gráficos vectoriales escalables</h2>
    <p>SVG (scalable vector graphics) es un formato de imagen. La palabra "vector" en su nombre indica que es fundamentalmente diferente de los formatos de imagen de trama, como GIF, JPEG y PNG, que especifican una matriz de valores de píxeles. En su lugar, una "imagen" SVG es una descripción precisa e independiente de la resolución (de ahí lo de "escalable") de los pasos necesarios para dibujar el gráfico deseado. Las imágenes SVG se describen mediante archivos de texto que utilizan el lenguaje de marcado XML, bastante similar al HTML.</p>
    <p>Existen tres formas de utilizar SVG en los navegadores web:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede utilizar archivos de imagen <em>.svg</em> con etiquetas HTML <codeinline>&lt;img></codeinline> normales, del mismo modo que utilizaría una imagen <em>.png</em> o <em>.jpeg</em>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Dado que el formato SVG basado en XML es tan similar al HTML, puede incrustar etiquetas SVG directamente en sus documentos HTML. Si lo hace, el analizador HTML del navegador le permitirá omitir los espacios de nombres XML y tratar las etiquetas SVG como si fueran etiquetas HTML.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede utilizar la API DOM para crear dinámicamente elementos SVG que generen imágenes bajo demanda.
        </p>
      </li>
    </ul>
    <p>Las subsecciones siguientes muestran el segundo y tercer uso de SVG. Tenga en cuenta, sin embargo, que SVG tiene una gramática amplia y moderadamente compleja. Además de las sencillas primitivas de dibujo de formas, incluye soporte para curvas arbitrarias, texto y ani- mación. Los gráficos SVG pueden incluso incorporar scripts JavaScript y hojas de estilo CSS para añadir información de comportamiento y presentación. Una descripción completa de SVG va mucho más allá del alcance de este libro. El objetivo de esta sección es sólo para mostrar cómo se puede utilizar SVG en sus documentos HTML y la secuencia de comandos con JavaScript.</p>
  </section>
  <section id="7-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.1 SVG en HTML</h2>
    <p>Por supuesto, las imágenes SVG pueden mostrarse mediante etiquetas HTML <codeinline>&lt;img></codeinline>. Pero también puede incrustar SVG directamente en HTML. Y si lo hace, puede incluso utilizar hojas de estilo CSS para especificar cosas como fuentes, colores y anchos de línea. Aquí tiene, por ejemplo, un archivo HTML que utiliza SVG para mostrar la esfera de un reloj analógico:</p>
    <pre class="language-js">
    <code class="language-js">&lt;html>
    &lt;head>
    &lt;title>Analog Clock&lt;/title>
    &lt;style>
    /* Todos estos estilos CSS se aplican a los elementos SVG definidos a continuación */
    #clock &lbrace; /* Estilos para todo en el reloj:*/
      stroke: black; /* líneas negras */
      stroke-linecap: round; /* con extremos redondeados */
      fill: #ffe; /* sobre un fondo blanquecino */
    }
    #clock .face &lbrace; stroke-width: 3; } /* Contorno de la esfera del reloj */
    #clock .ticks &lbrace; stroke-width: 2; } /* Líneas que marcan cada hora */
    #clock .hands &lbrace; stroke-width: 3; } /* Cómo dibujar las manecillas del reloj */
    #clock .numbers &lbrace; /* Cómo dibujar los números */
      font-family: sans-serif; font-size: 10; font-weight: bold;
      text-anchor: middle; stroke: none; fill: black;
    }
    &lt;/style>
    &lt;/head>
    &lt;body>
      &lt;svg id="clock" viewBox="0 0 100 100" width="250" height="250">
        &lt;!-- Los atributos de ancho y alto son el tamaño de pantalla del gráfico. -->
        &lt;!-- El atributo viewBox proporciona el sistema de coordenadas interno -->
        &lt;circle class="face" cx="50" cy="50" r="45"/> &lt;!-- La cara del reloj -->
        &lt;g class="ticks"> &lt;!-- Marcas de verificación para cada una de las 12 horas -->
          &lt;line x1='50' y1='5.000' x2='50.00' y2='10.00'/>
          &lt;line x1='72.50' y1='11.03' x2='70.00' y2='15.36'/>
          &lt;line x1='88.97' y1='27.50' x2='84.64' y2='30.00'/>
          &lt;line x1='95.00' y1='50.00' x2='90.00' y2='50.00'/>
          &lt;line x1='88.97' y1='72.50' x2='84.64' y2='70.00'/>
          &lt;line x1='72.50' y1='88.97' x2='70.00' y2='84.64'/>
          &lt;line x1='50.00' y1='95.00' x2='50.00' y2='90.00'/>
          &lt;line x1='27.50' y1='88.97' x2='30.00' y2='84.64'/>
          &lt;line x1='11.03' y1='72.50' x2='15.36' y2='70.00'/>
          &lt;line x1='5.000' y1='50.00' x2='10.00' y2='50.00'/>
          &lt;line x1='11.03' y1='27.50' x2='15.36' y2='30.00'/>
          &lt;line x1='27.50' y1='11.03' x2='30.00' y2='15.36'/>
        &lt;/g>
        &lt;g class="numbers"> &lt;!-- Numera los puntos cardinales -->
          &lt;text x="50" y="18">12&lt;/text>&lt;text x="85" y="53">3&lt;/text>
          &lt;text x="50" y="88">6&lt;/text>&lt;text x="15" y="53">9&lt;/text>
        &lt;/g>
        &lt;g class="hands"> &lt;!-- Dibuja manos apuntando hacia arriba. -->
          &lt;line class="hourhand" x1="50" y1="50" x2="50" y2="25"/>
          &lt;line class="minutehand" x1="50" y1="50" x2="50" y2="20"/>
        &lt;/g>
      &lt;/svg>
      &lt;script src="clock.js">&lt;/script>
    &lt;/body>
    &lt;/html></code></pre>
    <p>Observará que los descendientes de la etiqueta <codeinline>&lt;svg></codeinline> no son etiquetas HTML normales. Sin embargo, las etiquetas <codeinline>&lt;circle></codeinline>, <codeinline>&lt;line></codeinline> y <codeinline>&lt;text></codeinline> tienen propósitos obvios y debería estar claro cómo funciona este gráfico SVG. Hay muchas otras etiquetas SVG, sin embargo, y usted tendrá que consultar una referencia SVG para aprender más. También puede observar que la hoja de estilo es extraña. Los estilos <codeinline>fill</codeinline>, <codeinline>stroke-width</codeinline> y <codeinline>text-anchor</codeinline> no son propiedades de estilo CSS normales. En este caso, CSS se utiliza esencialmente para establecer los atributos de las etiquetas SVG que aparecen en el documento. Tenga en cuenta también que la propiedad CSS <codeinline>font</codeinline> shorthand no funciona para las etiquetas SVG, y debe establecer explícitamente <codeinline>font-family</codeinline>, <codeinline>font-size</codeinline> y <codeinline>font-weight</codeinline> como propiedades de estilo independientes.</p>
  </section>
  <section id="7-2">
    <h2>15.7.2 Secuencias de comandos SVG</h2>
    <p>Una de las razones para incrustar SVG directamente en sus archivos HTML (en lugar de utilizar sólo estática <codeinline>&lt;img></codeinline>) es que si lo hace, puede utilizar la API DOM para manipular la imagen SVG. Supongamos que utiliza SVG para mostrar iconos en su aplicación web. Puede incrustar SVG en una etiqueta <codeinline>&lt;template></codeinline> (<a href="#6-2">§15.6.2</a>) y clonar el contenido de la plantilla cuando necesite insertar una copia de ese icono en la interfaz de usuario. Y si quieres que el icono responda a la actividad del usuario -por ejemplo, cambiando de color cuando el usuario pasa el puntero por encima-, a menudo puedes conseguirlo con CSS.</p>
    <p>También es posible manipular dinámicamente gráficos SVG directamente incrustados en HTML. El ejemplo de la esfera del reloj de la sección anterior muestra un reloj estático con las manecillas de la hora y los minutos mirando hacia arriba y mostrando la hora del mediodía o la medianoche. Pero habrá notado que el archivo HTML incluye una etiqueta <codeinline>&lt;script></codeinline>. Ese script ejecuta una función periódicamente para comprobar la hora y transformar las manecillas de las horas y los minutos girándolas el número apropiado de grados para que el reloj muestre realmente la hora actual, como se muestra en la <a href="#figure15-5">Figura 15-5</a>.</p>
    <figure id="figure15-5">
      <img src="/public/javascript/capitulo-15/figure15-5.avif" alt="imagen de consola">
      <figcaption>Figura 15-5. Un reloj analógico SVG con guión</figcaption>
    </figure>
    <p>El código para manipular el reloj es sencillo. Determina el ángulo adecuado de las manecillas de las horas y los minutos en función de la hora actual, luego utiliza <codeinline>querySelector()</codeinline> para buscar los elementos SVG que muestran esas manecillas, y luego les asigna un atributo transform para girarlas alrededor del centro de la esfera del reloj. La función utiliza <codeinline>setTimeout()</codeinline> para asegurarse de que se ejecuta una vez por minuto:</p>
    <pre class="language-js">
    <code class="language-js">(function updateClock() &lbrace;     // Actualiza el gráfico del reloj SVG 
                                  // para mostrar la hora actual

      let now = new Date();       // Hora actual
      let sec = now.getSeconds(); // Segundos
      let min = now.getMinutes() + sec/60;       // Minutos fraccionarios
      let hour = (now.getHours() % 12) + min/60; // Horas fraccionarias
      let minangle = min * 6;     // 6 grados por minuto
      let hourangle = hour * 30;  // 30 grados por hora

      // Obtiene los elementos SVG para las manecillas del reloj
      let minhand = document.querySelector("#clock .minutehand");
      let hourhand = document.querySelector("#clock .hourhand");

      // Establece un atributo SVG para rotar las manecillas alrededor de la cara del reloj
      minhand.setAttribute("transform", `rotate($&lbrace;minangle},50,50)`);
      hourhand.setAttribute("transform", `rotate($&lbrace;hourangle},50,50)`);
      
      // Ejecuta esta función de nuevo en 10 segundos
      setTimeout(updateClock, 10000);
    }()); // Nota: la función se invoca inmediatamente aquí.</code></pre>
  </section>
  <section id="7-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.3 Creación de imágenes SVG con JavaScript</h2>
    <p>Además de simplemente programar imágenes SVG incrustadas en sus documentos HTML, también puede crear imágenes SVG desde cero, lo que puede ser útil para crear visualizaciones de datos cargados dinámicamente, por ejemplo. El <a href="#ejemplo15-4">Ejemplo 15-4</a> muestra cómo utilizar JavaScript para crear gráficos circulares SVG, como el que se muestra en la <a href="#figure15-6">Figura 15-6</a>.</p>
    <p>Aunque las etiquetas SVG pueden incluirse en documentos HTML, técnicamente son etiquetas XML, no HTML, y si desea crear elementos SVG con la API DOM de Java Script, no puede utilizar la función normal <codeinline>createElement()</codeinline> que se introdujo en <a href="#3-5">§15.3.5</a>. En su lugar, debe utilizar <codeinline>createElementNS()</codeinline>, que toma una cadena de espacio de nombres XML como primer argumento.Para SVG, ese espacio de nombres es la cadena literal "http://www.w3.org/2000/svg".</p>
    <figure id="figure15-5">
      <img src="/public/javascript/capitulo-15/figure15-6.avif" alt="imagen de consola">
      <figcaption>Figura 15-6. Un gráfico circular SVG construido con JavaScript (datos de la encuesta de desarrolladores de 2018 de Stack Overflow sobre las tecnologías más populares)</figcaption>
    </figure>
    <p>Aparte del uso de <codeinline>createElementNS()</codeinline>, el código para dibujar el gráfico circular del <a href="ejemplo15-4">Ejemplo 15-4</a> es relativamente sencillo. Hay un poco de matemática para convertir los datos que se grafican en ángulos de cortes circulares. La mayor parte del ejemplo, sin embargo, es código DOM que crea elementos SVG y establece atributos en esos elementos.</p>
    <p>La parte más opaca de este ejemplo es el código que dibuja las porciones de tarta. El elemento utilizado para mostrar cada porción es <codeinline>&lt;path></codeinline>. Este elemento SVG describe formas arbitrarias compuestas por líneas y curvas. La descripción de la forma se especifica mediante el atributo d del elemento <codeinline>&lt;path></codeinline>. El valor de este atributo utiliza una gramática compacta de códigos de letras y números que especifican coordenadas, ángulos y otros valores. La letra M, por ejemplo, significa "mover a" y va seguida de las coordenadas <em>x</em> e <em>y</em>. La letra L significa "línea a" y dibuja una línea desde el punto actual hasta las coordenadas que le siguen. Este ejemplo también utiliza la letra A para dibujar un arco. Esta letra va seguida de siete números que describen el arco, y puedes buscar la sintaxis en Internet si quieres saber más.</p>
    <p><em>Ejemplo 15-4. Dibujo de un gráfico circular con JavaScript y SVG</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * Crea un elemento &lt;svg> y dibuja un gráfico de pastel dentro de él.
    *
    * Esta función espera un argumento objeto con las siguientes propiedades:
    *
    * width, height: el tamaño del gráfico SVG, en píxeles
    * cx, cy, r: el centro y el radio del pastel
    * lx, ly: la esquina superior izquierda de la leyenda del gráfico
    * data: un objeto cuyos nombres de propiedad son las etiquetas de datos y
    * cuyos valores son los valores asociados a cada etiqueta
    *
    * La función devuelve un elemento &lt;svg>. El llamador debe insertarlo en
    * el documento para que sea visible.
    */
    function pieChart(options) &lbrace;
      let &lbrace;width, height, cx, cy, r, lx, ly, data} = options;

      // Este es el espacio de nombres XML para los elementos SVG
      let svg = "http://www.w3.org/2000/svg";

      // Crea el elemento &lt;svg> y especifica el tamaño en píxeles y las 
      // coordenadas del usuario.
      let chart = document.createElementNS(svg, "svg");
      chart.setAttribute("width", width);
      chart.setAttribute("height", height);
      chart.setAttribute("viewBox", `0 0 $&lbrace;width} $&lbrace;height}`);

      // Define los estilos de texto que se usarán para el gráfico.
      chart.setAttribute("font-family", "sans-serif");
      chart.setAttribute("font-size", "18");

      // Obtén etiquetas y valores como arreglos y suma los valores para conocer
      // el tamaño total del pastel.
      let labels = Object.keys(data);
      let values = Object.values(data);
      let total = values.reduce((x,y) => x+y);

      // Calcula los ángulos para todas las porciones. La porción i empieza en angles[i]
      // y termina en angles[i+1]. Los ángulos se miden en radianes.
      let angles = [0];
      values.forEach((x, i) => angles.push(angles[i] + x/total * 2 * Math.PI));

      // Recorre las porciones del gráfico de pastel
      values.forEach((value, i) => &lbrace;
        // Calcula los dos puntos donde la porción intersecta el círculo
        // Estas fórmulas están elegidas para que un ángulo de 0 esté a las 12 en punto
        // y los ángulos positivos aumenten en sentido horario.
        let x1 = cx + r * Math.sin(angles[i]);
        let y1 = cy - r * Math.cos(angles[i]);
        let x2 = cx + r * Math.sin(angles[i+1]);
        let y2 = cy - r * Math.cos(angles[i+1]);
        // Esta es una bandera para ángulos mayores a medio círculo
        // Se requiere para el componente de dibujo de arco SVG
        let big = (angles[i+1] - angles[i] > Math.PI) ? 1 : 0;

        // Esta cadena describe cómo dibujar una porción del gráfico de pastel:
        let path = `M$&lbrace;cx},$&lbrace;cy}` +   // Moverse al centro del círculo
            `L$&lbrace;x1},$&lbrace;y1}` +          // Dibujar línea hasta (x1, y1)
            `A$&lbrace;r},$&lbrace;r} 0 $&lbrace;big} 1` + // Dibujar un arco de radio r...
            `$&lbrace;x2},$&lbrace;y2}` +           // ...terminando en (x2, y2)
            "Z";                      // Cerrar el camino de regreso a (cx, cy)

        // Calcula el color CSS para esta porción. Esta fórmula funciona para
        // aproximadamente 15 colores. No incluir más de 15 porciones en el gráfico.
        let color = `hsl($&lbrace;(i*40)%360},$&lbrace;90-3*i}%,$&lbrace;50+2*i}%)`;

        // Describimos una porción con un elemento &lt;path>. Nota el uso de createElementNS().
        let slice = document.createElementNS(svg, "path");

        // Ahora establece atributos en el elemento &lt;path>
        slice.setAttribute("d", path);           // Establecer el camino para esta porción
        slice.setAttribute("fill", color);       // Establecer el color de la porción
        slice.setAttribute("stroke", "black");   // Contorno de la porción en negro
        slice.setAttribute("stroke-width", "1"); // Contorno de 1 píxel CSS
        chart.append(slice);                     // Añadir la porción al gráfico

        // Dibuja un pequeño cuadrado coincidente para la leyenda
        let icon = document.createElementNS(svg, "rect");
        icon.setAttribute("x", lx);           // Posicionar el cuadrado
        icon.setAttribute("y", ly + 30*i);
        icon.setAttribute("width", 20);       // Tamaño del cuadrado
        icon.setAttribute("height", 20);
        icon.setAttribute("fill", color);     // Mismo color que la porción
        icon.setAttribute("stroke", "black"); // Mismo contorno también
        icon.setAttribute("stroke-width", "1");
        chart.append(icon);                   // Añadir al gráfico

        // Añadir una etiqueta a la derecha del rectángulo
        let label = document.createElementNS(svg, "text");
        label.setAttribute("x", lx + 30);      // Posicionar el texto
        label.setAttribute("y", ly + 30*i + 16);
        label.append(`$&lbrace;labels[i]} $&lbrace;value}`); // Añadir texto a la etiqueta
        chart.append(label);                   // Añadir la etiqueta al gráfico
      });

      return chart;
    }</code></pre>
    <p>El gráfico circular de la <a href="figure15-6">Figura 15-6</a> se creó utilizando la función <codeinline>pieChart()</codeinline> <a href="ejemplo15-6">Ejemplo 15-4</a>, de esta manera:</p>
    <pre class="language-js">
    <code class="language-js">document.querySelector("#chart").append(pieChart(&lbrace;
      width: 640, height:400,   // Tamaño total del gráfico
      cx: 200, cy: 200, r: 180, // Centro y radio del gráfico circular
      lx: 400, ly: 10,          // Posición de la leyenda
      data: &lbrace;                   // Posición de la leyenda
        "JavaScript": 71.5,
        "Java": 45.4,
        "Bash/Shell": 40.4,
        "Python": 37.9,
        "C#": 35.3,
        "PHP": 31.4,
        "C++": 24.6,
        "C": 22.1,
        "TypeScript": 18.3,
        "Ruby": 10.3,
        "Swift": 8.3,
        "Objective-C": 7.3,
        "Go": 7.2,
      }
    }));</code></pre>
  </section>
  <section id="8">
    <h2>15.8 Gráficos en un &lt;canvas></h2>
    <p>El elemento <codeinline>&lt;canvas></codeinline> no tiene apariencia propia, sino que crea una superficie de dibujo dentro del documento y expone una potente API de dibujo a JavaScript del lado del cliente. La principal diferencia entre la API <codeinline>&lt;canvas></codeinline> y SVG es que con el lienzo se crean dibujos llamando a métodos, y con SVG se crean dibujos construyendo un árbol de elementos XML. Estos dos enfoques son equivalentemente potentes: cualquiera de ellos puede simularse con el otro. Sin embargo, a primera vista son bastante diferentes y cada uno tiene sus puntos fuertes y débiles. Un dibujo SVG, por ejemplo, se edita fácilmente eliminando elementos de su descripción. Para eliminar un elemento del mismo gráfico en un <codeinline>&lt;canvas></codeinline>, a menudo es necesario borrar el dibujo y volver a dibujarlo desde cero. Dado que la API de dibujo Canvas está basada en JavaScript y es relativamente compacta (a diferencia de la gramática SVG), se documenta con más detalle en este libro.</p>
    <article>
      <p class="title-article">Gráficos 3D en un lienzo</p>
      <p>También puede llamar a <codeinline>getContext()</codeinline> con la cadena "webgl" para obtener un objeto de contexto que le permita dibujar gráficos 3D utilizando la API WebGL. WebGL es una API grande, complicada y de bajo nivel que permite a los programadores de JavaScript acceder a la GPU, escribir sombreadores de usuario y realizar otras operaciones gráficas muy potentes. Sin embargo, WebGL no se documenta en este libro: es más probable que los desarrolladores web utilicen librerías de utilidades creadas sobre WebGL que la API WebGL directamente.</p>
    </article>
    <p>La mayor parte de la API de dibujo del lienzo no se define en el elemento <codeinline>&lt;canvas></codeinline> en sí, sino en un objeto "contexto de dibujo" que se obtiene con el método <codeinline>getContext()</codeinline> del lienzo. Llame a <codeinline>getContext()</codeinline> con el argumento "2d" para obtener un objeto CanvasRenderingContext2D que puede utilizar para dibujar gráficos bidimensionales en el lienzo.</p>
    <p>Como ejemplo sencillo de la API Canvas, el siguiente documento HTML utiliza <codeinline>&lt;canvas></codeinline> y algo de JavaScript para mostrar dos formas simples:</p>
    <pre class="language-js">
    <code class="language-js">&lt;p>This is a red square: &lt;canvas id="square" width=10 height=10>&lt;/canvas>.
    &lt;p>This is a blue circle: &lt;canvas id="circle" width=10 height=10>&lt;/canvas>.
    &lt;script>
    let canvas = document.querySelector("#square"); // Get first canvas element
    let context = canvas.getContext("2d");          // Get 2D drawing context
    context.fillStyle = "#f00";                     // Set fill color to red
    context.fillRect(0,0,10,10);                    // Fill a square

    canvas = document.querySelector("#circle");     // Second canvas element
    context = canvas.getContext("2d");              // Get its context
    context.beginPath();                            // Begin a new "path"
    context.arc(5, 5, 5, 0, 2*Math.PI, true);       // Add a circle to the path
    context.fillStyle = "#00f";                     // Set blue fill color
    context.fill();                                 // Fill the path
    &lt;/script></code></pre>
    <p>Hemos visto que SVG describe formas complejas como un "camino" de líneas y curvas que se pueden dibujar o rellenar. La API Canvas también utiliza la noción de trazado. En lugar de describir un trazado como una cadena de letras y números, un trazado se define mediante una serie de llamadas a métodos, como las invocaciones a <codeinline>beginPath()</codeinline> y <codeinline>arc()</codeinline> del código anterior. Una vez definido el recorrido, otros métodos, como <codeinline>fill()</codeinline>, actúan sobre él. Varias propiedades del objeto de contexto, como <codeinline>fillStyle</codeinline>, especifican cómo se realizan estas operaciones.</p>
    <p>Las subsecciones que siguen demuestran los métodos y propiedades de la API Canvas 2D. Gran parte del código de ejemplo que sigue opera sobre una variable <codeinline>c</codeinline>. Esta variable contiene el objeto CanvasRenderingContext2D del lienzo, pero el código para inicializar esa variable a veces no se muestra. Para que estos ejemplos funcionen, tendrías que añadir marcado HTML para definir un lienzo con los atributos de <codeinline>width</codeinline> y <codeinline>height</codeinline> apropiados, y luego añadir código como éste para inicializar la variable <codeinline>c</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let canvas = document.querySelector("#my_canvas_id");
    let c = canvas.getContext('2d');</code></pre>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.1 Trayectorias y polígonos</h2>
    <p>Para dibujar líneas en un lienzo y rellenar las áreas delimitadas por esas líneas, se empieza por definir un <em>path</em>. Un trayecto es una secuencia de uno o más subtrayectos. Un subtrayecto es una secuencia de dos o más puntos conectados por segmentos de línea (o, como veremos más adelante, por segmentos de curva). Inicie un nuevo trayecto con el método <codeinline>beginPath()</codeinline>. Comenzar un nuevo con el método <codeinline>moveTo()</codeinline>. Una vez que haya establecido el punto de partida de un subtrayecto con <codeinline>moveTo()</codeinline>, puede conectar ese punto a un nuevo punto con una línea recta llamando a <codeinline>lineTo()</codeinline>. El siguiente código define un camino que incluye dos segmentos de línea:</p>
    <pre class="language-js">
    <code class="language-js">c.beginPath();      // Start a new path
    c.moveTo(100, 100); // Begin a subpath at (100,100)
    c.lineTo(200, 200); // Add a line from (100,100) to (200,200)
    c.lineTo(100, 200); // Add a line from (200,200) to (100,200)</code></pre>
    <p>Este código simplemente define un trazado; no dibuja nada en el lienzo. Para dibujar (o "trazar") los dos segmentos de línea del trazado, llame al método <codeinline>stroke()</codeinline>, y para rellenar el área definida por esos segmentos de línea, llame a <codeinline>fill()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">c.fill();   // Fill a triangular area
    c.stroke(); // Stroke two sides of the triangle</code></pre>
    <p>Este código (junto con algún código adicional para establecer los anchos de línea y los colores de relleno) produjo el dibujo que se muestra en la <a href="#figure15-7">Figura 15-7</a>.</p>
    <figure id="figure15-7">
      <img src="/public/javascript/capitulo-15/figure15-7.avif" alt="imagen de consola">
      <figcaption>Figura 15-7. Una trayectoria simple, rellenada y trazada</figcaption>
    </figure>
    <p>Observa que el subcamino definido en la <a href="#figure15-7">Figura 15-7</a> es "abierto". Consta de sólo dos segmentos de línea, y el punto final no está conectado al punto inicial. Esto significa que no encierra una región. El método <codeinline>fill()</codeinline> rellena subtrayectorias abiertas actuando como si una línea recta conectara el último punto de la subtrayectoria con el primer punto de la subtrayectoria. Por eso este código rellena un triángulo, pero traza sólo dos lados del triángulo.</p>
    <p>Si quisieras trazar los tres lados del triángulo que acabamos de mostrar, llamarías al método <codeinline>closePath()</codeinline> para conectar el punto final del subtrayecto con el punto inicial. (También podría llamar a <codeinline>lineTo(100,100)</codeinline>, pero entonces acabaría con tres segmentos de línea que comparten un punto inicial y final pero que no están realmente cerrados. Cuando se dibuja con líneas anchas, los resultados visuales son mejores si se utiliza <codeinline>closePath()</codeinline>).</p>
    <p>Hay otros dos puntos importantes a tener en cuenta sobre <codeinline>stroke()</codeinline> y <codeinline>fill()</codeinline>. Primero, ambos métodos operan en todos los subcaminos del camino actual. Supongamos que hemos añadido otro subtrayecto en el código anterior:</p>
    <pre class="language-js">
    <code class="language-js">c.moveTo(300,100); // Begin a new subpath at (300,100);
    c.lineTo(300,200); // Draw a vertical line down to (300,200);</code></pre>
    <p>Si entonces llamáramos a <codeinline>stroke()</codeinline>, dibujaríamos dos aristas conectadas de un triángulo y una línea vertical desconectada.</p>
    <p>El segundo punto a tener en cuenta sobre <codeinline>stroke()</codeinline> y <codeinline>fill()</codeinline> es que ninguno altera el trazado actual: puede llamar a <codeinline>fill()</codeinline> y el trazado seguirá ahí cuando llame a <codeinline>stroke()</codeinline>. Cuando haya terminado con un trazado y quiera comenzar otro, debe recordar llamar a <codeinline>beginPath()</codeinline>. Si no lo hace, acabará añadiendo nuevos subtrayectos al trazado existente, y puede acabar dibujando esos viejos subtrayectos una y otra vez.</p>
    <p>El <a href="#ejemplo15-5">Ejemplo 15-5</a> define una función para dibujar polígonos regulares y demuestra el uso de <codeinline>moveTo()</codeinline>, <codeinline>lineTo()</codeinline>, y <codeinline>closePath()</codeinline> para definir subtrayectorias y de <codeinline>fill()</codeinline> y <codeinline>stroke()</codeinline> para dibujar esas trayectorias. Produce el dibujo mostrado en la <a href="figure15-8">Figura 15-8</a>.</p>
    <figure id="figure15-8">
      <img src="/public/javascript/capitulo-15/figure15-8.avif" alt="imagen de consola">
      <figcaption>Figura 15-8. Polígonos regulares</figcaption>
    </figure>
    <p><em>Ejemplo 15-5. Polígonos regulares con moveTo(), lineTo() y closePath()</em></p>
    <pre class="language-js">
    <code class="language-js">// Define a regular polygon with n sides, centered at (x,y) with radius r.
    // The vertices are equally spaced along the circumference of a circle.
    // Put the first vertex straight up or at the specified angle.
    // Rotate clockwise, unless the last argument is true.
    function polygon(c, n, x, y, r, angle=0, counterclockwise=false) &lbrace;
      c.moveTo(x + r*Math.sin(angle),   // Begin a new subpath at the first vertex
          y - r*Math.cos(angle));       // Use trigonometry to compute position
      let delta = 2*Math.PI/n;          // Angular distance between vertices
      for(let i = 1; i &lt; n; i++) &lbrace;      // For each of the remaining vertices
          angle += counterclockwise?-delta:delta; // Adjust angle
          c.lineTo(x + r*Math.sin(angle),         // Add line to next vertex
              y - r*Math.cos(angle));
      }
      c.closePath(); // Connect last vertex back to the first
    }

    // Assume there is just one canvas, and get its context object to draw with.
    let c = document.querySelector("canvas").getContext("2d");

    // Start a new path and add polygon subpaths
    c.beginPath();
    polygon(c, 3, 50, 70, 50);                   // Triangle
    polygon(c, 4, 150, 60, 50, Math.PI/4);       // Square
    polygon(c, 5, 255, 55, 50);                  // Pentagon
    polygon(c, 6, 365, 53, 50, Math.PI/6);       // Hexagon
    polygon(c, 4, 365, 53, 20, Math.PI/4, true); // Small square inside the hexagon

    // Set some properties that control how the graphics will look
    c.fillStyle = "#ccc";                  // Light gray interiors
    c.strokeStyle = "#008";                // outlined with dark blue lines
    c.lineWidth = 5;                       // five pixels wide.

    // Now draw all the polygons (each in its own subpath) with these calls
    c.fill();                              // Fill the shapes
    c.stroke();                            // And stroke their outlines</code></pre>
    <p>Observa que este ejemplo dibuja un hexágono con un cuadrado en su interior. El cuadrado y el hexágono son subtrayectorias separadas, pero se solapan. Cuando esto ocurre (o cuando un subtrayecto se cruza a sí mismo), el lienzo necesita ser capaz de determinar qué regiones están dentro del trazado y cuáles están fuera. Para ello, el lienzo utiliza una prueba denominada "regla de enrollamiento no nulo". En este caso, el interior del cuadrado no está relleno porque el cuadrado y el hexágono se dibujaron en direcciones opuestas: los vértices del hexágono se conectaron con segmentos de línea que se movían en el sentido de las agujas del reloj alrededor del círculo. Los vértices del cuadrado se conectaron en sentido contrario a las agujas del reloj. Si el cuadrado también se hubiera dibujado en el sentido de las agujas del reloj, la llamada a <codeinline>fill()</codeinline> también habría rellenado el interior del cuadrado .</p>
  </section>
  <section id="8-2">
    <h2>15.8.2 Dimensiones y coordenadas del lienzo</h2>
    <p>Los atributos <codeinline>width</codeinline> y <codeinline>height</codeinline> del elemento <codeinline>&lt;canvas></codeinline> y las correspondientes propiedades <codeinline>width</codeinline> y <codeinline>height</codeinline> del objeto Canvas especifican las dimensiones del lienzo. El sistema de coordenadas predeterminado del lienzo sitúa el origen (0,0) en la esquina superior izquierda del lienzo. Las coordenadas <em>x</em> aumentan hacia la derecha y las coordenadas <em>y</em> aumentan a medida que se desciende por la pantalla. Los puntos del lienzo pueden especificarse utilizando valores de coma flotante.</p>
    <p>Las dimensiones de un lienzo no pueden alterarse sin restablecer completamente el canvas. Al establecer las propiedades de <codeinline>width</codeinline> o <codeinline>height</codeinline> de un lienzo (incluso al establecerlas en su valor actual) se borra el lienzo, se borra la ruta actual y se restablecen todos los atributos gráficos (incluida la transformación actual y la región de recorte) a su estado original.</p>
    <p>Los atributos de <codeinline>width</codeinline> y <codeinline>height</codeinline> de un lienzo especifican el número real de píxeles en los que el lienzo puede dibujar. Se asignan cuatro bytes de memoria por cada píxel, por lo que si la <codeinline>width</codeinline> y <codeinline>height</codeinline> se establecen en 100, el lienzo asigna 40.000 bytes para representar 10.000 píxeles.</p>
    <p>Los atributos de <codeinline>width</codeinline> y <codeinline>height</codeinline> también especifican el tamaño predeterminado (en píxeles CSS) con el que se mostrará el lienzo en la pantalla. Si <codeinline>window.devicePixelRatio</codeinline> es 2, entonces 100 × 100 píxeles CSS son en realidad 40.000 píxeles de hardware. Cuando el contenido del lienzo se dibuje en la pantalla, los 10.000 píxeles de la memoria tendrán que ampliarse para cubrir los 40.000 píxeles físicos de la pantalla, lo que significa que los gráficos no serán tan nítidos como podrían ser.</p>
    <p>Para obtener una calidad de imagen óptima, no debe utilizar los atributos de <codeinline>width</codeinline> y <codeinline>height</codeinline> para establecer el tamaño en pantalla del lienzo. En su lugar, establezca el tamaño de píxel CSS en pantalla deseado del lienzo con los atributos de estilo CSS <codeinline>width</codeinline> y <codeinline>height</codeinline>. A continuación, antes de empezar a dibujar en el código JavaScript, establezca las propiedades width y height del objeto canvas en el número de píxeles CSS multiplicado por <codeinline>window.devicePixelRatio</codeinline>. Siguiendo con el ejemplo anterior, esta técnica haría que el lienzo se mostrara con 100 × 100 píxeles CSS, pero asignando memoria para 200 × 200 píxeles. (Incluso con esta técnica, el usuario puede ampliar el lienzo y ver gráficos borrosos o pixelados si lo hace. Esto contrasta con los gráficos SVG, que permanecen nítidos sin importar el tamaño en pantalla o el nivel de zoom).</p>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.3 Atributos gráficos</h2>
    <p>El <a href="#ejemplo15-5">Ejemplo 15-5</a> establece las propiedades <codeinline>fillStyle</codeinline>, <codeinline>strokeStyle</codeinline> y <codeinline>lineWidth</codeinline> en el objeto contexto del lienzo. Estas propiedades son atributos gráficos que especifican el color a utilizar por <codeinline>fill()</codeinline> y por <codeinline>stroke()</codeinline>, y la anchura de las líneas a dibujar por <codeinline>stroke()</codeinline>. Observe que estos parámetros no se pasan a los métodos <codeinline>fill()</codeinline> y <codeinline>stroke()</codeinline>, sino que forman parte del <em>estado gráfico</em> general del lienzo. Si defines un método que dibuja una forma y no estableces estas propiedades, el que llama a tu método puede definir el color de la forma estableciendo las propiedades <codeinline>strokeStyle</codeinline> y <codeinline>fillStyle</codeinline> antes de llamar a tu método. Esta separación entre el estado de los gráficos y los comandos de dibujo es fundamental para la API Canvas y es similar a la separación entre la presentación y el contenido que se consigue aplicando hojas de estilo CSS a los documentos HTML.</p>
    <p>Hay una serie de propiedades (y también algunos métodos) en el objeto contexto que afectan al estado gráfico del lienzo. Se detallan a continuación.</p>
    <p class="title-article text-left">Estilos de línea</p>
    <p>La propiedad <codeinline>lineWidth</codeinline> especifica cómo de anchas (en píxeles CSS) serán las líneas dibujadas por <codeinline>stroke()</codeinline>. El valor por defecto es 1. Es importante entender que la anchura de la línea viene determinada por la propiedad <codeinline>lineWidth</codeinline> en el momento en que se llama a <codeinline>stroke()</codeinline>, no en el momento en que se llama a <codeinline>lineTo()</codeinline> y otros métodos de construcción de trazados. Para entender completamente la propiedad <codeinline>lineWidth</codeinline>, es importante visualizar los trazados como líneas unidimensionales infinitamente finas. Las líneas y curvas dibujadas por el método <codeinline>stroke()</codeinline> están centradas sobre el trazado, con la mitad del ancho de línea a cada lado. Si estás trazando una y sólo desea que la línea aparezca fuera del trazado, trace primero el trazado y luego rellene con un color opaco para ocultar la parte del trazado que aparece dentro del trazado. O si sólo desea que la línea aparezca dentro de un trazado cerrado, llame primero a los métodos <codeinline>save()</codeinline> y <codeinline>clip()</codeinline>, y luego llame a <codeinline>stroke()</codeinline> y restore(). (Los métodos <codeinline>save()</codeinline>, <codeinline>restore()</codeinline> y <codeinline>clip()</codeinline> se describen más adelante).</p>
    <p>Cuando se dibujan líneas que tienen más de dos píxeles de ancho, las propiedades <codeinline>lineCap</codeinline> y <codeinline>lineJoin</codeinline> pueden tener un impacto significativo en la apariencia visual de los extremos de una ruta y los vértices en los que se encuentran dos segmentos de ruta. La Figura 15-9 ilustra los valores y el aspecto gráfico resultante de <codeinline>lineCap</codeinline> y <codeinline>lineJoin</codeinline>.</p>
    <figure id="figure15-9">
      <img src="/public/javascript/capitulo-15/figure15-9.avif" alt="imagen de consola">
      <figcaption>Figura 15-9. Atributos lineCap y lineJoin Atributos lineCap y lineJoin</figcaption>
    </figure>
    <p>El valor por defecto para <codeinline>lineCap</codeinline> es "butt". El valor por defecto para <codeinline>lineJoin</codeinline> es "inglete". Tenga en cuenta, sin embargo, que si dos líneas se unen en un ángulo muy estrecho, entonces el inglete resultante puede llegar a ser bastante largo y distraer visualmente. Si el inglete en un vértice dado fuera más largo que la mitad del ancho de la línea multiplicado por la propiedad <codeinline>miterLimit</codeinline>, ese vértice se dibujará con una unión biselada en lugar de una unión a inglete. El valor por defecto de <codeinline>miterLimit</codeinline> es 10.</p>
    <p>El método <codeinline>stroke()</codeinline> puede dibujar líneas discontinuas y punteadas así como líneas sólidas, y el estado gráfico de un lienzo incluye una matriz de números que sirve como "patrón de guiones" especificando cuántos píxeles dibujar, y luego cuántos omitir. A diferencia de otras propiedades de dibujo de líneas, el patrón de guiones se establece y consulta con los métodos <codeinline>setLineDash()</codeinline> y <codeinline>getLineDash()</codeinline> en lugar de con una propiedad. Para especificar un patrón de guiones punteados, puede utilizar <codeinline>setLineDash()</codeinline> de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">c.setLineDash([18, 3, 3, 3]); // 18px dash, 3px space, 3px dot, 3px space</code></pre>
    <p>Por último, la propiedad <codeinline>lineDashOffset</codeinline> especifica a qué distancia debe comenzar el dibujo del patrón de guiones. El valor predeterminado es 0. Las rutas trazadas con el patrón de guiones mostrado aquí comienzan con un guión de 18 píxeles, pero si <codeinline>lineDashOffset</codeinline> se establece en 21, entonces esa misma ruta comenzaría con un punto seguido de un espacio y un guión.</p>
    <p class="title-article text-left">Colores, motivos y degradados</p>
    <p>Las propiedades <codeinline>fillStyle</codeinline> y <codeinline>strokeStyle</codeinline> especifican cómo se rellenan y se trazan los trazados. La palabra "estilo" a menudo significa color, pero estas propiedades también pueden utilizarse para especificar un degradado de color o una imagen que se utilizará para el relleno y el trazo. (Tenga en cuenta que dibujar una línea es básicamente lo mismo que rellenar una región estrecha a ambos lados de la línea, y rellenar y trazar son fundamentalmente la misma operación).</p>
    <p>Si desea rellenar o trazar con un color sólido (o un color translúcido), simplemente establezca estas propiedades a una cadena de color CSS válida. No se requiere nada más.</p>
    <p>Para rellenar (o trazar) con un gradiente de color, establezca <codeinline>fillStyle</codeinline> (o <codeinline>strokeStyle</codeinline>) en un objeto CanvasGradient devuelto por los métodos <codeinline>createLinearGradient()</codeinline> o <codeinline>createRadialGradient()</codeinline> del contexto. Los argumentos de <codeinline>createLinearGradient()</codeinline> son las coordenadas de dos puntos que definen una línea (no es necesario que sea horizontal o vertical) a lo largo de la cual variarán los colores. Los argumentos de <codeinline>createRadialGradient()</codeinline> especifican los centros y radios de dos círculos. (No es necesario que sean concéntricos, pero el primer círculo suele estar completamente dentro del segundo). Las áreas dentro del círculo más pequeño o fuera del más grande se rellenarán con colores sólidos; las áreas entre los dos se rellenarán con un gradiente de color.</p>
    <p>Después de crear el objeto CanvasGradient que define las regiones del lienzo que serán rellenadas, debe definir los colores del gradiente llamando al método <codeinline>addColorStop()</codeinline> del CanvasGradient. El primer argumento de este método es un número entre 0.0 y 1.0. El segundo argumento es una especificación de color CSS. Debe llamar a este método al menos dos veces para definir un gradiente de color simple, pero puede llamarlo más veces. El color en 0.0 aparecerá al principio del gradiente, y el color en 1.0 aparecerá al final. Si especifica colores adicionales, aparecerán en la posición fraccional especificada dentro del degradado. Entre los puntos que especifique, los colores se interpolarán suavemente. He aquí algunos ejemplos:</p>
    <pre class="language-js">
    <code class="language-js">// A linear gradient, diagonally across the canvas (assuming no transforms)
    let bgfade = c.createLinearGradient(0,0,canvas.width,canvas.height);
    bgfade.addColorStop(0.0, "#88f");                // Start with light blue in upper left
    bgfade.addColorStop(1.0, "#fff");                // Fade to white in lower right

    // A gradient between two concentric circles. Transparent in the middle
    // fading to translucent gray and then back to transparent.
    let donut = c.createRadialGradient(300,300,100, 300,300,300);
    donut.addColorStop(0.0, "transparent");          // Transparent
    donut.addColorStop(0.7, "rgba(100,100,100,.9)"); // Translucent gray
    donut.addColorStop(1.0, "rgba(0,0,0,0)");        // Transparent again</code></pre>
    <p>Un punto importante que hay que entender sobre los degradados es que no son independientes de la posición. Cuando se crea un degradado, se especifican los límites del mismo. Si luego intenta rellenar un área fuera de esos límites, obtendrá el color sólido definido en uno u otro extremo del degradado.</p>
    <p>Además de colores y degradados de color, también puede rellenar y trazar utilizando imágenes. Para ello, establezca <codeinline>fillStyle</codeinline> o <codeinline>strokeStyle</codeinline> a un CanvasPattern devuelto por el método <codeinline>createPattern()</codeinline> del objeto context. El primer argumento de este método debe ser un <codeinline>&lt;img></codeinline> o <codeinline>&lt;canvas></codeinline> que contiene la imagen que desea rellenar o trazar. (Tenga en cuenta que no es necesario insertar la imagen o el lienzo de origen en el documento para poder utilizarlos de este modo). El segundo argumento de <codeinline>createPattern()</codeinline> es la cadena "repeat", "repeat-x", "repeat-y" o "no-repeat", que especifica si las imágenes de fondo se repiten (y en qué dimensiones).</p>
    <p class="title-article text-left">Estilos de texto</p>
    <p>La propiedad <codeinline>font</codeinline> especifica la fuente que utilizarán los métodos de dibujo de texto <codeinline>fillText()</codeinline> y <codeinline>strokeText()</codeinline> (véase <a href="#15-text">"Texto"</a>). El valor de la propiedad <codeinline>font</codeinline> debe ser una cadena con la misma sintaxis que el atributo font de CSS.</p>
    <p>La propiedad <codeinline>textAlign</codeinline> especifica cómo debe alinearse horizontalmente el texto con respecto a la coordenada X pasada a <codeinline>fillText()</codeinline> o <codeinline>strokeText()</codeinline>. Los valores legales son "start", "left", "center", "right" y "end". El valor por defecto es "inicio", que, para texto de izquierda a derecha, tiene el mismo significado que "izquierda".</p>
    <p>La propiedad <codeinline>textBaseline</codeinline> especifica cómo debe alinearse verticalmente el texto con respecto a la coordenada <em>y</em>. El valor por defecto es "alfabético", y es apropiado para alfabetos latinos y similares. El valor "ideographic" está pensado para escrituras como la china y la japonesa. El valor "colgante" está pensado para su uso con Devana- gari y escrituras similares (que se utilizan para muchas de las lenguas de la India). Las líneas de base "superior", "media" e "inferior" son líneas de base puramente geométricas, basadas en el "cuadrado em" de la fuente.</p>
    <p class="title-article text-left">Sombras</p>
    <p>Cuatro propiedades del objeto de contexto controlan el dibujo de sombras paralelas. Si establece estas propiedades adecuadamente, cualquier línea, área, texto o imagen que dibuje recibirá una sombra, que hará que parezca que flota sobre la superficie del lienzo.</p>
    <p>La propiedad <codeinline>shadowColor</codeinline> especifica el color de la sombra. Por defecto es negro totalmente transparente, y las sombras nunca aparecerán a menos que establezca esta propiedad a un color translúcido u opaco. Esta propiedad sólo puede establecerse a una cadena de color: los patrones y degradados no están permitidos para las sombras. El uso de un color de sombra translúcido produce los efectos de sombra más realistas, ya que permite que se vea el fondo.</p>
    <p>Las propiedades <codeinline>shadowOffsetX</codeinline> y <codeinline>shadowOffsetY</codeinline> especifican los desplazamientos X e Y de la sombra. El valor predeterminado para ambas propiedades es 0, que sitúa la sombra directamente debajo del dibujo, donde no es visible. Si establece ambas propiedades a un valor positivo, las sombras aparecerán debajo y a la derecha de lo que dibuje, como si hubiera un fuente de luz situada por encima y a la izquierda, que incide sobre el lienzo desde el exterior de la pantalla del ordenador. Los desplazamientos mayores producen sombras más grandes y hacen que los objetos dibujados parezcan flotar "más alto" sobre el lienzo. Estos valores no se ven afectados por las transformaciones de coordenadas (§15.8.5): la dirección de la sombra y la "altura" permanecen constantes incluso cuando las formas se giran y escalan.</p>
    <p>La propiedad <codeinline>shadowBlur</codeinline> especifica el grado de desenfoque de los bordes de la sombra. El valor por defecto es 0, que produce sombras nítidas y sin desenfoque. Valores mayores producen más desenfoque, hasta un límite superior definido por la implementación.</p>
    <p class="title-article text-left">Translucidez y composición</p>
    <p>Si desea trazar o rellenar un trazado utilizando un color translúcido, puede definir <codeinline>strokeStyle</codeinline> o <codeinline>fillStyle</codeinline> utilizando una sintaxis de color CSS como "rgba(<codeinline>...</codeinline>)" que admita la transparencia alfa. La "a" en "RGBA" significa "alfa" y es un valor entre 0 (totalmente transparente) y 1 (totalmente opaco). Pero la API del lienzo ofrece otra forma de trabajar con colores translúcidos. Si no quieres especificar explícitamente un canal alfa para cada color, o si quieres añadir translucidez a imágenes o patrones opacos, puedes establecer la propiedad <codeinline>globalAlpha</codeinline>. Cada píxel que dibujes tendrá su valor alfa multiplicado por <codeinline>globalAlpha</codeinline>. El valor por defecto es 1, que no añade transparencia. Si estableces <codeinline>globalAlpha</codeinline> a 0, todo lo que dibujes será completamente transparente, y nada aparecerá en el lienzo. Pero si estableces esta propiedad a 0.5, entonces los píxeles que habrían sido opacos serán opacos al 50%, y los píxeles que habrían sido opacos al 50% serán opacos al 25%.</p>
    <p>Cuando trazas líneas, rellenas regiones, dibujas texto o copias imágenes, generalmente esperas que los nuevos píxeles se dibujen encima de los píxeles que ya están en el lienzo. Si estás dibujando píxeles opacos, simplemente reemplazan a los píxeles que ya están ahí. Si dibuja con píxeles translúcidos, el píxel nuevo ("origen") se combina con el píxel antiguo ("destino") de modo que el píxel antiguo se muestra a través del píxel nuevo en función de lo transparente que sea ese píxel.</p>
    <p>Este proceso de combinar píxeles de origen nuevos (posiblemente translúcidos) con píxeles de destino existentes (posiblemente translúcidos) se denomina <em>composición</em>, y el proceso de composición descrito anteriormente es la forma predeterminada en que la API Canvas combina los píxeles. Pero puede establecer la propiedad <codeinline>globalCompositeOperation</codeinline> para especificar otras formas de combinar píxeles. El valor predeterminado es "source-over", lo que significa que los píxeles de origen se dibujan "sobre" los píxeles de destino y se combinan con ellos si el origen es translúcido. Pero si establece <codeinline>globalCompositeOperation</codeinline> como "destination-over", el lienzo combinará los píxeles como si los nuevos píxeles de origen se dibujaran debajo de los píxeles de destino existentes. Si el destino es translúcido o transparente, parte o la totalidad del color del píxel de origen será visible en el color resultante. Como otro ejemplo, el modo de composición "source-atop" combina los píxeles de origen con la transparencia de los píxeles de destino para que no se dibuje nada en las partes del lienzo que ya son transparentes totalmente transparente. Existen varios valores legales para <codeinline>globalCompositeOperation</codeinline>, pero la mayoría sólo tienen usos especializados y no se tratan aquí.</p>
    <p class="title-article text-left">Guardar y restaurar el estado de los gráficos</p>
    <p>Dado que la API Canvas define atributos gráficos en el objeto contexto, podría verse tentado a llamar a <codeinline>getContext()</codeinline> varias veces para obtener varios objetos contexto. Si pudieras hacer esto, podrías definir diferentes atributos en cada contexto: cada contexto sería entonces como un pincel diferente y pintaría con un color diferente o dibujaría líneas de diferentes anchos. Desafortunadamente, no puede utilizar el lienzo de esta manera. Cada <codeinline>&lt;canvas></codeinline> tiene un único objeto de contexto, y cada llamada a <codeinline>getContext()</codeinline> devuelve el mismo objeto CanvasRenderingContext2D.</p>
    <p>Aunque la API Canvas sólo permite definir un único conjunto de atributos gráficos a la vez, permite guardar el estado actual de los gráficos para poder modificarlo y restaurarlo fácilmente más tarde. El mé todo <codeinline>save()</codeinline> coloca el estado actual de los gráficos en una pila de estados guardados. El mé todo <codeinline>restore()</codeinline> abre la pila y restaura el último estado guardado. Todas las propiedades que se han descrito en esta sección forman parte del estado guardado, así como la transformación actual y la región de recorte (ambas se explican más adelante). Es importante destacar que la ruta definida actualmente y el punto actual no forman parte del estado de los gráficos y no pueden guardarse y restaurarse.</p>
  </section>
  <section id="8-4">
    <h2>15.8.4 Operaciones de dibujo en el lienzo</h2>
    <p>Ya hemos visto algunos métodos básicos del lienzo: <codeinline>beginPath()</codeinline>, <codeinline>moveTo()</codeinline>, <codeinline>lineTo()</codeinline>, <codeinline>closePath()</codeinline>, <codeinline>fill(</codeinline>) y <codeinline>stroke()</codeinline> -para definir, rellenar y dibujar líneas y polígonos. Pero la API Canvas también incluye otros métodos de dibujo.</p>
    <p class="title-article text-left">Rectangles</p>
    <p>CanvasRenderingContext2D define cuatro métodos para dibujar rectángulos. Los cuatro métodos de rectángulo esperan dos argumentos que especifiquen una esquina del rectángulo seguida de la anchura y la altura del rectángulo. Normalmente, se especifica la esquina superior izquierda y luego se pasa una anchura positiva y una altura positiva, pero también se pueden especificar otras esquinas y pasar dimensiones negativas.</p>
    <p><codeinline>fillRect()</codeinline> rellena el rectángulo especificado con el <codeinline>fillStyle</codeinline> actual. <codeinline>strokeRect()</codeinline> traza el contorno del rectángulo especificado utilizando el strokeStyle actual y otros atributos de línea. <codeinline>clearRect()</codeinline> es como <codeinline>fillRect()</codeinline>, pero ignora el estilo de relleno actual y rellena el rectángulo con píxeles negros transparentes (el color por defecto de todos los lienzos en blanco). Lo importante de estos tres métodos es que no afectan al trazado actual ni al punto actual dentro de ese trazado.</p>
    <p>El último método de rectángulo se llama <codeinline>rect()</codeinline>, y afecta al trazado actual: añade el rectángulo especificado, en un subtrazado propio, al trazado. Al igual que otros métodos de definición de rutas, no rellena ni traza nada por sí mismo.</p>
    <p class="title-article text-left">Curves</p>
    <p>Un camino es una secuencia de subcaminos, y un subcamino es una secuencia de puntos conectados. En los trazados que definimos en <a href="#8-1">§15.8.1</a>, esos puntos estaban conectados con segmentos de líneas rectas, pero no tiene por qué ser siempre así. El objeto CanvasRenderingContext2D define un número de métodos que añaden un nuevo punto al subtrayecto y conectan el punto actual a ese nuevo punto con una curva:</p>
    <p><codeinline>arc()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método añade un círculo, o una parte de un círculo (un arco), a la trayectoria. El arco a dibujar se especifica con seis parámetros: las coordenadas <em>x</em> e <em>y</em> del centro del círculo, el radio del círculo, los ángulos inicial y final del arco, y la dirección (en el sentido de las agujas del reloj o en sentido contrario) del arco entre esos dos ángulos. Si hay un punto actual en la trayectoria, este método conecta el punto actual con el inicio del arco mediante una línea recta (lo que resulta útil para dibujar cuñas o porciones de tarta) y, a continuación, conecta el inicio del arco con el final del arco mediante una porción de círculo, dejando el final del arco como nuevo punto actual. Si no hay punto actual cuando se llama a este método, entonces sólo añade el arco circular a la ruta.</p>
    <p><codeinline>ellipse()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método es muy parecido a <codeinline>arc()</codeinline> excepto en que añade una elipse o una porción de elipse a la trayectoria. En lugar de un radio, tiene dos: un radio en el eje <em>x</em> y un radio en el eje <em>y</em>. Además, como las elipses no son radialmente simétricas, este método toma otro argumento que especifica el número de radianes en los que la elipse gira en el sentido de las agujas del reloj alrededor de su centro.</p>
    <p><codeinline>arcTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método dibuja una línea recta y un arco circular igual que el método arc(), pero especifica el arco a dibujar utilizando parámetros diferentes. Los argumentos de <codeinline>arcTo()</codeinline> especifican los puntos P1 y P2 y un radio. El arco que se añade a la trayectoria tiene el radio especificado. Comienza en el punto tangente con la línea (imaginaria) desde el punto actual a P1 y termina en el punto tangente con la línea (imaginaria) entre P1 y P2. Este método de especificar arcos, que parece poco habitual, es bastante útil para dibujar formas con esquinas redondeadas. Si especifica un radio de 0, este método dibuja una línea recta desde el punto actual hasta P1. Con un radio distinto de cero, sin embargo, dibuja una línea recta desde el punto actual en la dirección de P1, luego curva esa línea en un círculo hasta que se dirige en la dirección de P2.</p>
    <p><codeinline>bezierCurveTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método añade un nuevo punto P a la subtrayectoria y lo conecta al punto actual con una curva cúbica de Bézier. La forma de la curva se especifica mediante dos "puntos de control", C1 y C2. Al principio de la curva (en el punto actual), la curva se dirige en la dirección de C1. Al final de la curva (en el punto P), la curva llega desde la dirección de C2. Entre estos puntos, la dirección de la curva varía suavemente. El punto P se convierte en el nuevo punto actual del subtrayecto./p>
    <p><codeinline>quadraticCurveTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método es como <codeinline>bezierCurveTo()</codeinline>, pero utiliza una curva de Bezier cuadrática en lugar de una curva de Bezier cúbica y sólo tiene un único punto de control.</p>
    <p>Puede utilizar estos métodos para dibujar trazados como los de la <a href="figure15-10">Figura 15-10</a>.</p>
    <figure id="figure15-10">
      <img src="/public/javascript/capitulo-15/figure15-10.avif" alt="imagen de consola">
      <figcaption>Figura 15-10. Trayectorias curvas en un lienzo</figcaption>
    </figure>
    <p>El <a href="ejemplo15-6">Ejemplo 15-6</a> muestra el código utilizado para crear la <a href="figure15-10">Figura 15-10</a>. Los métodos demostrados en este código son algunos de los más complicados de la API Canvas. Los métodos demostrados en este código son algunos de los más complicados de la API Canvas; consulte una referencia en línea para obtener detalles completos sobre los métodos y sus argumentos.</p>
    <p><em>Ejemplo 15-6. Añadir curvas a un trazado</em></p>
    <pre class="language-js">
    <code class="language-js">// A utility function to convert angles from degrees to radians
    function rads(x) &lbrace; return Math.PI*x/180; }

    // Get the context object of the document's canvas element
    let c = document.querySelector("canvas").getContext("2d");

    // Define some graphics attributes and draw the curves
    c.fillStyle = "#aaa"; // Gray fills
    c.lineWidth = 2;      // 2-pixel black (by default) lines

    // Draw a circle.
    // There is no current point, so draw just the circle with no straight
    // line from the current point to the start of the circle.
    c.beginPath();
    c.arc(75,100,50,      // Center at (75,100), radius 50
    0,rads(360),false);   // Go clockwise from 0 to 360 degrees
    c.fill();             // Fill the circle
    c.stroke();           // Stroke its outline.

    // Now draw an ellipse in the same way
    c.beginPath();        // Start new path not connected to the circle
    c.ellipse(200, 100, 50, 35, rads(15), // Center, radii, and rotation
    0, rads(360), false); // Start angle, end angle, direction

    // Draw a wedge. Angles are measured clockwise from the positive x axis.
    // Note that arc() adds a line from the current point to the arc start.
    c.moveTo(325, 100);   // Start at the center of the circle.
    c.arc(325, 100, 50,   // Circle center and radius
    rads(-60), rads(0),   // Start at angle -60 and go to angle 0
    true);                // counterclockwise
    c.closePath();        // Add radius back to the center of the circle

    // Similar wedge, offset a bit, and in the opposite direction
    c.moveTo(340, 92);
    c.arc(340, 92, 42, rads(-60), rads(0), false);
    c.closePath();

    // Use arcTo() for rounded corners. Here we draw a square with
    // upper left corner at (400,50) and corners of varying radii.
    c.moveTo(450, 50);            // Begin in the middle of the top edge.
    c.arcTo(500,50,500,150,30);   // Add part of top edge and upper right corner.
    c.arcTo(500,150,400,150,20);  // Add right edge and lower right corner.
    c.arcTo(400,150,400,50,10);   // Add bottom edge and lower left corner.
    c.arcTo(400,50,500,50,0);     // Add left edge and upper left corner.
    c.closePath();                // Close path to add the rest of the top edge.

    // Quadratic Bezier curve: one control point
    c.moveTo(525, 125);                     // Begin here
    c.quadraticCurveTo(550, 75, 625, 125);  // Draw a curve to (625, 125)
    c.fillRect(550-3, 75-3, 6, 6);          // Mark the control point (550,75)

    // Cubic Bezier curve
    c.moveTo(625, 100);                     // Start at (625, 100)
    c.bezierCurveTo(645,70,705,130,725,100);// Curve to (725, 100)
    c.fillRect(645-3, 70-3, 6, 6);          // Mark control points
    c.fillRect(705-3, 130-3, 6, 6);

    // Finally, fill the curves and stroke their outlines.
    c.fill();
    c.stroke();</code></pre>
    <p id="15-text" class="title-article text-left">Texto</p>
    <p>Para dibujar texto en un lienzo, normalmente se utiliza el método <codeinline>fillText()</codeinline>, que dibuja el texto utilizando el color (o gradiente o patrón) especificado por la propiedad <codeinline>fillStyle</codeinline>. Para obtener efectos especiales en tamaños de texto grandes, puede utilizar <codeinline>strokeText()</codeinline> para dibujar el contorno de los glifos individuales de la fuente. Ambos métodos toman el texto a dibujar como primer argumento y las coordenadas <em>x</em> e <em>y</em> del texto como segundo y tercer argumento. Ningún método afecta al trazado actual o al punto actual.</p>
    <p><codeinline>fillText()</codeinline> y <codeinline>strokeText()</codeinline> toman un cuarto argumento opcional. Si se da, este argumento especifica la anchura máxima del texto a mostrar. Si el texto fuera más ancho que el valor especificado cuando se dibuja utilizando la propiedad de <codeinline>font</codeinline>, el lienzo hará que quepa escalándolo o utilizando una fuente más estrecha o más pequeña.</p>
    <p>Si necesita medir el texto usted mismo antes de dibujarlo, páselo al método <codeinline>measureText()</codeinline>. Este método devuelve un objeto TextMetrics que especifica las medidas del texto cuando se dibuja con la fuente actual. En el momento de escribir esto, la única "métrica" contenida en el objeto <codeinline>TextMetrics</codeinline> es la anchura. Consulte la anchura en pantalla de una cadena de este modo:</p>
    <pre class="language-js">
    <code class="language-js">let width = c.measureText(text).width;</code></pre>
    <p>Esto es útil si desea centrar una cadena de texto dentro de un lienzo, por ejemplo.</p>
    <p class="title-article text-left">Images</p>
    <p>Además de gráficos vectoriales (trazados, líneas, etc.), la API Lienzo también admite imágenes de mapa de bits. El método <codeinline>drawImage()</codeinline> copia los píxeles de una imagen de origen (o de un rectángulo dentro de la imagen de origen) en el lienzo, escalando y rotando los píxeles de la imagen según sea necesario.</p>
    <p><codeinline>drawImage()</codeinline> puede invocarse con tres, cinco o nueve argumentos. En todos los casos, el primer argumento es la imagen de origen de la que se van a copiar los píxeles. Este argumento de imagen suele ser un elemento <codeinline>&lt;img></codeinline>, pero también puede ser otro elemento <codeinline>&lt;canvas></codeinline> o incluso un elemento <codeinline>&lt;video></codeinline> (del que se copiará un único fotograma). Si especifica un elemento <codeinline>&lt;img></codeinline> o <codeinline>&lt;video></codeinline> que todavía está cargando sus datos, la llamada a <codeinline>drawImage()</codeinline> no hará nada.</p>
    <p>En la versión de tres argumentos de <codeinline>drawImage()</codeinline>, el segundo y tercer argumento especifican las coordenadas <em>x</em> e <em>y</em> en las que se dibujará la esquina superior izquierda de la imagen. En esta versión del método, toda la imagen de origen se copia en el lienzo. Las coordenadas <em>x</em> e <em>y</em> se interpretan en el sistema de coordenadas actual, y la imagen se escala y rota si es necesario, dependiendo de la transformación del lienzo actualmente en efecto.</p>
    <p>La versión de cinco argumentos de <codeinline>drawImage()</codeinline> añade argumentos de anchura y altura a los argumentos <codeinline>x</codeinline> e <codeinline>y</codeinline> descritos anteriormente. Estos cuatro argumentos definen un recuadro de destino dentro del lienzo. La esquina superior izquierda de la imagen de origen va en (<codeinline>x</codeinline>,<codeinline>y</codeinline>), y la esquina inferior derecha va en (<codeinline>x+width</codeinline>, <codeinline>y+height</codeinline>). De nuevo, toda la se copia la imagen. Con esta versión del método, la imagen de origen se escalará para ajustarse al rectángulo de destino.</p>
    <p>La versión de nueve argumentos de <codeinline>drawImage()</codeinline> especifica un rectángulo de origen y un rectángulo de destino y copia sólo los píxeles dentro del rectángulo de origen. Los argumentos dos a cinco especifican el rectángulo de origen. Se miden en píxeles CSS. Si la imagen de origen es otro lienzo, el rectángulo de origen utiliza el sistema de coordenadas predeterminado para ese lienzo e ignora cualquier transformación que se haya especificado. Los argumentos del seis al nueve especifican el rectángulo de destino en el que se dibuja la imagen y están en el sistema de coordenadas actual del lienzo, no en el sistema de coordenadas por defecto.</p>
    <p>Además de dibujar imágenes en un lienzo, también podemos extraer el contenido de un canvas como una imagen utilizando el método <codeinline>toDataURL()</codeinline>. A diferencia de todos los demás métodos descritos aquí, <codeinline>toDataURL()</codeinline> es un método del propio elemento Canvas, no del objeto contexto. Normalmente se invoca a <codeinline>toDataURL()</codeinline> sin argumentos, y devuelve el contenido del lienzo como una imagen PNG, codificada como una cadena utilizando una dirección <codeinline>data:</codeinline> URL. La URL devuelta es adecuada para su uso con un elemento <codeinline>&lt;img></codeinline>, y puede hacer una instantánea estática de un lienzo con código como este:</p>
    <pre class="language-js">
    <code class="language-js">let img = document.createElement("img"); // Create an &lt;img> element
    img.src = canvas.toDataURL();            // Set its src attribute
    document.body.appendChild(img);          // Append it to the document</code></pre>
  </section>
  <section id="8-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.5 Transformaciones de sistemas de coordenadas</h2>
    <p>Como hemos señalado, el sistema de coordenadas por defecto de un lienzo sitúa el origen en la esquina superior izquierda, tiene coordenadas <em>x</em> que aumentan hacia la derecha <em>y</em> coordenadas y que aumentan hacia abajo. En este sistema por defecto, las coordenadas de un punto se asignan directamente a un píxel CSS (que a su vez se asigna directamente a uno o más píxeles del dispositivo). Ciertas operaciones y atributos can- vas (como la extracción de valores de píxel sin procesar y la configuración de desplazamientos de sombra) utilizan siempre este sistema de coordenadas predeterminado. Sin embargo, además del sistema de coordenadas por defecto, cada lienzo tiene una "matriz de transformación actual" como parte de su estado gráfico. Esta matriz define el sistema de coordenadas actual del lienzo. En la mayoría de las operaciones del lienzo, cuando se especifican las coordenadas de un punto, se toma como un punto en el sistema de coordenadas actual, no en el sistema de coordenadas por defecto. La matriz de transformación actual se utiliza para convertir las coordenadas especificadas en coordenadas equivalentes en el sistema de coordenadas por defecto.</p>
    <p>El método <codeinline>setTransform()</codeinline> permite establecer directamente la matriz de transformación de un lienzo, pero las transformaciones del sistema de coordenadas suelen ser más fáciles de especificar como una secuencia de traslaciones, rotaciones y operaciones de escalado. La <a href="#figure15-11">Figura 15-11</a> ilustra estas operaciones y su efecto en el sistema de coordenadas del lienzo. El programa que produjo la figura dibujó el mismo conjunto de ejes siete veces seguidas. Lo único que que cambiaba cada vez era la transformación actual. Observe que las transformaciones afectan tanto al texto como a las líneas que se dibujan.</p>
    <figure id="figure15-11">
      <img src="/public/javascript/capitulo-15/figure15-11.avif" alt="imagen de consola">
      <figcaption>Figura 15-11. Transformaciones de sistemas de coordenadas</figcaption>
    </figure>
    <p>El método <codeinline>translate()</codeinline> simplemente mueve el origen del sistema de coordenadas a la izquierda, derecha, arriba o abajo. El método <codeinline>rotate()</codeinline> rota los ejes en el sentido de las agujas del reloj en el ángulo especificado. (La API Canvas siempre especifica los ángulos en radianes. Para convertir grados a radianes, divida por 180 y multiplique por <codeinline>Math.PI</codeinline>). El método <codeinline>scale()</codeinline> amplía o reduce las distancias a lo largo de los ejes <em>x</em> o <em>y</em>.</p>
    <p>Pasando un factor de escala negativo al método <codeinline>scale()</codeinline> se invierte ese eje a través del origen, como si se reflejara en un espejo. Esto es lo que se hizo en la parte inferior izquierda de la <a href="#figure15-11">Figura 15-11</a>: se utilizó <codeinline>translate()</codeinline> para mover el origen a la esquina inferior izquierda del lienzo, luego se utilizó <codeinline>scale()</codeinline> para voltear el eje <em>y</em> de modo que las coordenadas <em>y</em> aumenten a medida que subimos por la página. Un sistema de coordenadas invertidas como este es familiar de la clase de álgebra y puede ser útil para trazar puntos de datos en gráficos. Tenga en cuenta, sin embargo, que hace que el texto sea difícil de leer.</p>
    <p class="title-article text-left">Comprender matemáticamente las transformaciones</p>
    <p>Me resulta más fácil entender las transformaciones geométricamente, pensando en <codeinline>translate()</codeinline>, <codeinline>rotate()</codeinline> y <codeinline>scale()</codeinline> como transformaciones de los ejes del sistema de coordenadas, tal como se ilustra en la <a href="#figure15-11">Figura 15-11</a>. También es posible entender las transformaciones algebraicamente como ecuaciones que asignan las coordenadas de un punto <codeinline>(x,y)</codeinline> en el sistema de coordenadas transformado a las coordenadas <codeinline>(x',y')</codeinline> del mismo punto en el sistema de coordenadas anterior.</p>
    <p>La llamada al método <codeinline>c.translate(dx,dy)</codeinline> puede describirse con estas ecuaciones:</p>
    <pre class="language-js">
    <code class="language-js">x' = x + dx; // An X coordinate of 0 in the new system is dx in the old
    y' = y + dy;</code></pre>
    <p>Las operaciones de escala tienen ecuaciones igualmente sencillas. Una llamada <codeinline>c.scale(sx,sy)</codeinline> puede describirse así:</p>
    <pre class="language-js">
    <code class="language-js">x' = sx * x;
    y' = sy * y;</code></pre>
    <p>Las rotaciones son más complicadas. La llamada <codeinline>c.rotate(a)</codeinline> se describe mediante estas ecuaciones trigonométricas:</p>
    <pre class="language-js">
    <code class="language-js">x' = x * cos(a) - y * sin(a);
    y' = y * cos(a) + x * sin(a);</code></pre>
    <p>Fíjate en que el orden de las transformaciones importa. Supongamos que empezamos con el sistema de coordenadas por defecto de un lienzo, luego lo trasladamos y luego lo escalamos. Para mapear el punto <codeinline>(x,y)</codeinline> en el sistema de coordenadas actual de vuelta al punto <codeinline>(x'',y'')</codeinline> en el sistema de coordenadas por defecto, primero debemos aplicar las ecuaciones de escalado para mapear el punto a un punto intermedio <codeinline>(x',y')</codeinline> en el sistema de coordenadas trasladado pero sin escalar, luego usar las ecuaciones de traslación para mapear desde este punto intermedio a <codeinline>(x'',y'')</codeinline>. El resultado es el siguiente:</p>
    <pre class="language-js">
    <code class="language-js">x'' = sx*x + dx;
    y'' = sy*y + dy;</code></pre>
    <p>Si, por otro lado, hubiéramos llamado a <codeinline>scale()</codeinline> antes de llamar a <codeinline>translate()</codeinline>, las ecuaciones resultantes serían diferentes:</p>
    <pre class="language-js">
    <code class="language-js">x'' = sx*(x + dx);
    y'' = sy*(y + dy);</code></pre>
    <p>La clave que hay que recordar cuando se piensa algebraicamente en secuencias de transformaciones es que hay que trabajar hacia atrás desde la última transformación (la más reciente) hasta la primera. Sin embargo, cuando se piensa geométricamente sobre ejes transformados, se trabaja hacia adelante desde la primera transformación hasta la última.</p>
    <p>Las transformaciones soportadas por el lienzo se conocen como <em>transformaciones afines</em>. Las transformaciones afines pueden modificar las distancias entre puntos y los ángulos entre líneas, pero las líneas paralelas siempre permanecen paralelas después de una transformación afín; no es posible, por ejemplo, especificar una distorsión de lente ojo de pez con una transformación afín. En una transformación afín arbitraria puede describirse mediante los seis parámetros de <codeinline>a</codeinline> a <codeinline>f</codeinline> de estas ecuaciones:</p>
    <pre class="language-js">
    <code class="language-js">x' = ax + cy + e
    y' = bx + dy + f</code></pre>
    <p>Puede aplicar una transformación arbitraria al sistema de coordenadas actual pasando esos seis parámetros al método <codeinline>transform()</codeinline>. La <a href="figure15-11">Figura 15-11</a> ilustra dos tipos de transformaciones-cizallas y rotaciones alrededor de un punto especificado- que puedes implementar con el método <codeinline>transform()</codeinline> de esta manera:</p>
    <pre class="language-js">
    <code class="language-js">// Shear transform:
    // x' = x + kx*y;
    // y' = ky*x + y;
    function shear(c, kx, ky) &lbrace; c.transform(1, ky, kx, 1, 0, 0); }

    // Rotate theta radians counterclockwise around the point (x,y)
    // This can also be accomplished with a translate, rotate, translate sequence
    function rotateAbout(c, theta, x, y) &lbrace;
      let ct = Math.cos(theta);
      let st = Math.sin(theta);
      c.transform(ct, -st, st, ct, -x*ct-y*st+x, x*st-y*ct+y);
    }</code></pre>
    <p>El método <codeinline>setTransform()</codeinline> toma los mismos argumentos que <codeinline>transform()</codeinline>, pero en lugar de transformar el sistema de coordenadas actual, ignora el sistema actual, trans- forma el sistema de coordenadas por defecto, y hace que el resultado sea el nuevo sistema de coordenadas actual. <codeinline>setTransform()</codeinline> es útil para restablecer temporalmente el lienzo a su sistema de coordenadas por defecto:</p>
    <pre class="language-js">
    <code class="language-js">c.save();                    // Save current coordinate system
    c.setTransform(1,0,0,1,0,0); // Revert to the default coordinate system
    // Perform operations using default CSS pixel coordinates
    c.restore();</code></pre>
    <p class="title-article text-left">Ejemplo de transformación</p>
    <p>El <a href="#ejemplo15-7">Ejemplo 15-7</a> demuestra el poder de las transformaciones del sistema de coordenadas utilizando los métodos <codeinline>translate()</codeinline>, <codeinline>rotate()</codeinline>, y <codeinline>scale()</codeinline> recursivamente para dibujar un fractal de copos de nieve Koch- . La salida de este ejemplo aparece en la <a href="#figure15-12">Figura 15-12</a>, que muestra copos de nieve Koch con 0, 1, 2, 3 y 4 niveles de recursión.</p>
    <figure id="figure15-12">
      <img src="/public/javascript/capitulo-15/figure15-12.avif" alt="imagen de consola">
      <figcaption>Figura 15-12. Copos de nieve de Koch</figcaption>
    </figure>
    <p>El código que produce estas figuras es elegante, pero su uso de transformaciones recursivas del sistema de coordenadas lo hace algo difícil de entender. Aunque no entienda todos los matices, tenga en cuenta que el código sólo incluye una invocación al método <codeinline>lineTo()</codeinline>. Cada segmento de línea en la <a href="#figure15-12">Figura 15-12</a> se dibuja así:</p>
    <pre class="language-js">
    <code class="language-js">c.lineTo(len, 0);</code></pre>
    <p>El valor de la variable <codeinline>len</codeinline> no cambia durante la ejecución del programa, por lo que la posición, orientación y longitud de cada uno de los segmentos de línea viene determinada por traslaciones, rotaciones y operaciones de escalado.</p>
    <p><em>Ejemplo 15-7. Un copo de nieve Koch con transformaciones</em></p>
    <pre class="language-js">
    <code class="language-js">let deg = Math.PI/180; // For converting degrees to radians

    // Draw a level-n Koch snowflake fractal on the canvas context c,
    // with lower-left corner at (x,y) and side length len.
    function snowflake(c, n, x, y, len) &lbrace;
      c.save();           // Save current transformation
      c.translate(x,y);   // Translate origin to starting point
      c.moveTo(0,0);      // Begin a new subpath at the new origin
      leg(n);             // Draw the first leg of the snowflake
      c.rotate(-120*deg); // Now rotate 120 degrees counterclockwise
      leg(n);             // Draw the second leg
      c.rotate(-120*deg); // Rotate again
      leg(n);             // Draw the final leg
      c.closePath();      // Close the subpath
      c.restore();        // And restore original transformation

      // Draw a single leg of a level-n Koch snowflake.
      // This function leaves the current point at the end of the leg it has
      // drawn and translates the coordinate system so the current point is (0,0).
      // This means you can easily call rotate() after drawing a leg.
      function leg(n) &lbrace;
        c.save();             // Save the current transformation
        if (n === 0) &lbrace;        // Nonrecursive case:
          c.lineTo(len, 0);   // Just draw a horizontal line
        } // _ _
        else &lbrace;      // Recursive case: draw 4 sub-legs like: \/
          c.scale(1/3,1/3);   // Sub-legs are 1/3 the size of this leg
          leg(n-1); // Recurse for the first sub-leg
          c.rotate(60*deg);   // Turn 60 degrees clockwise
          leg(n-1); // Second sub-leg
          c.rotate(-120*deg); // Rotate 120 degrees back
          leg(n-1); // Third sub-leg
          c.rotate(60*deg);   // Rotate back to our original heading
          leg(n-1); // Final sub-leg
        }
        c.restore();          // Restore the transformation
        c.translate(len, 0);  // But translate to make end of leg (0,0)
      }
    }

    let c = document.querySelector("canvas").getContext("2d");
    snowflake(c, 0, 25, 125, 125);  // A level-0 snowflake is a triangle
    snowflake(c, 1, 175, 125, 125); // A level-1 snowflake is a 6-sided star
    snowflake(c, 2, 325, 125, 125); // etc.
    snowflake(c, 3, 475, 125, 125);
    snowflake(c, 4, 625, 125, 125); // A level-4 snowflake looks like a snowflake!
    c.stroke();</code></pre>
  </section>
  <section id="8-6">
    <h2>15.8.6 Recorte</h2>
    <p>Después de definir un trazado, normalmente se llama a <codeinline>stroke()</codeinline> o <codeinline>fill()</codeinline> (o ambos). También puede llamar al método <codeinline>clip()</codeinline> para definir una región de recorte. Una vez definida una región de recorte, no se dibujará nada fuera de ella. La <a href="#figure15-13">Figura 15-13</a> muestra un dibujo complejo producido utilizando regiones de recorte. La franja vertical que corre por el centro y el texto a lo largo de la parte inferior de la figura fueron trazados sin región de recorte y luego rellenados después de que la región de recorte triangular fuera definida.</p>
    <figure id="figure15-13">
      <img src="/public/javascript/capitulo-15/figure15-13.avif" alt="imagen de consola">
      <figcaption>Figura 15-13. Trazos sin recortar y rellenos recortados</figcaption>
    </figure>
    <p>La <a href="#figure15-13">Figura 15-13</a> fue generada utilizando el método <codeinline>polygon()</codeinline> del <a href="#ejemplo15-5">Ejemplo 15-5</a> y el siguiente código:</p>
    <pre class="language-js">
    <code class="language-js">// Define some drawing attributes
    c.font = "bold 60pt sans-serif"; // Big font
    c.lineWidth = 2;                 // Narrow lines
    c.strokeStyle = "#000";          // Black lines

    // Outline a rectangle and some text
    c.strokeRect(175, 25, 50, 325);    // A vertical stripe down the middle
    c.strokeText("&lt;canvas>", 15, 330); // Note strokeText() instead of fillText()
    
    // Define a complex path with an interior that is outside.
    polygon(c,3,200,225,200);        // Large triangle
    polygon(c,3,200,225,100,0,true); // Smaller reverse triangle inside
    
    // Make that path the clipping region.
    c.clip();
    
    // Stroke the path with a 5 pixel line, entirely inside the clipping region.
    c.lineWidth = 10; // Half of this 10 pixel line will be clipped away
    c.stroke();
    
    // Fill the parts of the rectangle and text that are inside the clipping region
    c.fillStyle = "#aaa";            // Light gray
    c.fillRect(175, 25, 50, 325);    // Fill the vertical stripe
    c.fillStyle = "#888";            // Darker gray
    c.fillText("&lt;canvas>", 15, 330); // Fill the text</code></pre> 
    <p>Es importante tener en cuenta que cuando se llama a <codeinline>clip()</codeinline>, el trazado actual se recorta a sí mismo en la región de recorte actual, y luego ese trazado recortado se convierte en la nueva región de recorte. Esto significa que el método <codeinline>clip()</codeinline> puede reducir la región de recorte pero nunca puede ampliarla. No existe ningún método para restablecer la región de recorte, por lo que antes de llamar a <codeinline>clip()</codeinline>, debería llamar a <codeinline>save()</codeinline> para poder <codeinline>restaurar()</codeinline> más tarde la región sin recortar.</p>
  </section>
  <section id="8-7" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.7 Manipulación de píxeles</h2>
    <p>El método <codeinline>getImageData()</codeinline> devuelve un objeto ImageData que representa los píxeles en bruto (como componentes R, G, B y A) de una región rectangular de su lienzo. Puede crear objetos <codeinline>ImageData</codeinline> vacíos con <codeinline>createImageData()</codeinline>. Los píxeles de un objeto ImageData son escribibles, por lo que puede configurarlos como desee y luego copiarlos de nuevo en el lienzo con <codeinline>putImageData()</codeinline>.</p>
    <p>Estos métodos de manipulación de píxeles proporcionan un acceso de muy bajo nivel al lienzo. El rectángulo que se pasa a <codeinline>getImageData()</codeinline> está en el sistema de coordenadas por defecto: sus dimensiones se miden en píxeles CSS, y no se ve afectado por la transformación actual. Cuando llame a <codeinline>putImageData()</codeinline>, la posición que especifique también se medirá en el sistema de coordenadas por defecto. Además, <codeinline>putImageData()</codeinline> ignora todos los gráficos atributos. No realiza ninguna composición, no multiplica píxeles por <codeinline>globalAlfa</codeinline> y no dibuja sombras.</p>
    <p>Los métodos de manipulación de píxeles son útiles para implementar el procesamiento de imágenes. El <a href="#ejemplo15-8">Ejemplo 15-8</a> muestra cómo crear un desenfoque de movimiento simple o efecto "smear" como el que se muestra en la <a href="#figure15-14">Figura 15-14</a>.</p>
    <figure id="figure15-14">
      <img src="/public/javascript/capitulo-15/figure15-14.avif" alt="imagen de consola">
      <figcaption>Figura 15-14. Efecto de desenfoque de movimiento creado por procesamiento de imágenes</figcaption>
    </figure>
    <p>El siguiente código demuestra <codeinline>getImageData()</codeinline> y <codeinline>putImageData()</codeinline> iterar y modificar los valores de píxel en un objeto ImageData.</p>
    <p><em>Ejemplo 15-8. Desenfoque de movimiento con ImageData</em></p>
    <pre class="language-js">
    <code class="language-js">// Smear the pixels of the rectangle to the right, producing a
    // sort of motion blur as if objects are moving from right to left.
    // n must be 2 or larger. Larger values produce bigger smears.
    // The rectangle is specified in the default coordinate system.
    function smear(c, n, x, y, w, h) &lbrace;
      // Get the ImageData object that represents the rectangle of pixels to smear
      let pixels = c.getImageData(x, y, w, h);

      // This smear is done in-place and requires only the source ImageData.
      // Some image processing algorithms require an additional ImageData to
      // store transformed pixel values. If we needed an output buffer, we could
      // create a new ImageData with the same dimensions like this:
      // let output_pixels = c.createImageData(pixels);

      // Get the dimensions of the grid of pixels in the ImageData object
      let width = pixels.width, height = pixels.height;

      // This is the byte array that holds the raw pixel data, left-to-right and
      // top-to-bottom. Each pixel occupies 4 consecutive bytes in R,G,B,A order.
      let data = pixels.data;

      // Each pixel after the first in each row is smeared by replacing it with
      // 1/nth of its own value plus m/nths of the previous pixel's value
      let m = n-1;

      for(let row = 0; row &lt; height; row++) &lbrace;      // For each row
        let i = row*width*4 + 4;          // The offset of the second pixel of the row
        for(let col = 1; col &lt; width; col++, i += 4) &lbrace; // For each column
          data[i] = (data[i] + data[i-4]*m)/n;     // Red pixel component
          data[i+1] = (data[i+1] + data[i-3]*m)/n; // Green
          data[i+2] = (data[i+2] + data[i-2]*m)/n; // Blue
          data[i+3] = (data[i+3] + data[i-1]*m)/n; // Alpha component
        }
      }

      // Now copy the smeared image data back to the same position on the canvas
      c.putImageData(pixels, x, y);
    }</code></pre>
  </section>
  <section id="9">
    <h2>15.9 API de audio</h2>
    <p>Las etiquetas HTML <codeinline>&lt;audio></codeinline> y <codeinline>&lt;video></codeinline> permiten incluir fácilmente sonido y vídeos en las páginas web. Se trata de elementos complejos con importantes API e interfaces de usuario no triviales. Puede controlar la reproducción multimedia con los métodos <codeinline>play()</codeinline> y <codeinline>pause()</codeinline>. Puede establecer las propiedades <codeinline>volumen</codeinline> y <codeinline>playbackRate</codeinline> para controlar el volumen de audio y la velocidad de reproducción. Y puede saltar a un momento determinado dentro del medio estableciendo la propiedad <codeinline>currentTime</codeinline>.</p>
    <p>Sin embargo, no trataremos aquí en detalle las etiquetas <codeinline>&lt;audio></codeinline> y <codeinline>&lt;video></codeinline>. Las siguientes subsecciones muestran dos formas de añadir efectos de sonido con guión a las páginas web.</p>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.9.1 El constructor Audio()</h2>
    <p>No es necesario incluir una etiqueta <codeinline>&lt;audio></codeinline> en el documento HTML para incluir efectos de sonido en las páginas web. Puede crear dinámicamente elementos <codeinline>&lt;audio></codeinline> con el método normal DOM <codeinline>document.createElement()</codeinline> o, como método abreviado, puede utilizar simplemente el constructor <codeinline>Audio()</codeinline>. No es necesario añadir el elemento creado al documento para reproducirlo. Basta con llamar a su método <codeinline>play()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Load the sound effect in advance so it is ready for use
    let soundeffect = new Audio("soundeffect.mp3");

    // Play the sound effect whenever the user clicks the mouse button
    document.addEventListener("click", () => &lbrace;
      soundeffect.cloneNode().play();   // Load and play the sound
    });</code></pre>
    <p>Observe el uso de <codeinline>cloneNode()</codeinline> aquí. Si el usuario hace clic en el ratón rápidamente, queremos ser capaces de tener múltiples copias superpuestas del efecto de sonido reproduciéndose al mismo tiempo. Para ello, necesitamos múltiples elementos Audio. Como los elementos Audio no se añaden al documento, serán recolectados cuando terminen de reproducirse.</p>
  </section>
  <section id="9-2">
    <h2>15.9.2 La API WebAudio</h2>
    <p>Además de la reproducción de sonidos grabados con elementos Audio, los navegadores web también permiten generar y reproducir sonidos sintetizados con la API WebAudio. Utilizar la API WebAudio es como conectar un sintetizador electrónico antiguo con cables de conexión. Con WebAudio, se crea un conjunto de objetos AudioNode, que representan fuentes, transformaciones o destinos de formas de onda, y luego se conectan estos nodos en una red para producir sonidos. La API no es particularmente compleja, pero una explicación completa requiere una comprensión de la música electrónica y los conceptos de procesamiento de señales que están más allá del alcance de este libro.</p>
    <p>El siguiente código utiliza la API WebAudio para sintetizar un acorde corto que se desvanece en aproximadamente un segundo. Este ejemplo muestra los fundamentos de la API WebAu- dio. Si le interesa, puede encontrar más información sobre esta API en Internet:</p>
    <pre class="language-js">
    <code class="language-js">// Begin by creating an audioContext object. Safari still requires
    // us to use webkitAudioContext instead of AudioContext.
    let audioContext = new (this.AudioContext||this.webkitAudioContext)();

    // Define the base sound as a combination of three pure sine waves
    let notes = [ 293.7, 370.0, 440.0 ]; // D major chord: D, F# and A
    
    // Create oscillator nodes for each of the notes we want to play
    let oscillators = notes.map(note => &lbrace;
      let o = audioContext.createOscillator();
      o.frequency.value = note;
      return o;
    });
    
    // Shape the sound by controlling its volume over time.
    // Starting at time 0 quickly ramp up to full volume.
    // Then starting at time 0.1 slowly ramp down to 0.
    let volumeControl = audioContext.createGain();
    volumeControl.gain.setTargetAtTime(1, 0.0, 0.02);
    volumeControl.gain.setTargetAtTime(0, 0.1, 0.2);
    
    // We're going to send the sound to the default destination:
    // the user's speakers
    let speakers = audioContext.destination;
    
    // Connect each of the source notes to the volume control
    oscillators.forEach(o => o.connect(volumeControl));
    
    // And connect the output of the volume control to the speakers.
    volumeControl.connect(speakers);
    
    // Now start playing the sounds and let them run for 1.25 seconds.
    let startTime = audioContext.currentTime;
    let stopTime = startTime + 1.25;
    oscillators.forEach(o => &lbrace;
      o.start(startTime);
      o.stop(stopTime);
    });
    
    // If we want to create a sequence of sounds we can use event handlers
    oscillators[0].addEventListener("ended", () => &lbrace;
      // This event handler is invoked when the note stops playing
    });</code></pre>
  </section>
  <section id="10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10 Localización, navegación e historia</h2>
    <p>La propiedad <codeinline>location</codeinline> de los objetos Window y Document hace referencia al objeto Location, que representa la URL actual del documento mostrado en la ventana, y que también proporciona una API para cargar nuevos documentos en la ventana.</p>
    <p>El objeto Location es muy parecido a un objeto URL (<a href="capitulo-11#9">§11.9</a>), y puede utilizar propiedades como <codeinline>protocol</codeinline>, <codeinline>hostname</codeinline>, <codeinline>port</codeinline> y <codeinline>path</codeinline> para acceder a las distintas partes de la URL del documento actual. La propiedad <codeinline>href</codeinline> devuelve la URL completa como una cadena, al igual que el método <codeinline>toString()</codeinline>.</p>
    <p>Las propiedades <codeinline>hash</codeinline> y <codeinline>search</codeinline> del objeto Location son interesantes. La propiedad <codeinline>hash</codeinline> devuelve la parte del "identificador de fragmento" de la URL, si existe: una almohadilla (#) seguida de un ID de elemento. La propiedad de <codeinline>search</codeinline> es similar. Devuelve la parte de la URL que comienza con un signo de interrogación: a menudo algún tipo de cadena de consulta. En general, esta parte de una URL se utiliza para parametrizar la URL y proporciona una forma de incrustar argumentos en ella. Aunque estos argumentos suelen estar destinados a scripts que se ejecutan en un servidor, no hay ninguna razón por la que no puedan utilizarse también en páginas habilitadas para JavaScript.</p>
    <p>Los objetos URL tienen una propiedad <codeinline>searchParams</codeinline> que es una representación analizada de la propiedad <codeinline>search</codeinline>. El objeto Location no tiene una propiedad <codeinline>searchParams</codeinline>, pero si desea analizar <codeinline>window.location.search</codeinline>, puede crear un objeto URL a partir del objeto Location y utilizar los <codeinline>searchParams</codeinline> de la URL:</p>
    <pre class="language-js">
    <code class="language-js">let url = new URL(window.location);
    let query = url.searchParams.get("q");
    let numResults = parseInt(url.searchParams.get("n") || "10");</code></pre>
    <p>Además del objeto Location al que puedes referirte como <codeinline>window.location</codeinline> o <codeinline>document.location</codeinline>, y el constructor <codeinline>URL()</codeinline> que usamos antes, los navegadores también definen una propiedad <codeinline>document.URL</codeinline>. Sorprendentemente, el valor de esta propiedad no es un objeto URL, sino simplemente una cadena. La cadena contiene la URL del documento actual.</p>
  </section>
  <section id="10-1">
    <h2>15.10.1 Carga de nuevos documentos</h2>
    <p>Si asignas una cadena a <codeinline>window.location</codeinline> o a <codeinline>document.location</codeinline>, esa cadena se interpreta como una URL y el navegador la carga, sustituyendo el documento actual por uno nuevo:</p>
    <pre class="language-js">
    <code class="language-js">window.location = "http://www.oreilly.com"; // Go buy some books!</code></pre>
    <p>También puede asignar URL relativas a la <codeinline>location</codeinline>. Se resuelven en relación con la URL actual:</p>
    <pre class="language-js">
    <code class="language-js">document.location = "page2.html"; // Load the next page</code></pre>
    <p>Un identificador de fragmento desnudo es un tipo especial de URL relativa que no hace que el navegador cargue un nuevo documento, sino que simplemente se desplaza para que el elemento del documento con <codeinline>id</codeinline> o <codeinline>nombre</codeinline> que coincide con el fragmento sea visible en la parte superior de la ventana del navegador. Como caso especial, el identificador de fragmento <codeinline>#top</codeinline> hace que el navegador salte al principio del documento (suponiendo que ningún elemento tenga un atributo <codeinline>id="top"</codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">location = "#top"; // Jump to the top of the document</code></pre>
    <p>Las propiedades individuales del objeto Location son escribibles, y establecerlas cambia la URL de localización y también hace que el navegador cargue un nuevo documento (o, en el caso de la propiedad <codeinline>hash</codeinline>, que navegue dentro del documento actual):</p>
    <pre class="language-js">
    <code class="language-js">document.location.path = "pages/3.html"; // Load a new page
    document.location.hash = "TOC";          // Scroll to the table of contents
    location.search = "?page=" + (page+1);   // Reload with new query string</code></pre>
    <p>También puede cargar una nueva página pasando una nueva cadena al método <codeinline>assign()</codeinline> del objeto Location. Esto es lo mismo que asignar la cadena a la propiedad <codeinline>location</codeinline>, sin embargo, por lo que no es particularmente interesante.</p>
    <p>Por otro lado, el método <codeinline>replace()</codeinline> del objeto Location es bastante útil. Cuando se pasa una cadena a <codeinline>replace()</codeinline>, se interpreta como una URL y hace que el navegador cargue una nueva página, igual que hace <codeinline>assign()</codeinline>.La diferencia es que <codeinline>replace()</codeinline> reemplaza el documento actual en el historial del navegador. Si un script en el documento A establece la propiedad <codeinline>location</codeinline> o llama a <codeinline>assign()</codeinline> para cargar el documento B y luego el usuario pulsa el botón Atrás, el navegador volverá al documento A. Si en cambio utiliza <codeinline>replace()</codeinline>, el documento A se borra del historial del navegador, y cuando el usuario pulsa el botón Atrás, el navegador vuelve al documento que se mostraba antes del documento A.</p>
    <p>Cuando un script carga incondicionalmente un nuevo documento, el método <codeinline>replace()</codeinline> es una mejor opción que <codeinline>assign()</codeinline>. De lo contrario, el botón Atrás llevaría al navegador de vuelta al documento original, y el mismo script volvería a cargar el nuevo documento. Supongamos que tiene una versión mejorada con JavaScript de su página y una versión estática que no utiliza JavaScript. Si determina que el navegador del usuario no admiten las API de la plataforma web que desea utilizar, podría utilizar <codeinline>location.replace()</codeinline> para cargar la versión estática:</p>
    <pre class="language-js">
    <code class="language-js">// If the browser does not support the JavaScript APIs we need,
    // redirect to a static page that does not use JavaScript.
    if (!isBrowserSupported()) location.replace("staticpage.html");</code></pre>
    <p>Observe que la URL pasada a <codeinline>replace()</codeinline> es relativa. Las URL relativas se interpretan en relación con la página en la que aparecen, igual que si se utilizaran en un hipervínculo.</p>
    <p>Además de los métodos <codeinline>assign()</codeinline> y <codeinline>replace()</codeinline>, el objeto Location también define <codeinline>reload()</codeinline>, que simplemente hace que el navegador recargue el documento.</p>
  </section>
  <section id="10-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.2 Historial de navegación</h2>
    <p>La propiedad <codeinline>history</codeinline> del objeto Window hace referencia al objeto History de la ventana. El objeto History modela el historial de navegación de una ventana como una lista de documentos y estados de documentos. La propiedad <codeinline>length</codeinline> del objeto History especifica el número de elementos de la lista del historial de navegación, pero por razones de seguridad, los scripts no pueden acceder a las URL almacenadas. (Si pudieran, cualquier script podría husmear en tu historial de navegación).</p>
    <p>El objeto History tiene métodos <codeinline>back()</codeinline> y <codeinline>forward()</codeinline> que se comportan como los botones Back y Forward del navegador: hacen que el navegador retroceda o avance un paso en su historial de navegación. Un tercer método, <codeinline>go()</codeinline>, toma un argumento entero y puede saltar cualquier número de páginas hacia adelante (para argumentos positivos) o hacia atrás (para argumentos negativos) en la lista del historial:</p>
    <pre class="language-js">
    <code class="language-js">history.go(-2); // Go back 2, like clicking the Back button twice
    history.go(0);  // Another way to reload the current page</code></pre>
    <p>Si una ventana contiene ventanas hijas (como elementos <codeinline>&lt;iframe></codeinline>), los historiales de navegación de las ventanas hijas se intercalan cronológicamente con el historial de la ventana principal. Esto significa que una llamada a <codeinline>history.back()</codeinline> (por ejemplo) en la ventana principal puede hacer que una de las ventanas secundarias vuelva a un documento previamente reproducido, pero deja la ventana principal en su estado actual.</p>
    <p>El objeto History descrito aquí se remonta a los primeros días de la web, cuando los documentos eran pasivos y todo el cálculo se realizaba en el servidor. Hoy en día, las aplicaciones web a menudo generan o cargan contenido dinámicamente y muestran nuevos estados de la aplicación sin cargar realmente nuevos documentos. Este tipo de aplicaciones deben realizar su propia gestión del historial si quieren que el usuario pueda utilizar los botones Atrás y Adelante (o los gestos equivalentes) para navegar de un estado de la aplicación a otro de forma intuitiva. Hay dos formas de conseguirlo, que se describen en las dos secciones siguientes.</p>
  </section>
  <section id="10-3">
    <h2>15.10.3 Gestión del historial con hashchange Events</h2>
    <p>Una técnica de gestión del historial implica <codeinline>location.hash</codeinline> Estos son los datos clave que debes conocer para entender esta técnica</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La propiedad <codeinline>location.hash</codeinline> establece el identificador de fragmento de la URL y se utiliza tradicionalmente para especificar el ID de una sección del documento a la que desplazarse. Pero <codeinline>location.hash</codeinline> no tiene por qué ser el ID de un elemento: puedes ponerle cualquier cadena. Mientras ningún elemento tenga esa cadena como ID, el navegador no se desplazará cuando establezcas la propiedad <codeinline>hash</codeinline> de esta forma.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Al establecer la propiedad <codeinline>location.hash</codeinline> se actualiza la URL que aparece en la barra de direcciones y, lo que es muy importante, se añade una entrada al historial del navegador.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cada vez que cambia el identificador de fragmento del documento, el navegador dispara un evento "hashchange" en el objeto Window. Si estableces <codeinline>location.hash</codeinline> explícitamente, se dispara un evento "hashchange". Y, como hemos mencionado, este cambio en el objeto Location crea una nueva entrada en el historial de navegación del navegador. Así que si el usuario ahora pulsa el botón Atrás, el navegador volverá a su URL anterior antes de que establecieras <codeinline>location.hash</codeinline>. Pero esto significa que el identificador del fragmento ha cambiado de nuevo, por lo que en este caso se dispara otro evento "hashchange". Esto significa que mientras puedas crear un identificador de fragmento único para cada posible estado de tu aplicación, los eventos "hashchange" te notificarán si el usuario retrocede y avanza en su historial de navegación.
        </p>
      </li>
    </ul>
    <p>Para utilizar este mecanismo de gestión del historial, tendrás que ser capaz de codificar la información de estado necesaria para representar una "página" de tu aplicación en una cadena de texto relativamente corta que sea adecuada para su uso como identificador de fragmento. Y tendrás que escribir una función para convertir el estado de la página en una cadena y otra función para analizar la cadena y recrear el estado de la página que representa.</p>
    <p>Una vez que hayas escrito esas funciones, el resto es fácil. Define una función window.onhash change (o registra un "hashchange" listener con <codeinline>addEventListener()</codeinline>) que lea <codeinline>location.hash</codeinline>, convierta esa cadena en una representación del estado de tu aplicación, y luego tome las acciones que sean necesarias para mostrar ese nuevo estado de la aplicación.</p>
    <p>Cuando el usuario interactúa con tu aplicación (por ejemplo, haciendo clic en un enlace) de forma que la aplicación entra en un nuevo estado, no renderices el nuevo estado directamente. En su lugar, codifica el nuevo estado deseado como una cadena y establece <codeinline>location.hash</codeinline> a esa cadena. Esto activará un evento "hashchange", y tu manejador para ese evento mostrará el nuevo estado. El uso de esta técnica indirecta garantiza que el nuevo estado se inserte en el historial de navegación para que los botones Atrás y Adelante sigan funcionando.</p>
  </section>
  <section id="10-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.4 Gestión del historial con pushState()</h2>
    <p>La segunda técnica para gestionar el historial es algo más compleja, pero menos complicada que el evento "hashchange". Esta técnica más robusta de gestión del historial se basa en el método <codeinline>history.pushState()</codeinline> y el evento "popstate". Cuando una aplicación web entra en un nuevo estado, llama a <codeinline>history.pushState()</codeinline> para añadir un objeto que representa el estado al historial del navegador. Si el usuario pulsa el botón Atrás, el navegador lanza un evento "popstate" con una copia de ese objeto de estado guardado, y la aplicación utiliza ese objeto para recrear su estado anterior. Además del objeto de estado guardado, las aplicaciones también pueden guardar una URL con cada estado, lo que es importante si quieres que los usuarios puedan marcar y compartir enlaces a los estados internos de la aplicación.</p>
    <p>El primer argumento de <codeinline>pushState()</codeinline> es un objeto que contiene toda la información de estado necesaria para restaurar el estado actual del documento. Este objeto se guarda utilizando el algoritmo de <em>clonado estructurado</em> de HTML, que es más versátil que <codeinline>JSON.stringify()</codeinline> y puede admitir objetos Map, Set y Date, así como matrices tipadas y ArrayBuffers.</p>
    <p>El segundo argumento estaba pensado para ser una cadena de título para el estado, pero la mayoría de los navegadores no lo soportan, y deberías pasar simplemente una cadena vacía. El tercer argumento es una URL opcional que se mostrará en la barra de direcciones inmediatamente y también si el usuario vuelve a este estado a través de los botones Atrás y Adelante. Las URL relativas se resuelven contra la ubicación actual del documento. Asociar una URL a cada estado permite al usuario marcar estados internos de su aplicación. Recuerda, sin embargo, que si el usuario guarda un marcador y lo visita un día después, no recibirás un evento "popstate" sobre esa visita: tendrás que restaurar el estado de tu aplicación analizando la URL.</p>
    <article id="algoritmo-clon-estructurado">
      <p class="title-article">El algoritmo del clon estructurado</p>
      <p>El método <codeinline>history.pushState()</codeinline> no utiliza <codeinline>JSON.stringify()</codeinline> (<a href="capitulo-11#6">§11.6</a>) para serializar los datos de estado. En su lugar, utiliza (al igual que otras APIs del navegador que veremos más adelante) una técnica de serialización más robusta conocida como algoritmo de clonación estructurada, definida por el estándar HTML.</p>
      <p>El algoritmo de clonado estructurado puede serializar cualquier cosa que <codeinline>JSON.stringify()</codeinline> pueda, pero además, permite la serialización de la mayoría de los otros tipos de JavaScript, incluyendo Map, Set, Date, RegExp, y arrays tipados, y puede manejar estructuras de datos que incluyen referencias circulares. Sin embargo, el algoritmo de clonación estructurada <em>no puede</em> serializar funciones o clases. Al clonar objetos no copia el objeto prototipo, los getters y setters, ni las propiedades no enumerables. Aunque el algoritmo de clonación estructurada puede clonar la mayoría de los tipos incorporados de JavaScript, no puede copiar tipos definidos por el entorno host, como los objetos document Element.</p>
      <p>Esto significa que el objeto de estado que se pasa a <codeinline>history.pushState()</codeinline> no tiene por qué limitarse a los objetos, matrices y valores primitivos que admite <codeinline>JSON.stringify()</codeinline>. Nota, Sin embargo, si pasas una instancia de una clase que has definido, esa instancia se serializará como un objeto JavaScript ordinario y perderá su prototipo.</p>
    </article>
    <p>Además del método <codeinline>pushState()</codeinline>, el objeto Historial también define <codeinline>replaceState()</codeinline>, que toma los mismos argumentos pero reemplaza el estado actual del historial en lugar de añadir un nuevo estado al historial de navegación. Cuando se carga por primera vez una aplicación que utiliza <codeinline>pushState()</codeinline>, suele ser una buena idea llamar a <codeinline>replaceState()</codeinline> para definir un objeto de estado para este estado inicial de la aplicación.</p>
    <p>Cuando el usuario navega a los estados guardados del historial usando los botones Atrás o Adelante, el navegador dispara un evento "popstate" en el objeto Window. El objeto de evento asociado con el evento tiene una propiedad llamada <codeinline>state</codeinline>, que contiene una copia (otro clon estructurado) del objeto state que pasaste a <codeinline>pushState()</codeinline>.</p>
    <p>El <a href="#ejemplo15-9">Ejemplo 15-9</a> es una aplicación web sencilla -el juego de adivinar números de la <a href="figure15-15">Figura 15-15</a> - que utiliza <codeinline>pushState()</codeinline> para guardar su historial, permitiendo al usuario "ir atrás" para revisar o rehacer sus conjeturas.</p>
    <figure id="figure15-15">
      <img src="/public/javascript/capitulo-15/figure15-15.avif" alt="imagen de consola">
      <figcaption>Figura 15-15. Un juego de adivinanzas numéricas</figcaption>
    </figure>
    <p><em>Ejemplo 15-9. Gestión del historial con pushState()</em></p>
    <pre class="language-js">
    <code class="language-js">&lt;html>&lt;head>&lt;title>I'm thinking of a number...&lt;/title>
    &lt;style>
    body &lbrace; height: 250px; display: flex; flex-direction: column;
        align-items: center; justify-content: space-evenly; }
    #heading &lbrace; font: bold 36px sans-serif; margin: 0; }
    #container &lbrace; border: solid black 1px; height: 1em; width: 80%; }
    #range &lbrace; background-color: green; margin-left: 0%; height: 1em; width: 100%; }
    #input &lbrace; display: block; font-size: 24px; width: 60%; padding: 5px; }
    #playagain &lbrace; font-size: 24px; padding: 10px; border-radius: 5px; }
    &lt;/style>
    &lt;/head>
    &lt;body>
    &lt;h1 id="heading">I'm thinking of a number...&lt;/h1>
    &lt;!-- A visual representation of the numbers that have not been ruled out -->
    &lt;div id="container">&lt;div id="range">&lt;/div>&lt;/div>
    &lt;!-- Where the user enters their guess -->
    &lt;input id="input" type="text">
    &lt;!-- A button that reloads with no search string. Hidden until game ends. -->
    &lt;button id="playagain" hidden onclick="location.search='';">Play Again&lt;/button>
    &lt;script>
    /**
    * An instance of this GameState class represents the internal state of
    * our number guessing game. The class defines static factory methods for
    * initializing the game state from different sources, a method for
    * updating the state based on a new guess, and a method for modifying the
    * document based on the current state.
    */
    class GameState &lbrace;
      // This is a factory function to create a new game
      static newGame() &lbrace;
        let s = new GameState();
        s.secret = s.randomInt(0, 100); // An integer: 0 &lt; n &lt; 100
        s.low = 0;        // Guesses must be greater than this
        s.high = 100;     // Guesses must be less than this
        s.numGuesses = 0; // How many guesses have been made
        s.guess = null;   // What the last guess was
        return s;
      }

      // When we save the state of the game with history.pushState(), it is just
      // a plain JavaScript object that gets saved, not an instance of GameState.
      // So this factory function re-creates a GameState object based on the
      // plain object that we get from a popstate event.
      static fromStateObject(stateObject) &lbrace;
        let s = new GameState();
        for(let key of Object.keys(stateObject)) &lbrace;
          s[key] = stateObject[key];
        }
        return s;
      }

      // In order to enable bookmarking, we need to be able to encode the
      // state of any game as a URL. This is easy to do with URLSearchParams.
      toURL() &lbrace;
        let url = new URL(window.location);
        url.searchParams.set("l", this.low);
        url.searchParams.set("h", this.high);
        url.searchParams.set("n", this.numGuesses);
        url.searchParams.set("g", this.guess);
        // Note that we can't encode the secret number in the url or it
        // will give away the secret. If the user bookmarks the page with
        // these parameters and then returns to it, we will simply pick a
        // new random number between low and high.
        return url.href;
      }

      // This is a factory function that creates a new GameState object and
      // initializes it from the specified URL. If the URL does not contain the
      // expected parameters or if they are malformed it just returns null.
      static fromURL(url) &lbrace;
        let s = new GameState();
        let params = new URL(url).searchParams;
        s.low = parseInt(params.get("l"));
        s.high = parseInt(params.get("h"));
        s.numGuesses = parseInt(params.get("n"));
        s.guess = parseInt(params.get("g"));

        // If the URL is missing any of the parameters we need or if
        // they did not parse as integers, then return null;
        if (isNaN(s.low) || isNaN(s.high) || isNaN(s.numGuesses) || isNaN(s.guess)) &lbrace;
          return null;
        }

        // Pick a new secret number in the right range each time we
        // restore a game from a URL.
        s.secret = s.randomInt(s.low, s.high);
        return s;
      }

      // Return an integer n, min &lt; n &lt; max
      randomInt(min, max) &lbrace;
        return min + Math.ceil(Math.random() * (max - min - 1));
      }

      // Modify the document to display the current state of the game.
      render() &lbrace;
        let heading = document.querySelector("#heading"); // The &lt;h1> at the top
        let range = document.querySelector("#range");     // Display guess range
        let input = document.querySelector("#input");     // Guess input field
        let playagain = document.querySelector("#playagain");

        // Update the document heading and title
        heading.textContent = document.title =
          `I'm thinking of a number between $&lbrace;this.low} and $&lbrace;this.high}.`;

        // Update the visual range of numbers
        range.style.marginLeft = `$&lbrace;this.low}%`;
        range.style.width = `$&lbrace;(this.high-this.low)}%`;

        // Make sure the input field is empty and focused.
        input.value = "";
        input.focus();

        // Display feedback based on the user's last guess. The input
        // placeholder will show because we made the input field empty.
        if (this.guess === null) &lbrace;
          input.placeholder = "Type your guess and hit Enter";
        } else if (this.guess &lt; this.secret) &lbrace;
          input.placeholder = `$&lbrace;this.guess} is too low. Guess again`;
        } else if (this.guess > this.secret) &lbrace;
          input.placeholder = `$&lbrace;this.guess} is too high. Guess again`;
        } else &lbrace;
          input.placeholder = document.title = `$&lbrace;this.guess} is correct!`;
          heading.textContent = `You win in $&lbrace;this.numGuesses} guesses!`;
          playagain.hidden = false;
        }
      }

      // Update the state of the game based on what the user guessed.
      // Returns true if the state was updated, and false otherwise.
      updateForGuess(guess) &lbrace;
        // If it is a number and is in the right range
        if ((guess > this.low) && (guess &lt; this.high)) &lbrace;
          // Update state object based on this guess
          if (guess &lt; this.secret) this.low = guess;
          else if (guess > this.secret) this.high = guess;
          this.guess = guess;
          this.numGuesses++;
          return true;
        }
        else &lbrace; // An invalid guess: notify user but don't update state
          alert(`Please enter a number greater than $&lbrace;
            this.low} and less than $&lbrace;this.high}`);
          return false;
        }
      }
    }
    // With the GameState class defined, making the game work is just a matter
    // of initializing, updating, saving and rendering the state object at
    // the appropriate times.

    // When we are first loaded, we try get the state of the game from the URL
    // and if that fails we instead begin a new game. So if the user bookmarks a
    // game that game can be restored from the URL. But if we load a page with
    // no query parameters we'll just get a new game.
    let gamestate = GameState.fromURL(window.location) || GameState.newGame();

    // Save this initial state of the game into the browser history, but use
    // replaceState instead of pushState() for this initial page
    history.replaceState(gamestate, "", gamestate.toURL());

    // Display this initial state
    gamestate.render();

    // When the user guesses, update the state of the game based on their guess
    // then save the new state to browser history and render the new state
    document.querySelector("#input").onchange = (event) => &lbrace;
      if (gamestate.updateForGuess(parseInt(event.target.value))) &lbrace;
        history.pushState(gamestate, "", gamestate.toURL());
      }
      gamestate.render();
    };

    // If the user goes back or forward in history, we'll get a popstate event
    // on the window object with a copy of the state object we saved with
    // pushState. When that happens, render the new state.
    window.onpopstate = (event) => &lbrace;
      gamestate = GameState.fromStateObject(event.state); // Restore the state
      gamestate.render();                                 // and display it
    };
    &lt;/script>
    &lt;/body>&lt;/html></code></pre>
  </section>
  <section id="11" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11 Networking</h2>
    <p>Cada vez que se carga una página web, el navegador realiza peticiones de red -utilizando los protocolos HTTP y HTTPS- para un archivo HTML, así como para las imágenes, fuentes, scripts y hojas de estilo de los que depende el archivo. Pero además de ser capaces de hacer peticiones de red en respuesta a las acciones del usuario, los navegadores web también exponen APIs de JavaScript para la creación de redes.</p>
    <p>Esta sección cubre tres APIs de red:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El método <codeinline>fetch()</codeinline> define una API basada en promesas para realizar peticiones HTTP y HTTPS. La API <codeinline>fetch()</codeinline> simplifica las solicitudes GET básicas, pero cuenta con un amplio conjunto de funciones que también admite prácticamente cualquier caso de uso HTTP posible.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API Server-Sent Events (o SSE) es una práctica interfaz basada en eventos para las técnicas HTTP de "sondeo prolongado", en las que el servidor web mantiene abierta la conexión de red para poder enviar datos al cliente cuando lo desee.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          WebSockets es un protocolo de red que no es HTTP, sino que está diseñado para interactuar con HTTP. Define una API asíncrona de transmisión de mensajes en la que clientes y servidores pueden enviar y recibir mensajes entre sí de forma similar a los sockets de red TCP.
        </p>
      </li>
    </ul>
  </section>
  <section id="11-1">
    <h2>15.11.1 fetch()</h2>
    <p>Para peticiones HTTP básicas, el uso de <codeinline>fetch()</codeinline> es un proceso de tres pasos:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Llame a <codeinline>fetch()</codeinline>, pasando la URL cuyo contenido desea recuperar.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Obtener el objeto de respuesta que es devuelto asíncronamente por el paso 1 cuando la respuesta HTTP comienza a llegar y llamar a un método de este objeto de respuesta para pedir el cuerpo de la respuesta.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Obtén el objeto cuerpo devuelto de forma asíncrona en el paso 2 y procésalo como quieras.
        </p>
      </li>
    </ul>
    <p>La API <codeinline>fetch()</codeinline> está completamente basada en promesas, y hay dos pasos asíncronos aquí, por lo que típicamente se esperan dos llamadas <codeinline>then()</codeinline> o dos expresiones <codeinline>await</codeinline> cuando se usa <codeinline>fetch()</codeinline>. (Y si has olvidado lo que son, puede que quieras releer el <a href="capitulo-13">Capítulo 13</a> antes de continuar con esta sección).</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/users/current")          // Make an HTTP (or HTTPS) GET request
      .then(response => response.json()) // Parse its body as a JSON object
      .then(currentUser => &lbrace;             // Then process that parsed object
        displayUserInfo(currentUser);
      });</code></pre>
    <p>Este es el aspecto de una solicitud <codeinline>fetch()</codeinline> si utiliza <codeinline>then()</codeinline> y espera que la respuesta del servidor a su solicitud tenga formato JSON:</p>
    <pre class="language-js">
    <code class="language-js">async function isServiceReady() &lbrace;
      let response = await fetch("/api/service/status");
      let body = await response.text();
      return body === "ready";
    }</code></pre>
    <p>A continuación se muestra una solicitud similar realizada utilizando las palabras clave y <codeinline>await</codeinline> a una API que devuelve una cadena sin formato en lugar de un objeto async JSON:</p>
    <p>Si entiende estos dos ejemplos de código, entonces conoce el 80% de lo que necesita saber para utilizar la API <codeinline>fetch()</codeinline>. Las subsecciones que siguen demostrarán cómo hacer peticiones y recibir respuestas que son algo más complicadas que las mostradas aquí.</p>
    <article>
      <p class="title-article">Adiós a XMLHttpRequest</p>
      <p>La API <codeinline>fetch()</codeinline> sustituye a la barroca y engañosamente llamada API XMLHttpRequest (que no tiene nada que ver con XML). Puede que aún veas XHR (como se abrevia a menudo) en código existente, pero hoy en día no hay razón para usarlo en código nuevo, y no está documentado en este capítulo. Sin embargo, hay un ejemplo de XMLHttpRequest en este libro, y puedes consultar <a href="capitulo-13#1-3">§13.1.3</a> si quieres ver un ejemplo de redes JavaScript al viejo estilo.</p>
    </article>
    <p class="title-article text-left">Códigos de estado HTTP, cabeceras de respuesta y errores de red</p>
    <p>El proceso <codeinline>fetch()</codeinline> de tres pasos mostrado en <a href="#11-1">§15.11.1</a> elude todo el código de gestión de errores. He aquí una versión más realista:</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/users/current")   // Make an HTTP (or HTTPS) GET request.
      .then(response => &lbrace;         // When we get a response, first check it
        if (response.ok &&        // for a success code and the expected type.
          response.headers.get("Content-Type") === "application/json") &lbrace;
          return response.json(); // Return a Promise for the body.
        } else &lbrace;
          throw new Error(        // Or throw an error.
          `Unexpected response status $&lbrace;response.status} or content type`);
        }
      })
      .then(currentUser => &lbrace;      // When the response.json() Promise resolves
        displayUserInfo(currentUser); // do something with the parsed body.
      })
      .catch(error => &lbrace;      // Or if anything went wrong, just log the error.
        // If the user's browser is offline, fetch() itself will reject.
        // If the server returns a bad response then we throw an error above.
        console.log("Error while fetching current user:", error);
      });</code></pre>
    <p>La promesa devuelta por <codeinline>fetch()</codeinline> resuelve a un objeto Response. La propiedad <codeinline>status</codeinline> de este objeto es el código de estado HTTP, como 200 para peticiones exitosas o 404 para respuestas "No Encontrado". (<codeinline>statusText</codeinline> proporciona el texto estándar en inglés que acompaña al código de estado numérico). Convenientemente, la propiedad <codeinline>ok</codeinline> de una Respuesta es <codeinline>statusText</codeinline> si el <codeinline>status</codeinline> es 200 o cualquier código entre 200 y 299 y es <codeinline>false</codeinline> para cualquier otro código.</p>
    <p><codeinline>fetch()</codeinline> resuelve su Promise cuando la respuesta del servidor comienza a llegar, tan pronto como el estado HTTP y las cabeceras de respuesta están disponibles, pero normalmente antes de que el cuerpo completo de la respuesta haya llegado. Aunque el cuerpo no esté disponible todavía, puedes examinar las cabeceras en este segundo paso del proceso de obtención. La propiedad <codeinline>headers</codeinline> de un objeto Response es un objeto Headers. Utilice su método <codeinline>has()</codeinline> para comprobar la presencia de una cabecera, o utilice su método <codeinline>get()</codeinline> para obtener el valor de una cabecera. Los nombres de cabecera HTTP no distinguen entre mayúsculas y minúsculas, por lo que puede pasar nombres de cabecera en minúsculas o mixtos a estas funciones.</p>
    <p>El objeto Headers también es iterable por si alguna vez necesita hacerlo:</p>
    <pre class="language-js">
    <code class="language-js">fetch(url).then(response => &lbrace;
      for(let [name,value] of response.headers) &lbrace;
        console.log(`$&lbrace;name}: $&lbrace;value}`);
      }
    });</code></pre>
    <p>Si un servidor web responde a la solicitud de <codeinline>fetch()</codeinline>, la promesa devuelta se cumplirá con un objeto Response, incluso si la respuesta del servidor es un error 404 Not Found o un error 500 Internal Server Error. <codeinline>fetch()</codeinline> sólo rechaza la promesa devuelta si no puede ponerse en contacto con el servidor web. Esto puede ocurrir si el ordenador del usuario está desconectado, el servidor no responde o la URL especifica un nombre de host que no existe. Debido a que estas cosas pueden ocurrir en cualquier petición de red, siempre es una buena idea incluir una cláusula <codeinline>.catch()</codeinline> cada vez que hagas una llamada a <codeinline>fetch()</codeinline>.</p>
    <p class="title-article text-left">Configuración de los parámetros de la solicitud</p>
    <p>A veces se desea pasar parámetros adicionales junto con la URL cuando se hace una petición. Esto se puede hacer añadiendo pares nombre/valor al final de una URL después de un <codeinline>?.</codeinline> Las clases URL y URLSearchParams (que se trataron en <a href="capitulo-11#9">§11.9</a>) facilitan la construcción de URLs de esta forma, y la función <codeinline>fetch()</codeinline> acepta objetos URL como primer argumento, por lo que se pueden incluir parámetros de petición en una petición <codeinline>fetch()</codeinline> como ésta:</p>
    <pre class="language-js">
    <code class="language-js">async function search(term) &lbrace;
      let url = new URL("/api/search");
      url.searchParams.set("q", term);
      let response = await fetch(url);
      if (!response.ok) throw new Error(response.statusText);
      let resultsArray = await response.json();
      return resultsArray;
    }</code></pre>
    <p class="title-article text-left">Establecer cabeceras de solicitud</p>
    <p>A veces es necesario establecer cabeceras en las peticiones <codeinline>fetch()</codeinline>. Por ejemplo, si realiza solicitudes de API web que requieren credenciales, puede que necesite incluir una cabecera Authorization que contenga dichas credenciales. Para ello, puede utilizar la versión de dos argumentos de <codeinline>fetch()</codeinline>. Como antes, el primer argumento es una cadena o un objeto URL que especifica la URL a obtener. El segundo argumento es un objeto que puede proporcionar opciones adicionales, incluyendo cabeceras de petición:</p>
    <pre class="language-js">
    <code class="language-js">let authHeaders = new Headers();
    // Don't use Basic auth unless it is over an HTTPS connection.
    authHeaders.set("Authorization",
            `Basic $&lbrace;btoa(`$&lbrace;username}:$&lbrace;password}`)}`);
    fetch("/api/users/", &lbrace; headers: authHeaders })
      .then(response => response.json()) // Error handling omitted...
      .then(usersList => displayAllUsers(usersList));</code></pre>
    <p>Hay otras opciones que se pueden especificar en el segundo argumento de <codeinline>fetch()</codeinline>, y lo volveremos a ver más adelante. Una alternativa a pasar dos argumentos a <codeinline>fetch()</codeinline> es pasar los mismos dos argumentos al constructor de <codeinline>Request()</codeinline> y luego pasar el objeto Request resultante a <codeinline>fetch()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let request = new Request(url, &lbrace; headers });
    fetch(request).then(response => ...);</code></pre>
    <p class="title-article text-left">Análisis de los cuerpos de respuesta</p>
    <p>En el proceso <codeinline>fetch()</codeinline> de tres pasos que hemos demostrado, el segundo paso termina llamando a los métodos <codeinline>json()</codeinline> o <codeinline>text()</codeinline> del objeto Response y devolviendo el objeto Promise que esos métodos devuelven. Luego, el tercer paso comienza cuando esa Promesa se resuelve con el cuerpo de la respuesta analizado como un objeto JSON o simplemente como una cadena de texto.</p>
    <p>Estos son probablemente los dos escenarios más comunes, pero no son las únicas formas de obtener el cuerpo de la respuesta de un servidor web. Además de <codeinline>json()</codeinline> y <codeinline>text()</codeinline>, el objeto Response también tiene estos métodos:</p>
    <p><codeinline>arrayBuffer()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve a un ArrayBuffer. Esto es útil cuando la respuesta contiene datos binarios. Puedes utilizar el ArrayBuffer para crear un array tipado (<a href="capitulo-11#2">§11.2</a>) o un objeto DataView (<a href="capitulo-11#2-5">§11.2.5</a>) del que puedas leer los datos binarios.</p>
    <p><codeinline>blob()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve un objeto Blob. Los objetos Blob no se tratan en detalle en este libro, pero su nombre significa "Binary Large Object", y son útiles cuando se esperan grandes cantidades de datos binarios. Si pides el cuerpo de la respuesta como un Blob, la implementación del navegador puede transmitir los datos de la respuesta a un archivo temporal y luego devolver un objeto Blob que representa ese archivo temporal. Los objetos Blob, por lo tanto, no permiten el acceso aleatorio al cuerpo de la respuesta de la misma forma que un ArrayBuffer. Una vez que tenga un Blob, puede crear una URL que haga referencia a él con <codeinline>URL.createObjectURL()</codeinline>, o puede utilizar la API FileReader basada en eventos para obtener de forma asíncrona el contenido del Blob como una cadena o un ArrayBuffer. En el momento de escribir esto, algunos navegadores también definen métodos <codeinline>text()</codeinline> y <codeinline>arrayBuffer()</codeinline> basados en promesas que ofrecen una ruta más directa para obtener el contenido de un Blob.</p>
    <p><codeinline>formData()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve a un objeto FormData. Debería utilizar este método si espera que el cuerpo de la respuesta esté codificado en formato "multi-parte/form-data". Este formato es común en las solicitudes POST realizadas a un servidor, pero poco común en las respuestas del servidor, por lo que este método no se utiliza con frecuencia.</p>
    <p class="title-article text-left">Organismos de respuesta en tiempo real</p>
    <p>Además de los cinco métodos de respuesta que devuelven de forma asíncrona alguna forma del cuerpo de respuesta completo, también hay una opción para transmitir el cuerpo de respuesta, que es útil si hay algún tipo de procesamiento que puede hacer en los trozos del cuerpo de respuesta a medida que llegan a través de la red. Pero transmitir la respuesta también es útil si quieres mostrar una barra de progreso para que el usuario pueda ver el progreso de la descarga.</p>
    <p>La propiedad <codeinline>body</codeinline> de un objeto Response es un objeto ReadableStream. Si ya ha llamado a un método de respuesta como <codeinline>text()</codeinline> o <codeinline>json()</codeinline> que lee, analiza y devuelve el body, entonces <codeinline>bodyUsed</codeinline> será <codeinline>true</codeinline> para indicar que el flujo del <codeinline>body</codeinline> ya ha sido leído. Sin embargo, si <codeinline>bodyUsed</codeinline> es <codeinline>false</codeinline>, entonces el flujo aún no ha sido leído. En este caso, puede llamar a <codeinline>getReader()</codeinline> sobre <codeinline>response.body</codeinline> para obtener un flujo y utilizar el método <codeinline>read()</codeinline> de este objeto lector para leer asíncronamente trozos de texto del flujo. El método <codeinline>read()</codeinline> devuelve una Promise que resuelve a un objeto con las propiedades <codeinline>done</codeinline> y <codeinline>value</codeinline>. <codeinline>done</codeinline> será <codeinline>true</codeinline> si se ha leído todo el cuerpo o si se ha cerrado el flujo. Y value será el siguiente trozo de , como un Uint8Array, o <codeinline>undefined</codeinline> si no hay más trozos.</p>
    <p>Esta API de streaming es relativamente sencilla si usas <codeinline>async</codeinline> y <codeinline>await</codeinline> pero es sorprendentemente compleja si intentas usarla con Promises sin procesar. El <a href="#ejemplo15-10">Ejemplo 15-10</a> demuestra la API definiendo una función <codeinline>streamBody()</codeinline>. Suponga que quiere descargar un archivo JSON grande y reportar el progreso de la descarga al usuario. No puede hacer eso con el método <codeinline>json()</codeinline> del objeto Response, pero podría hacerlo con la función <codeinline>streamBody()</codeinline>, así (asumiendo que una función <codeinline>updateProgress()</codeinline> está definida para establecer el atributo <codeinline>value</codeinline> en un elemento HTML <codeinline>&lt;progress></codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">fetch('big.json')
      .then(response => streamBody(response, updateProgress))
      .then(bodyText => JSON.parse(bodyText))
      .then(handleBigJSONObject);</code></pre>
    <p>La función <codeinline>streamBody()</codeinline> puede ser implementada como se muestra en el <a href="#ejemplo15-10">Ejemplo 15-10</a>.</p>
    <p><em>Ejemplo 15-10. Transmisión del cuerpo de la respuesta de una petición fetch()</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * An asynchronous function for streaming the body of a Response object
    * obtained from a fetch() request. Pass the Response object as the first
    * argument followed by two optional callbacks.
    *
    * If you specify a function as the second argument, that reportProgress
    * callback will be called once for each chunk that is received. The first
    * argument passed is the total number of bytes received so far. The second
    * argument is a number between 0 and 1 specifying how complete the download
    * is. If the Response object has no "Content-Length" header, however, then
    * this second argument will always be NaN.
    *
    * If you want to process the data in chunks as they arrive, specify a
    * function as the third argument. The chunks will be passed, as Uint8Array
    * objects, to this processChunk callback.
    *
    * streamBody() returns a Promise that resolves to a string. If a processChunk
    * callback was supplied then this string is the concatenation of the values
    * returned by that callback. Otherwise the string is the concatenation of
    * the chunk values converted to UTF-8 strings.
    */
    async function streamBody(response, reportProgress, processChunk) &lbrace;
      // How many bytes are we expecting, or NaN if no header
      let expectedBytes = parseInt(response.headers.get("Content-Length"));
      let bytesRead = 0;                      // How many bytes received so far
      let reader = response.body.getReader(); // Read bytes with this function
      let decoder = new TextDecoder("utf-8"); // For converting bytes to text
      let body = "";                          // Text read so far

      while(true) &lbrace;                              // Loop until we exit below
        let &lbrace;done, value} = await reader.read(); // Read a chunk

        if (value) &lbrace;                             // If we got a byte array:
          if (processChunk) &lbrace;                    // Process the bytes if
            let processed = processChunk(value); // a callback was passed.
            if (processed) &lbrace;
              body += processed;
            }
          } else &lbrace; // Otherwise, convert bytes
            body += decoder.decode(value, &lbrace;stream: true}); // to text.
          }

          if (reportProgress) &lbrace;        // If a progress callback was
            bytesRead += value.length; // passed, then call it
            reportProgress(bytesRead, bytesRead / expectedBytes);
          }
        }
        if (done) &lbrace; // If this is the last chunk,
          break;    // exit the loop
        }
      }

      return body; // Return the body text we accumulated
    }</code></pre>
    <p>Esta API de streaming es nueva en el momento de escribir este artículo y se espera que evolucione. En particular, está previsto que los objetos ReadableStream sean iterables de forma asíncrona para que puedan utilizarse con bucles <codeinline>for/await</codeinline> (<a href="capitulo-13#4-1">§13.4.1</a>).</p>
    <p class="title-article text-left">Especificar el método y el cuerpo de la solicitud</p>
    <p>En cada uno de los ejemplos de <codeinline>fetch()</codeinline> mostrados hasta ahora, hemos realizado una petición HTTP (o HTTPS) GET. Si desea utilizar un método de solicitud diferente (como POST, PUT o DELETE), simplemente utilice la versión de dos argumentos de <codeinline>fetch()</codeinline>, pasando un objeto Options con un parámetro de <codeinline>method</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">fetch(url, &lbrace; method: "POST" }).then(r => r.json()).then(handleResponse);</code></pre>
    <p>Las peticiones POST y PUT suelen tener un cuerpo de petición que contiene los datos que se enviarán al servidor. Siempre que la propiedad <codeinline>method</codeinline> no sea <codeinline>"GET"</codeinline> o <codeinline>"HEAD"</codeinline> (que no admiten cuerpos de petición), puede especificar un cuerpo de petición estableciendo la propiedad body del objeto Options:</p>
    <pre class="language-js">
    <code class="language-js">fetch(url, &lbrace;
      method: "POST",
      body: "hello world"
    })</code></pre>
    <p>Cuando se especifica un cuerpo de petición, el navegador añade automáticamente una cabecera "Content-Length" apropiada a la petición. Cuando el cuerpo es una cadena, como en el ejemplo anterior, el navegador añade por defecto a la cabecera "Content-Type" "text/ plain;charset=UTF-8". Es posible que tenga que anular este valor predeterminado si especifica un cuerpo de cadena de algún tipo más específico, como "text/html" o "application/json":</p>
    <pre class="language-js">
    <code class="language-js">fetch(url, &lbrace;
      method: "POST",
      headers: new Headers(&lbrace;"Content-Type": "application/json"}),
      body: JSON.stringify(requestBody)
    })</code></pre>
    <p>La propiedad <codeinline>body</codeinline> del objeto <codeinline>fetch()</codeinline> options no tiene por qué ser una cadena. Si tiene datos binarios en un array tipado o un objeto DataView o un ArrayBuffer, puede establecer la propiedad <codeinline>body</codeinline> a ese valor y especificar una cabecera "Content-Type" apropiada. Si tiene datos binarios en forma de Blob, puede simplemente establecer <codeinline>body</codeinline> al Blob. Los Blobs tienen una propiedad <codeinline>type</codeinline> que especifica su tipo de contenido, y el valor de esta propiedad se utiliza como valor por defecto de la cabecera "Content-Type".</p>
    <p>Con las peticiones POST, es algo común pasar un conjunto de parámetros nombre/valor en el cuerpo de la petición (en lugar de codificarlos en la parte de consulta de la URL). Hay dos formas de hacerlo:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Con las peticiones POST, es algo común pasar un conjunto de parámetros nombre/valor en el cuerpo de la petición (en lugar de codificarlos en la parte de consulta de la URL). Hay dos formas de hacerlo:
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si, por el contrario, especifica los nombres y valores de los parámetros con un objeto FormData, el cuerpo utilizará una codificación multiparte más detallada y "Content-Type" se establecerá como "multipart/form-data; boundary=..." con una cadena límite única que coincida con el cuerpo. El uso de un objeto FormData es particularmente útil cuando los valores que desea cargar son largos, o son objetos File o Blob que pueden tener cada uno su propio "Content-Type". Los objetos FormData se pueden crear e inicializar con valores pasando un elemento <codeinline>&lt;form></codeinline> al constructor <codeinline>FormData()</codeinline>. Pero también se pueden crear cuerpos de petición "multipart/form-data" invocando al constructor <codeinline>FormData()</codeinline> sin argumentos e inicializando los pares nombre/valor que representa con los métodos <codeinline>set()</codeinline> y <codeinline>append()</codeinline>.
        </p>
      </li>
    </ul>
    <p class="title-article text-left">Carga de archivos con fetch()</p>
    <p>Cargar archivos desde el ordenador de un usuario a un servidor web es una tarea común y puede llevarse a cabo utilizando un objeto FormData como cuerpo de la petición. Una forma común de obtener un objeto File es mostrar un elemento <codeinline>&lt;input type="file"></codeinline> en su página web y escuchar eventos "change" en ese elemento. Cuando se produce un evento "change", el array <codeinline>files</codeinline> del elemento input debe contener al menos un objeto File. Los objetos File también están disponibles a través de la API HTML drag-and-drop. Esta API no está cubierta en este libro, pero puedes obtener archivos de la matriz <codeinline>dataTransfer.files</codeinline> del objeto de evento pasado a un escuchador de eventos para eventos "drop".</p>
    <p>Recuerda también que los objetos File son un tipo de Blob, y a veces puede ser útil cargar Blobs. Supongamos que has escrito una aplicación web que permite al usuario crear dibujos en un elemento <codeinline>&lt;canvas></codeinline>. Puede cargar los dibujos del usuario como archivos PNG con código como el siguiente:</p>
    <pre class="language-js">
    <code class="language-js">// The canvas.toBlob() function is callback-based.
    // This is a Promise-based wrapper for it.
    async function getCanvasBlob(canvas) &lbrace;
      return new Promise((resolve, reject) => &lbrace;
        canvas.toBlob(resolve);
      });
    }

    // Here is how we upload a PNG file from a canvas
    async function uploadCanvasImage(canvas) &lbrace;
      let pngblob = await getCanvasBlob(canvas);
      let formdata = new FormData();
      formdata.set("canvasimage", pngblob);
      let response = await fetch("/upload", &lbrace; method: "POST", body: formdata });
      let body = await response.json();
    }</code></pre>
    <p class="title-article text-left">Solicitudes de origen cruzado</p>
    <p>Las aplicaciones web suelen utilizar <codeinline>fetch()</codeinline> para solicitar datos a su propio servidor web. Este tipo de peticiones se conocen como peticiones del mismo origen porque la URL que se pasa a <codeinline>fetch()</codeinline> tiene el mismo origen (protocolo más nombre de host más puerto) que el documento que contiene el script que realiza la petición.</p>
    <p>Por razones de seguridad, los navegadores web no suelen permitir (aunque hay excepciones para imágenes y scripts) las peticiones de red de origen cruzado. Sin embargo, el uso compartido de recursos entre orígenes, o CORS, permite realizar peticiones seguras entre orígenes. Cuando se utiliza <codeinline>fetch()</codeinline> con una URL de origen cruzado, el navegador añade una cabecera "Origen" a la petición (y no permite que se sobrescriba mediante la propiedad headers) para notificar al servidor web que la petición procede de un documento con un origen diferente. Si el servidor responde a la petición con una cabecera "Access-Control-Allow-Origin" apropiada, entonces se procede con la petición. En caso contrario, si el servidor no permite explícitamente la solicitud, se rechaza la Promise devuelta por <codeinline>fetch()</codeinline>.</p>
    <p class="title-article text-left">Abortar una solicitud</p>
    <p>A veces es posible que desee abortar una solicitud <codeinline>fetch()</codeinline> que ya ha emitido, tal vez porque el usuario ha pulsado un botón Cancelar o porque la solicitud está tardando demasiado. La API fetch permite abortar peticiones mediante las clases AbortController y AbortSig- nal. (Estas clases definen un mecanismo de interrupción genérico que también pueden utilizar otras API).</p>
    <p>Si desea tener la opción de abortar una petición <codeinline>fetch()</codeinline>, cree un objeto Abort- Controller antes de iniciar la petición. La propiedad <codeinline>signal</codeinline> del objeto controlador es un objeto AbortSignal. Pase este objeto señal como valor de la propiedad <codeinline>signal</codeinline> del objeto options que pase a <codeinline>fetch()</codeinline>. Una vez hecho esto, puede llamar al método <codeinline>abort()</codeinline> del objeto controlador para abortar la petición, lo que hará que cualquier objeto Promise relacionado con la petición fetch sea rechazado con una excepción.</p>
    <p>A continuación se muestra un ejemplo de uso del mecanismo AbortController para imponer un tiempo de espera para las solicitudes de obtención:</p>
    <pre class="language-js">
    <code class="language-js">// This function is like fetch(), but it adds support for a timeout
    // property in the options object and aborts the fetch if it is not complete
    // within the number of milliseconds specified by that property.
    function fetchWithTimeout(url, options=&lbrace;}) &lbrace;
      if (options.timeout) &lbrace; // If the timeout property exists and is nonzero
        let controller = new AbortController(); // Create a controller
        options.signal = controller.signal;     // Set the signal property
        // Start a timer that will send the abort signal after the specified
        // number of milliseconds have passed. Note that we never cancel
        // this timer. Calling abort() after the fetch is complete has
        // no effect.
        setTimeout(() => &lbrace; controller.abort(); }, options.timeout);
      }
      // Now just perform a normal fetch
      return fetch(url, options);
    }</code></pre>
    <p class="title-article text-left">Opciones varias de solicitud</p>
    <p>Hemos visto que se puede pasar un objeto Options como segundo argumento a <codeinline>fetch()</codeinline> (o como segundo argumento al constructor <codeinline>Request()</codeinline>) para especificar el método de petición, las cabeceras y el cuerpo de la petición. También admite otras opciones, entre las que se incluyen las siguientes:</p>
    <p><codeinline>cache</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Utilice esta propiedad para anular el comportamiento de caché por defecto del navegador. La caché HTTP es un tema complejo que está más allá del alcance de este libro, pero si sabes algo acerca de cómo funciona, puedes utilizar los siguientes valores legales de <codeinline>cache</codeinline>:</p>
    <p><codeinline>"default"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor especifica el comportamiento predeterminado de la caché. Las respuestas frescas en la caché se sirven directamente desde la caché, y las respuestas obsoletas se revalidan antes de ser servidas.</p>
    <p><codeinline>"no-store"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor hace que el navegador ignore su caché. La caché no se comprueba en busca de coincidencias cuando se realiza la solicitud y no se actualiza cuando llega la respuesta.</p>
    <p><codeinline>"reload"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor indica al navegador que realice siempre una petición de red normal, ignorando la caché. Sin embargo, cuando llega la respuesta, se almacena en la caché.</p>
    <p><codeinline>"no-cache"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este (engañosamente llamado) valor le dice al navegador que no sirva valores frescos de la caché. Los valores frescos o antiguos de la caché se revalidan antes de ser devueltos.</p>
    <p><codeinline>"force-cache"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor indica al navegador que sirva las respuestas de la caché aunque estén obsoletas.</p>
    <p><codeinline>redirect</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9"> Esta propiedad controla cómo maneja el navegador las respuestas de redirección del servidor. Los tres valores legales son:</p>
    <p><codeinline>"follow"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este es el valor por defecto, y hace que el navegador siga las redirecciones automáticamente. Si utiliza este valor por defecto, los objetos Response que obtenga con <codeinline>fetch()</codeinline> nunca deberían tener un <codeinline>status</codeinline> en el rango 300 a 399.</p>
    <p><codeinline>"error"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor hace que <codeinline>fetch()</codeinline> rechace su Promise devuelta si el servidor devuelve una respuesta de redirección.</p>
    <p><codeinline>"manual"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor significa que usted quiere manejar manualmente las respuestas de redirección, y la Promesa devuelta por <codeinline>fetch()</codeinline> puede resolver a un objeto Respuesta con un <codeinline>status</codeinline> en el rango 300 a 399. En este caso, tendrá que utilizar la cabecera "Location" de la Respuesta para seguir manualmente la redirección.</p>
    <p><codeinline>referrer</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Puede establecer esta propiedad a una cadena que contenga una URL relativa para especificar el valor de la cabecera HTTP "Referer" (que históricamente se escribe mal con tres erres en lugar de cuatro). Si establece esta propiedad a una cadena vacía, la cabecera "Referer" se omitirá en la petición.</p>
  </section>
  <section id="11-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11.2 Eventos enviados por el servidor</h2>
    <p>Una característica fundamental del protocolo HTTP en el que se basa la web es que los clientes inician las peticiones y los servidores responden a ellas. Sin embargo, a algunas aplicaciones web les resulta útil que el servidor les envíe notificaciones cuando se producen eventos. Esto no es algo natural en HTTP, pero la técnica que se ha ideado es que el cliente haga una petición al servidor y luego ni el cliente ni el servidor cierren la conexión. Cuando el servidor tiene algo que comunicar al cliente, escribe datos en la conexión pero la mantiene abierta. El efecto es como si el cliente hiciera una petición a la red y el servidor respondiera de forma lenta y a ráfagas, con pausas significativas entre las ráfagas de actividad. Las conexiones de red de este tipo no suelen permanecer abiertas para siempre, pero si el cliente detecta que la conexión se ha cerrado, puede simplemente hacer otra petición para reabrir la conexión.</p>
    <p>Esta técnica para permitir que los servidores envíen mensajes a los clientes es sorprendentemente eficaz (aunque puede ser costosa en el lado del servidor porque éste debe mantener una conexión activa con todos sus clientes). Dado que es un patrón de programación útil, JavaScript del lado del cliente lo soporta con la API EventSource. Para crear este tipo de conexión de petición de larga duración a un servidor web, simplemente pasa una URL al constructor <codeinline>EventSource()</codeinline>. Cuando el servidor escribe datos (con el formato adecuado) en la conexión, el objeto EventSource los traduce en eventos que puedes escuchar:</p>
    <pre class="language-js">
    <code class="language-js">let ticker = new EventSource("stockprices.php");
    ticker.addEventListener("bid", (event) => &lbrace;
      displayNewBid(event.data);
    }</code></pre>
    <p>El objeto de evento asociado con un evento de mensaje tiene una propiedad <codeinline>data</codeinline> que contiene la cadena que el servidor envió como carga útil para este evento. El objeto evento también tiene una propiedad <codeinline>type</codeinline>, como todos los objetos evento, que especifica el nombre del evento. El servidor determina el tipo de los eventos que se generan. Si el servidor omite un nombre de evento en los datos que escribe, entonces el tipo de evento por defecto es "mensaje".</p>
    <p>El protocolo Server-Sent Event es sencillo. El cliente inicia una conexión con el servidor (cuando crea el objeto <codeinline>EventSource</codeinline>), y el servidor mantiene esta conexión abierta. Cuando ocurre un evento, el servidor escribe líneas de texto en la conexión. Si se omitieran los comentarios, un evento transmitido por cable podría tener este aspecto:</p>
    <pre class="language-js">
    event: bid // sets the type of the event object
    data: GOOG // sets the data property
    data: 999  // appends a newline and more data
               // a blank line marks the end of the event</pre>
    <p>Existen algunos detalles adicionales en el protocolo que permiten asignar identificadores a los eventos y que permiten a un cliente que se vuelve a conectar indicar al servidor el identificador del último evento que recibió, de modo que el servidor pueda volver a enviar los eventos que se haya perdido. Sin embargo, estos detalles son invisibles para el cliente y no se tratan aquí.</p>
    <p>Una aplicación obvia para los Eventos Enviados por el Servidor es para colaboraciones multiusuario como el chat online. Un cliente de chat puede usar <codeinline>fetch()</codeinline> para enviar mensajes a la sala de chat y suscribirse al flujo de conversaciones con un objeto EventSource. El <a href="#ejemplo15-11">Ejemplo 15-11</a> demuestra lo fácil que es escribir un cliente de chat como este con EventSource.</p>
    <p><em>Ejemplo 15-11. Un cliente de chat simple usando EventSource</em></p>
    <pre class="language-js">
    <code class="language-js">&lt;html>
    &lt;head>&lt;title>SSE Chat&lt;/title>&lt;/head>
    &lt;body>
    &lt;!-- The chat UI is just a single text input field -->
    &lt;!-- New chat messages will be inserted before this input field -->
    &lt;input id="input" style="width:100%; padding:10px; border:solid black 2px"/>
    &lt;script>
    // Take care of some UI details
    let nick = prompt("Enter your nickname");     // Get user's nickname
    let input = document.getElementById("input"); // Find the input field
    input.focus();                                // Set keyboard focus

    // Register for notification of new messages using EventSource
    let chat = new EventSource("/chat");
    chat.addEventListener("chat", event => &lbrace;   // When a chat message arrives
      let div = document.createElement("div"); // Create a &lt;div>
      div.append(event.data);       // Add text from the message
      input.before(div);            // And add div before input
      input.scrollIntoView();       // Ensure input elt is visible
    });

    // Post the user's messages to the server using fetch
    input.addEventListener("change", ()=>&lbrace; // When the user strikes return
      fetch("/chat", &lbrace;                     // Start an HTTP request to this url.
        method: "POST",                    // Make it a POST request with body
        body: nick + ": " + input.value    // set to the user's nick and input.
      })
      .catch(e => console.error); // Ignore response, but log any errors.
      input.value = "";           // Clear the input
    });
    &lt;/script>
    &lt;/body>
    &lt;/html></code></pre>
    <p>El código del lado del servidor para este programa de chat no es mucho más complicado que el código del lado del cliente. El <a href="#ejemplo15-12">Ejemplo 15-12</a> es un simple servidor HTTP Node. Cuando un cliente solicita la URL raíz "/", envía el código de cliente de chat mostrado en el <a href="#ejemplo15-11">Ejemplo 15-11</a>. Cuando un cliente hace una petición GET para la URL "/chat", guarda el objeto respuesta y mantiene esa conexión abierta. Y cuando un cliente hace una petición POST a "/chat", usa el cuerpo de la petición como un mensaje de chat y lo escribe, usando el formato "text/event-stream" a cada uno de los objetos de respuesta guardados. El código del servidor escucha en el puerto 8080, así que después de ejecutarlo con Node, apunta tu navegador a <codeinline>http://localhost:8080</codeinline> para conectarte y empezar a chatear contigo mismo.</p>
    <p><em>Ejemplo 15-12. Un servidor de chat de Eventos Enviados por el Servidor</em></p>
    <pre class="language-js">
    <code class="language-js">// This is server-side JavaScript, intended to be run with NodeJS.
    // It implements a very simple, completely anonymous chat room.
    // POST new messages to /chat, or GET a text/event-stream of messages
    // from the same URL. Making a GET request to / returns a simple HTML file
    // that contains the client-side chat UI.
    const http = require("http");
    const fs = require("fs");
    const url = require("url");

    // The HTML file for the chat client. Used below.
    const clientHTML = fs.readFileSync("chatClient.html");

    // An array of ServerResponse objects that we're going to send events to
    let clients = [];
    
    // Create a new server, and listen on port 8080.
    // Connect to http://localhost:8080/ to use it.
    let server = new http.Server();
    server.listen(8080);
    
    // When the server gets a new request, run this function
    server.on("request", (request, response) => &lbrace;
      // Parse the requested URL
      let pathname = url.parse(request.url).pathname;
      
      // If the request was for "/", send the client-side chat UI.
      if (pathname === "/") &lbrace; // A request for the chat UI
        response.writeHead(200, &lbrace;"Content-Type": "text/html"}).end(clientHTML);
      }
      // Otherwise send a 404 error for any path other than "/chat" or for
      // any method other than "GET" and "POST"
      else if (pathname !== "/chat" ||
            (request.method !== "GET" && request.method !== "POST")) &lbrace;
        response.writeHead(404).end();
      }
      // If the /chat request was a GET, then a client is connecting.
      else if (request.method === "GET") &lbrace;
        acceptNewClient(request, response);
      }
      // Otherwise the /chat request is a POST of a new message
      else &lbrace;
        broadcastNewMessage(request, response);
      }
    });

    // This handles GET requests for the /chat endpoint which are generated when
    // the client creates a new EventSource object (or when the EventSource
    // reconnects automatically).
    function acceptNewClient(request, response) &lbrace;
      // Remember the response object so we can send future messages to it
      clients.push(response);

      // If the client closes the connection, remove the corresponding
      // response object from the array of active clients
      request.connection.on("end", () => &lbrace;
        clients.splice(clients.indexOf(response), 1);
        response.end();
      });

      // Set headers and send an initial chat event to just this one client
      response.writeHead(200, &lbrace;
        "Content-Type": "text/event-stream",
        "Connection": "keep-alive",
        "Cache-Control": "no-cache"
      });
      response.write("event: chat\ndata: Connected\n\n");

      // Note that we intentionally do not call response.end() here.
      // Keeping the connection open is what makes Server-Sent Events work.
    }

    // This function is called in response to POST requests to the /chat endpoint
    // which clients send when users type a new message.
    async function broadcastNewMessage(request, response) &lbrace;
      // First, read the body of the request to get the user's message
      request.setEncoding("utf8");
      let body = "";
      for await (let chunk of request) &lbrace;
        body += chunk;
      }

      // Once we've read the body send an empty response and close the connection
      response.writeHead(200).end();

      // Format the message in text/event-stream format, prefixing each
      // line with "data: "
      let message = "data: " + body.replace("\n", "\ndata: ");

      // Give the message data a prefix that defines it as a "chat" event
      // and give it a double newline suffix that marks the end of the event.
      let event = `event: chat\n$&lbrace;message}\n\n`;

      // Now send this event to all listening clients
      clients.forEach(client => client.write(event));
    }</code></pre>
  </section>
  <section id="11-3">
    <h2>15.11.3 WebSockets</h2>
    <p>La API WebSocket es una interfaz sencilla para un complejo y potente protocol de red. Los WebSockets permiten al código JavaScript del navegador intercambiar fácilmente mensajes de texto y binarios con un servidor. Al igual que con los eventos enviados por el servidor, el cliente debe establecer la conexión, pero una vez establecida, el servidor puede enviar mensajes al cliente de forma asíncrona. A diferencia de SSE, los mensajes binarios están soportados, y los mensajes pueden ser enviados en ambas direcciones, no sólo de servidor a cliente.</p>
    <p>El protocolo de red que permite WebSockets es una especie de extensión de HTTP. Aunque la API WebSocket recuerda a los sockets de red de bajo nivel, los puntos finales de conexión no se identifican por dirección IP y puerto. En su lugar, cuando se quiere conectar a un servicio mediante el protocolo WebSocket, se especifica el servicio con una URL, igual que se haría con un servicio web. Sin embargo, las URL de WebSocket empiezan por <codeinline>wss://</codeinline> en lugar de <codeinline>https://</codeinline>. (Los navegadores suelen restringir los WebSockets para que sólo funcionen en páginas cargadas a través de conexiones seguras <codeinline>https://</codeinline>).</p>
    <p>Para establecer una conexión WebSocket, el navegador establece primero una conexión HTTP y envía al servidor una cabecera <codeinline>Upgrade: websocket</codeinline> solicitando que la conexión pase del protocolo HTTP al protocolo WebSocket. Lo que esto significa es que para utilizar WebSockets en su JavaScript del lado del cliente, necesitará trabajar con un servidor web que también hable el protocolo WebSocket, y necesitará tener código del lado del servidor escrito para enviar y recibir datos utilizando ese protocolo. Si tu servidor está configurado de esta manera, entonces esta sección explicará todo lo que necesitas saber para manejar el lado cliente de la conexión. Si su servidor no soporta el protocolo WebSocket, considere usar Eventos Enviados por el Servidor (<a href="#11-2">§15.11.2</a>) en su lugar.</p>
    <p class="title-article text-left">Creación, conexión y desconexión de WebSockets</p>
    <p>Si desea comunicarse con un servidor habilitado para WebSocket, cree un objeto WebSocket, especificando la URL <codeinline>wss://</codeinline> que identifica el servidor y el servicio que desea utilizar:</p>
    <pre class="language-js">
    <code class="language-js">let socket = new WebSocket("wss://example.com/stockticker");</code></pre>
    <p>Cuando se crea un WebSocket, el proceso de conexión comienza automáticamente. Pero un WebSocket recién creado no se conectará cuando se devuelva por primera vez.</p>
    <p>La propiedad <codeinline>readyState</codeinline> del socket especifica en qué estado se encuentra la conexión. Esta propiedad puede tener los siguientes valores:</p>
    <p><codeinline>WebSocket.CONNECTING</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket se está conectando.</p>
    <p><codeinline>WebSocket.OPEN</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket está conectado y listo para la comunicación.</p>
    <p><codeinline>WebSocket.CLOSING</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta conexión WebSocket se está cerrando.</p>
    <p><codeinline>WebSocket.CLOSED</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket se ha cerrado; no es posible ninguna otra comunicación. Este estado también puede ocurrir cuando falla el intento de conexión inicial.</p>
    <p>Cuando un WebSocket pasa del estado CONNECTING al estado OPEN, lanza un evento "open", y usted puede escuchar este evento estableciendo la propiedad <codeinline>onopen</codeinline> del WebSocket o llamando a <codeinline>addEventListener()</codeinline> en ese objeto.</p>
    <p>Si se produce un error de protocolo o de otro tipo en una conexión WebSocket, el objeto WebSocket lanza un evento "error". Puede definir un controlador con onerror o, alternativamente, utilizar addEventListener().</p>
    <p>Cuando haya terminado con un WebSocket, puede cerrar la conexión llamando al método <codeinline>close()</codeinline> del objeto WebSocket. Cuando un WebSocket cambia al estado CERRADO, dispara un evento "close", y puedes establecer la propiedad <codeinline>onclose</codeinline> para escuchar este evento.</p>
    <p class="title-article text-left">Envío de mensajes a través de un WebSocket</p>
    <p>Para enviar un mensaje al servidor en el otro extremo de una conexión WebSocket, simplemente invoque el método <codeinline>send()</codeinline> del objeto WebSocket. <codeinline>send()</codeinline> espera un único argumento de mensaje, que puede ser una cadena, Blob, ArrayBuffer, matriz tipada u objeto DataView.</p>
    <p>El método <codeinline>send()</codeinline> almacena en búfer el mensaje especificado que se va a transmitir y devuelve antes de que el mensaje se envíe realmente. La propiedad <codeinline>bufferedAmount</codeinline> del objeto WebSocket especifica el número de bytes que están almacenados en el buffer pero que aún no han sido enviados. (Sorprendentemente, los WebSockets no disparan ningún evento cuando este valor llega a 0).</p>
    <p class="title-article text-left">Recepción de mensajes de un WebSocket</p>
    <p>Para recibir mensajes de un servidor a través de un WebSocket, registre un manejador de eventos para los eventos "message" de , bien estableciendo la propiedad <codeinline>onmessage</codeinline> del objeto WebSocket, bien llamando a <codeinline>addEventListener()</codeinline>. El objeto asociado a un evento "message" es una instancia de MessageEvent con una propiedad <codeinline>data</codeinline> que contiene el mensaje del servidor. Si el servidor envió texto codificado en UTF-8, entonces <codeinline>event.data</codeinline> será una cadena conteniendo ese texto.</p>
    <p>Si el servidor envía un mensaje que consiste en datos binarios en lugar de texto, entonces la propiedad <codeinline>data</codeinline> será (por defecto) un objeto Blob representando esos datos. Si prefiere recibir mensajes binarios como ArrayBuffers en lugar de Blobs, establezca la propiedad <codeinline>binaryType</codeinline> del objeto WebSocket a la cadena "arraybuffer".</p>
    <p>Existen varias APIs Web que utilizan objetos MessageEvent para el intercambio de mensajes. Algunas de estas APIs utilizan el algoritmo del clon estructurado (ver <a href="#algoritmo-clon-estructurado">"El Algoritmo del Clon Estructurado"</a> ) para permitir estructuras de datos complejas como carga de mensajes. WebSockets no es una de esas APIs: los mensajes intercambiados a través de un WebSocket son una única cadena de caracteres Unicode o una única cadena de bytes (representada como un Blob o un ArrayBuffer).</p>
    <p class="title-article text-left">Negociación de protocolos</p>
    <p>El protocolo WebSocket permite el intercambio de mensajes de texto y binarios, pero no dice nada en absoluto sobre la estructura o el significado de esos mensajes. Las aplicaciones que utilizan WebSockets deben construir su propio protocolo de comunicación sobre este sencillo mecanismo de intercambio de mensajes. El uso de URLs <codeinline>wss://</codeinline> ayuda con esto: cada URL tendrá típicamente sus propias reglas sobre cómo deben intercambiarse los mensajes. Si escribes código para conectarte a <codeinline>wss://ejemplo.com/stockticker</codeinline>, entonces probablemente sepas que vas a recibir mensajes sobre los precios de las acciones.</p>
    <p>Sin embargo, los protocolos tienden a evolucionar. Si se actualiza un protocolo hipotético de cotización de acciones, puede definir una nueva URL y conectarse al servicio actualizado como <codeinline>wss://example.com/stockticker/v2</codeinline>. Sin embargo, el versionado basado en URL no siempre es suficiente. Con protocolos complejos que han evolucionado con el tiempo, es posible que acabe con servidores desplegados que admiten varias versiones del protocolo y clientes desplegados que admiten un conjunto diferente de versiones del protocolo.</p>
    <p>Anticipándose a esta situación, el protocolo WebSocket y la API incluyen una función de negociación de protocolo a nivel de aplicación. Cuando se llama al constructor <codeinline>WebSocket()</codeinline>, la URL <codeinline>wss://</codeinline> es el primer argumento, pero también se puede pasar una matriz de cadenas como segundo argumento. Si hace esto, está especificando una lista de protocolos de aplicación que sabe cómo manejar y pidiendo al servidor que elija uno. Durante el proceso de conexión, el servidor elegirá uno de los protocolos (o fallará con un error si no soporta alguna de las opciones del cliente). Una vez establecida la conexión, la propiedad <codeinline>protocol</codeinline> del objeto WebSocket especifica qué versión de protocolo ha elegido el servidor .</p>
  </section>
  <section id="12" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12 Almacenamiento</h2>
    <p>Las aplicaciones web pueden utilizar las API del navegador para almacenar datos localmente en el ordenador del usuario. Este almacenamiento del lado del cliente sirve para dotar al navegador web de memoria. Las aplicaciones web pueden almacenar las preferencias del usuario, por ejemplo, o incluso guardar su estado completo, de modo que puedan reanudar la navegación exactamente donde la dejó al final de su última visita. El almacenamiento del lado del cliente está segregado por origen, de modo que las páginas de un sitio no pueden leer los datos almacenados por las páginas de otro sitio. Pero dos páginas del mismo sitio pueden compartir el almacenamiento y utilizarlo como mecanismo de comunicación. Por ejemplo, los datos introducidos en un formulario de una página pueden mostrarse en una tabla de otra página. Las aplicaciones web pueden elegir el tiempo de vida de los datos que almacenan: los datos pueden almacenarse temporalmente para que sólo se conserven hasta que se cierre la ventana o salga el navegador, o pueden guardarse en el ordenador del usuario y almacenarse de forma permanente para que estén disponibles meses o años después.</p>
    <p>Existen varias formas de almacenamiento del lado del cliente:</p>
    <p><em>Almacenamiento web</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La API de Almacenamiento Web consiste en los objetos <codeinline>localStorage</codeinline> y <codeinline>sessionStorage</codeinline>, que son esencialmente objetos persistentes que asignan claves de cadena a valores de cadena. Web Storage es muy fácil de usar y resulta adecuado para almacenar grandes (pero no enormes) cantidades de datos.</p>
    <p><em>Cookies</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Las cookies son un viejo mecanismo de almacenamiento del lado del cliente que fue diseñado para ser utilizado por scripts del lado del servidor. Una complicada API de JavaScript hace que las cookies se puedan utilizar en el cliente, pero son difíciles de usar y sólo sirven para almacenar pequeñas cantidades de datos textuales. Además, cualquier dato almacenado como cookie se transmite siempre al servidor con cada petición HTTP, incluso si los datos sólo interesan al cliente.</p>
    <p><em>IndexedDB</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">IndexedDB es una API asíncrona para una base de datos de objetos que admite indexación.</p>
    <article>
      <p class="title-article">Almacenamiento, seguridad y privacidad</p>
      <p>Los navegadores web a menudo ofrecen recordar las contraseñas web por ti, y las almacenan de forma segura y encriptada en el dispositivo. Pero ninguna de las formas de almacenamiento de datos del lado del cliente descritas en este capítulo implica cifrado: debes asumir que cualquier cosa que tus aplicaciones web guarden reside en el dispositivo del usuario de forma no cifrada. Por lo tanto, los datos almacenados son accesibles a usuarios curiosos que compartan el acceso al dispositivo y a software malicioso (como spyware) que exista en el dispositivo. Por esta razón, nunca se debe utilizar ninguna forma de almacenamiento del lado del cliente para contraseñas, números de cuentas financieras u otra información sensible similar.</p>
    </article>
  </section>
  <section id="12-1">
    <h2>15.12.1 localStorage y sessionStorage</h2>
    <p>Las propiedades <codeinline>localStorage</codeinline> y <codeinline>sessionStorage</codeinline> del objeto Window hacen referencia a objetos Storage. Un objeto Storage se comporta de forma muy similar a un objeto JavaScript normal, con la salvedad de que:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los valores de las propiedades de los objetos Storage deben ser cadenas.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las propiedades almacenadas en un objeto Storage persisten. Si establece una propiedad del objeto local- Storage y luego el usuario recarga la página, el valor que guardó en esa propiedad sigue estando disponible para su programa.
        </p>
      </li>
    </ul>
    <p>Por ejemplo, puedes utilizar el objeto localStorage de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">let name = localStorage.username;      // Query a stored value.
    if (!name) &lbrace;
      name = prompt("What is your name?"); // Ask the user a question.
      localStorage.username = name;        // Store the user's response.
    }</code></pre>
    <p>Puede utilizar el operador <codeinline>delete</codeinline> para eliminar propiedades de <codeinline>localStorage</codeinline> y <codeinline>sessionStorage</codeinline>, y puede utilizar un bucle <codeinline>for/in</codeinline> o <codeinline>Object.keys()</codeinline> para enumerar las propiedades de un objeto Storage. Si desea eliminar todas las propiedades de un objeto Storage, llame al método <codeinline>clear()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">localStorage.clear();</code></pre>
    <p>Los objetos de almacenamiento también definen los métodos <codeinline>getItem()</codeinline>, <codeinline>setItem()</codeinline> y <codeinline>deleteItem()</codeinline>, que puede utilizar en lugar del acceso directo a propiedades y el operador <codeinline>delete</codeinline> si lo desea.</p>
    <p>Tenga en cuenta que las propiedades de los objetos Storage sólo pueden almacenar cadenas. Si quieres almacenar y recuperar otro tipo de datos, tendrás que codificarlos y descodificarlos tú mismo.</p>
    <p>Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// If you store a number, it is automatically converted to a string.
    // Don't forget to parse it when retrieving it from storage.
    localStorage.x = 10;
    let x = parseInt(localStorage.x);

    // Convert a Date to a string when setting, and parse it when getting
    localStorage.lastRead = (new Date()).toUTCString();
    let lastRead = new Date(Date.parse(localStorage.lastRead));

    // JSON makes a convenient encoding for any primitive or data structure
    localStorage.data = JSON.stringify(data); // Encode and store
    let data = JSON.parse(localStorage.data); // Retrieve and decode.</code></pre>
    <p class="title-article text-left">Duración y alcance del almacenamiento</p>
    <p>La diferencia entre <codeinline>localStorage</codeinline> y <codeinline>sessionStorage</codeinline> tiene que ver con la duración y el alcance del almacenamiento. Los datos almacenados a través de <codeinline>localStorage</codeinline> son permanentes: no caducan y permanecen almacenados en el dispositivo del usuario hasta que una aplicación web los elimina o el usuario pide al navegador (a través de alguna interfaz de usuario específica del navegador) que los elimine.</p>
    <p><codeinline>localStorage</codeinline> se refiere al origen del documento. Como se explica en <a href="politica-del-mismo-origen">"La política del mismo origen"</a>, el origen de un documento se define por su protocolo, nombre de host y puerto. Todos los documentos con el mismo origen comparten los mismos datos de <codeinline>localStorage</codeinline> (independientemente del origen de los scripts que realmente acceden a <codeinline>localStorage</codeinline>). Pueden leer los datos de los demás, y pueden sobrescribir los datos de los demás. Pero los documentos con orígenes diferentes nunca pueden leer o sobrescribir los datos de los demás (incluso si ambos están ejecutando un script desde el mismo servidor de terceros).</p>
    <p>Tenga en cuenta que <codeinline>localStorage</codeinline> también depende de la implementación del navegador. Si visitas un sitio con Firefox y luego vuelves a visitarlo con Chrome (por ejemplo), los datos almacenados durante la primera visita no estarán accesibles durante la segunda.</p>
    <p>Los datos almacenados a través de <codeinline>sessionStorage</codeinline> tienen un tiempo de vida diferente al de los datos almacenados a través de <codeinline>localStorage</codeinline>: tienen el mismo tiempo de vida que la ventana de nivel superior o la pestaña del navegador en la que se está ejecutando el script que los almacenó. Cuando la ventana o pestaña se cierra permanentemente, cualquier dato almacenado a través de <codeinline>sessionStorage</codeinline> se borra. (Ten en cuenta, sin embargo, que los navegadores modernos tienen la capacidad de reabrir las pestañas cerradas recientemente y restaurar la última sesión de navegación, por lo que el tiempo de vida de estas pestañas y su <codeinline>sessionStorage</codeinline> asociado puede ser más largo de lo que parece).</p>
    <p>Al igual que <codeinline>localStorage</codeinline>, <codeinline>sessionStorage</codeinline> se asigna al origen del documento, de modo que documentos con orígenes diferentes nunca compartirán <codeinline>sessionStorage</codeinline>. Pero <codeinline>sessionStorage</codeinline> también se asigna a cada ventana. Si un usuario tiene dos pestañas en el navegador mostrando documentos del mismo origen, esas dos pestañas tienen datos <codeinline>sessionStorage</codeinline> separados: los scripts que se ejecutan en una pestaña no pueden leer o sobrescribir los datos escritos por los scripts en la otra pestaña, incluso si ambas pestañas están visitando exactamente la misma página y están ejecutando exactamente los mismos scripts.</p>
    <p class="title-article text-left">Eventos de almacenamiento</p>
    <p>Cada vez que los datos almacenados en <codeinline>localStorage</codeinline> cambian, el navegador dispara un evento "storage" en cualquier otro objeto Window al que esos datos sean visibles (pero no en el win- dow que hizo el cambio). Si un navegador tiene dos pestañas abiertas a páginas con el mismo origen, y una de esas páginas almacena un valor en <codeinline>localStorage</codeinline>, la otra pestaña recibirá un evento "storage".</p>
    <p>Registre un controlador para los eventos de "almacenamiento", ya sea estableciendo window.onstorage o llamando a <codeinline>window.addEventListener()</codeinline> con el tipo de evento "almacenamiento".</p>
    <p>El objeto de evento asociado a un evento "almacenamiento" tiene algunas propiedades importantes:</p>
    <p><codeinline>key</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nombre o la clave del elemento que se ha establecido o eliminado. Si se llamó al método <codeinline>clear()</codeinline>, esta propiedad será <codeinline>null</codeinline>.</p>
    <p><codeinline>newValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Contiene el nuevo valor del elemento, si existe. Si se ha llamado a <codeinline>removeItem()</codeinline>, esta propiedad no estará presente.</p>
    <p><codeinline>oldValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Mantiene el valor antiguo de un elemento existente que cambió o fue eliminado. Si se añade una nueva propiedad (sin valor antiguo), esta propiedad no estará presente en el objeto de evento.</p>
    <p><codeinline>storageArea</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El objeto Storage que ha cambiado. Suele ser el objeto <codeinline>localStorage</codeinline>.</p>
    <p><codeinline>url</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La URL (como cadena) del documento cuyo script realizó este cambio de almacenamiento.</p>
    <p>Tenga en cuenta que <codeinline>localStorage</codeinline> y el evento "storage" pueden servir como un mecanismo de difusión por el cual un navegador envía un mensaje a todas las ventanas que están visitando el mismo sitio web. Si un usuario solicita que un sitio web deje de realizar animaciones, por ejemplo, el sitio podría almacenar esa preferencia en <codeinline>localStorage</codeinline> para poder respetarla en futuras visitas. Y al almacenar la preferencia, genera un evento que permite a otras ventanas que muestren el mismo sitio web respetar también la petición.</p>
    <p>Como otro ejemplo, imagine una aplicación web de edición de imágenes que permite al usuario mostrar paletas de herramientas en ventanas separadas. Cuando el usuario selecciona una herramienta, la aplicación utiliza <codeinline>localStorage</codeinline> para guardar el estado actual y generar una notificación a otras ventanas de que se ha seleccionado una nueva herramienta.</p>
  </section>
  <section id="12-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12.2 Cookies</h2>
    <p>Una <em>cookie</em> es una pequeña cantidad de datos almacenados por el navegador y asociados a una página o sitio web concreto. Las cookies se diseñaron para la programación del lado del servidor y, en el nivel más bajo, se implementan como una extensión del protocolo HTTP. Los datos de las cookies se transmiten automáticamente entre el navegador y el servidor web, por lo que los scripts del lado del servidor pueden leer y escribir valores de cookies almacenados en el cliente. Esta sección demuestra cómo los scripts del lado del cliente también pueden manipular cookies utilizando la propiedad <codeinline>cookie</codeinline> del objeto Document.</p>
    <article>
      <p class="title-article">¿Por qué "Cookie"?</p>
      <p>El nombre "cookie" no tiene mucho significado, pero no se utiliza sin premeditación. En los anales de la historia de la informática, el término "cookie" o "cookie mágica" se ha utilizado para referirse a un pequeño fragmento de datos, en particular un fragmento de datos privilegiados o secretos, similares a una contraseña, que prueban la identidad o permiten el acceso. En JavaScript, las cookies se utilizan para guardar el estado y pueden establecer una especie de identidad para un navegador web. Las cookies en JavaScript no utilizan ningún tipo de criptografía, sin embargo, y no son seguras de ninguna manera (aunque transmitirlas a través de una conexión <codeinline>https:</codeinline> ayuda).</p>
    </article>
    <p>La API para manipular cookies es antigua y críptica. No hay métodos implicados: las <codeinline>cookies</codeinline> se consultan, establecen y eliminan leyendo y escribiendo la propiedad cookie del objeto Document utilizando cadenas con un formato especial. El tiempo de vida y el alcance de cada cookie pueden especificarse individualmente con atributos de cookie. Estos atributos también se especifican con cadenas especialmente formateadas en la misma propiedad <codeinline>cookies</codeinline>.</p>
    <p>Las subsecciones siguientes explican cómo consultar y establecer los valores y atributos de las cookies.</p>
    <p class="title-article text-left">Galletas de lectura</p>
    <p>Cuando se lee la propiedad <codeinline>document.cookie</codeinline>, devuelve una cadena que contiene todas las cookies que se aplican al documento actual. La cadena es una lista de pares nombre/valor separados entre sí por un punto y coma y un espacio. El valor de la cookie es sólo el valor en sí mismo y no incluye ninguno de los atributos que puedan estar asociados a esa cookie. (Hablaremos de los atributos más adelante.) Para hacer uso de la propiedad <codeinline>document.cookie</codeinline>, normalmente debe llamar al método <codeinline>split()</codeinline> para dividirla en pares nombre/valor individuales.</p>
    <p>Una vez que haya extraído el valor de una cookie de la propiedad <codeinline>cookie</codeinline>, debe interpretar ese valor basándose en cualquier formato o codificación que haya utilizado el creador de la cookie. Por ejemplo, puede pasar el valor de la cookie a <codeinline>decodeURIComponent()</codeinline> y luego a <codeinline>JSON.parse()</codeinline>.</p>
    <p>El código que sigue define una función <codeinline>getCookie()</codeinline> que analiza la propiedad <codeinline>document.cookie</codeinline> y devuelve un objeto cuyas propiedades especifican los nombres y valores de las cookies del documento:</p>
    <pre class="language-js">
    <code class="language-js">// Return the document's cookies as a Map object.
    // Assume that cookie values are encoded with encodeURIComponent().
    function getCookies() &lbrace;
      let cookies = new Map();      // The object we will return
      let all = document.cookie;    // Get all cookies in one big string
      let list = all.split("; ");   // Split into individual name/value pairs
      for(let cookie of list) &lbrace;              // For each cookie in that list
        if (!cookie.includes("=")) continue; // Skip if there is no = sign
        let p = cookie.indexOf("=");         // Find the first = sign
        let name = cookie.substring(0, p);   // Get cookie name
        let value = cookie.substring(p+1);   // Get cookie value
        value = decodeURIComponent(value);   // Decode the value
        cookies.set(name, value);            // Remember cookie name and value
      }
      return cookies;
    }</code></pre>
    <p class="title-article text-left">Galletas de lectura</p>
    <p>Atributos de las cookies: vida útil y alcance</p>
    <p>Además de un nombre y un valor, cada cookie tiene atributos opcionales que controlan su duración y alcance. Antes de describir cómo establecer cookies con JavaScript, debemos explicar los atributos de las cookies.</p>
    <p>Las cookies son transitorias por defecto; los valores que almacenan duran lo que dura la sesión del navegador web, pero se pierden cuando el usuario sale del navegador. Si desea que una cookie dure más allá de una única sesión de navegación, debe indicar al navegador cuánto tiempo (en segundos) desea que retenga la cookie especificando un atributo <codeinline>max-age</codeinline>. Si especifica un tiempo de vida, el navegador almacenará las cookies en un archivo y las borrará sólo cuando caduquen.</p>
    <p>La visibilidad de las cookies está determinada por el origen del documento, como ocurre con <codeinline>localStorage</codeinline> y <codeinline>sessionStorage</codeinline>, pero también por la ruta del documento. Este ámbito es configurable a través de los atributos de cookie <codeinline>path</codeinline> y <codeinline>domain</codeinline>. Por defecto, una cookie está asociada con, y accesible a, la página web que la creó y cualquier otra página web en el mismo directorio o cualquier subdirectorio de ese directorio. Si la página web <em>example.com/catalog/index.html</em> crea una cookie, por ejemplo, esa cookie también es visible para <em>example.com/catalog/order.html</em> y <em>exam.com/catalog/widgets/index.html</em>, pero no es visible para <em>example.com/about.html</em>.</p>
    <p>Este comportamiento de visibilidad por defecto es a menudo exactamente lo que usted desea. A veces, sin embargo, querrá utilizar los valores de las cookies en todo el sitio web, independientemente de la página que cree la cookie. Por ejemplo, si el usuario introduce su dirección de correo en un formulario de una página, es posible que desee guardar esa dirección para utilizarla como predeterminada la próxima vez que vuelva a la página y también como predeterminada en un formulario no relacionado de otra página en el que se le pida que introduzca una dirección de facturación. Para permitir este uso, especifique una <codeinline>path</codeinline> para la cookie. Entonces, cualquier página web del mismo servidor web cuya URL comience con el prefijo de ruta que ha especificado puede compartir la cookie. Por ejemplo, si una cookie establecida por <em>example.com/catalog/widgets/index.html</em> tiene su ruta establecida en "/catalog", esa cookie también es visible para <em>example.com/catalog/order.html</em>. O, si la ruta se establece en "/", la cookie es visible para cualquier página en el dominio <em>example.com</em>, dando a la cookie un alcance como el de <codeinline>localStorage</codeinline>.</p>
    <p>Por defecto, las cookies se clasifican según el origen del documento. Sin embargo, los sitios web grandes pueden querer que las cookies se compartan entre subdominios. Por ejemplo, el servidor de <em>order.example.com</em> puede necesitar leer valores de cookies establecidos desde <em>catalog.example.com</em>. Aquí es donde entra en juego el atributo de <codeinline>dominio</codeinline>. Si una cookie creada por una página en <em>catalog.example.com</em> establece su atributo <codeinline>path</codeinline> en "/" y su atributo domain en ".example.com", esa cookie estará disponible para todas las páginas web en <em>catalog.example.com</em>, <em>pedidos.example.com</em> y cualquier otro servidor en el dominio <em>example.com</em>. Tenga en cuenta que no puede establecer el dominio de una cookie en un dominio que no sea el dominio principal de su servidor.</p>
    <p>El último atributo de las cookies es un atributo booleano llamado <codeinline>secure</codeinline> que especifica cómo se transmiten los valores de las cookies a través de la red. Por defecto, las cookies son inseguras, lo que significa que se transmiten a través de una conexión HTTP normal e insegura. Sin embargo, si una cookie está marcada como segura, sólo se transmite cuando el navegador y el servidor están conectados a través de HTTPS u otro protocolo seguro.</p>
    <article>
      <p class="title-article">Limitaciones de las cookies</p>
      <p>Las cookies están pensadas para almacenar pequeñas cantidades de datos mediante scripts en el servidor, y esos datos se transfieren al servidor cada vez que se solicita una URL relevante. La norma que define las cookies anima a los fabricantes de navegadores a permitir un número ilimitado de cookies de tamaño ilimitado, pero no exige que los navegadores retengan más de 300 cookies en total, 20 cookies por servidor web o 4 KB de datos por cookie (tanto el nombre como el valor cuentan para este límite de 4 KB). En la práctica, los navegadores permiten muchas más de 300 cookies en total, pero es posible que algunos sigan aplicando el límite de 4 KB.</p>
    </article>
    <p class="title-article text-left">Almacenar cookies</p>
    <p>Para asociar un valor de cookie transitorio al documento actual, basta con establecer la <codeinline>cookie</codeinline> el parámetro a una cadena <codeinline>name=value</codeinline>. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">document.cookie = `version=$&lbrace;encodeURIComponent(document.lastModified)}`;</code></pre>
    <p>La próxima vez que lea la propiedad <codeinline>cookie</codeinline>, el par nombre/valor almacenado se incluirá en la lista de cookies del documento. Los valores de las cookies no pueden incluir puntos y comas ni espacios en blanco. Por esta razón, es posible que desee utilizar la función global del núcleo Java Script <codeinline>encodeURIComponent()</codeinline> para codificar el valor antes de almacenarlo en la cookie. Si hace esto, tendrá que usar la función correspondiente <codeinline>decodeURIComponent()</codeinline> cuando lea el valor de la cookie.</p>
    <p>Una cookie escrita con un simple par nombre/valor dura toda la sesión de navegación actual, pero se pierde cuando el usuario sale del navegador. Para crear una cookie que pueda durar a través de las sesiones del navegador, especifique su tiempo de vida (en segundos) con un atributo <codeinline>max-age</codeinline>. Puede hacer esto estableciendo la propiedad <codeinline>cookie</codeinline> a una cadena de la forma: <codeinline>name=value; max-age=seconds</codeinline>. La siguiente función establece una cookie con un atributo opcional <codeinline>max-age</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Store the name/value pair as a cookie, encoding the value with
    // encodeURIComponent() in order to escape semicolons, commas, and spaces.
    // If daysToLive is a number, set the max-age attribute so that the cookie
    // expires after the specified number of days. Pass 0 to delete a cookie.
    function setCookie(name, value, daysToLive=null) &lbrace;
      let cookie = `$&lbrace;name}=$&lbrace;encodeURIComponent(value)}`;
      if (daysToLive !== null) &lbrace;
        cookie += `; max-age=$&lbrace;daysToLive*60*60*24}`;
      }
      document.cookie = cookie;
    }</code></pre>
    <p>De forma similar, puede establecer los atributos de <codeinline>path</codeinline> y <codeinline>domain</codeinline> de una cookie añadiendo cadenas de la forma <codeinline>;path=value</codeinline> o <codeinline>;domain=value</codeinline> a la cadena que estableció en la propiedad document.cookie. Para establecer la propiedad <codeinline>secure</codeinline>, simplemente añada <codeinline>;secure</codeinline>.</p>
    <p>Para cambiar el valor de una cookie, establezca su valor de nuevo utilizando el mismo nombre, ruta y dominio junto con el nuevo valor. Puede cambiar el tiempo de vida de una cookie cuando cambie su valor especificando un nuevo atributo <codeinline>max-age</codeinline>.</p>
    <p>Para eliminar una cookie, configúrela de nuevo utilizando el mismo nombre, ruta y dominio, especificando un valor arbitrario (o vacío) y un atributo <codeinline>max-age</codeinline> de 0.</p>
  </section>
  <section id="12-3">
    <h2>15.12.3 IndexedDB</h2>
    <p>Tradicionalmente, la arquitectura de las aplicaciones web se ha basado en HTML, CSS y JavaScript en el cliente y una base de datos en el servidor. Por tanto, puede que te sorprenda saber que la plataforma web incluye una sencilla base de datos de objetos con una API JavaScript para almacenar de forma persistente objetos JavaScript en el ordenador del usuario y recuperarlos cuando sea necesario.</p>
    <p>IndexedDB es una base de datos de objetos, no una base de datos relacional, y es mucho más simple que las bases de datos que soportan consultas SQL. Sin embargo, es más potente, eficiente y robusta que el almacenamiento clave/valor proporcionado por <codeinline>localStorage</codeinline>. Al igual que el <codeinline>localStorage</codeinline>, las bases de datos IndexedDB tienen como ámbito el origen del documento que las contiene: dos páginas web con el mismo origen pueden acceder a los datos de la otra, pero las páginas web de orígenes diferentes no pueden.</p>
    <p>Cada origen puede tener cualquier número de bases de datos IndexedDB. Cada una tiene un nombre que debe ser único dentro del origen. En la API IndexedDB, una base de datos es simplemente una colección de <em>almacenes de objetos</em> con nombre. Como su nombre indica, un almacén de objetos almacena objetos. Los objetos se serializan en el almacén de objetos utilizando el algoritmo de clonación estructurada (véase <a href="#algoritmo-clon-estructurado">"El algoritmo de clonación estructurada"</a>), lo que significa que los objetos almacenados pueden tener propiedades cuyos valores sean Mapas, Conjuntos o matrices tipadas. Cada objeto debe tener una <em>clave</em> que permita ordenarlo y recuperarlo del almacén. Las claves deben ser únicas -dos objetos del mismo almacén no pueden tener la misma clave- y deben tener un orden natural para que puedan ordenarse. Cadenas, números y Los objetos de fecha son claves válidas. Una base de datos IndexedDB puede generar automáticamente una clave única para cada objeto que inserte en la base de datos. Sin embargo, a menudo los objetos que se insertan en un almacén de objetos ya tienen una propiedad que puede utilizarse como clave. En este caso, se especifica una "ruta de clave" para esa propiedad cuando se crea el almacén de objetos. Conceptualmente, una ruta de clave es un valor que indica a la base de datos cómo extraer la clave de un objeto.</p>
    <p>Además de recuperar objetos de un almacén de objetos por su valor de clave principal, es posible que desee poder buscar basándose en el valor de otras propiedades del objeto. Para poder hacer esto, puedes definir cualquier número de <em>índices</em> en el almacén de objetos. (La capacidad de indexar un almacén de objetos explica el nombre "IndexedDB".) Cada índice define una clave secundaria para los objetos almacenados. Estos índices no suelen ser únicos, y varios objetos pueden coincidir con un mismo valor de clave.</p>
    <p>IndexedDB ofrece garantías de atomicidad: las consultas y actualizaciones de la base de datos se agrupan dentro de una <em>transacción</em>, de modo que todas tienen éxito juntas o todas fallan juntas y nunca dejan la base de datos en un estado indefinido, parcialmente actualizado. Las transacciones en IndexedDB son más sencillas que en muchas API de bases de datos; volveremos a mencionarlas más adelante.</p>
    <p>Conceptualmente, la API IndexedDB es bastante sencilla. Para consultar o actualizar una base de datos, primero se abre la base de datos deseada (especificándola por su nombre). A continuación, se crea un objeto de transacción y se utiliza dicho objeto para buscar el almacén de objetos deseado dentro de la base de datos, también por su nombre. Por último, se busca un objeto llamando al método <codeinline>get()</codeinline> del almacén de objetos o se almacena un nuevo objeto llamando a <codeinline>put()</codeinline> (o llamando a <codeinline>add()</codeinline>, si se quiere evitar sobrescribir objetos existentes).</p>
    <p>Si desea buscar los objetos de un rango de claves, cree un objeto IDBRange que especifique los límites superior e inferior del rango y páselo a los métodos <codeinline>getAll()</codeinline> o <codeinline>openCursor()</codeinline> del almacén de objetos.</p>
    <p>Si desea realizar una consulta utilizando una clave secundaria, busque el índice con nombre del almacén de objetos y, a continuación, llame a los métodos <codeinline>get()</codeinline>, <codeinline>getAll()</codeinline> o <codeinline>openCursor()</codeinline> del objeto índice, pasándole una única clave o un objeto IDBRange.</p>
    <p>Esta simplicidad conceptual de la API IndexedDB se complica, sin embargo, por el hecho de que la API es asíncrona (para que las aplicaciones web puedan utilizarla sin bloquear el hilo principal de la interfaz de usuario del navegador). IndexedDB se definió antes de que las promesas estuvieran ampliamente soportadas, por lo que la API está basada en eventos en lugar de en promesas, lo que significa que no funciona con <codeinline>async</codeinline> y <codeinline>await</codeinline>.</p>
    <p>La creación de transacciones y la consulta de almacenes de objetos e índices son operaciones síncronas. Pero abrir una base de datos, actualizar un almacén de objetos y consultar un almacén o índice son operaciones asíncronas. Todos estos métodos asíncronos devuelven inmediatamente un objeto de petición. El navegador lanza un evento de éxito o error en el objeto request cuando la petición tiene éxito o falla, y puedes definir manejadores con las propiedades <codeinline>onsuccess</codeinline> y <codeinline>onerror</codeinline>. Dentro de un manejador <codeinline>onsuccess</codeinline>, el resultado de la operación está disponible como propiedad de <codeinline>result</codeinline> del objeto de solicitud. Otro evento útil es el evento "completo" que se envía a los objetos de transacción cuando una transacción se ha completado con éxito.</p>
    <p>Una característica conveniente de esta API asíncrona es que simplifica la gestión de transacciones. La API IndexedDB obliga a crear un objeto de transacción p a r a obtener el almacén de objetos sobre el que realizar consultas y actualizaciones. En una API sincrónica, se esperaría marcar explícitamente el final de la transacción llamando a un método <codeinline>commit()</codeinline>. Pero con IndexedDB, las transacciones se consignan automáticamente (si no se cancelan explícitamente) cuando todos los controladores de eventos <codeinline>onsuccess</codeinline> se han ejecutado y no hay más peticiones asíncronas pendientes que hagan referencia a esa transacción.</p>
    <p>Hay un evento más que es importante para la API de IndexedDB. Cuando abres una base de datos por primera vez, o cuando incrementas el número de versión de una base de datos existente, IndexedDB lanza un evento "upgradeneed" en el objeto request devuelto por la llamada <codeinline>indexedDB.open()</codeinline>. El trabajo del manejador de eventos "upgradeneeded" es definir o actualizar el esquema para la nueva base de datos (o la nueva versión de la base de datos existente). Para bases de datos IndexedDB, esto significa crear almacenes de objetos y definir índices en esos almacenes de objetos. De hecho, la única vez que la API IndexedDB permite crear un almacén de objetos o un índice es en respuesta a un evento "upgradenee- ded".</p>
    <p>Con esta visión general de IndexedDB en mente, debería ser capaz de entender el <a href="#ejemplo15-13">Ejemplo 15-13</a>. Este ejemplo utiliza IndexedDB para crear y consultar una base de datos que mapea los códigos postales de EE.UU. con las ciudades de EE.UU. Este ejemplo utiliza IndexedDB para crear y consultar una base de datos que mapea códigos postales de EE.UU. con ciudades de EE.UU. Demuestra muchas, aunque no todas, de las características básicas de IndexedDB. Demuestra muchas, pero no todas, las características básicas de IndexedDB. El <a href="#ejemplo15-13">Ejemplo 15-13</a> es largo, pero está bien comentado.</p>
    <p><em>Ejemplo 15-13. Una base de datos IndexedDB de códigos postales de EE.UU.</em></p>
    <pre class="language-js">
    <code class="language-js">// This utility function asynchronously obtains the database object (creating
    // and initializing the DB if necessary) and passes it to the callback.
    function withDB(callback) &lbrace;
      let request = indexedDB.open("zipcodes", 1); // Request v1 of the database
      request.onerror = console.error;             // Log any errors
      request.onsuccess = () => &lbrace; // Or call this when done
        let db = request.result;  // The result of the request is the database
        callback(db);             // Invoke the callback with the database
      };

      // If version 1 of the database does not yet exist, then this event
      // handler will be triggered. This is used to create and initialize
      // object stores and indexes when the DB is first created or to modify
      // them when we switch from one version of the DB schema to another.
      request.onupgradeneeded = () => &lbrace; initdb(request.result, callback); };
    }
    // withDB() calls this function if the database has not been initialized yet.
    // We set up the database and populate it with data, then pass the database to
    // the callback function.
    //
    // Our zip code database includes one object store that holds objects like this:
    //
    // &lbrace;
    // zipcode: "02134",
    // city: "Allston",
    // state: "MA",
    // }
    //
    // We use the "zipcode" property as the database key and create an index for
    // the city name.
    function initdb(db, callback) &lbrace;
      // Create the object store, specifying a name for the store and
      // an options object that includes the "key path" specifying the
      // property name of the key field for this store.
      let store = db.createObjectStore("zipcodes", // store name
              &lbrace; keyPath: "zipcode" });

      // Now index the object store by city name as well as by zip code.
      // With this method the key path string is passed directly as a
      // required argument rather than as part of an options object.
      store.createIndex("cities", "city");

      // Now get the data we are going to initialize the database with.
      // The zipcodes.json data file was generated from CC-licensed data from
      // www.geonames.org: https://download.geonames.org/export/zip/US.zip
      fetch("zipcodes.json")               // Make an HTTP GET request
        .then(response => response.json()) // Parse the body as JSON
        .then(zipcodes => &lbrace;                // Get 40K zip code records
          // In order to insert zip code data into the database we need a
          // transaction object. To create our transaction object, we need
          // to specify which object stores we'll be using (we only have
          // one) and we need to tell it that we'll be doing writes to the
          // database, not just reads:
          let transaction = db.transaction(["zipcodes"], "readwrite");
          transaction.onerror = console.error;

          // Get our object store from the transaction
          let store = transaction.objectStore("zipcodes");

          // The best part about the IndexedDB API is that object stores
          // are *really* simple. Here's how we add (or update) our records:
          for(let record of zipcodes) &lbrace; store.put(record); }

          // When the transaction completes successfully, the database
          // is initialized and ready for use, so we can call the
          // callback function that was originally passed to withDB()
          transaction.oncomplete = () => &lbrace; callback(db); };
        });
      }

      // Given a zip code, use the IndexedDB API to asynchronously look up the city
      // with that zip code, and pass it to the specified callback, or pass null if
      // no city is found.
      function lookupCity(zip, callback) &lbrace;
        withDB(db => &lbrace;
        // Create a read-only transaction object for this query. The
        // argument is an array of object stores we will need to use.
        let transaction = db.transaction(["zipcodes"]);

        // Get the object store from the transaction
        let zipcodes = transaction.objectStore("zipcodes");

        // Now request the object that matches the specified zipcode key.
        // The lines above were synchronous, but this one is async.
        let request = zipcodes.get(zip);
        request.onerror = console.error; // Log errors
        request.onsuccess = () => &lbrace; // Or call this function on success
          let record = request.result; // This is the query result
          if (record) &lbrace; // If we found a match, pass it to the callback
            callback(`$&lbrace;record.city}, $&lbrace;record.state}`);
          } else &lbrace; // Otherwise, tell the callback that we failed
            callback(null);
          }
        };
      });
    }

    // Given the name of a city, use the IndexedDB API to asynchronously
    // look up all zip code records for all cities (in any state) that have
    // that (case-sensitive) name.
    function lookupZipcodes(city, callback) &lbrace;
      withDB(db => &lbrace;
        // As above, we create a transaction and get the object store
        let transaction = db.transaction(["zipcodes"]);
        let store = transaction.objectStore("zipcodes");

        // This time we also get the city index of the object store
        let index = store.index("cities");

        // Ask for all matching records in the index with the specified
        // city name, and when we get them we pass them to the callback.
        // If we expected more results, we might use openCursor() instead.
        let request = index.getAll(city);
        request.onerror = console.error;
        request.onsuccess = () => &lbrace; callback(request.result); };
      });
    }</code></pre>
  </section>
  <section id="13" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13 Hilos de trabajo y mensajería</h2>
    <p>Una de las características fundamentales de JavaScript es que es monohilo: un navegador nunca ejecutará dos manejadores de eventos al mismo tiempo, y nunca activará un temporizador mientras se esté ejecutando un manejador de eventos, por ejemplo. Las actualizaciones concurrentes del estado de la aplicación o del documento simplemente no son posibles, y los programadores del lado del cliente no necesitan pensar en la programación concurrente, ni siquiera entenderla. Un corolario es que las funciones JavaScript del lado del cliente no deben ejecutarse demasiado tiempo; de lo contrario, atascarán el bucle de eventos y el navegador web dejará de responder a la entrada del usuario. Esta es la razón por la que <codeinline>fetch()</codeinline> es una función asíncrona, por ejemplo.</p>
    <p>Los navegadores web relajan cuidadosamente el requisito de un único hilo con la clase Worker: las instancias de esta clase representan hilos que se ejecutan simultáneamente con el hilo principal y el bucle de eventos. Los trabajadores viven en un entorno de ejecución autónomo con un objeto global completamente independiente y sin acceso a los objetos Window o Document. Los Workers sólo pueden comunicarse con el hilo principal mediante el paso asíncrono de mensajes. Esto significa que las modificaciones concurrentes del DOM siguen siendo imposibles, pero también significa que puedes escribir funciones de larga duración que no bloqueen el bucle de eventos y cuelguen el navegador. Crear un nuevo trabajador no es una operación pesada como abrir una nueva ventana del navegador, pero los trabajadores tampoco son "fibras" de peso mosca, y no tiene sentido crear nuevos trabajadores para realizar operaciones triviales. Las aplicaciones web complejas pueden encontrar útil crear decenas de trabajadores, pero es poco probable que una aplicación con cientos o miles de trabajadores sea práctica.</p>
    <p>Los workers son útiles cuando tu aplicación necesita realizar tareas computacionalmente intensivas, como el procesamiento de imágenes. El uso de un worker desplaza este tipo de tareas del hilo principal para que el navegador no deje de responder. Además, los workers ofrecen la posibilidad de dividir el trabajo entre varios subprocesos. Pero los workers también son útiles cuando tienes que realizar frecuentemente cálculos moderadamente intensivos. Supongamos, por ejemplo, que estás implementando un sencillo editor de código en el navegador y quieres incluir resaltado de sintaxis. Para que el resaltado sea correcto, tienes que analizar el código en cada pulsación de tecla. Pero si lo haces en el hilo principal, es probable que el código de análisis impida que los controladores de eventos que responden a las pulsaciones de teclas del usuario se ejecuten con prontitud y la experiencia de escritura del usuario sea lenta.</p>
    <p>Como con cualquier API de hilos, hay dos partes en la API Worker. La primera es el objeto Worker: este es el aspecto que tiene un worker desde el exterior, para el hilo que lo crea. La segunda es el WorkerGlobalScope: este es el objeto global para un nuevo worker, y es lo que un hilo worker parece, por dentro, a sí mismo.</p>
    <p>Las siguientes secciones cubren Worker y WorkerGlobalScope y también explican la API de paso de mensajes que permite a los trabajadores comunicarse con el hilo principal y entre sí. La misma API de comunicación se utiliza para intercambiar mensajes entre un y los elementos <codeinline>&lt;iframe></codeinline> contenidos en el documento, y esto también se trata en las secciones siguientes.</p>
  </section>
  <section id="13-1">
    <h2>15.13.1 Objetos de trabajo</h2>
    <p>Para crear un nuevo trabajador, llame al constructor <codeinline>Worker()</codeinline>, pasando una URL que especifique el código JavaScript que el trabajador debe ejecutar:</p>
    <pre class="language-js">
    <code class="language-js">let dataCruncher = new Worker("utils/cruncher.js");</code></pre>
    <p>Si especifica una URL relativa, se resuelve en relación a la URL del documento que contiene el script que llamó al constructor <codeinline>Worker()</codeinline>. Si especifica una URL absoluta, debe tener el mismo origen (mismo protocolo, host y puerto) que el documento que la contiene.</p>
    <p>Una vez que tenga un objeto Worker, puede enviarle datos con <codeinline>postMessage()</codeinline>. El valor que pases a <codeinline>postMessage()</codeinline> será copiado utilizando el algoritmo de clonación estructurada (ver <a href="#algoritmo-clon-estructurado">"El algoritmo de clonación estructurada"</a>), y la copia resultante será entregada al trabajador a través de un evento de mensaje:</p>
    <pre class="language-js">
    <code class="language-js">dataCruncher.postMessage("/api/data/to/crunch");</code></pre>
    <p>Aquí sólo estamos pasando un único mensaje de cadena, pero también puede utilizar objetos, matrices, matrices tipadas, mapas, conjuntos, etc. Puedes recibir mensajes de un trabajador buscando eventos "mensaje" en el objeto Trabajador:</p>
    <pre class="language-js">
    <code class="language-js">dataCruncher.onmessage = function(e) &lbrace;
      let stats = e.data; // The message is the data property of the event
      console.log(`Average: $&lbrace;stats.mean}`);
    }</code></pre>
    <p>Como todos los destinos de eventos, los objetos Worker definen las funciones <codeinline>addEventListener()</codeinline> y <codeinline>removeEventListener()</codeinline>, y puede utilizarlos en lugar de <codeinline>onmessage</codeinline>.</p>
    <p>Además de <codeinline>postMessage()</codeinline>, los objetos Worker sólo tienen otro método, <codeinline>terminate()</codeinline>, que fuerza a un hilo worker a dejar de ejecutarse.</p>
  </section>
  <section id="13-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.2 El objeto global en los trabajadores</h2>
    <p>Cuando se crea un nuevo trabajador con el constructor <codeinline>Worker()</codeinline>, se especifica la URL de un archivo de código JavaScript. Ese código se ejecuta en un nuevo entorno de ejecución JavaScript prístino, aislado del script que creó el trabajador. El objeto global para ese nuevo entorno de ejecución es un objeto WorkerGlobalScope. Un WorkerGlobalScope es algo más que el objeto global de JavaScript, pero menos que un objeto Window del lado del cliente.</p>
    <p>El objeto WorkerGlobalScope tiene un método <codeinline>postMessage()</codeinline> y un método <codeinline>onmessage</codeinline> que son iguales que los del objeto Worker pero funcionan en el modo</p>
    <p>dirección opuesta: llamar a <codeinline>postMessage()</codeinline> dentro de un worker genera un evento de mensaje fuera del worker, y los mensajes enviados desde fuera del worker se convierten en eventos y se entregan al manejador <codeinline>onmessage</codeinline>. Debido a que el WorkerGlobalScope es el objeto global para un worker, <codeinline>postMessage()</codeinline> y <codeinline>onmessage</codeinline> parecen una función global y variable global para el código del worker.</p>
    <p>Si pasas un objeto como segundo argumento al constructor <codeinline>Worker()</codeinline>, y si ese objeto tiene una propiedad <codeinline>name</codeinline>, entonces el valor de esa propiedad se convierte en el valor de la propiedad <codeinline>name</codeinline> en el objeto global del worker. Un trabajador puede incluir este nombre en cualquier mensaje que imprima con <codeinline>console.warn()</codeinline> o <codeinline>console.error()</codeinline>.</p>
    <p>La función <codeinline>close()</codeinline> permite que un trabajador se termine a sí mismo, y es similar en efecto al método <codeinline>terminate()</codeinline> de un objeto Worker.</p>
    <p>Dado que WorkerGlobalScope es el objeto global para los trabajadores, tiene todas las propiedades del objeto global del núcleo de JavaScript, como el objeto JSON, la función <codeinline>isNaN()</codeinline> y el constructor <codeinline>Date()</codeinline>. Además, sin embargo, WorkerGlobalScope también tiene las siguientes propiedades del objeto Window del lado del cliente:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          <codeinline>self</codeinline> es una referencia al propio objeto global. WorkerGlobalScope no es un objeto Window y no define una propiedad de <codeinline>window</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de temporizador <codeinline>setTimeout()</codeinline>, <codeinline>clearTimeout()</codeinline>, <codeinline>setInterval()</codeinline>, y <codeinline>clearInterval()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Una propiedad <codeinline>location</codeinline> que describe la URL que se pasó al constructor <codeinline>Worker()</codeinline>. Esta propiedad se refiere a un objeto Location, al igual que la propiedad <codeinline>location</codeinline> de una ventana. El objeto Location tiene las propiedades <codeinline>href</codeinline>, <codeinline>protocol</codeinline>, <codeinline>host</codeinline>, <codeinline>hostname</codeinline>, <codeinline>port</codeinline>, <codeinline>pathname</codeinline>, <codeinline>search</codeinline> y <codeinline>hash</codeinline>. En un trabajador, estas propiedades son de sólo lectura.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Una propiedad del <codeinline>navigator</codeinline> que hace referencia a un objeto con propiedades como las del objeto Navegador de una ventana. El objeto Navigator de un trabajador tiene las propiedades <codeinline>appName</codeinline>, <codeinline>appVersion</codeinline>, <codeinline>platform</codeinline>, <codeinline>userAgent</codeinline> y <codeinline>onLine</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos habituales de destino de eventos <codeinline>addEventListener()</codeinline> y <codeinline>removeEventListener()</codeinline>.
        </p>
      </li>
    </ul>
    <p>Por último, el objeto WorkerGlobalScope incluye importantes API JavaScript del lado del cliente, como el objeto Console, la función <codeinline>fetch()</codeinline> y la API IndexedDB. WorkerGlobalScope también incluye el constructor <codeinline>Worker()</codeinline>, lo que significa que los hilos worker pueden crear sus propios workers.</p>
  </section>
  <section id="13-3">
    <h2>15.13.3 Importar código a un trabajador</h2>
    <p>Los workers se definieron en los navegadores web antes de que JavaScript tuviera un sistema de módulos, por lo que los workers tienen un sistema único para incluir código adicional. WorkerGlobalScope define <codeinline>importScripts()</codeinline> como una función global a la que todos los workers tienen acceso:</p>
    <pre class="language-js">
    <code class="language-js">// Before we start working, load the classes and utilities we'll need
    importScripts("utils/Histogram.js", "utils/BitSet.js");</code></pre>
    <p><codeinline>importScripts()</codeinline> toma uno o más argumentos de URL, cada uno de los cuales debe referirse a un archivo de código JavaScript. Las URL relativas se resuelven en relación con la URL que se pasó al constructor <codeinline>Worker()</codeinline> (no en relación con el documento contenedor). <codeinline>importScripts()</codeinline> carga y ejecuta de forma sincrónica estos archivos uno tras otro, en el orden en que se especificaron. Si la carga de un script causa un error de red, o si la ejecución arroja un error de cualquier tipo, ninguno de los scripts subsiguientes es cargado o ejecutado. Un script cargado con <codeinline>importScripts()</codeinline> puede llamar a su vez a <codeinline>importScripts()</codeinline> para cargar los archivos de los que depende. Tenga en cuenta, sin embargo, que <codeinline>importScripts()</codeinline> no intenta realizar un seguimiento de los scripts que ya se han cargado y no hace nada para evitar los ciclos de dependencia.</p>
    <p><codeinline>importScripts()</codeinline> es una función síncrona: no retorna hasta que todos los scripts se han cargado y ejecutado. Puede empezar a usar los scripts que ha cargado tan pronto como <codeinline>importScripts()</codeinline> devuelva: no hay necesidad de una llamada de retorno, manejador de eventos, método <codeinline>then()</codeinline> o <codeinline>await</codeinline>. Una vez que se ha interiorizado la naturaleza asíncrona de JavaScript del lado del cliente, resulta extraño volver a la programación simple y síncrona. Pero esa es la belleza de los hilos: se puede utilizar una llamada a una función de bloqueo en un trabajador sin bloquear el bucle de eventos en el hilo principal, y sin bloquear los cálculos que se realizan simultáneamente en otros trabajadores.</p>
    <article>
      <p class="title-article">Módulos en Trabajadores</p>
      <p>Para utilizar módulos en los workers, debes pasar un segundo argumento al constructor <codeinline>Worker()</codeinline>. Este segundo argumento debe ser un objeto con una propiedad <codeinline>type</codeinline> establecida a la cadena "module". Pasar una opción <codeinline>type: "module"</codeinline> al constructor <codeinline>Worker()</codeinline> es muy parecido a usar el atributo <codeinline>type="module"</codeinline> en una etiqueta HTML <codeinline>&lt;script></codeinline>: significa que el código debe ser interpretado como un módulo y que las declaraciones de <codeinline>import</codeinline> están permitidas.</p>
      <p>Cuando un trabajador carga un módulo en lugar de un script tradicional, el WorkerGlobalScope no define la función <codeinline>importScripts()</codeinline>.</p>
      <p>Tenga en cuenta que a principios de 2020, Chrome es el único navegador que soporta verdaderos módulos y declaraciones de <codeinline>import</codeinline> en los trabajadores.</p>
    </article>
  </section>
  <section id="13-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.4 Modelo de ejecución de los trabajadores</h2>
    <p>Los hilos de trabajo ejecutan su código (y todos los scripts o módulos importados) de forma sincrónica de arriba a abajo, y luego entran en una fase asincrónica en la que responden a eventos y temporizadores. Si un worker registra un manejador de eventos "mensaje", nunca saldrá mientras exista la posibilidad de que sigan llegando eventos mensaje. Pero si un trabajador no escucha mensajes, se ejecutará hasta que no haya más tareas pendientes (como promesas <codeinline>fetch()</codeinline> y temporizadores) y todas las llamadas de retorno relacionadas con la tarea hayan sido llamadas. Una vez que todos los callbacks registrados han sido llamados, no hay manera de que un trabajador pueda comenzar una nueva tarea, por lo que es seguro para el hilo salir, lo que hará automáticamente. Un worker también puede cerrarse explícitamente llamando a la función global <codeinline>close()</codeinline>. Ten en cuenta que no hay propiedades o métodos en el objeto Worker que especifiquen si un hilo worker sigue ejecutándose o no, por lo que los workers no deberían cerrarse a sí mismos sin coordinarlo de alguna manera con su hilo padre.</p>
    <p class="title-article text-left">Errores en los trabajadores</p>
    <p>Si se produce una excepción en un trabajador y no es capturada por ninguna cláusula <codeinline>catch</codeinline>, se lanza un evento "error" en el objeto global del trabajador. Si este evento es manejado y el manejador llama al método <codeinline>preventDefault()</codeinline> del objeto evento, la propagación del error termina. En caso contrario, el evento "error" se dispara sobre el objeto Worker. Si se llama allí a <codeinline>preventDefault()</codeinline>, la propagación termina. En caso contrario, se imprime un mensaje de error en la consola del desarrollador y se invoca al manejador onerror (§15.1.7) del objeto Window.</p>
    <pre class="language-js">
    <code class="language-js">// Handle uncaught worker errors with a handler inside the worker.
    self.onerror = function(e) &lbrace;
      console.log(`Error in worker at $&lbrace;e.filename}:$&lbrace;e.lineno}: $&lbrace;e.message}`);
      e.preventDefault();
    };

    // Or, handle uncaught worker errors with a handler outside the worker.
    worker.onerror = function(e) &lbrace;
      console.log(`Error in worker at $&lbrace;e.filename}:$&lbrace;e.lineno}: $&lbrace;e.message}`);
      e.preventDefault();
    };</code></pre>
    <p>Al igual que windows, los workers pueden registrar un manejador para ser invocado cuando una Promise es rechazada y no hay una función <codeinline>.catch()</codeinline> para manejarla. Dentro de un worker puedes detectar esto definiendo una función <codeinline>self.onunhandledrejection</codeinline> o utilizando <codeinline>addEventListener()</codeinline> para registrar un manejador global para eventos "unhandledrejection". El objeto de evento pasado a este manejador tendrá una propiedad <codeinline>promise</codeinline> cuyo valor es el objeto Promise que rechazó y una propiedad <codeinline>reason</codeinline> cuyo valor es lo que se habría pasado a una función <codeinline>.catch()</codeinline>.</p>
  </section>
  <section id="13-5">
    <h2>15.13.5 postMessage(), MessagePorts y MessageChannels</h2>
    <p>El método <codeinline>postMessage()</codeinline> del objeto Worker y la función global <codeinline>postMesage()</codeinline> definida dentro de un worker funcionan invocando los métodos <codeinline>postMessage()</codeinline> de un par de objetos MessagePort que se crean automáticamente junto con el worker. JavaScript del lado del cliente no puede acceder directamente a estos objetos MessagePort creados automáticamente, pero puede crear nuevos pares de puertos conectados con el constructor <codeinline>MessageChannel()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let channel = new MessageChannel; // Create a new channel.
    let myPort = channel.port1;       // It has two ports
    let yourPort = channel.port2;     // connected to each other.

    myPort.postMessage("Can you hear me?"); // A message posted to one will
    yourPort.onmessage = (e) => console.log(e.data); // be received on the other.</code></pre>
    <p>Un MessageChannel es un objeto con propiedades <codeinline>port1</codeinline> y <codeinline>port2</codeinline> que hacen referencia a un par de objetos MessagePort conectados. Un MessagePort es un objeto con un método <codeinline>postMessage()</codeinline> y una propiedad manejadora de eventos <codeinline>onmessage</codeinline>. Cuando se llama a <codeinline>postMessage()</codeinline> en un puerto de un par conectado, se dispara un evento "mensaje" en el otro puerto del par. Puedes recibir estos eventos "mensaje" estableciendo la propiedad <codeinline>onmessage</codeinline> o utilizando <codeinline>addEventListener()</codeinline> para registrar un receptor de eventos "mensaje".</p>
    <p>Los mensajes enviados a un puerto se ponen en cola hasta que se define la propiedad <codeinline>onmessage</codeinline> o hasta que se llama al método <codeinline>start()</codeinline> en el puerto. Esto evita que los mensajes enviados por un extremo del canal sean perdidos por el otro extremo. Si utiliza <codeinline>addEventListener()</codeinline> con un MessagePort, no olvide llamar a <codeinline>start()</codeinline> o puede que nunca vea un mensaje entregado.</p>
    <p>Todas las llamadas a <codeinline>postMessage()</codeinline> que hemos visto hasta ahora han tomado un único argumento de mensaje. Pero el método también acepta un segundo argumento opcional. Este segundo argumento es un array de elementos que van a ser transferidos al otro extremo del canal en lugar de tener una copia enviada a través del canal. Los valores que pueden ser transferidos en lugar de copiados son MessagePorts y ArrayBuffers. (Algunos navegadores también implementan otros tipos transferibles, como ImageBitmap y OffscreenCanvas. Sin embargo, éstos no están soportados universalmente y no se tratan en este libro). Si el primer argumento de <codeinline>postMessage()</codeinline> incluye un MessagePort (anidado en cualquier lugar dentro del objeto mensaje), entonces ese MessagePort debe aparecer también en el segundo argumento. Si hace esto, entonces el MessagePort estará disponible para el otro extremo del canal e inmediatamente dejará de ser funcional en su extremo. Supongamos que ha creado un trabajador y desea tener dos canales para comunicarse con él: un canal para el intercambio de datos ordinarios y un canal para mensajes de alta prioridad. En el hilo principal, puede crear un MessageChannel, luego llamar a <codeinline>postMessage()</codeinline> en el trabajador para pasarle uno de los MessagePorts:</p>
    <pre class="language-js">
    <code class="language-js">let worker = new Worker("worker.js");
    let urgentChannel = new MessageChannel();
    let urgentPort = urgentChannel.port1;
    worker.postMessage(&lbrace; command: "setUrgentPort", value: urgentChannel.port2 },
              [ urgentChannel.port2 ]);
    // Now we can receive urgent messages from the worker like this
    urgentPort.addEventListener("message", handleUrgentMessage);
    urgentPort.start();       // Start receiving messages
    // And send urgent messages like this
    urgentPort.postMessage("test");</code></pre>
    <p>Los MessageChannels también son útiles si creas dos workers y quieres permitirles comunicarse directamente entre ellos en lugar de requerir código en el hilo principal para retransmitir mensajes entre ellos.</p>
    <p>El otro uso del segundo argumento de <codeinline>postMessage()</codeinline> es transferir ArrayBuffers entre workers sin tener que copiarlos. Esta es una importante mejora de rendimiento para grandes ArrayBuffers como los utilizados para contener datos de imagen. Cuando un ArrayBuffer se transfiere a través de un MessagePort, el ArrayBuffer se vuelve inutilizable en el hilo original, por lo que no hay posibilidad de acceso concurrente a su contenido. Si el primer argumento de <codeinline>postMessage()</codeinline> incluye un ArrayBuffer, o cualquier valor (como un array tipado) que tenga un ArrayBuffer, entonces ese buffer puede aparecer como un elemento de array en el segundo argumento de <codeinline>postMessage()</codeinline>. Si aparece, se transferirá sin copiar. Si no, entonces el ArrayBuffer será copiado en lugar de transferido. El <a href="#ejemplo15-14">Ejemplo 15-14</a> demostrará el uso de esta técnica de transferencia con ArrayBuffers.</p>
  </section>
  <section id="13-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.6 Mensajería entre orígenes con postMessage()</h2>
    <p>Hay otro caso de uso para el método <codeinline>postMessage()</codeinline> en JavaScript del lado del cliente. Se trata de ventanas en lugar de trabajadores, pero hay suficientes similitudes entre los dos casos que vamos a describir el método <codeinline>postMessage()</codeinline> del objeto Window aquí.</p>
    <p>Cuando un documento contiene un elemento <codeinline>&lt;iframe></codeinline>, ese elemento actúa como una ventana incrustada pero independiente. El objeto Element que representa el <codeinline>&lt;iframe></codeinline> tiene una propiedad con tentWindow que es el objeto Window para el documento incrustado. Y para los scripts que se ejecutan dentro de ese iframe anidado, la propiedad <codeinline>window.parent</codeinline> hace referencia al objeto Window que lo contiene. Cuando dos ventanas muestran documentos con el mismo origen, los scripts de cada una de esas ventanas tienen acceso al contenido de la otra ventana. Pero cuando los documentos tienen orígenes diferentes, la política del mismo origen del navegador impide que el JavaScript de una ventana acceda al contenido de otra ventana.</p>
    <p>Para workers, <codeinline>postMessage()</codeinline> proporciona una forma segura para que dos hilos independientes se comuniquen sin compartir memoria. Para ventanas, <codeinline>postMessage()</codeinline> proporciona una forma controlada para que dos orígenes independientes intercambien mensajes de forma segura. Incluso si la política del mismo origen impide que tu script vea el contenido de otra ventana, aún puede llamar a <codeinline>postMessage()</codeinline> en esa ventana, y al hacerlo se disparará un evento "mensaje" en esa ventana, donde podrá ser visto por los manejadores de eventos en los scripts de esa ventana.</p>
    <p>Sin embargo, el método <codeinline>postMessage()</codeinline> de una Ventana es un poco diferente al método <codeinline>postMessage()</codeinline> de un Trabajador. El primer argumento sigue siendo un mensaje arbitrario que será copiado por el algoritmo de clonado estructurado. Pero el segundo argumento opcional que lista los objetos a ser transferidos en lugar de copiados se convierte en un tercer argumento opcional. El método <codeinline>postMessage()</codeinline> de una ventana toma una cadena como segundo argumento obligatorio. Este segundo argumento debe ser un origen (un protocolo, nombre de host y puerto opcional) que especifique quién se espera que reciba el mensaje. Si pasas la cadena "https://good.example.com" como segundo argumento, pero la ventana en la que estás enviando el mensaje en realidad contiene contenido de "https://malware.example.com", entonces el mensaje que has enviado no será entregado. Si estás dispuesto a enviar tu mensaje a contenidos de cualquier origen, entonces puedes pasar el comodín "*" como segundo argumento.</p>
    <p>El código JavaScript que se ejecuta dentro de una ventana o <codeinline>&lt;iframe></codeinline> puede recibir mensajes enviados a esa ventana o marco definiendo la propiedad <codeinline>onmessage</codeinline> de esa ventana o llamando a <codeinline>addEventListener()</codeinline> para los eventos "message". Al igual que con los workers, cuando se recibe un evento "message" para una ventana, la propiedad data del objeto de evento es el mensaje que se envió. Sin embargo, además, los eventos "mensaje" enviados a ventanas también definen las propiedades <codeinline>source</codeinline> y <codeinline>origin</codeinline>. La propiedad <codeinline>source</codeinline> especifica el objeto Window que envió el evento, y puede utilizar <codeinline>event.source.postMessage()</codeinline> para enviar una respuesta. La propiedad <codeinline>origin</codeinline> especifica el origen del contenido en la ventana fuente. Esto no es algo que el emisor del mensaje pueda falsificar, y cuando recibas un evento "mensaje", normalmente querrás verificar que proviene de un origen que esperas.</p>
  </section>
  <section id="14">
    <h2>15.16 Ejemplo: El conjunto de Mandelbrot</h2>
    <p>Este capítulo sobre JavaScript del lado del cliente culmina con un largo ejemplo que demuestra el uso de workers y mensajería para paralelizar tareas de cálculo intensivo. Pero está escrito para ser una aplicación web atractiva, del mundo real y también demuestra una serie de otras APIs demostradas en este capítulo, incluyendo la gestión de la historia, el uso de la clase ImageData con un <codeinline>&lt;canvas></codeinline>, y el uso del teclado, puntero, y eventos de cambio de tamaño. También demuestra importantes características básicas de JavaScript, incluyendo generadores y un uso sofisticado de Promises.</p>
    <p>El ejemplo es un programa para visualizar y explorar el conjunto de Mandelbrot, un fractal complejo que incluye bellas imágenes como la que se muestra en la <a href="#figure15-16">Figura 15-16</a>.</p>
    <figure id="figure15-16">
      <img src="/public/javascript/capitulo-15/figure15-16.avif" alt="imagen de consola">
      <figcaption>Figura 15-16. Una porción del conjunto de Mandelbrot</figcaption>
    </figure>
    <p>El conjunto de Mandelbrot se define como el conjunto de puntos del plano complejo que, cuando se someten a un proceso repetido de multiplicación y suma compleja, producen un valor cuya magnitud permanece acotada. Los contornos del conjunto son sorprendentemente complejos, y calcular qué puntos son miembros del conjunto y cuáles no lo son exige un gran esfuerzo informático: para producir una imagen de 500×500 del conjunto de Mandelbrot, hay que calcular individualmente la pertenencia de cada uno de los 250.000 píxeles de la imagen. Y para verificar que el valor asociado a cada píxel sigue estando acotado, puede que tenga que repetir el proceso de multiplicación compleja 1.000 veces o más. (Con más iteraciones se obtienen límites más definidos para el conjunto; con menos iteraciones se obtienen límites más difusos). Con hasta 250 millones de pasos de aritmética compleja necesarios para producir una imagen de alta calidad del conjunto de Mandelbrot, se puede entender por qué el uso de trabajadores es una técnica valiosa. El <a href="#ejemplo15-14">Ejemplo 15-14</a> muestra el código worker que utilizaremos. Este archivo es relativamente compacto: es sólo el músculo computacional en bruto para el programa más grande. Sin embargo, vale la pena destacar dos cosas:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El trabajador crea un objeto ImageData para representar la cuadrícula rectangular de píxeles para los que está calculando la pertenencia al conjunto de Mandelbrot. Pero en lugar de almacenar los valores reales de los píxeles en ImageData, utiliza una matriz personalizada para tratar cada píxel como un entero de 32 bits. En esta matriz almacena el número de iteraciones necesarias para cada píxel. Si la magnitud del número complejo calculado para cada píxel es mayor que cuatro, entonces está matemáticamente garantizado que crecerá sin límites a partir de ese momento, y decimos que ha "escapado". Así que el valor que este trabajador devuelve para cada píxel es el número de iteraciones antes de que el valor haya escapado. Le decimos al trabajador el número máximo de iteraciones que debe intentar para cada valor, y los píxeles que alcanzan este número máximo se consideran dentro del conjunto.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El trabajador transfiere el ArrayBuffer asociado con el ImageData de vuelta al hilo principal para que la memoria asociada a él no tenga que ser copiada.
        </p>
      </li>
    </ul>
    <p><em>Ejemplo 15-14. Código de trabajo para calcular las regiones del conjunto de Mandelbrot</em></p>
    <pre class="language-js">
    <code class="language-js">// This is a simple worker that receives a message from its parent thread,
    // performs the computation described by that message and then posts the
    // result of that computation back to the parent thread.
    onmessage = function(message) &lbrace;
      // First, we unpack the message we received:
      // - tile is an object with width and height properties. It specifies the
      // size of the rectangle of pixels for which we will be computing
      // Mandelbrot set membership.
      // - (x0, y0) is the point in the complex plane that corresponds to the
      // upper-left pixel in the tile.
      // - perPixel is the pixel size in both the real and imaginary dimensions.
      // - maxIterations specifies the maximum number of iterations we will
      // perform before deciding that a pixel is in the set.
      const &lbrace;tile, x0, y0, perPixel, maxIterations} = message.data;
      const &lbrace;width, height} = tile;

      // Next, we create an ImageData object to represent the rectangular array
      // of pixels, get its internal ArrayBuffer, and create a typed array view
      // of that buffer so we can treat each pixel as a single integer instead of
      // four individual bytes. We'll store the number of iterations for each
      // pixel in this iterations array. (The iterations will be transformed into
      // actual pixel colors in the parent thread.)
      const imageData = new ImageData(width, height);
      const iterations = new Uint32Array(imageData.data.buffer);

      // Now we begin the computation. There are three nested for loops here.
      // The outer two loop over the rows and columns of pixels, and the inner
      // loop iterates each pixel to see if it "escapes" or not. The various
      // loop variables are the following:
      // - row and column are integers representing the pixel coordinate.
      // - x and y represent the complex point for each pixel: x + yi.
      // - index is the index in the iterations array for the current pixel.
      // - n tracks the number of iterations for each pixel.
      // - max and min track the largest and smallest number of iterations
      // we've seen so far for any pixel in the rectangle.
      let index = 0, max = 0, min=maxIterations;
      for(let row = 0, y = y0; row &lt; height; row++, y += perPixel) &lbrace;
        for(let column = 0, x = x0; column &lt; width; column++, x += perPixel) &lbrace;
          // For each pixel we start with the complex number c = x+yi.
          // Then we repeatedly compute the complex number z(n+1) based on
          // this recursive formula:
          // z(0) = c
          // z(n+1) = z(n)^2 + c
          // If |z(n)| (the magnitude of z(n)) is > 2, then the
          // pixel is not part of the set and we stop after n iterations.
          let n;                // The number of iterations so far
          let r = x, i = y;     // Start with z(0) set to c
          for(n = 0; n &lt; maxIterations; n++) &lbrace;
            let rr = r*r, ii = i*i;   // Square the two parts of z(n).
            if (rr + ii > 4) &lbrace;        // If |z(n)|^2 is > 4 then
              break;        // we've escaped and can stop iterating.
            }
            i = 2*r*i + y;            // Compute imaginary part of z(n+1).
            r = rr - ii + x;          // And the real part of z(n+1).
          }
          iterations[index++] = n;    // Remember # iterations for each pixel.
          if (n > max) max = n;       // Track the maximum number we've seen.
          if (n &lt; min) min = n;       // And the minimum as well.
        }
      }

      // When the computation is complete, send the results back to the parent
      // thread. The imageData object will be copied, but the giant ArrayBuffer
      // it contains will be transferred for a nice performance boost.
      postMessage(&lbrace;tile, imageData, min, max}, [imageData.data.buffer]);
    };</code></pre>
    <p>La aplicación de visualización del conjunto de Mandelbrot que utiliza ese código de trabajador se muestra en el <a href="#ejemplo15-15">Ejemplo 15-15</a>. Ahora que casi has llegado al final de este capítulo, este largo ejemplo es algo así como una experiencia de culminación que reúne una serie de importantes características y APIs del núcleo y del lado del cliente de JavaScript. El código está minuciosamente comentado, y te animo a que lo leas con atención.</p>
    <p><em>Ejemplo 15-15. Una aplicación web para visualizar y explorar el conjunto de Mandelbrot</em></p>
    <pre class="language-js">
    <code class="language-js">/*
    * This class represents a subrectangle of a canvas or image. We use Tiles to
    * divide a canvas into regions that can be processed independently by Workers.
    */
    class Tile &lbrace;
      constructor(x, y, width, height) &lbrace;
        this.x = x;           // The properties of a Tile object
        this.y = y;           // represent the position and size
        this.width = width;   // of the tile within a larger
        this.height = height; // rectangle.
      }
      
      // This static method is a generator that divides a rectangle of the
      // specified width and height into the specified number of rows and
      // columns and yields numRows*numCols Tile objects to cover the rectangle.
      static *tiles(width, height, numRows, numCols) &lbrace;
        let columnWidth = Math.ceil(width / numCols);
        let rowHeight = Math.ceil(height / numRows);

        for(let row = 0; row &lt; numRows; row++) &lbrace;
          let tileHeight = (row &lt; numRows-1)
            ? rowHeight                            // height of most rows
            : height - rowHeight * (numRows-1);    // height of last row
          for(let col = 0; col &lt; numCols; col++) &lbrace;
            let tileWidth = (col &lt; numCols-1)
              ? columnWidth                        // width of most columns
              : width - columnWidth * (numCols-1); // and last column

            yield new Tile(col * columnWidth, row * rowHeight, tileWidth, tileHeight);
          }
        }
      }
    }

    /*
    * This class represents a pool of workers, all running the same code. The
    * worker code you specify must respond to each message it receives by
    * performing some kind of computation and then posting a single message with
    * the result of that computation.
    *
    * Given a WorkerPool and message that represents work to be performed, simply
    * call addWork(), with the message as an argument. If there is a Worker
    * object that is currently idle, the message will be posted to that worker
    * immediately. If there are no idle Worker objects, the message will be
    * queued and will be posted to a Worker when one becomes available.
    *
    * addWork() returns a Promise, which will resolve with the message recieved
    * from the work, or will reject if the worker throws an unhandled error.
    */
    class WorkerPool &lbrace;
      constructor(numWorkers, workerSource) &lbrace;
        this.idleWorkers = [];      // Workers that are not currently working
        this.workQueue = [];        // Work not currently being processed
        this.workerMap = new Map(); // Map workers to resolve and reject funcs

        // Create the specified number of workers, add message and error
        // handlers and save them in the idleWorkers array.
        for(let i = 0; i &lt; numWorkers; i++) &lbrace;
          let worker = new Worker(workerSource);
          worker.onmessage = message => &lbrace;
            this._workerDone(worker, null, message.data);
          };
          worker.onerror = error => &lbrace;
            this._workerDone(worker, error, null);
          };
          this.idleWorkers[i] = worker;
        }
      }

      // This internal method is called when a worker finishes working, either
      // by sending a message or by throwing an error.
      _workerDone(worker, error, response) &lbrace;
        // Look up the resolve() and reject() functions for this worker
        // and then remove the worker's entry from the map.
        let [resolver, rejector] = this.workerMap.get(worker);
        this.workerMap.delete(worker);
        // If there is no queued work, put this worker back in
        // the list of idle workers. Otherwise, take work from the queue
        // and send it to this worker.
        if (this.workQueue.length === 0) &lbrace;
          this.idleWorkers.push(worker);
        } else &lbrace;
          let [work, resolver, rejector] = this.workQueue.shift();
          this.workerMap.set(worker, [resolver, rejector]);
          worker.postMessage(work);
        }

        // Finally, resolve or reject the promise associated with the worker.
        error === null ? resolver(response) : rejector(error);
      }

      // This method adds work to the worker pool and returns a Promise that
      // will resolve with a worker's response when the work is done. The work
      // is a value to be passed to a worker with postMessage(). If there is an
      // idle worker, the work message will be sent immediately. Otherwise it
      // will be queued until a worker is available.
      addWork(work) &lbrace;
        return new Promise((resolve, reject) => &lbrace;
          if (this.idleWorkers.length > 0) &lbrace;
            let worker = this.idleWorkers.pop();
            this.workerMap.set(worker, [resolve, reject]);
            worker.postMessage(work);
          } else &lbrace;
            this.workQueue.push([work, resolve, reject]);
          }
        });
      }
    }

    /*
    * This class holds the state information necessary to render a Mandelbrot set.
    * The cx and cy properties give the point in the complex plane that is the
    * center of the image. The perPixel property specifies how much the real and
    * imaginary parts of that complex number changes for each pixel of the image.
    * The maxIterations property specifies how hard we work to compute the set.
    * Larger numbers require more computation but produce crisper images.
    * Note that the size of the canvas is not part of the state. Given cx, cy, and
    * perPixel we simply render whatever portion of the Mandelbrot set fits in
    * the canvas at its current size.
    *
    * Objects of this type are used with history.pushState() and are used to read
    * the desired state from a bookmarked or shared URL.
    */
    class PageState &lbrace;
      // This factory method returns an initial state to display the entire set.
      static initialState() &lbrace;
        let s = new PageState();
        s.cx = -0.5;
        s.cy = 0;
        s.perPixel = 3/window.innerHeight;
        s.maxIterations = 500;
        return s;
      }

      // This factory method obtains state from a URL, or returns null if
      // a valid state could not be read from the URL.
      static fromURL(url) &lbrace;
        let s = new PageState();
        let u = new URL(url); // Initialize state from the url's search params.
        s.cx = parseFloat(u.searchParams.get("cx"));
        s.cy = parseFloat(u.searchParams.get("cy"));
        s.perPixel = parseFloat(u.searchParams.get("pp"));
        s.maxIterations = parseInt(u.searchParams.get("it"));
        // If we got valid values, return the PageState object, otherwise null.
        return (isNaN(s.cx) || isNaN(s.cy) || isNaN(s.perPixel) || isNaN(s.maxIterations))
          ? null
          : s;
      }
      // This instance method encodes the current state into the search
      // parameters of the browser's current location.
      toURL() &lbrace;
        let u = new URL(window.location);
        u.searchParams.set("cx", this.cx);
        u.searchParams.set("cy", this.cy);
        u.searchParams.set("pp", this.perPixel);
        u.searchParams.set("it", this.maxIterations);
        return u.href;
      }
    }

    // These constants control the parallelism of the Mandelbrot set computation.
    // You may need to adjust them to get optimum performance on your computer.
    const ROWS = 3, COLS = 4, NUMWORKERS = navigator.hardwareConcurrency || 2;

    // This is the main class of our Mandelbrot set program. Simply invoke the
    // constructor function with the &lt;canvas> element to render into. The program
    // assumes that this &lt;canvas> element is styled so that it is always as big
    // as the browser window.
    class MandelbrotCanvas &lbrace;
      constructor(canvas) &lbrace;
        // Store the canvas, get its context object, and initialize a WorkerPool
        this.canvas = canvas;
        this.context = canvas.getContext("2d");
        this.workerPool = new WorkerPool(NUMWORKERS, "mandelbrotWorker.js");

        // Define some properties that we'll use later
        this.tiles = null;          // Subregions of the canvas
        this.pendingRender = null;  // We're not currently rendering
        this.wantsRerender = false; // No render is currently requested
        this.resizeTimer = null;    // Prevents us from resizing too frequently
        this.colorTable = null;     // For converting raw data to pixel values.

        // Set up our event handlers
        this.canvas.addEventListener("pointerdown", e => this.handlePointer(e));
        window.addEventListener("keydown", e => this.handleKey(e));
        window.addEventListener("resize", e => this.handleResize(e));
        window.addEventListener("popstate", e => this.setState(e.state, false));

        // Initialize our state from the URL or start with the initial state.
        this.state =
            PageState.fromURL(window.location) || PageState.initialState();

        // Save this state with the history mechanism.
        history.replaceState(this.state, "", this.state.toURL());

        // Set the canvas size and get an array of tiles that cover it.
        this.setSize();

        // And render the Mandelbrot set into the canvas.
        this.render();
      }

      // Set the canvas size and initialize an array of Tile objects. This
      // method is called from the constructor and also by the handleResize()
      // method when the browser window is resized.
      setSize() &lbrace;
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.tiles = [...Tile.tiles(this.width, this.height, ROWS, COLS)];
      }

      // This function makes a change to the PageState, then re-renders the
      // Mandelbrot set using that new state, and also saves the new state with
      // history.pushState(). If the first argument is a function that function
      // will be called with the state object as its argument and should make
      // changes to the state. If the first argument is an object, then we simply
      // copy the properties of that object into the state object. If the optional
      // second argument is false, then the new state will not be saved. (We
      // do this when calling setState in response to a popstate event.)
      setState(f, save=true) &lbrace;
        // If the argument is a function, call it to update the state.
        // Otherwise, copy its properties into the current state.
        if (typeof f === "function") &lbrace;
          f(this.state);
        } else &lbrace;
          for(let property in f) &lbrace;
            this.state[property] = f[property];
          }
        }
        // In either case, start rendering the new state ASAP.
        this.render();

        // Normally we save the new state. Except when we're called with
        // a second argument of false which we do when we get a popstate event.
        if (save) &lbrace; 
          history.pushState(this.state, "", this.state.toURL());
        }
      }
      // This method asynchronously draws the portion of the Mandelbrot set
      // specified by the PageState object into the canvas. It is called by
      // the constructor, by setState() when the state changes, and by the
      // resize event handler when the size of the canvas changes.
      render() &lbrace;
        // Sometimes the user may use the keyboard or mouse to request renders
        // more quickly than we can perform them. We don't want to submit all
        // the renders to the worker pool. Instead if we're rendering, we'll
        // just make a note that a new render is needed, and when the current
        // render completes, we'll render the current state, possibly skipping
        // multiple intermediate states.
        if (this.pendingRender) &lbrace;    // If we're already rendering,
          this.wantsRerender = true; // make a note to rerender later
          return;                    // and don't do anything more now.
        }

        // Get our state variables and compute the complex number for the
        // upper left corner of the canvas.
        let &lbrace;cx, cy, perPixel, maxIterations} = this.state;
        let x0 = cx - perPixel * this.width/2;
        let y0 = cy - perPixel * this.height/2;

        // For each of our ROWS*COLS tiles, call addWork() with a message
        // for the code in mandelbrotWorker.js. Collect the resulting Promise
        // objects into an array.
        let promises = this.tiles.map(tile => this.workerPool.addWork(&lbrace;
          tile: tile,
          x0: x0 + tile.x * perPixel,
          y0: y0 + tile.y * perPixel,
          perPixel: perPixel,
          maxIterations: maxIterations
        }));

        // Use Promise.all() to get an array of responses from the array of
        // promises. Each response is the computation for one of our tiles.
        // Recall from mandelbrotWorker.js that each response includes the
        // Tile object, an ImageData object that includes iteration counts
        // instead of pixel values, and the minimum and maximum iterations
        // for that tile.
        this.pendingRender = Promise.all(promises).then(responses => &lbrace;
        
          // First, find the overall max and min iterations over all tiles.
          // We need these numbers so we can assign colors to the pixels.
          let min = maxIterations, max = 0;
          for(let r of responses) &lbrace;
            if (r.min &lt; min) min = r.min;
            if (r.max > max) max = r.max;
          }

          // Now we need a way to convert the raw iteration counts from the
          // workers into pixel colors that will be displayed in the canvas.
          // We know that all the pixels have between min and max iterations
          // so we precompute the colors for each iteration count and store
          // them in the colorTable array.

          // If we haven't allocated a color table yet, or if it is no longer
          // the right size, then allocate a new one.
          if (!this.colorTable || this.colorTable.length !== maxIterations+1)&lbrace;
            this.colorTable = new Uint32Array(maxIterations+1);
          }

          // Given the max and the min, compute appropriate values in the
          // color table. Pixels in the set will be colored fully opaque
          // black. Pixels outside the set will be translucent black with higher
          // iteration counts resulting in higher opacity. Pixels with
          // minimum iteration counts will be transparent and the white
          // background will show through, resulting in a grayscale image.
          if (min === max) &lbrace;             // If all the pixels are the same,
            if (min === maxIterations) &lbrace; // Then make them all black
              this.colorTable[min] = 0xFF000000;
            } else &lbrace;                     // Or all transparent.
              this.colorTable[min] = 0;
            }
          } else &lbrace;
            // In the normal case where min and max are different, use a
            // logarithic scale to assign each possible iteration count an
            // opacity between 0 and 255, and then use the shift left
            // operator to turn that into a pixel value.
            let maxlog = Math.log(1+max-min);
            for(let i = min; i &lt;= max; i++) &lbrace;
              this.colorTable[i] =
                (Math.ceil(Math.log(1+i-min)/maxlog * 255) &lt;&lt; 24);
            }
          }

          // Now translate the iteration numbers in each response's
          // ImageData to colors from the colorTable.
          for(let r of responses) &lbrace;
            let iterations = new Uint32Array(r.imageData.data.buffer);
            for(let i = 0; i &lt; iterations.length; i++) &lbrace;
              iterations[i] = this.colorTable[iterations[i]];
            }
          }

          // Finally, render all the imageData objects into their
          // corresponding tiles of the canvas using putImageData().
          // (First, though, remove any CSS transforms on the canvas that may
          // have been set by the pointerdown event handler.)
          this.canvas.style.transform = "";
          for(let r of responses) &lbrace;
            this.context.putImageData(r.imageData, r.tile.x, r.tile.y);
          }
        })
        .catch((reason) => &lbrace;
          // If anything went wrong in any of our Promises, we'll log
          // an error here. This shouldn't happen, but this will help with
          // debugging if it does.
          console.error("Promise rejected in render():", reason);
        })
        .finally(() => &lbrace;
          // When we are done rendering, clear the pendingRender flags
          this.pendingRender = null;
          // And if render requests came in while we were busy, rerender now.
          if (this.wantsRerender) &lbrace;
            this.wantsRerender = false;
            this.render();
          }
        });
      }

      // If the user resizes the window, this function will be called repeatedly.
      // Resizing a canvas and rerendering the Mandlebrot set is an expensive
      // operation that we can't do multiple times a second, so we use a timer
      // to defer handling the resize until 200ms have elapsed since the last
      // resize event was received.
      handleResize(event) &lbrace;
        // If we were already deferring a resize, clear it.
        if (this.resizeTimer) clearTimeout(this.resizeTimer);
        // And defer this resize instead.
        this.resizeTimer = setTimeout(() => &lbrace;
          this.resizeTimer = null; // Note that resize has been handled
          this.setSize();          // Resize canvas and tiles
          this.render();           // Rerender at the new size
        }, 200);
      }
      // If the user presses a key, this event handler will be called.
      // We call setState() in response to various keys, and setState() renders
      // the new state, updates the URL, and saves the state in browser history.
      handleKey(event) &lbrace;
        switch(event.key) &lbrace;
        case "Escape": // Type Escape to go back to the initial state
          this.setState(PageState.initialState());
          break;
        case "+":      // Type + to increase the number of iterations
          this.setState(s => &lbrace;
            s.maxIterations = Math.round(s.maxIterations*1.5);
          });
          break;
        case "-":     // Type - to decrease the number of iterations
          this.setState(s => &lbrace;
            s.maxIterations = Math.round(s.maxIterations/1.5);
            if (s.maxIterations &lt; 1) s.maxIterations = 1;
          });
          break;
        case "o":         // Type o to zoom out
          this.setState(s => s.perPixel *= 2);
          break;
        case "ArrowUp":   // Up arrow to scroll up
          this.setState(s => s.cy -= this.height/10 * s.perPixel);
          break;
        case "ArrowDown": // Down arrow to scroll down
          this.setState(s => s.cy += this.height/10 * s.perPixel);
          break;
        case "ArrowLeft": // Left arrow to scroll left
          this.setState(s => s.cx -= this.width/10 * s.perPixel);
          break;
        case "ArrowRight":// Right arrow to scroll right
          this.setState(s => s.cx += this.width/10 * s.perPixel);
          break;
        }
      }

      // This method is called when we get a pointerdown event on the canvas.
      // The pointerdown event might be the start of a zoom gesture (a click or
      // tap) or a pan gesture (a drag). This handler registers handlers for
      // the pointermove and pointerup events in order to respond to the rest
      // of the gesture. (These two extra handlers are removed when the gesture
      // ends with a pointerup.)
      handlePointer(event) &lbrace;
        // The pixel coordinates and time of the initial pointer down.
        // Because the canvas is as big as the window, these event coordinates
        // are also canvas coordinates.
        const x0 = event.clientX, y0 = event.clientY, t0 = Date.now();

        // This is the handler for move events.
        const pointerMoveHandler = event => &lbrace;
          // How much have we moved, and how much time has passed?
          let dx=event.clientX-x0, dy=event.clientY-y0, dt=Date.now()-t0;

          // If the pointer has moved enough or enough time has passed that
          // this is not a regular click, then use CSS to pan the display.
          // (We will rerender it for real when we get the pointerup event.)
          if (dx > 10 || dy > 10 || dt > 500) &lbrace;
            this.canvas.style.transform = `translate($&lbrace;dx}px, $&lbrace;dy}px)`;
          }
        };
        // This is the handler for pointerup events
        const pointerUpHandler = event => &lbrace;
          // When the pointer goes up, the gesture is over, so remove
          // the move and up handlers until the next gesture.
          this.canvas.removeEventListener("pointermove", pointerMoveHandler);
          this.canvas.removeEventListener("pointerup", pointerUpHandler);

          // How much did the pointer move, and how much time passed?
          const dx = event.clientX-x0, dy=event.clientY-y0, dt=Date.now()-t0;
          // Unpack the state object into individual constants.
          const &lbrace;cx, cy, perPixel} = this.state;

          // If the pointer moved far enough or if enough time passed, then
          // this was a pan gesture, and we need to change state to change
          // the center point. Otherwise, the user clicked or tapped on a
          // point and we need to center and zoom in on that point.
          if (dx > 10 || dy > 10 || dt > 500) &lbrace;
            // The user panned the image by (dx, dy) pixels.
            // Convert those values to offsets in the complex plane.
            this.setState(&lbrace;cx: cx - dx*perPixel, cy: cy - dy*perPixel});
          } else &lbrace;
            // The user clicked. Compute how many pixels the center moves.
            let cdx = x0 - this.width/2;
            let cdy = y0 - this.height/2;
            
            // Use CSS to quickly and temporarily zoom in
            this.canvas.style.transform =
                `translate($&lbrace;-cdx*2}px, $&lbrace;-cdy*2}px) scale(2)`;
                
            // Set the complex coordinates of the new center point and
            // zoom in by a factor of 2.
            this.setState(s => &lbrace;
              s.cx += cdx * s.perPixel;
              s.cy += cdy * s.perPixel;
              s.perPixel /= 2;
            });
          }
        };

        // When the user begins a gesture we register handlers for the
        // pointermove and pointerup events that follow.
        this.canvas.addEventListener("pointermove", pointerMoveHandler);
        this.canvas.addEventListener("pointerup", pointerUpHandler);
      }
    }

    // Finally, here's how we set up the canvas. Note that this JavaScript file
    // is self-sufficient. The HTML file only needs to include this one &lt;script>.
    let canvas = document.createElement("canvas"); // Create a canvas element
    document.body.append(canvas);     // Insert it into the body
    document.body.style = "margin:0"; // No margin for the &lt;body>
    canvas.style.width = "100%";      // Make canvas as wide as body
    canvas.style.height = "100%";     // and as high as the body.
    new MandelbrotCanvas(canvas);     // And start rendering into it!</code></pre>
  </section>
  <section id="15" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15 Resumen y sugerencias de lecturas complementarias</h2>
    <p>Este largo capítulo ha cubierto los fundamentos de la programación JavaScript del lado del cliente:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo se incluyen los scripts y módulos JavaScript en las páginas web y cómo y cuándo se ejecutan.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El modelo de programación asíncrona y basada en eventos de JavaScript del lado del cliente.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El Modelo de Objetos del Documento (DOM) que permite al código JavaScript inspeccionar y modificar el contenido HTML del documento en el que está incrustado. Esta API DOM es el corazón de toda la programación JavaScript del lado del cliente.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo el código JavaScript puede manipular los estilos CSS que se aplican al contenido dentro del documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo el código JavaScript puede obtener las coordenadas de los elementos del documento en la ventana del navegador y dentro del propio documento.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo crear "componentes web" de interfaz de usuario reutilizables con JavaScript, HTML y CSS utilizando las API de elementos personalizados y Shadow DOM.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo mostrar y generar gráficos dinámicamente con SVG y HTML Elemento <codeinline>&lt;canvas></codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo añadir efectos de sonido con guión (tanto grabados como sintetizados) a tus páginas web.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo JavaScript puede hacer que el navegador cargue nuevas páginas, retroceda y avance en el historial de navegación del usuario e incluso añada nuevas entradas al historial de navegación.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo los programas JavaScript pueden intercambiar datos con servidores web utilizando los protocolos HTTP y WebSocket.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo los programas JavaScript pueden almacenar datos en el navegador del usuario.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cómo los programas JavaScript pueden utilizar hilos de trabajo para lograr una forma segura de concurrencia.
        </p>
      </li>
    </ul>
    <p>Éste ha sido, con diferencia, el capítulo más largo del libro. Pero no puede ni acercarse a cubrir todas las APIs disponibles para los navegadores web. La plataforma web es extensa y está en constante evolución, y mi objetivo en este capítulo era presentar las API básicas más importantes. Con los conocimientos adquiridos en este libro, estarás bien equipado para aprender y utilizar nuevas API a medida que las necesites. Pero no puedes aprender sobre una nueva API si no sabes que existe, así que las breves secciones que siguen terminan el capítulo con una lista rápida de características de la plataforma web que quizás quieras investigar en el futuro.</p>
  </section>
  <section id="15-1">
    <h2>15.15.1 HTML y CSS</h2>
    <p>La web se basa en tres tecnologías clave: HTML, CSS y JavaScript, y el conocimiento de JavaScript sólo puede llevarte muy lejos como desarrollador web a menos que también desarrolles tu experiencia con HTML y CSS. Es importante saber utilizar Java-Script para manipular elementos HTML y estilos CSS, pero ese conocimiento es mucho más útil si también sabes qué elementos HTML y qué estilos CSS utilizar.</p>
    <p>Así que antes de empezar a explorar más API de JavaScript, te animo a que inviertas algo de tiempo en dominar las demás herramientas de un desarrollador web. Los formularios HTML y los elementos de entrada, por ejemplo, tienen un comportamiento sofisticado que es importante comprender, y los modos de diseño flexbox y grid de CSS son increíblemente potentes.</p>
    <p>Dos temas a los que merece la pena prestar especial atención en este ámbito son la accesibilidad (incluidos los atributos ARIA) y la internacionalización (incluida la compatibilidad con direcciones de escritura de derecha a izquierda).</p>
  </section>
  <section id="15-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.2 Rendimiento</h2>
    <p>Una vez que has escrito una aplicación web y la has lanzado al mundo, comienza la interminable búsqueda para hacerla más rápida. Sin embargo, es difícil optimizar cosas que no se pueden medir, por lo que merece la pena familiarizarse con las API de rendimiento. La propiedad <codeinline>performance</codeinline> del objeto ventana es el principal punto de entrada a esta API. Incluye una fuente de tiempo de alta resolución <codeinline>performance.now()</codeinline>, y métodos <codeinline>performance.mark()</codeinline> y <codeinline>performance.measure()</codeinline> para marcar puntos críticos en su código y medir el tiempo transcurrido entre ellos. Al llamar a estos métodos se crean objetos PerformanceEntry a los que puede acceder con <codeinline>performance.getEntries()</codeinline>. Los navegadores añaden sus propios objetos PerformanceEntry cada vez que el navegador carga una nueva página o recupera un archivo a través de la red, y estos objetos PerformanceEntry creados automáticamente incluyen detalles de tiempo granulares del rendimiento de la red de su aplicación. La clase PerformanceObserver permite especificar una función que se invocará cuando se creen nuevos objetos PerformanceEntry.</p>
  </section>
  <section id="15-3">
    <h2>15.15.3 Seguridad</h2>
    <p>Este capítulo ha introducido la idea general de cómo defenderse contra las vulnerabilidades de seguridad cross-site scripting (XSS) en sus sitios web, pero no hemos entrado en muchos detalles. El tema de la seguridad web es importante, y puede que quiera dedicar algo de tiempo a aprender más sobre él. Además de XSS, merece la pena aprender sobre la cabecera HTTP <codeinline>Content-Security-Policy</codeinline> y entender cómo CSP le permite pedir al navegador web que restrinja las capacidades que concede al código JavaScript. También es importante entender CORS (Cross-Origin Resource Sharing).</p>
  </section>
  <section id="15-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.4 WebAssembly</h2>
    <p>WebAssembly (o "wasm") es un formato de código de bytes de máquina virtual de bajo nivel diseñado para integrarse bien con los intérpretes de JavaScript de los navegadores web. Existen compiladores que permiten compilar programas C, C++ y Rust a bytecode WebAssembly y ejecutarlos en navegadores web a una velocidad cercana a la nativa, sin romper el sandbox del navegador ni el modelo de seguridad. WebAssembly puede exportar funciones que pueden ser invocadas por programas JavaScript. Un caso típico de uso de WebAssembly sería compilar la biblioteca estándar de compresión zlib en lenguaje C para que el código JavaScript tenga acceso a algoritmos de compresión y descompresión de alta velocidad. Más información en <a href="https://webassembly.org">https://webassembly.org</a>.</p>
  </section>
  <section id="15-5">
    <h2>15.15.5 Más funciones para documentos y ventanas</h2>
    <p>Los objetos Ventana y Documento tienen una serie de características que no se han
      tratado en este capítulo:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El objeto Window define los métodos <codeinline>alert()</codeinline>, <codeinline>confirm()</codeinline> y <codeinline>prompt()</codeinline> que muestran diálogos modales simples al usuario. Estos métodos bloquean el hilo principal. El método <codeinline>confirm()</codeinline> devuelve de forma sincrónica un valor booleano, y <codeinline>prompt()</codeinline> devuelve de forma sincrónica una cadena de texto introducida por el usuario. No son adecuados para uso productivo, pero pueden ser útiles para proyectos y prototipos sencillos.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las propiedades <codeinline>navigator</codeinline> y <codeinline>screen</codeinline> del objeto Ventana se mencionaron de pasada al principio de este capítulo, pero los objetos Navegador y Pantalla a los que hacen referencia tienen algunas características que no se describieron aquí y que pueden resultarle útiles.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El método <codeinline>requestFullscreen()</codeinline> de cualquier objeto Element solicita que ese elemento (un elemento <codeinline>&lt;video></codeinline> o <codeinline>&lt;canvas></codeinline>, por ejemplo) se muestre en modo de pantalla completa. El método <codeinline>exitFullscreen()</codeinline> del documento vuelve al modo de visualización normal.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El método <codeinline>requestAnimationFrame()</codeinline> del objeto Window toma una función como argumento y la ejecuta cuando el navegador se prepara para renderizar el siguiente fotograma. Cuando se realizan cambios visuales (especialmente repetidos o animados), envolver el código con una llamada a <codeinline>requestAnimationFrame()</codeinline> puede ayudar a asegurar que los cambios se renderizan sin problemas y de forma optimizada por el navegador.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si el usuario selecciona texto dentro de su documento, puede obtener detalles de esa selección con el método <codeinline>getSelection()</codeinline> de Window y obtener el texto seleccionado con <codeinline>getSelection().toString()</codeinline>. En algunos navegadores, <codeinline>navigator.clipboard</codeinline> es un objeto con una API asíncrona para leer y establecer el contenido del sistema portapapeles para permitir interacciones de copiar y pegar con aplicaciones fuera del navegador.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Una característica poco conocida de los navegadores web es que los elementos HTML con un atributo <codeinline>contenteditable="true"</codeinline> permiten editar su contenido. El método <codeinline>document.execCommand()</codeinline> habilita las funciones de edición de texto enriquecido para contenido editable.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un MutationObserver permite a JavaScript monitorizar los cambios en, o por debajo de, un elemento específico del documento. Cree un MutationObserver con el constructor <codeinline>MutationObserver()</codeinline>, pasando la función callback que debe ser llamada cuando se realicen cambios. A continuación, llame al método <codeinline>observe()</codeinline> del MutationObserver para especificar qué partes de qué elemento deben ser monitorizadas.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un IntersectionObserver permite a JavaScript determinar qué elementos del documento están en la pantalla y cuáles están cerca de estarlo. Resulta especialmente útil para aplicaciones que desean cargar contenido de forma dinámica a medida que el usuario se desplaza.
        </p>
      </li>
    </ul>
  </section>
  <section id="15-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.6 Eventos</h2>
    <p>La gran cantidad y diversidad de eventos que admite la plataforma web puede resultar desalentadora. En este capítulo se han tratado diversos tipos de eventos, pero aquí te ofrecemos algunos más que pueden resultarte útiles:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los navegadores disparan eventos "online" y "offline" en el objeto Window cuando el navegador obtiene o pierde una conexión a Internet.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los navegadores disparan un evento "visiblitychange" en el objeto Document cuando un documento se vuelve visible o invisible (normalmente porque un usuario ha cambiado de pestaña). JavaScript puede comprobar <codeinline>document.visibilityState</codeinline> para determinar si su documento es actualmente "visible" u "oculto".
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los navegadores disponen de una complicada API que permite arrastrar y soltar interfaces de usuario y facilita el intercambio de datos con aplicaciones externas al navegador. Esta API incluye una serie de eventos, como "dragstart", "dragover", "dragend" y "drop". Esta API es complicada de utilizar correctamente, pero útil cuando se necesita. Es una API importante que debes conocer si quieres permitir a los usuarios arrastrar archivos desde su escritorio a tu aplicación web.
        </p>
      </li>
  
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de bloqueo del puntero permite a JavaScript ocultar el puntero del ratón y obtener eventos de ratón sin procesar como cantidades de movimiento relativas en lugar de posiciones absolutas en la pantalla. Esto suele ser útil para los juegos. Llame a <codeinline>requestPointerLock()</codeinline> en el elemento al que desea que se dirijan todos los eventos del ratón. Después de hacer esto, los eventos "mousemove" enviados a ese elemento tendrán las propiedades <codeinline>movementX</codeinline> y <codeinline>movementY</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de bloqueo del puntero permite a JavaScript ocultar el puntero del ratón y obtener eventos de ratón sin procesar como cantidades de movimiento relativas en lugar de posiciones absolutas en la pantalla. Esto suele ser útil para los juegos. Llame a <codeinline>requestPointerLock()</codeinline> en el elemento al que desea que se dirijan todos los eventos del ratón. Después de hacer esto, los eventos "mousemove" enviados a ese elemento tendrán las propiedades <codeinline>movementX</codeinline> y <codeinline>movementY</codeinline>.
        </p>
      </li>
      <li class="font-normal">La API Gamepad añade soporte para mandos de juegos. Utilice <codeinline>navigator.getGamepads()</codeinline> para obtener objetos Gamepad conectados, y escuche los eventos "gamepadconnected" en el objeto Window para ser notificado cuando se conecte un nuevo mando. El objeto Gamepad define una API para consultar el estado actual de los botones del mando.</li>
    </ul>
  </section>
  <section id="15-7">
    <h2>15.15.7 Aplicaciones web progresivas y Service Workers</h2>
    <p>El término <em>Aplicaciones Web Progresivas</em>, o PWA, es una palabra de moda que describe las aplicaciones web que se construyen utilizando algunas tecnologías clave. Una documentación cuidadosa de estas tecnologías clave requeriría un libro propio, y no las he cubierto en este capítulo, pero deberías ser consciente de todas estas APIs. Vale la pena señalar que las API modernas y potentes como éstas están diseñadas normalmente para funcionar sólo en conexiones HTTPS seguras. Los sitios web que aún utilicen URLs <codeinline>http://</codeinline> no podrán aprovecharlas:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un ServiceWorker es un tipo de hilo trabajador con la capacidad de interceptar, inspeccionar y responder a peticiones de red de la aplicación web a la que "sirve". Cuando una aplicación web registra un trabajador de servicio, el código de ese trabajador se vuelve persistente en el almacenamiento local del navegador, y cuando el usuario vuelve a visitar el sitio web asociado, el trabajador de servicio se reactiva. Los service workers pueden almacenar en caché las respuestas de la red (incluidos los archivos de código JavaScript), lo que significa que las aplicaciones web que utilizan service workers pueden instalarse en el ordenador del usuario para un inicio rápido y un uso sin conexión. El <em>Service Worker Cookbook</em> en <a href="https://serviceworke.rs">https://serviceworke.rs</a> es un valioso recurso para aprender sobre service workers y sus tecnologías relacionadas.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de caché está diseñada para ser utilizada por los trabajadores de servicio (pero también está disponible para código JavaScript regular fuera de los trabajadores). Funciona con los objetos Request y Response definidos por la API <codeinline>fetch()</codeinline> e implementa una caché de pares Request/Response. La API de caché permite a un trabajador de servicios almacenar en caché los scripts y otros activos de la aplicación web que sirve y también puede ayudar a permitir el uso sin conexión de la aplicación web (que es particularmente importante para los dispositivos móviles).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un manifiesto web es un archivo con formato JSON que describe una aplicación web e incluye un nombre, una URL y enlaces a iconos de distintos tamaños. Si tu aplicación web utiliza un service worker e incluye una etiqueta <codeinline>&lt;link rel="manifest"></codeinline> que haga referencia a un archivo <codeinline>.web</codeinline> manifest, los navegadores (especialmente los navegadores de dispositivos móviles) pueden ofrecerte la opción de añadir un icono de la aplicación web a tu escritorio o pantalla de inicio.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de notificaciones permite a las aplicaciones web mostrar notificaciones utilizando el sistema de notificaciones nativo del sistema operativo, tanto en dispositivos móviles como de sobremesa. Las notificaciones pueden incluir una imagen y texto, y su código puede recibir un evento si el usuario hace clic en en la notificación. El uso de esta API se complica por el hecho de que primero debe solicitar el permiso del usuario para mostrar notificaciones.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API Push permite a las aplicaciones web que disponen de un service worker (y que cuentan con el permiso del usuario) suscribirse a las notificaciones de un servidor y mostrarlas incluso cuando la propia aplicación no se está ejecutando. Las notificaciones Push son habituales en los dispositivos móviles, y la API Push acerca las aplicaciones web a la paridad de prestaciones con las aplicaciones nativas en móviles.
        </p>
      </li>
    </ul>
  </section>
  <section id="15-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.8 API para dispositivos móviles</h2>
    <p>Hay una serie de API web que son útiles principalmente para aplicaciones web que se ejecutan en dispositivos móviles. (Por desgracia, varias de estas API solo funcionan en dispositivos Android y no en iOS).</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de geolocalización permite a JavaScript (con el permiso del usuario) determinar la ubicación física del usuario. Es compatible con dispositivos móviles y de escritorio, incluidos los dispositivos iOS. Utilice <codeinline>navigator.geolocation.getCurrentPosition()</codeinline> para solicitar la posición actual del usuario y utilice <codeinline>navigator.geolocation.watchPosition()</codeinline> para registrar una llamada de retorno a la que llamar cuando cambie la posición del usuario.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El método <codeinline>navigator.vibrate()</codeinline> hace que un dispositivo móvil (pero no iOS) vibre. A menudo esto sólo se permite en respuesta a un gesto del usuario, pero llamar a este método permitirá a su aplicación para proporcionar retroalimentación silenciosa que un gesto ha sido reconocido.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API ScreenOrientation permite a una aplicación web consultar la orientación actual de la pantalla de un dispositivo móvil y también bloquearse en la orientación horizontal o vertical.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los eventos "devicemotion" y "deviceorientation" del objeto ventana informan de los datos del acelerómetro y el magnetómetro del dispositivo, lo que permite determinar cómo se acelera el dispositivo y cómo lo orienta el usuario en el espacio. (Estos eventos sí funcionan en iOS).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La API de sensores aún no es ampliamente compatible más allá de Chrome en dispositivos Android, pero permite a JavaScript acceder a todo el conjunto de sensores de dispositivos móviles, incluidos el acelerómetro, el giroscopio, el magnetómetro y el sensor de luz ambiental. Estos sensores permiten a JavaScript determinar en qué dirección mira un usuario o detectar, por ejemplo, si el usuario agita el teléfono.
        </p>
      </li>
    </ul>
  </section>
  <section id="15-9">
    <h2>15.15.9 API binarias</h2>
    <p>Las matrices tipadas, ArrayBuffers y la clase DataView (todas ellas tratadas en <a href="capitulo-11#2">§11.2</a> ) permiten a Java-Script trabajar con datos binarios. Como se ha descrito anteriormente en este capítulo, la API <codeinline>fetch()</codeinline> permite a los programas JavaScript cargar datos binarios a través de la red. Otra fuente de datos binarios son los archivos del sistema de archivos local del usuario. Por razones de seguridad, JavaScript no puede leer sólo archivos locales. Pero si el usuario selecciona un archivo para cargarlo (usando un elemento de formulario <codeinline>&lt;input type="file></codeinline>) o usa arrastrar y soltar para soltar un archivo en su aplicación web, entonces JavaScript puede acceder a ese archivo como un objeto File.</p>
    <p>File es una subclase de Blob, y como tal, es una representación opaca de un trozo de datos. Puedes utilizar una clase FileReader para obtener de forma asíncrona el contenido de un archivo como un ArrayBuffer o una cadena. (En algunos navegadores, puedes omitir el FileReader y en su lugar utilizar los métodos <codeinline>text()</codeinline> y <codeinline>arrayBuffer()</codeinline> basados en Promise definidos por la clase Blob, o el método <codeinline>stream()</codeinline> para el acceso en streaming al contenido del archivo).</p>
    <p>Cuando se trabaja con datos binarios, especialmente en streaming de datos binarios, puede ser necesario decodificar bytes en texto o codificar texto como bytes. Las clases TextEncoder y TextDecoder ayudan en esta tarea.</p>
  </section>
  <section id="15-10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.10 API multimedia</h2>
    <p>La función <codeinline>navigator.mediaDevices.getUserMedia()</codeinline> permite a JavaScript solicitar acceso al micrófono y/o cámara de vídeo del usuario. Si la solicitud tiene éxito, se obtiene un objeto MediaStream. Las secuencias de vídeo pueden mostrarse en una etiqueta <codeinline>&lt;video></codeinline> (estableciendo la propiedad <codeinline>srcObject</codeinline> en la secuencia). Los fotogramas del vídeo se pueden capturar en un <codeinline>&lt;canvas></codeinline> fuera de pantalla con la función canvas <codeinline>drawImage()</codeinline>, lo que da como resultado una fotografía de relativamente baja resolución. Los flujos de audio y video devueltos por <codeinline>getUserMedia()</codeinline> pueden ser grabados y codificados en un Blob con un objeto MediaRecorder.</p>
    <p>La API WebRTC, más compleja, permite la transmisión y recepción de flujos multimedia a través de la red, lo que posibilita, por ejemplo, las videoconferencias entre iguales.</p>
  </section>
  <section id="15-11" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>15.15.11 Criptografía y API relacionadas</h2>
    <p>La propiedad <codeinline>crypto</codeinline> del objeto Window expone un método <codeinline>getRandomValues()</codeinline> para números pseudoaleatorios criptográficamente seguros. Otros métodos de cifrado, descifrado, generación de claves, firmas digitales, etc. están disponibles a través de <codeinline>crypto.subtle</codeinline>. El nombre de esta propiedad es una advertencia a todos los que utilizan estos métodos de que el uso adecuado de algoritmos criptográficos es difícil y que no se deben utilizar estos métodos a menos que realmente sepas lo que estás haciendo. Además, los métodos de <codeinline>crypto.subtle</codeinline> sólo están disponibles para el código JavaScript que se ejecuta dentro de documentos que se cargaron a través de una conexión HTTPS segura.</p>
    <p>La API de gestión de credenciales y la API de autenticación web permiten que JavaScript genere, almacene y recupere credenciales de clave pública (y de otros tipos) y permite la creación de cuentas y el inicio de sesión sin contraseñas. La API de JavaScript consiste principalmente en las funciones <codeinline>navigator.credentials.create()</codeinline> y <codeinline>navigator.credentials.get()</codeinline>, pero se requiere una infraestructura importante en el lado del servidor para que estos métodos funcionen. Estas API aún no están soportadas universalmente, pero tienen el potencial de revolucionar la forma en que iniciamos sesión en los sitios web.</p>
    <p>La API de solicitud de pago añade soporte de navegador para realizar pagos con tarjeta de crédito en la web. Permite a los usuarios almacenar sus datos de pago de forma segura en el navegador para que no tengan que teclear el número de su tarjeta de crédito cada vez que realicen una compra. Las aplicaciones web que desean solicitar un pago crean un objeto PaymentRequest y llaman a su método <codeinline>show()</codeinline> para mostrar la solicitud al usuario.</p>
  </section>
</Layoutjavascript>