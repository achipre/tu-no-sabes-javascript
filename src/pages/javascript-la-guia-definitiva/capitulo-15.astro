---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-14" capSiguiente="capitulo-16" />
  <section class="fadeIn">
    <h1>JavaScript en los navegadores web</h1>
    <p>El lenguaje JavaScript se creó en 1994 con el propósito expreso de permitir el comportamiento dinámico de en los documentos mostrados por los navegadores web. Desde entonces, el lenguaje ha evolucionado significativamente y, al mismo tiempo, el alcance y las capacidades de la plataforma web han crecido de forma explosiva. Hoy en día, los programadores de JavaScript pueden considerar la web como una plataforma completa para el desarrollo de aplicaciones. Los navegadores web están especializados en la visualización de texto formateado e imágenes, pero, al igual que los sistemas operativos nativos, los navegadores también proporcionan otros servicios, como gráficos, vídeo, audio, redes, almacenamiento y subprocesos. JavaScript es el lenguaje que permite a las aplicaciones web utilizar los servicios proporcionados por la plataforma web, y este capítulo muestra cómo utilizar los más importantes de estos servicios.</p>
    <p>El capítulo comienza con el modelo de programación de la plataforma web, explicando cómo se incrustan los scripts en las páginas HTML (§15.1) y cómo el código JavaScript se activa de forma asíncrona mediante eventos (§15.2). Las secciones que siguen a este material introductorio documentan las principales API de JavaScript que permiten a las aplicaciones web:</p>
    <p>Los temas de metaprogramación tratados en este capítulo incluyen:</p>
    <ul>
      <li class="font-normal">Controlar el contenido del documento (§15.3) y el estilo (§15.4)</li>
      <li class="font-normal">Determinar la posición en pantalla de los elementos del documento (§15.5)</li>
      <li class="font-normal">Crear componentes de interfaz de usuario reutilizables (§15.6)</li>
      <li class="font-normal">Dibujar gráficos (§15.7 y §15.8)</li>
      <li class="font-normal">Reproducir y generar sonidos (§15.9)</li>
      <li class="font-normal">Gestionar la navegación y el historial del navegador (§15.10)</li>
      <li class="font-normal">Intercambiar datos a través de la red (§15.11)</li>
      <li class="font-normal">Almacenar datos en el ordenador del usuario (§15.12)</li>
      <li class="font-normal">Realizar cálculos concurrentes con hilos (§15.13)</li>
    </ul>
    <article>
      <p class="title-article">JavaScript del lado del cliente</p>
      <p>En este libro, y en la web, verás el término "JavaScript del lado del cliente". El término es simplemente un sinónimo de JavaScript escrito para ejecutarse en un navegador web, y se contrapone al código "del lado del servidor", que se ejecuta en servidores web.</p>
      <p>Los dos "lados" se refieren a los dos extremos de la conexión de red que separan el servidor web y el navegador web, y el desarrollo de software para la web suele requerir que el código se escriba en ambos "lados". El lado del cliente y el lado del servidor también suelen llamarse "frontend" y "backend".</p>
    </article>
    <p>Las ediciones anteriores de este libro intentaban cubrir de forma exhaustiva todas las API de JavaScript definidas por los navegadores web y, como resultado, este libro era demasiado largo hace una década. El número y la complejidad de las API web no han dejado de crecer, y ya no creo que tenga sentido intentar abarcarlas todas en un solo libro. A partir de la séptima edición, mi objetivo es cubrir definitivamente el lenguaje JavaScript y proporcionar una introducción en profundidad al uso del lenguaje con Node y con los navegadores web. Este capítulo no puede cubrir todas las API web, pero presenta las más importantes con suficiente detalle como para que puedas empezar a usarlas de inmediato. Y, habiendo aprendido sobre las APIs principales cubiertas aquí, deberías ser capaz de coger nuevas APIs (como las resumidas en §15.15) cuando y si los necesita.</p>
    <p>Node tiene una única implementación y una única fuente autorizada de documentación. En cambio, las API web se definen por consenso entre los principales proveedores de navegadores web, y la documentación autorizada adopta la forma de una especificación destinada a los programadores de C++ que implementan la API, no a los programadores de JavaScript que la utilizarán. Afortunadamente, el proyecto "MDN web docs" de Mozilla es una <sup>fuente1</sup> fiable y completa de documentación sobre API web.</p>
    <article>
      <p class="title-article">API heredadas</p>
      <p>En los 25 años transcurridos desde el lanzamiento de JavaScript, los fabricantes de navegadores han ido añadiendo funciones y API para uso de los programadores. Muchas de esas API han quedado obsoletas. Entre ellas están:</p>
      <ul> <li class="font-normal">API propietarias que nunca se estandarizaron y/o nunca fueron implementadas
          por otros proveedores de navegadores. Internet Explorer de Microsoft definió
          muchas de estas API. Algunas (como la propiedad innerHTML) resultaron útiles y acabaron
          estandarizándose. Otros (como el método attachEvent()) llevan años obsoletos.</li>
        <li class="font-normal">APIs ineficientes (como el método document.write()) que tienen un impacto
          tan severo en el rendimiento que su uso ya no se considera aceptable.</li>
        <li class="font-normal">APIs obsoletas que hace tiempo que han sido sustituidas por nuevas APIs para
          conseguir lo mismo. Un ejemplo es document.bgColor, que se definió para
          permitir a Java Script establecer el color de fondo de un documento. Con la
          llegada de CSS, document.bgColor se convirtió en un pintoresco caso especial
          sin ningún propósito real.</li>
        <li class="font-normal">API mal diseñadas que han sido sustituidas por otras mejores. En los inicios de la
          web, los comités de normalización definieron la API clave del Modelo de Objetos
          de Documento de forma agnóstica al lenguaje, de modo que la misma API
          pudiera utilizarse en programas Java para trabajar con documentos XML y en
          programas JavaScript para trabajar con documentos HTML. El resultado fue una
          API que no se adaptaba bien al lenguaje JavaScript y que tenía características que
          no interesaban especialmente a los programadores web. Se tardó décadas en
          recuperarse de aquellos primeros errores de diseño, pero los navegadores web
          actuales soportan un Modelo de Objetos de Documento muy mejorado.</li>
      </ul>
      <p>Los vendedores de navegadores pueden necesitar dar soporte a estas APIs heredadas
        en un futuro previsible para asegurar la compatibilidad con versiones anteriores, pero
        ya no hay necesidad de que este libro las documente o de que tú aprendas sobre ellas.
        La plataforma web ha madurado y se ha estabilizado, y si eres un desarrollador web
        experimentado que recuerda la cuarta o quinta edición de este libro, entonces puede
        que tengas tanto conocimiento obsoleto que olvidar como nuevo material que
        aprender.</p>
    </article>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1 Conceptos básicos de programación web</h2>
    <p>Esta sección explica cómo se estructuran los programas JavaScript para la web, cómo se cargan en un navegador web, cómo obtienen la entrada, cómo producen la salida y cómo se ejecutan de forma asíncrona respondiendo a eventos.</p>
  </section>
  <section id="1-1">
    <h2>15.1.1 JavaScript en etiquetas HTML &lt;script></h2>
    <p>Los navegadores web muestran documentos HTML. Si desea que un navegador web ejecute código Java-Script, debe incluir (o hacer referencia a) ese código desde un documento HTML, y esto es lo que hace la etiqueta HTML &lt;script>.</p>
    <p>El código JavaScript puede aparecer en línea dentro de un archivo HTML entre &lt;script> y &lt;/script>. He aquí, por ejemplo, un archivo HTML que incluye una etiqueta script con código JavaScript que actualiza dinámicamente un elemento del documento para que se comporte como un reloj digital:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Aunque el código JavaScript puede incrustarse directamente dentro de una etiqueta &lt;script>, es más habitual utilizar el atributo src de la etiqueta &lt;script> para especificar la URL (una URL absoluta o una URL relativa a la URL del archivo HTML que se muestra) de un archivo que contiene código JavaScript. Si sacáramos el código JavaScript de este archivo HTML y lo almacenáramos en su propio archivo scripts/digital_clock.js, entonces la etiqueta &lt;script> podría hacer referencia a ese archivo de código de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Un archivo JavaScript contiene JavaScript puro, sin etiquetas &lt;script> ni ningún otro HTML. Por convención, los archivos de código JavaScript tienen nombres que terminan en .js.</p>
    <p>Una etiqueta &lt;script> con el atributo src se comporta exactamente igual que si el contenido del archivo JavaScript especificado apareciera directamente entre las etiquetas &lt;script> y &lt;/script>. Tenga en cuenta que la etiqueta &lt;/script> de cierre es necesaria en los documentos HTML incluso cuando se especifica el atributo src: HTML no admite la etiqueta &lt;script/>.</p>
    <p>Utilizar el atributo src tiene una serie de ventajas:</p>
    <ul>
      <li class="font-normal">Simplifica sus archivos HTML al permitirle eliminar de ellos grandes bloques de código Java-Script, es decir, ayuda a mantener separados el contenido y el comportamiento.</li>
      <li class="font-normal">Cuando varias páginas web comparten el mismo código JavaScript, el uso del atributo src permite mantener una sola copia de ese código, en lugar de tener que editar cada archivo HTML cuando cambia el código.</li>
      <li class="font-normal">Si más de una página comparte un archivo de código JavaScript, sólo tendrá que descargarlo una vez la primera página que lo utilice; las siguientes podrán recuperarlo de la caché del navegador.</li>
      <li class="font-normal">Dado que el atributo src toma como valor una URL arbitraria, un programa JavaScript o una página web de un servidor web pueden emplear código exportado por otros servidores web. Gran parte de la publicidad en Internet se basa en este hecho.</li>
    </ul>
    <p class="title-article text-left">Módulos</p>
    <p>§10.3 documenta los módulos JavaScript y cubre sus directivas import y export. Si ha escrito su programa JavaScript utilizando módulos (y no ha utilizado una herramienta de agrupación de código para combinar todos sus módulos en un único archivo JavaScript no modular), debe cargar el módulo de nivel superior de su programa con una directiva &lt;script> que tenga un atributo type="module". Si haces esto, el módulo que especifiques se cargará, y todos los módulos que importe se cargarán, y (recur- sivamente) todos los módulos que importen se cargarán. Para más información, véase §10.3.5.</p>
    <p class="title-article text-left">Especificación del tipo de script</p>
    <p>En los primeros días de la web, se pensaba que los navegadores podrían implementar algún día lenguajes distintos de JavaScript, y los programadores añadían atributos como language="javascript" y type="application/javascript" a sus etiquetas &lt;script>. Esto es completamente innecesario. JavaScript es el lenguaje por defecto (y el único) de la web. El atributo language está obsoleto, y sólo hay dos razones para usar un atributo type en una etiqueta &lt;script>:</p>
    <ul>
      <li class="font-normal">Para especificar que el script es un módulo</li>
      <li class="font-normal">Para incrustar datos en una página web sin mostrarlos (véase §15.3.4)</li>
    </ul>
    <p class="title-article text-left">Cuándo se ejecutan los scripts: async y diferido</p>
    <p>Cuando JavaScript se incorporó por primera vez a los navegadores web, no existía una API para recorrer y manipular la estructura y el contenido de un documento ya renderizado. La única forma en que el código JavaScript podía afectar al contenido de un documento era generando ese contenido sobre la marcha mientras el documento estaba en proceso de carga. Para ello utilizando el método document.write() para inyectar texto HTML en el documento en la ubicación del script.</p>
    <p>El uso de document.write() ya no se considera un buen estilo, pero el hecho de que sea posible significa que cuando el analizador HTML encuentra un elemento &lt;script>, debe, por defecto, ejecutar el script sólo para asegurarse de que no produce ninguna salida HTML antes de que pueda reanudar el análisis y la representación del documento. Esto puede ralentizar drásticamente el análisis y la representación de la página web.</p>
    <p>Afortunadamente, este modo de ejecución de scripts síncrono o de bloqueo por defecto no es la única opción. La etiqueta &lt;script> puede tener atributos defer y async, que hacen que los scripts se ejecuten de forma diferente. Se trata de atributos booleanos: no tienen valor; sólo tienen que estar presentes en la etiqueta &lt;script>. Ten en cuenta que estos atributos sólo son significativos cuando se utilizan junto con el atributo src:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Tanto el atributo defer como el async son formas de indicar al navegador que el script enlazado no utiliza document.write() para generar la salida HTML, y que el navegador, por lo tanto, puede continuar analizando y renderizando el documento mientras descarga el script. El atributo defer hace que el navegador aplace la ejecución del script hasta que el documento haya sido completamente cargado y analizado y esté listo para ser manipulado. El atributo async hace que el navegador ejecute el script lo antes posible, pero no bloquea el análisis del documento mientras se descarga el script. Si una etiqueta &lt;script> tiene ambos atributos, el atributo async tiene preferencia.</p>
    <p>Tenga en cuenta que los scripts diferidos se ejecutan en el orden en que aparecen en el documento. Los scripts asíncronos se ejecutan a medida que se cargan, lo que significa que pueden ejecutarse fuera de orden.</p>
    <p>Los scripts con el atributo type="module" se ejecutan, por defecto, después de que el documento se haya cargado, como si tuvieran el atributo defer. Puedes anular este valor por defecto con el atributo async, que hará que el código se ejecute tan pronto como el módulo y todas sus dependencias se hayan cargado.</p>
    <p>Una alternativa sencilla a los atributos async y defer -especialmente para el código que se incluye directamente en el HTML- es simplemente colocar tus scripts al final del archivo HTML. De esta forma, el script puede ejecutarse sabiendo que el contenido del documento que le precede ha sido analizado y está listo para ser manipulado.</p>
    <p class="title-article text-left">Carga de guiones a petición</p>
    <p>A veces, puede tener código JavaScript que no se utiliza cuando un documento se carga por primera vez y sólo se necesita si el usuario realiza alguna acción como pulsar un botón o abrir un menú. Si está desarrollando su código utilizando módulos, puede cargar un módulo bajo demanda con import(), como se describe en §10.3.6.</p>
    <p>Si no utiliza módulos, puede cargar un archivo de JavaScript bajo demanda simplemente añadiendo una etiqueta &lt;script> a su documento cuando desee que se cargue el script:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Esta función importScript() utiliza las API del DOM (§15.3) para crear una nueva etiqueta &lt;script> y añadirla al documento <head>. Y utiliza manejadores de eventos (§15.2) para determinar cuando el script se ha cargado correctamente o cuando la carga ha fallado.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.2 El modelo de objetos del documento</h2>
    <p>Uno de los objetos más importantes en la programación JavaScript del lado del cliente es el objeto Document, que representa el documento HTML que se muestra en una ventana o pestaña del navegador. La API para trabajar con documentos HTML se conoce como el Modelo de Objetos de Documento, o DOM, y se cubre en detalle en §15.3. Pero el DOM es tan importante para la programación JavaScript del lado del cliente que merece ser introducido aquí.</p>
    <p>Los documentos HTML contienen elementos HTML anidados unos dentro de otros, formando un árbol. Considere el siguiente documento HTML sencillo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La etiqueta &lt;html> de nivel superior contiene las etiquetas &lt;head> y &lt;body>. La etiqueta &lt;head> contiene un &lt;title>. Y la etiqueta &lt;body> contiene las etiquetas &lt;h1> y &lt;p>. Las etiquetas &lt;title> y &lt;h1> contienen cadenas de texto, y la etiqueta &lt;p> contiene dos cadenas de texto con una etiqueta &lt;i> entre ellas.</p>
    <p>La API DOM refleja la estructura de árbol de un documento HTML. A cada etiqueta HTML del documento le corresponde un objeto Elemento de JavaScript, y a cada segmento de texto del documento le corresponde un objeto Texto. Los objetos Element y las clases de texto, así como la propia clase Document, son todas subclases de la clase más general Node, y los objetos Node están organizados en una estructura de árbol que JavaScript puede consultar y recorrer utilizando la API DOM. La representación DOM de este documento e s el árbol que se muestra en la Figura 15-1.</p>
    <figure id="figure15-1">
      <img src="/public/javascript/capitulo-15/figure15-1.avif" alt="imagen de consola">
      <figcaption>Figura 15-1. Representación en árbol de un documento HTML</figcaption>
    </figure>
    <p>Si aún no está familiarizado con las estructuras de árbol en programación informática, es útil saber que toman prestada la terminología de los árboles genealógicos. El nodo situado justo encima de un nodo es su padre. Los nodos situados un nivel por debajo de otro nodo son sus hijos. Los nodos del mismo nivel y con el mismo padre son hermanos. El conjunto de nodos situados cualquier número de niveles por debajo de otro nodo son los descendientes de ese nodo. Y el padre, el abuelo y todos los demás nodos situados por encima de un nodo son los antepasados de ese nodo.</p>
    <p>La API DOM incluye métodos para crear nuevos nodos Element y Text, y para insertarlos en el documento como hijos de otros objetos Element. También hay métodos para mover elementos dentro del documento y para eliminarlos por completo. Mientras que una aplicación del lado del servidor puede producir una salida de texto plano escribiendo cadenas con console.log(), una aplicación JavaScript del lado del cliente puede producir una salida HTML formateada construyendo o manipulando el documento del árbol de documentos utilizando la API DOM.</p>
    <p>Hay una clase de JavaScript que corresponde a cada tipo de etiqueta HTML, y cada aparición de la etiqueta en un documento está representada por una instancia de la clase. La etiqueta &lt;body>, por ejemplo, está representada por una instancia de HTMLBodyElement, y una etiqueta &lt;table> está representada por una instancia de HTMLTableElement. Los objetos elemento de JavaScript tienen propiedades que corresponden a los atributos HTML de las etiquetas. En</p>
    <p>Por ejemplo, las instancias de HTMLImageElement, que representan etiquetas &lt;img>, tienen una propiedad src que corresponde al atributo src de la etiqueta. El valor inicial de la propiedad src es el valor del atributo que aparece en la etiqueta HTML, y establecer esta propiedad con JavaScript cambia el valor del atributo HTML (y hace que el navegador cargue y muestre una nueva imagen). La mayoría de las clases de elementos de JavaScript se limitan a reflejar los atributos de una etiqueta HTML, pero algunas definen métodos adicionales. Las clases HTMLAu- dioElement y HTMLVideoElement, por ejemplo, definen métodos como play() y pause() para controlar la reproducción de archivos de audio y vídeo.</p>
  </section>
  <section id="1-3">
    <h2>15.1.3 El objeto global en los navegadores web</h2>
    <p>Existe un objeto global por cada ventana o pestaña del navegador (§3.7). Todo el código JavaScript (excepto el código que se ejecuta en hilos de trabajo; véase §15.13) que se ejecuta en esa ventana comparte este único objeto global. Esto es así independientemente de cuántos scripts o módulos haya en el documento: todos los scripts y módulos de un documento comparten un único objeto global; si un script define una propiedad en ese objeto, esa propiedad es visible también para todos los demás scripts.</p>
    <p>El objeto global es donde se define la biblioteca estándar de JavaScript: la función parseInt(), el objeto Math, la clase Set, etc. En los navegadores web, el objeto global también contiene los principales puntos de entrada de varias API web. Por ejemplo, la propiedad document representa el documento mostrado actualmente, el método fetch() realiza peticiones de red HTTP y el constructor Audio() permite a los programas JavaScript reproducir sonidos.</p>
    <p>En los navegadores web, el objeto global tiene una doble función: además de definir tipos y funciones incorporadas, también representa la ventana actual del navegador web y define propiedades como history (§15.10.2), que representa el historial de navegación de la ventana, e innerWidth, que contiene el ancho de la ventana en píxeles. Una de las propiedades de este objeto global se llama window, y su valor es el propio objeto global. Esto significa que puedes simplemente escribir window para referirte al objeto global en tu código del lado del cliente. Cuando se utilizan características específicas de la ventana, a menudo es una buena idea incluir un prefijo window.: window.innerWidth es más claro que innerWidth, por ejemplo.</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.4 Los scripts comparten un espacio de nombres</h2>
    <p>Con los módulos, las constantes, variables, funciones y clases definidas en el nivel superior (es decir, fuera de cualquier definición de función o clase) del módulo son privadas para el módulo a menos que se exporten explícitamente, en cuyo caso, pueden ser importadas selectivamente por otros módulos. (Tenga en cuenta que esta propiedad de los módulos también es respetada por las herramientas de agrupación de código).</p>
    <p>Sin embargo, con los scripts que no son módulos, la situación es completamente diferente. Si el código de nivel superior de un script define una constante, variable, función o clase, esa declaración será visible para todos los demás scripts del mismo documento. Si un script define una función f() y otro script define una clase c, entonces un tercer script puede invocar la función e instanciar la clase sin tener que realizar ninguna acción para importarlos. Por lo tanto, si no utiliza módulos, los scripts independientes de su documento comparten un único espacio de nombres y se comportan como si formaran parte de un único script mayor. Esto puede ser conveniente para programas pequeños, pero la necesidad de evitar conflictos de nombres puede volverse problemática para programas más grandes, especialmente cuando algunos de los scripts son bibliotecas de terceros.</p>
    <p>Las declaraciones var y function en el nivel superior crean propiedades en el objeto global compartido. Si un script define una función de nivel superior f(), entonces otro script en el mismo documento puede invocar esa función como f() o como window.f(). Por otro lado, las declaraciones const, let y class de ES6, cuando se utilizan en el nivel superior, no crean propiedades en el objeto global. Sin embargo, siguen estando definidas en un espacio de nombres compartido: si un script define una clase C, otros scripts podrán crear instancias de esa clase con new C(), pero no con new window.C().</p>
    <p>En resumen: en los módulos, las declaraciones de nivel superior se aplican al módulo y pueden exportarse explícitamente. En los scripts que no son módulos, sin embargo, las declaraciones de nivel superior se refieren al documento que los contiene, y las declaraciones son compartidas por todos los scripts del documento. Las declaraciones var y function más antiguas se comparten a través de las propiedades del objeto global. Las declaraciones const, let y class más recientes también se comparten y tienen el mismo ámbito de documento, pero no existen como propiedades de ningún objeto al que tenga acceso el código JavaScript.</p>
  </section>
  <section id="1-5">
    <h2>15.1.5 Ejecución de programas JavaScript</h2>
    <p>No existe una definición formal de programa en JavaScript del lado del cliente, pero podemos decir que un programa JavaScript consiste en todo el código JavaScript de un documento o al que se hace referencia desde él. Estas partes separadas de código comparten un único objeto Window global, que les da acceso al mismo objeto Document subyacente que representa el documento HTML. Los scripts que no son módulos comparten además un espacio de nombres de nivel superior.</p>
    <p>Si una página web incluye un marco incrustado (utilizando el elemento &lt;iframe>), el código Java-Script en el documento incrustado tiene un objeto global y un objeto Documento diferentes del código en el documento incrustado, y puede considerarse un programa JavaScript independiente. Recuerde, sin embargo, que no existe una definición formal de cuáles son los límites de un programa JavaScript. Si el documento contenedor y el documento contenido se cargan desde el mismo servidor, el código en un documento puede interactuar con el código en el otro, y puede tratarlos como dos partes interactuantes de un único programa, si lo desea. En §15.13.6 se explica cómo un programa JavaScript puede enviar y recibir mensajes hacia y desde el código JavaScript que se ejecuta en un &lt;iframe>.</p>
    <p>La ejecución de un programa JavaScript puede dividirse en dos fases. En la primera fase, se carga el contenido del documento y se ejecuta el código de los elementos &lt;script> (tanto scripts en línea como scripts externos). Por lo general, los scripts se ejecutan en el orden en que aparecen en el documento, aunque este orden predeterminado puede modificarse mediante los atributos async y defer que hemos descrito. El código JavaScript de cualquier script se ejecuta de arriba abajo, sujeto, por supuesto, a los condicionales, bucles y otras sentencias de control de JavaScript. Algunos scripts no hacen realmente nada durante esta primera fase y se limitan a definir funciones y clases para su uso en la segunda fase. Otros scripts pueden realizar un trabajo importante durante la primera fase y no hacer nada en la segunda. Imagina un script al final de un documento que encuentra todas las etiquetas &lt;h1> y &lt;h2> en el documento y modifica el documento generando e insertando una tabla de contenidos al principio del documento. Esto podría hacerse completamente en la primera fase. (Véase en §15.3.6 un ejemplo que hace exactamente esto).</p>
    <p>Una vez cargado el documento y ejecutados todos los scripts, la ejecución de JavaScript entra en su segunda fase. Esta fase es asíncrona y dirigida por eventos. Si un script va a participar en esta segunda fase, entonces una de las cosas que debe haber hecho durante la primera fase es registrar al menos un manejador de eventos u otra función callback que será invocada de forma asíncrona. Durante esta segunda fase dirigida por eventos, el navegador web invoca funciones manejadoras de eventos y otras retrollamadas en respuesta a eventos que ocurren asincrónicamente. Los manejadores de eventos se invocan más comúnmente en respuesta a la entrada del usuario (clics del ratón, pulsaciones de teclas, etc.), pero también pueden ser activados por la actividad de la red, la carga de documentos y recursos, el tiempo transcurrido, o errores en el código JavaScript. Los eventos y los controladores de eventos se describen con detalle en §15.2.</p>
    <p>Algunos de los primeros eventos que se producen durante la fase dirigida por eventos son los eventos "DOMCon- tentLoaded" y "load". "DOMContentLoaded" se activa cuando el documento HTML ha sido completamente cargado y analizado. El evento "load" se activa cuando todos los recursos externos del documento -como las imágenes- también se han cargado por completo. Los programas Java Script a menudo utilizan uno de estos eventos como disparador o señal de inicio. Es común ver programas cuyos scripts definen funciones pero no realizan otra acción que registrar una función manejadora de eventos para ser activada por el evento "load" al comienzo de la fase de ejecución dirigida por eventos. Es este manejador de eventos "load" el que manipula el documento y hace lo que se supone que debe hacer el programa. Tenga en cuenta que es común en la programación JavaScript que una función manejadora de eventos como el manejador de eventos "load" descrito aquí registre otros manejadores de eventos.</p>
    <p>La fase de carga de un programa JavaScript es relativamente corta: idealmente menos de un segundo. Una vez cargado el documento, la fase basada en eventos dura mientras el navegador muestra el documento. Dado que esta fase es asíncrona y basada en eventos, puede haber largos periodos de inactividad en los que no se ejecute JavaScript, interrumpidos por ráfagas de actividad provocadas por eventos del usuario o de la red. A continuación trataremos estas dos fases con más detalle.</p>
    <p class="title-article text-left">Modelo de subprocesamiento de JavaScript en el cliente</p>
    <p>JavaScript es un lenguaje monohilo, y la ejecución monohilo simplifica mucho la programación: puede escribir código con la seguridad de que nunca se ejecutarán dos controladores de eventos al mismo tiempo. Puedes manipular el contenido de un documento sabiendo que ningún otro hilo está intentando modificarlo al mismo tiempo, y nunca tendrás que preocuparte por bloqueos, puntos muertos o condiciones de carrera al escribir código Java-Script.</p>
    <p>La ejecución monohilo significa que los navegadores dejan de responder a las entradas del usuario mientras se ejecutan los scripts y los controladores de eventos. Esto supone una carga para los programadores de JavaScript: significa que los scripts de JavaScript y los controladores de eventos no deben ejecutarse durante demasiado tiempo. Si un script realiza una tarea de cálculo intensivo, provocará un retraso en la carga del documento, y el usuario no verá el contenido del documento hasta que el script finalice. Si un manejador de eventos realiza una tarea computacionalmente intensiva, el navegador puede dejar de responder, posiblemente haciendo que el usuario piense que se ha bloqueado.</p>
    <p>La plataforma web define una forma controlada de concurrencia llamada "web worker". Un web worker es un hilo en segundo plano para realizar tareas de cálculo intensivo sin congelar la interfaz de usuario. El código que se ejecuta en un hilo web worker no tiene acceso al contenido del documento, no comparte ningún estado con el hilo principal o con otros workers, y sólo puede comunicarse con el hilo principal y con otros workers de a través de eventos de mensajes asíncronos, por lo que la concurrencia no es detectable para el hilo principal, y los web workers no alteran el modelo básico de ejecución de un solo hilo de los programas JavaScript. Véase §15.13 para más detalles sobre el mecanismo de threading seguro de la web.</p>
    <p class="title-article text-left">Línea de tiempo JavaScript del lado del cliente</p>
    <p>Ya hemos visto que los programas JavaScript comienzan en una fase de ejecución de
      secuencias de comandos y luego pasan a una fase de gestión de eventos. Estas dos
      fases pueden dividirse en los siguientes pasos:</p>
    <ul>
      <li class="font-normal">El navegador web crea un objeto Document y comienza a analizar la página web, añadiendo objetos Element y nodos Text al documento a medida que analiza los elementos HTML y su contenido textual. La propiedad document.readyState tiene el valor "loading" en esta etapa.</li>
      <li class="font-normal">Cuando el analizador HTML encuentra una etiqueta &lt;script> que no tiene ninguno de los atributos async, defer o type="module", añade esa etiqueta script al documento y, a continuación, ejecuta el script. El script se ejecuta de forma sincrónica, y el analizador HTML hace una pausa mientras el script se descarga (si es necesario) y se ejecuta. Un script como este puede usar document.write() para insertar texto en el flujo de entrada, y ese texto se convertirá en parte del documento cuando el analizador se reanude. Un script a menudo simplemente define funciones y registra manejadores de eventos para su uso posterior, pero puede recorrer y manipular el árbol del documento tal y como existe en ese momento. Es decir, los scripts no modulares que no tienen un atributo async o defer pueden ver su propia etiqueta &lt;script> y el contenido del documento que le precede.</li>
      <li class="font-normal">Cuando el analizador encuentra un elemento &lt;script> con el atributo async activado, comienza a descargar el texto del script (y si el script es un módulo, también descarga de forma recurrente todas las dependencias del script) y continúa analizando el documento. El script se ejecutará lo antes posible una vez descargado, pero el analizador no se detiene a esperar a que se descargue. Los scripts asíncronos no deben utilizar el método document.write(). Pueden ver su propio &lt;script> y todo el contenido del documento que le precede, y puede o no tener acceso a contenido adicional del documento.</li>
      <li class="font-normal">Cuando el documento está completamente analizado, la propiedad document.readyState cambia a "interactive".</li>
      <li class="font-normal">Cualquier script que tenga el atributo defer (junto con cualquier script de módulo que no tenga un atributo async) se ejecuta en el orden en el que aparece en el documento. Los scripts asíncronos también pueden ejecutarse en este momento. Los scripts diferidos tienen acceso al documento completo y no deben utilizar el método document.write().</li>
      <li class="font-normal">El navegador lanza un evento "DOMContentLoaded" sobre el objeto Document. Esto marca la transición de la fase síncrona de ejecución de scripts a la fase asíncrona, dirigida por eventos, de ejecución del programa. Tenga en cuenta, sin embargo, que todavía puede haber scripts asíncronos que aún no se han ejecutado en este punto.</li>
      <li class="font-normal">El documento está completamente analizado en este punto, pero el navegador aún puede estar esperando a que se cargue contenido adicional, como imágenes. Cuando todo ese contenido termina de cargarse, y cuando todos los scripts asíncronos se han cargado y ejecutado, la propiedad document.readyState cambia a "complete" y el navegador web lanza un evento "load" en el objeto Window.</li>
      <li class="font-normal">A partir de este punto, los manejadores de eventos se invocan de forma asíncrona en respuesta a eventos de entrada de usuario, eventos de red, vencimiento de temporizadores, etc.</li>
    </ul>
  </section>
  <section id="1-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.6 Entrada y salida de programas</h2>
    <p>Como cualquier programa, los programas JavaScript del lado del cliente procesan datos de entrada para producir datos de salida. Hay una gran variedad de entradas disponibles:</p>
    <ul>
      <li class="font-normal">El contenido del propio documento, al que el código JavaScript puede acceder con la API DOM (§15.3).</li>
      <li class="font-normal">Entradas del usuario, en forma de eventos, como clics del ratón (o toques en la pantalla táctil) en elementos HTML &lt;button>, o texto introducido en elementos HTML &lt;textarea>, por ejemplo. En §15.2 se muestra cómo los programas JavaScript pueden responder a este tipo de eventos de usuario.</li>
      <li class="font-normal">La URL del documento que se muestra está disponible para JavaScript del lado del cliente como document.URL. Si pasas esta cadena al constructor URL() (§11.9), puedes acceder fácilmente a las secciones path, query y fragment de la URL.</li>
      <li class="font-normal">El contenido de la cabecera de petición HTTP "Cookie" está disponible para el código del cliente como document.cookie. Las cookies suelen ser utilizadas por el código del servidor para mantener las sesiones de usuario, pero el código del cliente también puede leerlas (y escribirlas) si es necesario. Véase §15.12.2 para más detalles.</li>
      <li class="font-normal">La propiedad global navigator proporciona acceso a información sobre el navegador web, el sistema operativo sobre el que se ejecuta y las capacidades de cada uno. Por ejemplo, navigator.userAgent es una cadena que identifica al navegador web, navigator.lan guage es el idioma preferido del usuario, y navigator.hardwareConcurrency devuelve el número de CPUs lógicas disponibles para el navegador web. Del mismo modo, la propiedad global screen proporciona acceso al tamaño de la pantalla del usuario a través de las propiedades screen.width y screen.height. En cierto sentido, estos objetos navigator y screen son para los navegadores web lo que las variables de entorno son para los programas Node.</li>
    </ul>
    <p>El JavaScript del lado del cliente normalmente produce resultados, cuando es necesario, manipulando el documento HTML con la API DOM (§15.3) o usando un framework de alto nivel como React o Angular para manipular el documento. El código del lado del cliente también puede usar console.log() y métodos relacionados (§11.8) para producir salida. Pero esta salida sólo es visible en la consola del desarrollador web, por lo que es útil cuando se depura, pero no para la salida visible por el usuario.</p>
  </section>
  <section id="1-7">
    <h2>15.1.7 Errores del programa</h2>
    <p>A diferencia de las aplicaciones (como las aplicaciones Node) que se ejecutan directamente sobre el sistema operativo, los programas JavaScript en un navegador web no pueden realmente "bloquearse". Si se produce una excepción mientras se ejecuta su programa JavaScript, y si no tiene una sentencia catch para manejarla, se mostrará un mensaje de error en la consola del desarrollador, pero cualquier manejador de eventos que se haya registrado seguirá ejecutándose y respondiendo a los eventos.</p>
    <p>Si desea definir un manejador de errores de último recurso que se invoque cuando se produzca este tipo de excepción no capturada, establezca la propiedad onerror del objeto Window en una función manejadora de errores. Cuando una excepción no detectada se propaga por toda la cadena y se va a mostrar un mensaje de error en la consola del desarrollador, se invocará a la función window.onerror con tres argumentos de cadena. El primer argumento de window.onerror es un mensaje que describe el error. El segundo argumento es una cadena que contiene la URL del código JavaScript que causó el error. El tercer argumento es el número de línea del documento en el que se ha producido el error. Si el manejador onerror devuelve true, le dice al navegador que el manejador ha manejado el error y que no es necesaria ninguna otra acción-en otras palabras, el navegador no debe mostrar su propio mensaje de error.</p>
    <p>Cuando una Promise es rechazada y no hay una función .catch() para manejarla, esa es una situación muy parecida a una excepción no manejada: un error no anticipado o un error lógico en tu programa. Puedes detectar esto definiendo una función window.onunhandledrejection o usando window.addEventListener() para registrar un manejador de eventos "unhand- ledrejection". El objeto de evento pasado a este manejador tendrá una propiedad promise cuyo valor es el objeto Promise que rechazó y una propiedad reason cuyo valor es lo que se habría pasado a una función .catch(). Al igual que con los manejadores de error descritos anteriormente, si se llama a preventDefault() en el objeto de evento de rechazo no manejado, se considerará manejado y no causará un mensaje de error en la consola del desarrollador.</p>
    <p>A menudo no es necesario definir manejadores onerror o onunhandledrejection, pero puede ser bastante útil como mecanismo de telemetría si quieres informar de errores del lado del cliente al servidor (usando la función fetch() para hacer una petición HTTP POST, por ejemplo) para que puedas obtener información sobre errores inesperados que ocurren en los navegadores de tus usuarios.</p>
  </section>
  <section id="1-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.8 El modelo de seguridad web</h2>
    <p>El hecho de que las páginas web puedan ejecutar código JavaScript arbitrario en su dispositivo personal tiene claras implicaciones de seguridad, y los proveedores de navegadores han trabajado duro para equilibrar dos objetivos contrapuestos:</p>
    <ul>
      <li class="font-normal">Definición de potentes API del lado del cliente para crear aplicaciones web útiles</li>
      <li class="font-normal">Evitar que códigos maliciosos lean o alteren sus datos, comprometan su privacidad, le estafen o le hagan perder el tiempo.</li>
    </ul>
    <p>Las subsecciones siguientes ofrecen una rápida visión general de las restricciones y problemas de seguridad que, como programador de JavaScript, debe conocer.</p>
    <p class="title-article text-left">Lo que JavaScript no puede hacer</p>
    <p>La primera línea de defensa de los navegadores web contra el código malicioso es que simplemente no admiten ciertas capacidades. Por ejemplo, JavaScript del lado del cliente no proporciona ninguna forma de escribir o eliminar archivos arbitrarios o listar directorios arbitrarios en el ordenador cliente. Esto significa que un programa JavaScript no puede borrar datos ni plantar virus.</p>
    <p>Del mismo modo, JavaScript del lado del cliente no tiene capacidades de red de propósito general. Un programa JavaScript del lado del cliente puede hacer peticiones HTTP (§15.11.1). Y otro estándar, conocido como WebSockets (§15.11.3), define una API tipo socket para comunicarse con servidores especializados. Pero ninguna de estas API permite el acceso sin intermediarios a la red. Los clientes y servidores de Internet de propósito general no pueden escribirse en JavaScript del lado del cliente.</p>
    <p class="title-article text-left">La política del mismo origen</p>
    <p>La política del mismo origen es una restricción de seguridad radical sobre el contenido web con el que puede interactuar el código Java-Script. Normalmente entra en juego cuando una página web incluye &lt;iframe>. En este caso, la política del mismo origen rige las interacciones del código JavaScript de un marco con el contenido de otros marcos. En concreto, un script sólo puede leer las propiedades de ventanas y documentos que tengan el mismo origen que el documento que contiene el script.</p>
    <p>El origen de un documento se define como el protocolo, el host y el puerto de la URL desde la que se ha cargado el documento. Los documentos cargados desde distintos servidores web tienen orígenes diferentes. Los documentos cargados a través de diferentes puertos del mismo host tienen orígenes diferentes. Y un documento cargado con el protocolo http: tiene un origen distinto que uno cargado con el protocolo https:, aunque procedan del mismo servidor web. Los navegadores suelen tratar cada URL como un origen separado, lo que significa que si está trabajando en un programa que muestra más de un documento del mismo servidor, es posible que no pueda probarlo localmente utilizando file: URL y tendrás que ejecutar un servidor web estático durante el desarrollo.</p>
    <p>Es importante entender que el origen del script en sí no es relevante para la política del mismo origen: lo que importa es el origen del documento en el que está incrustado el script. Supongamos, por ejemplo, que un script alojado en el host A se incluye (utilizando la propiedad src de un elemento &lt;script>) en una página web servida por el host B. El origen de ese script es el host B, y el script tiene pleno acceso al contenido del documento que lo contiene. Si el documento contiene un &lt;iframe> que contiene un segundo documento del host B, entonces el script también tiene acceso completo al contenido de ese segundo documento. Pero si el documento de nivel superior contiene otro &lt;iframe> que muestra un documento del host C (o incluso uno del host A), entonces la política del mismo origen entra en vigor e impide que el script acceda a este documento anidado.</p>
    <p>La política del mismo origen también se aplica a las peticiones HTTP con scripts (véase §15.11.1). El código Java Script puede hacer peticiones HTTP arbitrarias al servidor web desde el que se cargó el documento contenedor, pero no permite que los scripts se comuniquen con otros servidores web (a menos que esos servidores web opten por CORS, como describimos a continuación).</p>
    <p>La política del mismo origen plantea problemas en sitios web de gran tamaño que utilizan múltiples subdominios. Por ejemplo, los scripts con origen pedidos.ejemplo.com pueden necesitar leer propiedades de documentos en ejemplo.com. Para soportar sitios web multidominio de este tipo, los scripts pueden alterar su origen estableciendo document.domain a un sufijo de dominio. Así, un script con origen https://orders.example.com puede cambiar su origen a https://example.com estableciendo document.domain como "ejemplo.com". Pero ese script no puede establecer docu ment.domain a "pedidos.ejemplo", "amplio.com", o "com".</p>
    <p>La segunda técnica para relajar la política del mismo origen es el uso compartido de recursos entre orígenes, o CORS (Cross-Origin Resource Sharing), que permite a los servidores decidir qué orígenes están dispuestos a servir. CORS amplía HTTP con una nueva cabecera de petición Origin: y una nueva cabecera de respuesta Access- Control-Allow-Origin. Permite a los servidores utilizar una cabecera para enumerar explícitamente los orígenes que pueden solicitar un archivo o utilizar un comodín y permitir que un archivo sea solicitado por cualquier sitio. Los navegadores respetan estas cabeceras CORS y no relajan las restricciones del mismo origen a menos que estén presentes.</p>
    <p class="title-article text-left">Secuencias de comandos en sitios cruzados</p>
    <p>Cross-site scripting, o XSS, es una categoría de problemas de seguridad en los que un atacante inyecta etiquetas HTML o scripts en un sitio web. Los programadores de JavaScript del lado del cliente deben conocer y defenderse contra el cross-site scripting.</p>
    <p>Una página web es vulnerable al cross-site scripting si genera dinámicamente el contenido de un documento y basa ese contenido en datos enviados por el usuario sin haber "saneado" previamente esos datos eliminando de ellos cualquier etiqueta HTML incrustada. Como ejemplo trivial, considere la siguiente página web que utiliza JavaScript para saludar al usuario por su nombre:</p>
    <p>Este script de dos líneas extrae la entrada del parámetro de consulta "nombre" de la URL del documento. A continuación, utiliza la API DOM para inyectar una cadena HTML en la primera etiqueta &lt;h1> del documento. Esta página está pensada para ser invocada con una URL como esta:</p>
    <p>Cuando se utiliza así, muestra el texto "Hola David". Pero considere lo que ocurre cuando se invoca con este parámetro de consulta:</p>
    <p>Cuando se decodifican los parámetros de la URL, esta URL provoca que se inyecte el siguiente HTML en el documento:</p>
    <p>Una vez cargada la imagen, se ejecuta la cadena de JavaScript del atributo onload. La función global alert() muestra un cuadro de diálogo modal. Un solo cuadro de diálogo es relativamente benigno, pero demuestra que la ejecución de código arbitrario es posible en este sitio porque muestra HTML sin desinfectar.</p>
    <p>Los ataques de secuencias de comandos entre sitios se llaman así porque hay más de un sitio implicado. El sitio B incluye un enlace especialmente diseñado (como el del ejemplo anterior) al sitio A. Si el sitio B puede convencer a los usuarios para que hagan clic en el enlace, serán conducidos al sitio A, pero ese sitio estará ejecutando código del sitio B. Ese código podría desfigurar la página o hacer que funcione mal. Y lo que es más peligroso, el código malicioso podría leer las cookies almacenadas por el sitio A (quizás números de cuenta u otra información de identificación personal) y enviar esos datos de vuelta al sitio B. El código inyectado podría incluso rastrear las pulsaciones de teclado del usuario y enviar esos datos de vuelta al sitio B.</p>
    <p>En general, la forma de prevenir los ataques XSS es eliminar las etiquetas HTML de cualquier dato no fiable antes de utilizarlo para crear contenido de documentos dinámicos. Puede corregir el archivo greet.html mostrado anteriormente sustituyendo los caracteres HTML especiales de la cadena de entrada no fiable por sus entidades HTML equivalentes:</p>
    <p>Otra forma de abordar el problema del XSS es estructurar las aplicaciones web de modo que el contenido que no sea de confianza se muestre siempre en un &lt;iframe> con el atributo sandbox configurado para desactivar el scripting y otras capacidades.</p>
    <p>Cross-site scripting es una vulnerabilidad perniciosa cuyas raíces se hunden en lo más profundo de la arquitectura de la web. Merece la pena conocer esta vulnerabilidad en profundidad, pero su análisis va más allá del alcance de este libro. Hay muchos recursos en línea para ayudar a a defenderse contra el cross-site scripting.</p>
  </section>
  <section id="2">
    <h2>15.2 Eventos</h2>
    <p>Los programas JavaScript del lado del cliente utilizan un modelo de programación asíncrono basado en eventos. En este estilo de programación, el navegador web genera un evento cada vez que ocurre algo interesante en el documento o navegador o en algún elemento u objeto asociado a él. Por ejemplo, el navegador genera un evento cuando termina de cargar un documento, cuando el usuario mueve el ratón sobre un hipervínculo o cuando pulsa una tecla del teclado. Si una aplicación JavaScript se preocupa por un tipo particular de evento, puede registrar una o más funciones para que sean invocadas cuando se produzcan eventos de ese tipo. Tenga en cuenta que esto no es exclusivo de la programación web: todas las aplicaciones con interfaces gráficas de usuario están diseñadas de esta manera: se sientan a esperar a que se interactúe con ellas (es decir, esperan a que se produzcan eventos) y luego responden.</p>
    <p>En JavaScript del lado del cliente, los eventos pueden ocurrir en cualquier elemento dentro de un documento HTML, y este hecho hace que el modelo de eventos de los navegadores web sea significativamente más complejo que el modelo de eventos de Node. Comenzamos esta sección con algunas definiciones importantes que ayudan a explicar ese modelo de eventos:</p>
    <p><em>tipo de evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta cadena especifica qué tipo de evento se ha producido. El tipo "mousemove", por ejemplo, significa que el usuario movió el ratón. El tipo "keydown" significa que el usuario pulsó una tecla del teclado hacia abajo. Y el tipo "load" significa que un documento (o algún otro recurso) ha terminado de cargarse desde la red. Como el tipo de un evento es sólo una cadena, a veces se le llama nombre del evento, y de hecho, usamos este nombre para identificar el tipo de evento del que estamos hablando.</p>
    <p><em>objetivo del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Es el objeto en el que se ha producido el suceso o al que está asociado. Cuando hablamos de un evento, debemos especificar tanto el tipo como el destino. Un evento de carga en una ventana, por ejemplo, o un evento de clic en un elemento &lt;button>. Los objetos Window, Document y Element son los destinos de eventos más comunes en las aplicaciones JavaScript del lado del cliente, pero algunos eventos se activan en otros tipos de objetos. Por ejemplo, un objeto Worker (un tipo de hilo, cubierto en §15.13) es un objetivo para eventos "mensaje" que ocurren cuando el hilo worker envía un mensaje al hilo principal.</p>
    <p><em>controlador de eventos o receptor de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función maneja o responde a un evento.2 Las aplicaciones registran sus funciones manejadoras de eventos con el navegador web, especificando un tipo de evento y un objetivo de evento. Cuando se produce un evento del tipo especificado en el objetivo especificado, el navegador invoca la función manejadora. Cuando los manejadores de eventos son invocados para un objeto, decimos que el navegador ha "disparado" o "despachado" el evento. Hay varias maneras de registrar manejadores de eventos, y los detalles del registro y la invocación de manejadores se explican en §15.2.2 y §15.2.3.</p>
    <p><em>objeto del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este objeto está asociado a un evento concreto y contiene detalles sobre ese evento. Los objetos evento se pasan como argumento a la función manejadora de eventos. Todos los objetos de evento tienen una propiedad type que especifica el tipo de evento y una propiedad target que especifica el objetivo del evento. Cada tipo de evento define un conjunto de propiedades para su objeto de evento asociado. El objeto asociado a un evento de ratón incluye las coordenadas del puntero del ratón, por ejemplo, y el objeto asociado a un evento de teclado contiene detalles sobre la tecla que se pulsó y las teclas modificadoras que se mantuvieron pulsadas. Muchos tipos de eventos sólo definen algunas propiedades estándar -como el tipo y el objetivo- y no contienen mucha más información útil. Para esos eventos, lo que importa es la simple ocurrencia del evento, no los detalles del mismo.</p>
    <p><em>propagación de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este es el proceso por el cual el navegador decide qué objetos activan los manejadores de eventos. Para los eventos que son específicos de un único objeto -como el evento "load" en el objeto Window o un evento "message" en un objeto Worker- no se requiere ningún proceso. Sin embargo, cuando ciertos tipos de eventos ocurren en elementos dentro del documento HTML, se propagan o "burbujean" hacia arriba en el árbol del documento. Si el usuario mueve el ratón sobre un hipervínculo, el evento mousemove se dispara primero en el elemento &lt;a> que define ese enlace. Luego se dispara sobre los elementos que lo contienen: quizás un elemento &lt;p>, un elemento &lt;section>, y el propio objeto Documento. A veces es más conveniente registrar un único manejador de eventos en un Documento u otro elemento contenedor que registrar manejadores en cada elemento individual en el que estés interesado. Un manejador de eventos puede detener la propagación de un evento para que no continúe burbujeando y no active manejadores en los elementos que lo contienen. Los manejadores hacen esto invocando un método del objeto del evento. En otra forma de propagación de eventos, conocida como captura de eventos, los manejadores especialmente registrados en elementos contenedores tienen la oportunidad de interceptar (o "capturar") eventos antes de que sean enviados a su destino real. El burbujeo y la captura de eventos se tratan en detalle en §15.2.4.</p>
    <p>Algunos eventos tienen asociadas acciones por defecto. Cuando se produce un evento de clic en un hipervínculo, por ejemplo, la acción por defecto es que el navegador siga el enlace y cargue una nueva página. Los manejadores de eventos pueden evitar esta acción por defecto invocando un método del objeto del evento. Esto a veces se llama "cancelar" el evento y se trata en §15.2.5.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.1 Categorías de eventos</h2>
    <p>JavaScript del lado del cliente soporta un número tan grande de tipos de eventos que no hay forma de que este capítulo pueda cubrirlos todos. Puede ser útil, sin embargo, agrupar los eventos en algunas categorías generales, para ilustrar el alcance y la amplia variedad de eventos soportados:</p>
    <p><em>Eventos de entrada dependientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos están directamente vinculados a un dispositivo de entrada específico, como el ratón o el teclado. Incluyen tipos de eventos como "mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "keydown" y "keyup".</p>
    <p><em>Eventos de entrada independientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos de entrada no están directamente vinculados a un dispositivo de entrada específico. El evento "clic", por ejemplo, indica que se ha activado un enlace o un botón (u otro elemento del documento). Esto suele hacerse mediante un clic del ratón, pero también puede hacerse con el teclado o (en dispositivos táctiles) con un toque. El evento "input" es una alternativa independiente del dispositivo al evento "keydown" y admite la entrada por teclado, así como alternativas como cortar y pegar y métodos de entrada utilizados para scripts ideográficos. Los eventos "pointerdown", "pointermove" y "pointerup" son alternativas independientes del dispositivo a los eventos de ratón y táctiles. Funcionan con punteros de tipo ratón, con pantallas táctiles y también con entradas de tipo lápiz o bolígrafo.</p>
    <p><em>Eventos de la interfaz de usuario</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los eventos de interfaz de usuario son eventos de nivel superior, a menudo en elementos de formulario HTML que definen una interfaz de usuario para una aplicación web. Incluyen el evento "focus" (cuando un campo de entrada de texto obtiene el foco del teclado), el evento "change" (cuando el usuario cambia el valor mostrado por un elemento de formulario) y el evento "submit" (cuando el usuario hace clic en un botón Enviar de un formulario).</p>
    <p><em>Cambios de estado</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Algunos eventos no se desencadenan directamente por la actividad del usuario, sino por la actividad de la red o del navegador, e indican algún tipo de cambio relacionado con el ciclo de vida o el estado. Los eventos "load" y "DOMContentLoaded" -provocados en los objetos Window y Document, respectivamente, al final de la carga del documento- son probablemente los más utilizados de estos eventos (ver "Línea de tiempo JavaScript del lado del cliente" en la página 420). Los navegadores disparan eventos "online" y "offline" en el objeto Window cuando la conectividad de la red cambia. El mecanismo de gestión del historial del navegador (§15.10.4) dispara el evento "popstate" en respuesta al botón Atrás del navegador.</p>
    <p><em>Eventos específicos de la API</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Varias API web definidas por HTML y especificaciones relacionadas incluyen sus propios tipos de eventos. Los elementos HTML &lt;video> y &lt;audio> definen una larga lista de tipos de eventos asociados, como "espera", "reproducción", "búsqueda", "cambio de volumen", etc., y puedes utilizarlos para personalizar la reproducción multimedia. En términos generales, las API de plataformas web que son asíncronas y se desarrollaron antes de que se añadieran las promesas a JavaScript se basan en eventos y definen eventos específicos de la API. La API IndexedDB, por ejemplo (§15.12.3), dispara eventos de "éxito" y "error" cuando las peticiones a la base de datos tienen éxito o fallan. Y aunque la nueva API fetch() (§15.11.1) para realizar peticiones HTTP está basada en promesas, la API XMLHttpRequest a la que sustituye define una serie de tipos de eventos específicos de la API.</p>
  </section>
  <section id="2-2">
    <h2>15.2.2 Registro de controladores de eventos</h2>
    <p>Hay dos formas básicas de registrar manejadores de eventos. La primera, desde los primeros días de la web, es establecer una propiedad en el objeto o elemento del documento que es el tar- minador del evento. La segunda técnica (más reciente y general) consiste en pasar el controlador al método addEventListener() del objeto o elemento.</p>
    <p class="title-article text-left">Configuración de las propiedades de los controladores de eventos</p>
    <p>La forma más sencilla de registrar un manejador de eventos es estableciendo una propiedad del tar- gador de eventos en la función deseada del manejador de eventos. Por convención, las propiedades de los manejadores de eventos tienen nombres que consisten en la palabra "on" seguida del nombre del evento: onclick, onchange, onload, onmouseover, etcétera. Tenga en cuenta que los nombres de estas propiedades distinguen entre mayúsculas y minúsculas,3 incluso cuando el tipo de evento (como "mouse- down") consta de varias palabras. El siguiente código incluye dos registros de manejadores de eventos de este tipo:</p>
    <p>El defecto de las propiedades de los manejadores de eventos es que están diseñadas bajo la suposición de que los objetivos de eventos tendrán como máximo un manejador para cada tipo de evento. En a menudo es mejor registrar manejadores de eventos usando addEventListener() porque esa técnica no sobreescribe ningún manejador previamente registrado.</p>
    <p class="title-article text-left">Establecer atributos del manejador de eventos</p>
    <p>Las propiedades de los manejadores de eventos de los elementos del documento también pueden definirse directamente en el archivo HTML como atributos en la etiqueta HTML correspondiente. (Los manejadores que se registrarían en el elemento Window con JavaScript pueden definirse con atributos en la etiqueta &lt;body> en HTML). Esta técnica es generalmente mal vista en el desarrollo web moderno, pero es posible, y se documenta aquí porque todavía se puede ver en el código existente.</p>
    <p>Cuando se define un manejador de eventos como un atributo HTML, el valor del atributo debe ser una cadena de código JavaScript. Ese código debe ser el cuerpo de la función del manejador de eventos, no una declaración de función completa. Es decir, el código HTML del controlador de eventos no debe estar rodeado de llaves y precedido de la palabra clave function. Por ejemplo:</p>
    <p>Si un atributo de controlador de eventos HTML contiene varias sentencias JavaScript, no olvide separarlas con punto y coma o dividir el valor del atributo en varias líneas.</p>
    <p>Cuando se especifica una cadena de código JavaScript como valor de un atributo HTML manejador de eventos, el navegador convierte la cadena en una función que funciona de forma parecida a ésta:</p>
    <p>El argumento event significa que el código de su manejador puede referirse al objeto de evento actual como event. Las sentencias with significan que el código de tu manejador puede referirse a las propiedades del objeto destino, al &lt;form> contenedor (si lo hay), y al objeto Documento contenedor directamente, como si fueran variables en scope. La sentencia with está prohibida en modo estricto (§5.6.3), pero el código JavaScript en atributos HTML nunca es estricto. Los manejadores de eventos definidos de esta forma se ejecutan en un entorno en el que se definen variables inesperadas. Esto puede ser una fuente de errores confusos y es una buena razón para evitar escribir manejadores de eventos en HTML.</p>
    <p class="title-article text-left">addEventListener()</p>
    <p>Cualquier objeto que pueda ser objetivo de un evento -esto incluye los objetos Window y Document y todos los Elementos del documento- define un método llamado addEventListener() que puede utilizar para registrar un controlador de eventos para ese objetivo. addEventListener() toma tres argumentos. El primero es el tipo de evento para el que se está registrando el controlador. El tipo de evento (o nombre) es una cadena que no incluye el prefijo "on" utilizado al establecer las propiedades del manejador de eventos. El segundo argumento de addEventListener() es la función que se invocará cuando se produzca el tipo de evento especificado. El tercer argumento es opcional y se explica a continuación.</p>
    <p>El siguiente código registra dos manejadores para el evento "click" en un elemento &lt;button>. Observe las diferencias entre las dos técnicas utilizadas:</p>
    <p>Llamar a addEventListener() con "click" como primer argumento no afecta al valor de la propiedad onclick. En este código, un clic de botón registrará dos mensajes en la consola del desarrollador. Y si llamáramos primero a addEventListener() y luego estableciéramos onclick, seguiríamos registrando dos mensajes, sólo que en el orden inverso. Más importante aún, puedes llamar a addEventListener() varias veces para registrar más de una función manejadora para el mismo tipo de evento en el mismo objeto. Cuando ocurre un evento en un objeto, todos los manejadores registrados para ese tipo de evento son invocados en el orden en que fueron registrados. Invocar addEventListener() más de una vez sobre el mismo objeto con los mismos argumentos no tiene ningún efecto - la función manejadora permanece registrada sólo una vez, y la invocación repetida no altera el orden en que los manejadores son invocados.</p>
    <p>addEventListener() está emparejado con un método removeEventListener() que espera los mismos dos argumentos (más un tercero opcional) pero elimina una función manejadora de eventos de un objeto en lugar de añadirla. A menudo es útil registrar temporalmente un controlador de eventos y eliminarlo poco después. Por ejemplo, cuando recibes un evento "mousedown", puedes registrar temporalmente manejadores de eventos "mousemove" y "mouseup" para ver si el usuario arrastra el ratón. A continuación, anularías el registro de estos manejadores cuando llegue el evento "mouseup". En tal situación, tu código de eliminación de manejadores de eventos podría verse así:</p>
    <p>El tercer argumento opcional de addEventListener() es un valor booleano o un objeto. Si pasa true, entonces su función manejadora se registra como un manejador de eventos de captura y se invoca en una fase diferente del envío de eventos. Cubriremos la captura de eventos en §15.2.4. Si pasas un tercer argumento de true cuando registras un receptor de eventos, entonces también debes pasar true como tercer argumento a removeEventListener() si quieres eliminar el manejador.</p>
    <p>Registrar un controlador de eventos de captura es sólo una de las tres opciones que admite addEven tListener(), y en lugar de pasar un único valor booleano, también puede pasar un objeto que especifique explícitamente las opciones que desea:</p>
    <p>Si el objeto Options tiene una propiedad de captura establecida a true, entonces el manejador de eventos será registrado como un manejador de captura. Si esa propiedad es falsa o se omite, entonces el manejador será no capturador.</p>
    <p>Si el objeto Options tiene la propiedad once establecida a true, entonces el manejador de eventos se eliminará automáticamente después de que se active una vez. Si esta propiedad es falsa o se omite, el controlador nunca se eliminará automáticamente.</p>
    <p>Si el objeto Options tiene una propiedad passive establecida a true, indica que el manejador de eventos nunca llamará a preventDefault() para cancelar la acción por defecto (ver §15.2.5). Esto es particularmente importante para eventos táctiles en dispositivos móviles - si los manejadores de eventos "touchmove" pueden prevenir la acción de desplazamiento por defecto del navegador, entonces el navegador no puede implementar un desplazamiento suave. Esta propiedad pasiva proporciona una forma de registrar un controlador de eventos potencialmente perjudicial de este tipo, pero permite que el navegador web sepa que puede iniciar de forma segura su comportamiento predeterminado -como el desplazamiento- mientras se ejecuta el controlador de eventos. El desplazamiento suave es tan importante para una buena experiencia de usuario que Firefox y Chrome hacen que los eventos "touchmove" y "mousewheel" sean pasivos por defecto. Así que si quieres registrar un manejador que llame a preventDefault() para uno de estos eventos, debes establecer explícitamente la propiedad passive a false.</p>
    <p>También puede pasar un objeto Options a removeEventListener(), pero la propiedad capture es la única relevante. No es necesario especificar once o passive al eliminar un listener, y estas propiedades se ignoran.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.3 Invocación del manejador de eventos</h2>
    <p>Una vez que hayas registrado un manejador de eventos, el navegador web lo invocará automáticamente cuando se produzca un evento del tipo especificado en el objeto especificado. Esta sección describe la invocación de manejadores de eventos en detalle, explicando los argumentos de los manejadores de eventos, el contexto de invocación (el valor this), y el significado del valor de retorno de un manejador de eventos.</p>
    <p class="title-article text-left">Argumento del controlador de eventos</p>
    <p>Los controladores de eventos se invocan con un objeto Evento como único argumento. Las propiedades del objeto Evento proporcionan detalles sobre el evento:</p>
    <p><codeinline>type</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Tipo de suceso ocurrido.</p>
    <p><codeinline>target</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El objeto en el que se ha producido el suceso.</p>
    <p><codeinline>currentTarget</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Para los eventos que se propagan, esta propiedad es el objeto en el que se registró el manejador del evento actual.</p>
    <p><codeinline>timeStamp</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una marca de tiempo (en milisegundos) que representa cuándo ocurrió el evento pero que no representa un tiempo absoluto. Puedes determinar el tiempo transcurrido entre dos eventos restando la marca de tiempo del primer evento de la marca de tiempo del segundo.</p>
    <p><codeinline>isTrusted</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad será verdadera si el evento fue enviado por el propio navegador web y falsa si el evento fue enviado por código JavaScript.</p>
    <p>Determinados tipos de eventos tienen propiedades adicionales. Los eventos de ratón y puntero, por ejemplo, tienen propiedades clientX y clientY que especifican las coordenadas de la ventana en la que se produjo el evento.</p>
    <p class="title-article text-left">Contexto del controlador de eventos</p>
    <p>Cuando se registra un manejador de eventos estableciendo una propiedad, parece como si se estuviera definiendo un nuevo método en el objeto de destino:</p>
    <p>No es sorprendente, por tanto, que los manejadores de eventos sean invocados como métodos del objeto sobre el que están definidos. Es decir, dentro del cuerpo de un manejador de eventos, la palabra clave this se refiere al objeto sobre el que se registró el manejador de eventos.</p>
    <p>Los manejadores se invocan con el objetivo como su valor this, incluso cuando se registran usando addEventListener(). Sin embargo, esto no funciona para los manejadores definidos como funciones de flecha: las funciones de flecha siempre tienen el mismo valor this que el ámbito en el que se definen.</p>
    <p class="title-article text-left">Valor de retorno del manipulador</p>
    <p>En el JavaScript moderno, los manejadores de eventos no deberían devolver nada. Puedes ver manejadores de eventos que devuelven valores en código antiguo, y el valor devuelto es típicamente una señal al navegador de que no debe realizar la acción por defecto asociada con el evento. Si el manejador onclick de un botón Enviar en un formulario devuelve false, por ejemplo, entonces el navegador web no enviará el formulario (normalmente porque el manejador de eventos determinó que la entrada del usuario falla la validación del lado del cliente).</p>
    <p>La forma estándar y preferida de evitar que el navegador realice una acción por defecto es llamar al método preventDefault() (§15.2.5) en el objeto Evento.</p>
    <p class="title-article text-left">Orden de invocación</p>
    <p>Un objetivo de evento puede tener más de un manejador de evento registrado para un tipo particular de evento. Cuando ocurre un evento de ese tipo, el navegador invoca todos los manejadores en el orden en que fueron registrados. Curiosamente, esto es cierto incluso si se mezclan manejadores de eventos registrados con addEventListener() con un manejador de eventos registrado en una propiedad de objeto como onclick.</p>
  </section>
  <section id="2-4">
    <h2>15.2.4 Propagación de eventos</h2>
    <p>Cuando el objetivo de un evento es el objeto Window o algún otro objeto independiente, el navegador responde a un evento simplemente invocando los manejadores apropiados en ese objeto. Sin embargo, cuando el objetivo del evento es un Documento o un Elemento del documento, la situación es más complicada.</p>
    <p>Una vez invocados los manejadores de eventos registrados en el elemento de destino, la mayoría de los eventos "burbujean" hacia arriba en el árbol DOM. Se invocan los manejadores de eventos del padre del objetivo. Luego se invocan los manejadores registrados en el abuelo del objetivo. Esto continúa hasta el objeto Documento, y luego más allá hasta el objeto Ventana. El burbujeo de eventos proporciona una alternativa al registro de manejadores en muchos elementos individuales del documento: en su lugar, puedes registrar un único manejador en un elemento ancestro común y manejar los eventos allí. Por ejemplo, puede registrar un controlador de "cambio" en un elemento &lt;form>, en lugar de registrar un controlador de "cambio" para cada elemento del formulario.</p>
    <p>La mayoría de los eventos que se producen en los elementos del documento burbujean. Excepciones notables son los eventos "focus", "blur" y "scroll". El evento "load" de los elementos del documento burbujea, pero deja de burbujear en el objeto Documento y no se propaga al objeto Ventana. (Los manejadores de eventos "load" del objeto Window se disparan sólo cuando todo el documento se ha cargado).</p>
    <p>El burbujeo de eventos es la tercera "fase" de la propagación de eventos. La invocación de los manejadores de eventos del propio objeto de destino es la segunda fase. La primera fase, que ocurre incluso antes de que se invoquen los manejadores de destino, se denomina fase de "captura". Recordemos que addEventListener() toma un tercer argumento opcional. Si ese argumento es verdadero o &lbrace;capture:true}, entonces el manejador de eventos es registrado como un manejador de eventos de captura para invocación durante esta primera fase de propagación de eventos. La fase de captura de la propagación de eventos es como la fase de burbujeo a la inversa. Los manejadores de captura del objeto Window son invocados primero, luego los manejadores de captura del objeto Document, luego del objeto body, y así sucesivamente hacia abajo en el árbol DOM hasta que los manejadores de captura de eventos del padre del objetivo del evento son invocados. Los manejadores de captura de eventos registrados en el propio objetivo del evento no son invocados.</p>
    <p>La captura de eventos proporciona una oportunidad para echar un vistazo a los eventos antes de que sean entregados a su objetivo. Un manejador de eventos de captura puede ser usado para depuración, o puede ser usado junto con la técnica de cancelación de eventos descrita en la siguiente sección para filtrar eventos de manera que los manejadores de eventos de destino nunca sean invocados. Un uso común para la captura de eventos es el manejo de arrastres del ratón, donde los eventos de movimiento del ratón necesitan ser manejados por el objeto que está siendo arrastrado, no por los elementos del documento sobre los que se arrastra.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.5 Cancelación de eventos</h2>
    <p>Los navegadores responden a muchos eventos del usuario, aunque tu código no lo haga: cuando el usuario hace clic con el ratón en un hipervínculo, el navegador sigue el enlace. Si un elemento HTML de entrada de texto tiene el foco en el teclado y el usuario teclea una tecla, el navegador introducirá la entrada del usuario. Si el usuario mueve el dedo por un dispositivo de pantalla táctil, el navegador se desplaza. Si registras un manejador de eventos para eventos como estos, puedes evitar que el navegador realice su acción por defecto invocando el método preventDefault() del objeto evento. (A menos que hayas registrado el manejador con la opción pasiva, lo que hace que preventDefault() sea ineficaz).</p>
    <p>Cancelar la acción por defecto asociada a un evento es sólo un tipo de cancelación de eventos. También podemos cancelar la propagación de eventos llamando al método stopPropaga tion() del objeto evento. Si hay otros manejadores definidos en el mismo objeto, el resto de esos manejadores seguirán siendo invocados, pero ningún manejador de evento en cualquier otro objeto será invocado después de llamar a stopPropagation(). stopPropagation() funciona durante la fase de captura, en el propio objetivo del evento, y durante la fase de burbujeo. stopImmediatePropagation() funciona como stopPropagation(), pero también previene la invocación de cualquier manejador de evento posterior registrado en el mismo objeto.</p>
  </section>
  <section id="2-6">
    <h2>15.2.6 Envío de eventos personalizados</h2>
    <p>La API de eventos de JavaScript del lado del cliente es relativamente potente, y puedes utilizarla para definir y enviar tus propios eventos. Supongamos, por ejemplo, que tu programa necesita peri-ódicamente realizar un cálculo largo o hacer una petición a la red y que, mientras esta operación está pendiente, otras operaciones no son posibles. Usted quiere que el usuario lo sepa mostrando "spinners" para indicar que la aplicación está ocupada. Pero el módulo que está ocupado no necesita saber dónde deben estar los mostrado. En su lugar, ese módulo podría enviar un evento para anunciar que está ocupado y luego enviar otro evento cuando ya no lo esté. Entonces, el módulo de interfaz de usuario puede registrar manejadores de eventos para esos eventos y tomar cualquier acción de interfaz de usuario que sea apropiada para notificar al usuario.</p>
    <p>Si un objeto JavaScript tiene un método addEventListener(), entonces es un "objetivo de evento", y esto significa que también tiene un método dispatchEvent(). Puede crear su propio objeto de evento con el constructor CustomEvent() y pasarlo a dispatchEvent(). El primer argumento de CustomEvent() es una cadena que especifica el tipo de tu evento, y el segundo argumento es un objeto que especifica las propiedades del objeto evento. Establezca la propiedad detail de este objeto a una cadena, objeto u otro valor que represente el contenido de su evento. Si planeas enviar tu evento sobre un elemento del documento y quiere que se burbujee hacia arriba en el árbol del documento, añade bubbles:true al segundo argumento:</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3 Documentos de secuencias de comandos</h2>
    <p>JavaScript del lado del cliente existe para convertir documentos HTML estáticos en aplicaciones web interactivas. El objetivo principal de JavaScript es crear scripts para el contenido de las páginas web.</p>
    <p>Todo objeto Ventana tiene una propiedad Documento que hace referencia a un objeto Documento. El objeto Documento representa el contenido de la ventana, y es el tema de esta sección. Sin embargo, el objeto Document no es el único. Es el objeto central del DOM para representar y manipular el contenido de los documentos.</p>
    <p>El DOM se introdujo en §15.1.2. Esta sección explica la API en detalle. Abarca:</p>
    <ul>
      <li class="font-normal">Cómo consultar o seleccionar elementos individuales de un documento.</li>
      <li class="font-normal">Cómo recorrer un documento y cómo encontrar los ancestros, hermanos y descendientes de cualquier elemento del documento.</li>
      <li class="font-normal">Cómo consultar y establecer los atributos de los elementos del documento.</li>
      <li class="font-normal">Cómo consultar, fijar y modificar el contenido de un documento.</li>
      <li class="font-normal">Cómo modificar la estructura de un documento creando, insertando y eliminando nodos.</li>
    </ul>
  </section>
  <section id="3-1">
    <h2>15.3.1 Selección de elementos del documento</h2>
    <p>Los programas JavaScript del lado del cliente a menudo necesitan manipular uno o más elementos dentro del documento. La propiedad global document se refiere al objeto Document, y el objeto Document tiene propiedades head y body que se refieren a los objetos Element para las etiquetas &lt;head> y &lt;body>, respectivamente. Pero un programa que quiera manipular un elemento incrustado más profundamente en el documento debe de alguna manera obtener o seleccionar los objetos Element que se refieren a esos elementos del documento.</p>
    <p class="title-article text-left">Seleccionar elementos con selectores CSS</p>
    <p>Las hojas de estilo CSS tienen una sintaxis muy potente, conocida como selectores, para describir elementos o conjuntos de elementos dentro de un documento. Los métodos DOM querySelector() y querySelectorAll() nos permiten encontrar el elemento o elementos dentro de un documento que coinciden con un selector CSS especificado. Antes de cubrir los métodos, comenzaremos con un rápido tutorial sobre la sintaxis de los selectores CSS.</p>
    <p>Los selectores CSS pueden describir elementos por el nombre de la etiqueta, el valor de su atributo id o las palabras de su atributo class:</p>
    <p>El carácter # se utiliza para hacer coincidencias basadas en el atributo id, y el carácter . se utiliza para hacer coincidencias basadas en el atributo class. Los elementos también pueden seleccionarse en función de valores de atributo más generales:</p>
    <p>Observe que estos ejemplos combinan un selector de nombre de etiqueta (o el comodín * de nombre de etiqueta) con un selector de atributo. También son posibles combinaciones más complejas:</p>
    <p>Los selectores también pueden especificar la estructura del documento:</p>
    <p>Si dos selectores están separados por una coma, significa que hemos seleccionado elementos que coinciden con cualquiera de los selectores:</p>
    <p>Como puedes ver, los selectores CSS nos permiten referirnos a elementos dentro de un documento por tipo, ID, clase, atributos y posición dentro del documento. El método querySelector() toma una cadena de selector CSS como argumento y devuelve el primer elemento coincidente que encuentra en el documento, o devuelve null si no coincide ninguno:</p>
    <p>querySelectorAll() es similar, pero devuelve todos los elementos coincidentes del documento en lugar de devolver sólo el primero:</p>
    <p>El valor devuelto por querySelectorAll() no es un array de objetos Element. En su lugar, es un objeto tipo array conocido como NodeList. Los objetos NodeList tienen una propiedad de longitud y pueden ser indexados como arrays, por lo que se puede hacer un bucle sobre ellos con un bucle for tradicional. Los NodeLists también son iterables, por lo que también puedes usarlos con bucles for/of. Si desea convertir un NodeList en un verdadero array, simplemente páselo a Array.from().</p>
    <p>La NodeList devuelta por querySelectorAll() tendrá una propiedad length establecida a 0 si no hay ningún elemento en el documento que coincida con el selector especificado.</p>
    <p>querySelector() y querySelectorAll() son implementados tanto por la clase Element como por la clase Document. Cuando se invocan sobre un elemento, estos métodos sólo devolverán elementos que sean descendientes de ese elemento.</p>
    <p>Tenga en cuenta que CSS define los pseudoelementos ::first-line y ::first- letter. En CSS, coinciden con partes de nodos de texto y no con elementos reales. No coincidirán si se utilizan con querySelectorAll() o querySelector(). Además, muchos navegadores se negarán a devolver coincidencias para las pseudoclases :link y :visited, ya que esto podría exponer información sobre el historial de navegación del usuario.</p>
    <p>Otro método de selección de elementos basado en CSS es closest(). Este método está definido por la clase Element y toma un selector como único argumento. Si el selector coincide con el elemento sobre el que se invoca, devuelve ese elemento. En caso contrario, devuelve el elemento antecesor más cercano con el que coincida el selector, o devuelve null si no coincide ninguno. En cierto sentido, closest() es lo contrario de querySelector(): closest() comienza en un elemento y busca una coincidencia por encima de él en el árbol, mientras que querySelector() comienza con un elemento y busca una coincidencia por debajo de él en el árbol. closest() puede ser útil cuando se ha registrado un controlador de eventos en un nivel alto en el árbol del documento. Si está manejando un evento "clic", por ejemplo, es posible que desee saber si se trata de un clic en un hipervínculo. El objeto de evento le dirá cuál era el objetivo, pero ese objetivo podría ser el texto dentro de un enlace en lugar de la propia etiqueta &lt;a> del hipervínculo. Tu manejador de eventos podría buscar el hipervínculo contenedor más cercano así:</p>
    <p>Esta es otra forma de utilizar closest():</p>
    <p>El método relacionado matches() no devuelve ancestros ni descendientes: simplemente comprueba si un elemento coincide con un selector CSS y devuelve true en caso afirmativo y false en caso contrario:</p>
    <p class="title-article text-left">Otros métodos de selección de elementos</p>
    <p>Además de querySelector() y querySelectorAll(), el DOM también define una serie de métodos de selección de elementos más antiguos que ahora están más o menos obsoletos. Sin embargo, es posible que aún se utilicen algunos de estos métodos (especialmente getElementById()):</p>
    <p>Al igual que querySelectorAll(), los métodos de este código devuelven un NodeList (excepto getElementById(), que devuelve un único objeto Element). Sin embargo, a diferencia de querySelectorAll(), los NodeLists devueltos por estos métodos de selección más antiguos son "vivos", lo que significa que la longitud y el contenido de la lista pueden cambiar si cambia el contenido o la estructura del documento.</p>
    <p class="title-article text-left">Elementos preseleccionados</p>
    <p>Por razones históricas, la clase Document define propiedades de acceso directo para acceder a ciertos tipos de nodos. Las propiedades images, forms y links, por ejemplo, facilitan el acceso a los elementos &lt;img>, &lt;form> y &lt;a> (pero sólo a las etiquetas &lt;a> que tienen un atributo href) de un documento. Estas propiedades hacen referencia a objetos HTMLCollection, que son muy parecidos a los objetos NodeList, pero además pueden indexarse por ID o nombre de elemento. Con la propiedad document.forms, por ejemplo, puede acceder a la etiqueta &lt;form id="address"> como:</p>
    <p>Una API aún más anticuada para seleccionar elementos es la propiedad document.all, que es como una HTMLCollection para todos los elementos del documento. document.all está obsoleta, y ya no deberías usarla.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.2 Estructura y desplazamiento de documentos</h2>
    <p>Una vez seleccionado un elemento de un documento, a veces es necesario encontrar partes del documento relacionadas estructuralmente (padre, hermanos, hijos). Cuando nos interesan principalmente los Elementos de un documento en lugar del texto que contienen (y los espacios en blanco entre ellos, que también son texto), existe una API de navegación que nos permite tratar un documento como un árbol de objetos Elemento, ignorando los nodos de Texto que también forman parte del documento. Esta API de navegación no implica ningún método; es simplemente un conjunto de propiedades de los objetos Elemento que nos permiten referirnos a los padres, hijos y hermanos de un elemento dado:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad de un elemento se refiere al padre del elemento, que será otro Elemento o un objeto Documento.</p>
    <p><codeinline>children</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta NodeList contiene los elementos hijos de un elemento, pero excluye los que no lo son, como los nodos de texto (y los nodos de comentario).</p>
    <p><codeinline>childElementCount</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Número de elementos hijos. Devuelve el mismo valor que children.length.</p>
    <p><codeinline>firstElementChild</codeinline>, <codeinline>lastElementChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren al primer y último elemento hijo de un elemento. Son nulas si el elemento no tiene elementos hijos.</p>
    <p><codeinline>nextElementSibling</codeinline>, <codeinline>previousElementSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren a los elementos hermanos inmediatamente anteriores o posteriores a un elemento, o a null si no hay ningún elemento hermano.</p>
    <p>Utilizando estas propiedades de Elemento, se puede hacer referencia al segundo Elemento hijo del primer Elemento hijo del Documento con cualquiera de estas expresiones:</p>
    <p>(En un documento HTML estándar, ambas expresiones se refieren a la etiqueta &lt;body> del documento).</p>
    <p>A continuación se muestran dos funciones que demuestran cómo se pueden utilizar estas propiedades para realizar de forma recurrente un recorrido en profundidad de un documento invocando una función específica para cada elemento del documento:</p>
    <p class="title-article text-left">Documentos como árboles de nodos</p>
    <p>Si desea recorrer un documento o alguna parte del mismo y no quiere ignorar los nodos de Texto, puede utilizar un conjunto diferente de propiedades definidas en todos los objetos Nodo. Esto le permitirá ver Elementos, nodos de Texto e incluso nodos de Comentario (que representan comentarios HTML en el documento).</p>
    <p>Todos los objetos Nodo definen las siguientes propiedades:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nodo que es el padre de éste, o null para nodos como el objeto Documento
      que no tienen padre.</p>
    <p><codeinline>childNodes</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una NodeList de sólo lectura que contiene todos los hijos (no sólo los hijos del Elemento) del nodo.</p>
    <p><codeinline>firstChild</codeinline>, <codeinline>lastChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El primer y último nodo hijo de un nodo, o null si el nodo no tiene hijos.</p>
    <p><codeinline>nextSibling</codeinline>, <codeinline>previousSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los nodos hermanos siguiente y anterior de un nodo. Estas propiedades
      conectan nodos en una lista doblemente enlazada.</p>
    <p><codeinline>nodeType</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Un número que especifica de qué tipo de nodo se trata. Los nodos documento tienen valor 9. Los nodos Elemento tienen valor 1. Los nodos de texto tienen valor 3. Los nodos de comentario tienen valor 8.</p>
    <p><codeinline>nodeValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El contenido textual de un nodo Texto o Comentario.</p>
    <p><codeinline>nodeName</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nombre de etiqueta HTML de un elemento, convertido a mayúsculas.</p>
    <p>Utilizando estas propiedades de Nodo, se puede hacer referencia al segundo nodo hijo del primer hijo del Documento con expresiones como estas:</p>
    <p>Supongamos que el documento en cuestión es el siguiente:</p>
    <p>El segundo hijo del primer hijo es el elemento &lt;body>. Tiene un nodeType de 1 y un nodeName de "BODY".</p>
    <p>Tenga en cuenta, sin embargo, que esta API es extremadamente sensible a las variaciones en el texto del documento. Si se modifica el documento insertando una sola nueva línea entre el &lt;html> y el icono&lt;head>, por ejemplo, el nodo Text que representa esa nueva línea se convierte en el primer hijo del primer hijo, y el segundo hijo es el elemento &lt;head> en lugar del elemento &lt;body>.</p>
    <p>Para demostrar esta API de navegación basada en nodos, he aquí una función que devuelve todo e l texto de un elemento o documento:</p>
    <p>Esta función es sólo una demostración-en la práctica, usted simplemente escribiría e.text Content para obtener el contenido textual del elemento e.</p>
  </section>
  <section id="3-3">
    <h2>15.3.3 Atributos</h2>
    <p>Los elementos HTML constan de un nombre de etiqueta y un conjunto de pares nombre/valor conocidos como atributos. El elemento &lt;a> que define un hipervínculo, por ejemplo, utiliza el valor de su atributo href como destino del enlace.</p>
    <p>La clase Element define métodos generales getAttribute(), setAttribute(), hasAttri bute() y removeAttribute() para consultar, establecer, comprobar y eliminar los atributos de un elemento. Pero los valores de los atributos de los elementos HTML (para todos los atributos estándar de los elementos HTML estándar) están disponibles como propiedades de los objetos HTMLElement que representan esos elementos, y normalmente es mucho más fácil trabajar con ellos como propiedades de JavaScript que llamar a getAttribute() y métodos relacionados.</p>
    <p class="title-article text-left">Atributos HTML como propiedades de elementos</p>
    <p>Los objetos Element que representan los elementos de un documento HTML suelen definir propiedades de lectura/escritura que reflejan los atributos HTML de los elementos. Elemento define propiedades para los atributos HTML universales como id, title, lang y dir y propiedades de manejador de eventos como onclick. Los subtipos específicos de elementos definen atributos específicos de esos elementos. Para consultar la URL de una imagen, por ejemplo, puede utilizar la propiedad src del HTMLElement que representa al elemento &lt;img>:</p>
    <p>De forma similar, podrías establecer los atributos de envío de formulario de un elemento &lt;form> con código como este:</p>
    <p>Para algunos elementos, como el elemento &lt;input>, algunos nombres de atributos HTML corresponden a propiedades con nombres diferentes. El atributo HTML value de un &lt;input>, por ejemplo, se refleja en la propiedad JavaScript defaultValue. La propiedad JavaScript value del elemento &lt;input> contiene la entrada actual del usuario, pero los cambios en la propiedad value no afectan a la propiedad defaultValue ni al atributo value.</p>
    <p>Los atributos HTML no distinguen entre mayúsculas y minúsculas, pero los nombres de propiedades JavaScript sí. Para convertir un nombre de atributo en una propiedad JavaScript, escríbalo en minúsculas. Sin embargo, si el atributo tiene más de una palabra, ponga la primera letra de cada palabra después de la primera en mayúsculas: defaultChecked y tabIndex, por ejemplo. Sin embargo, las propiedades de controlador de eventos como onclick son una excepción y se escriben en minúsculas.</p>
    <p>Algunos nombres de atributos HTML son palabras reservadas en JavaScript. Para ellos, la regla general es anteponer "html" al nombre de la propiedad. El atributo HTML for (del tipo &lt;label>), por ejemplo, se convierte en la propiedad htmlFor de JavaScript. "class" es una palabra reservada en JavaScript, y el importantísimo atributo HTML class es una excepción a la regla: se convierte en className en código JavaScript.</p>
    <p>Las propiedades que representan atributos HTML suelen tener valores de cadena. Pero cuando el atributo es un valor booleano o numérico (los atributos defaultChecked y maxLength de un elemento &lt;input>, por ejemplo), las propiedades son booleanas o numéricas en lugar de cadenas. Los atributos de manejador de eventos siempre tienen funciones (o null) como valores.</p>
    <p>Tenga en cuenta que esta API basada en propiedades para obtener y establecer valores de atributos no define ninguna forma de eliminar un atributo de un elemento. En particular, el operador delete no puede utilizarse para este propósito. Si necesita eliminar un atributo, utilice el método removeAttribute().</p>
    <p class="title-article text-left">El atributo de clase</p>
    <p>El atributo class de un elemento HTML es especialmente importante. Su valor es una lista separada por espacios de clases CSS que se aplican al elemento y afectan a su estilo con CSS. Como class es una palabra reservada en JavaScript, el valor de este atributo está disponible a través de la propiedad className en los objetos Element. La propiedad className puede establecer y devolver el valor del atributo class como una cadena. Pero la propiedad class está mal nombrado: su valor es una lista de clases CSS, no una sola clase, y es común en la programación JavaScript del lado del cliente querer añadir y eliminar nombres de clases individuales de esta lista en lugar de trabajar con la lista como una sola cadena.</p>
    <p>Por esta razón, los objetos Element definen una propiedad classList que permite tratar el atributo class como una lista. El valor de la propiedad classList es un objeto iterable tipo Array. Aunque el nombre de la propiedad es classList, se comporta más como un conjunto de clases, y define los métodos add(), remove(), contains() y toggle():</p>
    <p class="title-article text-left">Atributos del conjunto de datos</p>
    <p>A veces resulta útil adjuntar información adicional a elementos HTML, normalmente cuando el código JavaScript va a seleccionar esos elementos y manipularlos de alguna manera. En HTML, cualquier atributo cuyo nombre esté en minúsculas y empiece por el prefijo "data-" se considera válido, y puedes utilizarlos para cualquier propósito. Estos "atributos de conjunto de datos" no afectarán a la presentación de los elementos en los que aparecen, y definen una forma estándar de adjuntar datos adicionales sin comprometer la validez del documento.</p>
    <p>En el DOM, los objetos Element tienen una propiedad dataset que hace referencia a un objeto que tiene propiedades que corresponden a los atributos data- con su prefijo eliminado. Así, dataset.x contendría el valor del atributo data-x. Los atributos con guión se asignan a nombres de propiedad en camelCase: el atributo data-section-number se convierte en la propiedad dataset.sectionNumber.</p>
    <p>Supongamos que un documento HTML contiene este texto:</p>
    <p>Entonces podrías escribir JavaScript como este para acceder a ese número de sección:</p>
  </section>
  <section id="3-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.4 Elemento Contenido</h2>
    <p>Observe de nuevo el árbol de documentos de la Figura 15-1 y pregúntese cuál es el "contenido" del elemento <p>. Hay dos formas de responder a esta pregunta:</p>
    <ul>
      <li class="font-normal">El contenido es la cadena HTML "Este es un documento &lt;i>simple&lt;/i>".</li>
      <li class="font-normal">El contenido es la cadena de texto plano "This is a simple document".</li>
    </ul>
    <p>Ambas respuestas son válidas, y cada una de ellas es útil a su manera. Las secciones siguientes explican cómo trabajar con la representación HTML y la representación en texto plano del contenido de un elemento.</p>
    <p class="title-article text-left">Contenido del elemento como HTML</p>
    <p>La lectura de la propiedad innerHTML de un elemento devuelve el contenido de ese elemento como una cadena de marcado. Al establecer esta propiedad en un elemento, se invoca el analizador del navegador web y se sustituye el contenido actual del elemento por una representación analizada de la nueva cadena. Puedes probarlo abriendo la consola de desarrollo y escribiendo:</p>
    <p>Verá que toda la página web desaparece y es sustituida por el encabezado "Oops". Los navegadores web son muy buenos analizando HTML, y establecer innerHTML suele ser bastante eficiente. Tenga en cuenta, sin embargo, que añadir texto a la propiedad innerHTML con el operador += no es eficiente porque requiere un paso de serialización para convertir el contenido del elemento en una cadena y luego un paso de análisis para convertir la nueva cadena de nuevo en contenido del elemento.</p>
    <nota>
      <img class="self-start" src="/public/javascript/nota_warning.svg" alt="Nota de la warning">
      <div class="">
        <p>Cuando utilices estas API HTML, es muy importante que nunca introduzcas datos del usuario en el documento. Si lo hace, permitirá que usuarios malintencionados inyecten sus propios scripts en su aplicación. Consulte "Cross-site scripting" en la página 425 para más detalles.</p>
      </div>
    </nota>
    <p>La propiedad outerHTML de un elemento es como innerHTML, salvo que su valor incluye el propio elemento. Cuando se consulta outerHTML, el valor incluye las etiquetas de apertura y cierre del elemento. Y cuando estableces outerHTML en un elemento, el nuevo contenido sustituye al propio elemento.</p>
    <p>Un método relacionado con Element es insertAdjacentHTML(), que permite insertar una cadena de código HTML arbitraria "adyacente" al elemento especificado. La marca se pasa como segundo argumento a este método, y el significado exacto de "adyacente" depende del valor del primer argumento. Este primer argumento debe ser una cadena con uno de los valores "beforebegin", "afterbegin", "beforeend" o "afterend". Estos valores corresponden a los puntos de inserción que se ilustran en la Figura 15-2.</p>
    <figure id="figure15-2">
      <img src="/public/javascript/capitulo-15/figure15-2.avif" alt="imagen de consola">
      <figcaption>Figura 15-2. Puntos de inserción para insertAdjacentHTML()</figcaption>
    </figure>
  </section>
  <section id="3-5">
    <h2>15.3.5 Creación, inserción y supresión de nodos</h2>
  </section>
  <section id="3-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.6 Ejemplo: Generación de un índice</h2>
  </section>
  <section id="4">
    <h2>15.4 Secuencias de comandos CSS</h2>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.1 Clases de CSS</h2>
  </section>
  <section id="4-2">
    <h2>15.4.2 Estilos en línea</h2>
  </section>
  <section id="4-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.3 Estilos calculados</h2>
  </section>
  <section id="4-4">
    <h2>15.4.4 Hojas de estilo de secuencias de comandos</h2>
  </section>
  <section id="4-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.5 Animaciones y eventos CSS</h2>
  </section>
  <section id="5">
    <h2>15.5 Geometría del documento y desplazamiento</h2>
  </section>
  <section id="5-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.1 Coordenadas del documento y coordenadas de la ventana gráfica</h2>
  </section>
  <section id="5-2">
    <h2>15.5.2 Consulta de la geometría de un elemento</h2>
  </section>
  <section id="5-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.3 Determinación del elemento en un punto</h2>
  </section>
  <section id="5-4">
    <h2>15.5.4 Desplazamiento</h2>
  </section>
  <section id="5-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.5 Tamaño de la ventana, tamaño del contenido y posición de desplazamiento</h2>
  </section>
  <section id="6">
    <h2>15.6 Componentes web</h2>
    <p>HTML es un lenguaje de marcado de documentos que define un rico conjunto de etiquetas con ese fin. En las últimas tres décadas, se ha convertido en un lenguaje que se utiliza para describir las interfaces de usuario de las aplicaciones web, pero las etiquetas HTML básicas como &lt;input> y &lt;button> son inadecuadas para los diseños de interfaz de usuario modernos. Los desarrolladores web son capaces de hacer que funcione, pero sólo mediante el uso de CSS y JavaScript para aumentar la apariencia y el comportamiento de las etiquetas HTML básicas. Considere un componente típico de interfaz de usuario, como el cuadro de búsqueda que se muestra en la Figura 15-3.</p>
    <figure id="figure15-3">
      <img src="/public/javascript/capitulo-15/figure15-3.avif" alt="imagen de consola">
      <figcaption>Figura 15-3. Componente de la interfaz de usuario de un cuadro de búsqueda</figcaption>
    </figure>
  </section>
  <section id="6-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.1 Uso de componentes web</h2>
  </section>
  <section id="6-2">
    <h2>15.6.2 Plantillas HTML</h2>
  </section>
  <section id="6-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.3 Elementos personalizados</h2>
  </section>
  <section id="6-4">
    <h2>15.6.4 DOM en la sombra</h2>
  </section>
  <section id="6-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.5 Ejemplo: un componente web &lt;search-box>.</h2>
  </section>
  <section id="7">
    <h2>15.7 SVG: gráficos vectoriales escalables</h2>
  </section>
  <section id="7-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.1 SVG en HTML</h2>
  </section>
  <section id="7-2">
    <h2>15.7.2 Secuencias de comandos SVG</h2>
  </section>
  <section id="7-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.3 Creación de imágenes SVG con JavaScript</h2>
  </section>
  <section id="8">
    <h2>15.8 Gráficos en un &lt;canvas></h2>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.1 Trayectorias y polígonos</h2>
  </section>
  <section id="8-2">
    <h2>15.8.2 Dimensiones y coordenadas del lienzo</h2>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.3 Atributos gráficos</h2>
  </section>
  <section id="8-4">
    <h2>15.8.4 Operaciones de dibujo en el lienzo</h2>
  </section>
  <section id="8-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.5 Transformaciones de sistemas de coordenadas</h2>
  </section>
  <section id="8-6">
    <h2>15.8.6 Recorte</h2>
  </section>
  <section id="8-7" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.7 Manipulación de píxeles</h2>
  </section>
  <section id="9">
    <h2>15.9 API de audio</h2>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.9.1 El constructor Audio()</h2>
  </section>
  <section id="9-2">
    <h2>15.9.2 La API WebAudio</h2>
  </section>
  <section id="10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10 Localización, navegación e historia</h2>
  </section>
  <section id="10-1">
    <h2>15.10.1 Carga de nuevos documentos</h2>
  </section>
  <section id="10-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.2 Historial de navegación</h2>
  </section>
  <section id="10-3">
    <h2>15.10.3 Gestión del historial con hashchange Events</h2>
  </section>
  <section id="10-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.4 Gestión del historial con pushState()</h2>
  </section>
  <section id="10-1">
    <h2>15.10.1 Carga de nuevos documentos</h2>
  </section>
  <section id="11" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11 Red</h2>
  </section>
  <section id="11-1">
    <h2>15.11.1 buscar()</h2>
  </section>
  <section id="11-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11.2 Eventos enviados por el servidor</h2>
  </section>
  <section id="11-3">
    <h2>15.11.3 WebSockets</h2>
  </section>
  <section id="12" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12 Almacenamiento</h2>
  </section>
  <section id="12-1">
    <h2>15.12.1 localStorage y sessionStorage</h2>
  </section>
  <section id="12-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12.2 Cookies</h2>
  </section>
  <section id="12-3">
    <h2>15.12.3 IndexedDB</h2>
  </section>
  <section id="13" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13 Hilos de trabajo y mensajería</h2>
  </section>
  <section id="13-1">
    <h2>15.13.1 Objetos de trabajo</h2>
  </section>
  <section id="13-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.2 El objeto global en los trabajadores</h2>
  </section>
  <section id="13-3">
    <h2>15.13.3 Importar código a un trabajador</h2>
  </section>
  <section id="13-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.4 Modelo de ejecución de los trabajadores</h2>
  </section>
  <section id="13-5">
    <h2>15.13.5 postMessage(), MessagePorts y MessageChannels</h2>
  </section>
  <section id="13-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.6 Mensajería entre orígenes con postMessage()</h2>
  </section>
  <section id="14">
    <h2>15.14 Ejemplo: El conjunto de Mandelbrot</h2>
  </section>
  <section id="15" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15 Resumen y sugerencias de lecturas complementarias</h2>
  </section>
  <section id="15-1">
    <h2>15.15.1 HTML y CSS</h2>
  </section>
  <section id="15-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.2 Rendimiento</h2>
  </section>
  <section id="15-3">
    <h2>15.15.3 Seguridad</h2>
  </section>
  <section id="15-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.4 WebAssembly</h2>
  </section>
  <section id="15-5">
    <h2>15.15.5 Más funciones para documentos y ventanas</h2>
  </section>
  <section id="15-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.6 Eventos</h2>
  </section>
  <section id="15-7">
    <h2>15.15.7 Aplicaciones web progresivas y Service Workers</h2>
  </section>
  <section id="15-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.8 API para dispositivos móviles</h2>
  </section>
  <section id="15-9">
    <h2>15.15.9 API binarias</h2>
  </section>
  <section id="15-10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.10 API multimedia</h2>
  </section>
  <section id="15-11" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>15.15.11 Criptografía y API relacionadas</h2>
  </section>
  </Layoutjavascript>