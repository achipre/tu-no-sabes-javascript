---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-14" capSiguiente="capitulo-16" />
  <section class="fadeIn">
    <h1>JavaScript en los navegadores web</h1>
    <p>El lenguaje JavaScript se creó en 1994 con el propósito expreso de permitir el comportamiento dinámico de en los documentos mostrados por los navegadores web. Desde entonces, el lenguaje ha evolucionado significativamente y, al mismo tiempo, el alcance y las capacidades de la plataforma web han crecido de forma explosiva. Hoy en día, los programadores de JavaScript pueden considerar la web como una plataforma completa para el desarrollo de aplicaciones. Los navegadores web están especializados en la visualización de texto formateado e imágenes, pero, al igual que los sistemas operativos nativos, los navegadores también proporcionan otros servicios, como gráficos, vídeo, audio, redes, almacenamiento y subprocesos. JavaScript es el lenguaje que permite a las aplicaciones web utilizar los servicios proporcionados por la plataforma web, y este capítulo muestra cómo utilizar los más importantes de estos servicios.</p>
    <p>El capítulo comienza con el modelo de programación de la plataforma web, explicando cómo se incrustan los scripts en las páginas HTML (§15.1) y cómo el código JavaScript se activa de forma asíncrona mediante eventos (§15.2). Las secciones que siguen a este material introductorio documentan las principales API de JavaScript que permiten a las aplicaciones web:</p>
    <p>Los temas de metaprogramación tratados en este capítulo incluyen:</p>
    <ul>
      <li class="font-normal">Controlar el contenido del documento (§15.3) y el estilo (§15.4)</li>
      <li class="font-normal">Determinar la posición en pantalla de los elementos del documento (§15.5)</li>
      <li class="font-normal">Crear componentes de interfaz de usuario reutilizables (§15.6)</li>
      <li class="font-normal">Dibujar gráficos (§15.7 y §15.8)</li>
      <li class="font-normal">Reproducir y generar sonidos (§15.9)</li>
      <li class="font-normal">Gestionar la navegación y el historial del navegador (§15.10)</li>
      <li class="font-normal">Intercambiar datos a través de la red (§15.11)</li>
      <li class="font-normal">Almacenar datos en el ordenador del usuario (§15.12)</li>
      <li class="font-normal">Realizar cálculos concurrentes con hilos (§15.13)</li>
    </ul>
    <article>
      <p class="title-article">JavaScript del lado del cliente</p>
      <p>En este libro, y en la web, verás el término "JavaScript del lado del cliente". El término es simplemente un sinónimo de JavaScript escrito para ejecutarse en un navegador web, y se contrapone al código "del lado del servidor", que se ejecuta en servidores web.</p>
      <p>Los dos "lados" se refieren a los dos extremos de la conexión de red que separan el servidor web y el navegador web, y el desarrollo de software para la web suele requerir que el código se escriba en ambos "lados". El lado del cliente y el lado del servidor también suelen llamarse "frontend" y "backend".</p>
    </article>
    <p>Las ediciones anteriores de este libro intentaban cubrir de forma exhaustiva todas las API de JavaScript definidas por los navegadores web y, como resultado, este libro era demasiado largo hace una década. El número y la complejidad de las API web no han dejado de crecer, y ya no creo que tenga sentido intentar abarcarlas todas en un solo libro. A partir de la séptima edición, mi objetivo es cubrir definitivamente el lenguaje JavaScript y proporcionar una introducción en profundidad al uso del lenguaje con Node y con los navegadores web. Este capítulo no puede cubrir todas las API web, pero presenta las más importantes con suficiente detalle como para que puedas empezar a usarlas de inmediato. Y, habiendo aprendido sobre las APIs principales cubiertas aquí, deberías ser capaz de coger nuevas APIs (como las resumidas en §15.15) cuando y si los necesita.</p>
    <p>Node tiene una única implementación y una única fuente autorizada de documentación. En cambio, las API web se definen por consenso entre los principales proveedores de navegadores web, y la documentación autorizada adopta la forma de una especificación destinada a los programadores de C++ que implementan la API, no a los programadores de JavaScript que la utilizarán. Afortunadamente, el proyecto "MDN web docs" de Mozilla es una <sup>fuente1</sup> fiable y completa de documentación sobre API web.</p>
    <article>
      <p class="title-article">API heredadas</p>
      <p>En los 25 años transcurridos desde el lanzamiento de JavaScript, los fabricantes de navegadores han ido añadiendo funciones y API para uso de los programadores. Muchas de esas API han quedado obsoletas. Entre ellas están:</p>
      <ul> <li class="font-normal">API propietarias que nunca se estandarizaron y/o nunca fueron implementadas
          por otros proveedores de navegadores. Internet Explorer de Microsoft definió
          muchas de estas API. Algunas (como la propiedad innerHTML) resultaron útiles y acabaron
          estandarizándose. Otros (como el método attachEvent()) llevan años obsoletos.</li>
        <li class="font-normal">APIs ineficientes (como el método document.write()) que tienen un impacto
          tan severo en el rendimiento que su uso ya no se considera aceptable.</li>
        <li class="font-normal">APIs obsoletas que hace tiempo que han sido sustituidas por nuevas APIs para
          conseguir lo mismo. Un ejemplo es document.bgColor, que se definió para
          permitir a Java Script establecer el color de fondo de un documento. Con la
          llegada de CSS, document.bgColor se convirtió en un pintoresco caso especial
          sin ningún propósito real.</li>
        <li class="font-normal">API mal diseñadas que han sido sustituidas por otras mejores. En los inicios de la
          web, los comités de normalización definieron la API clave del Modelo de Objetos
          de Documento de forma agnóstica al lenguaje, de modo que la misma API
          pudiera utilizarse en programas Java para trabajar con documentos XML y en
          programas JavaScript para trabajar con documentos HTML. El resultado fue una
          API que no se adaptaba bien al lenguaje JavaScript y que tenía características que
          no interesaban especialmente a los programadores web. Se tardó décadas en
          recuperarse de aquellos primeros errores de diseño, pero los navegadores web
          actuales soportan un Modelo de Objetos de Documento muy mejorado.</li>
      </ul>
      <p>Los vendedores de navegadores pueden necesitar dar soporte a estas APIs heredadas
        en un futuro previsible para asegurar la compatibilidad con versiones anteriores, pero
        ya no hay necesidad de que este libro las documente o de que tú aprendas sobre ellas.
        La plataforma web ha madurado y se ha estabilizado, y si eres un desarrollador web
        experimentado que recuerda la cuarta o quinta edición de este libro, entonces puede
        que tengas tanto conocimiento obsoleto que olvidar como nuevo material que
        aprender.</p>
    </article>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1 Conceptos básicos de programación web</h2>
    <p>Esta sección explica cómo se estructuran los programas JavaScript para la web, cómo se cargan en un navegador web, cómo obtienen la entrada, cómo producen la salida y cómo se ejecutan de forma asíncrona respondiendo a eventos.</p>
  </section>
  <section id="1-1">
    <h2>15.1.1 JavaScript en etiquetas HTML &lt;script></h2>
    <p>Los navegadores web muestran documentos HTML. Si desea que un navegador web ejecute código Java-Script, debe incluir (o hacer referencia a) ese código desde un documento HTML, y esto es lo que hace la etiqueta HTML &lt;script>.</p>
    <p>El código JavaScript puede aparecer en línea dentro de un archivo HTML entre &lt;script> y &lt;/script>. He aquí, por ejemplo, un archivo HTML que incluye una etiqueta script con código JavaScript que actualiza dinámicamente un elemento del documento para que se comporte como un reloj digital:</p>
    <pre>
    <code class="language-js">&lt;!DOCTYPE html>               &lt;!-- This is an HTML5 file -->
    &lt;html>                        &lt;!-- The root element -->
    &lt;head>                        &lt;!-- Title, scripts & styles can go here -->
    &lt;title>Digital Clock</title>
    &lt;style>                       /* A CSS stylesheet for the clock */
    #clock &lbrace;                      /* Styles apply to element with id="clock" */
      font: bold 24px sans-serif; /* Use a big bold font */
      background: #ddf;           /* on a light bluish-gray background. */
      padding: 15px;              /* Surround it with some space */
      border: solid black 2px;    /* and a solid black border */
      border-radius: 10px;        /* with rounded corners. */
    }
    &lt;/style>
    &lt;/head>
    &lt;body>             &lt;!-- The body holds the content of the document. -->
    &lt;h1>Digital Clock</h1>  &lt;!-- Display a title. -->
    &lt;span id="clock"></span>  &lt;!-- We will insert the time into this element. -->
    &lt;script>
    // Define a function to display the current time
    function displayTime() &lbrace;
      let clock = document.querySelector("#clock"); // Get element with id="clock"
      let now = new Date();                         // Get current time
      clock.textContent = now.toLocaleTimeString(); // Display time in the clock
    }
    displayTime()                   // Display the time right away
    setInterval(displayTime, 1000); // And then update it every second.
    &lt;/script>
    &lt;/body>
    &lt;/html></code></pre>
    <p>Aunque el código JavaScript puede incrustarse directamente dentro de una etiqueta &lt;script>, es más habitual utilizar el atributo src de la etiqueta &lt;script> para especificar la URL (una URL absoluta o una URL relativa a la URL del archivo HTML que se muestra) de un archivo que contiene código JavaScript. Si sacáramos el código JavaScript de este archivo HTML y lo almacenáramos en su propio archivo scripts/digital_clock.js, entonces la etiqueta &lt;script> podría hacer referencia a ese archivo de código de la siguiente manera:</p>
    <pre>
    <code class="language-js">&lt;script src="scripts/digital_clock.js">&lt;/script></code></pre>
    <p>Un archivo JavaScript contiene JavaScript puro, sin etiquetas &lt;script> ni ningún otro HTML. Por convención, los archivos de código JavaScript tienen nombres que terminan en .js.</p>
    <p>Una etiqueta &lt;script> con el atributo src se comporta exactamente igual que si el contenido del archivo JavaScript especificado apareciera directamente entre las etiquetas &lt;script> y &lt;/script>. Tenga en cuenta que la etiqueta &lt;/script> de cierre es necesaria en los documentos HTML incluso cuando se especifica el atributo src: HTML no admite la etiqueta &lt;script/>.</p>
    <p>Utilizar el atributo src tiene una serie de ventajas:</p>
    <ul>
      <li class="font-normal">Simplifica sus archivos HTML al permitirle eliminar de ellos grandes bloques de código Java-Script, es decir, ayuda a mantener separados el contenido y el comportamiento.</li>
      <li class="font-normal">Cuando varias páginas web comparten el mismo código JavaScript, el uso del atributo src permite mantener una sola copia de ese código, en lugar de tener que editar cada archivo HTML cuando cambia el código.</li>
      <li class="font-normal">Si más de una página comparte un archivo de código JavaScript, sólo tendrá que descargarlo una vez la primera página que lo utilice; las siguientes podrán recuperarlo de la caché del navegador.</li>
      <li class="font-normal">Dado que el atributo src toma como valor una URL arbitraria, un programa JavaScript o una página web de un servidor web pueden emplear código exportado por otros servidores web. Gran parte de la publicidad en Internet se basa en este hecho.</li>
    </ul>
    <p class="title-article text-left">Módulos</p>
    <p>§10.3 documenta los módulos JavaScript y cubre sus directivas import y export. Si ha escrito su programa JavaScript utilizando módulos (y no ha utilizado una herramienta de agrupación de código para combinar todos sus módulos en un único archivo JavaScript no modular), debe cargar el módulo de nivel superior de su programa con una directiva &lt;script> que tenga un atributo type="module". Si haces esto, el módulo que especifiques se cargará, y todos los módulos que importe se cargarán, y (recur- sivamente) todos los módulos que importen se cargarán. Para más información, véase §10.3.5.</p>
    <p class="title-article text-left">Especificación del tipo de script</p>
    <p>En los primeros días de la web, se pensaba que los navegadores podrían implementar algún día lenguajes distintos de JavaScript, y los programadores añadían atributos como language="javascript" y type="application/javascript" a sus etiquetas &lt;script>. Esto es completamente innecesario. JavaScript es el lenguaje por defecto (y el único) de la web. El atributo language está obsoleto, y sólo hay dos razones para usar un atributo type en una etiqueta &lt;script>:</p>
    <ul>
      <li class="font-normal">Para especificar que el script es un módulo</li>
      <li class="font-normal">Para incrustar datos en una página web sin mostrarlos (véase §15.3.4)</li>
    </ul>
    <p class="title-article text-left">Cuándo se ejecutan los scripts: async y diferido</p>
    <p>Cuando JavaScript se incorporó por primera vez a los navegadores web, no existía una API para recorrer y manipular la estructura y el contenido de un documento ya renderizado. La única forma en que el código JavaScript podía afectar al contenido de un documento era generando ese contenido sobre la marcha mientras el documento estaba en proceso de carga. Para ello utilizando el método document.write() para inyectar texto HTML en el documento en la ubicación del script.</p>
    <p>El uso de document.write() ya no se considera un buen estilo, pero el hecho de que sea posible significa que cuando el analizador HTML encuentra un elemento &lt;script>, debe, por defecto, ejecutar el script sólo para asegurarse de que no produce ninguna salida HTML antes de que pueda reanudar el análisis y la representación del documento. Esto puede ralentizar drásticamente el análisis y la representación de la página web.</p>
    <p>Afortunadamente, este modo de ejecución de scripts síncrono o de bloqueo por defecto no es la única opción. La etiqueta &lt;script> puede tener atributos defer y async, que hacen que los scripts se ejecuten de forma diferente. Se trata de atributos booleanos: no tienen valor; sólo tienen que estar presentes en la etiqueta &lt;script>. Ten en cuenta que estos atributos sólo son significativos cuando se utilizan junto con el atributo src:</p>
    <pre>
    <code class="language-js">&lt;script defer src="deferred.js">&lt;/script>
    &lt;script async src="async.js">&lt;/script></code></pre>
    <p>Tanto el atributo defer como el async son formas de indicar al navegador que el script enlazado no utiliza document.write() para generar la salida HTML, y que el navegador, por lo tanto, puede continuar analizando y renderizando el documento mientras descarga el script. El atributo defer hace que el navegador aplace la ejecución del script hasta que el documento haya sido completamente cargado y analizado y esté listo para ser manipulado. El atributo async hace que el navegador ejecute el script lo antes posible, pero no bloquea el análisis del documento mientras se descarga el script. Si una etiqueta &lt;script> tiene ambos atributos, el atributo async tiene preferencia.</p>
    <p>Tenga en cuenta que los scripts diferidos se ejecutan en el orden en que aparecen en el documento. Los scripts asíncronos se ejecutan a medida que se cargan, lo que significa que pueden ejecutarse fuera de orden.</p>
    <p>Los scripts con el atributo type="module" se ejecutan, por defecto, después de que el documento se haya cargado, como si tuvieran el atributo defer. Puedes anular este valor por defecto con el atributo async, que hará que el código se ejecute tan pronto como el módulo y todas sus dependencias se hayan cargado.</p>
    <p>Una alternativa sencilla a los atributos async y defer -especialmente para el código que se incluye directamente en el HTML- es simplemente colocar tus scripts al final del archivo HTML. De esta forma, el script puede ejecutarse sabiendo que el contenido del documento que le precede ha sido analizado y está listo para ser manipulado.</p>
    <p class="title-article text-left">Carga de guiones a petición</p>
    <p>A veces, puede tener código JavaScript que no se utiliza cuando un documento se carga por primera vez y sólo se necesita si el usuario realiza alguna acción como pulsar un botón o abrir un menú. Si está desarrollando su código utilizando módulos, puede cargar un módulo bajo demanda con import(), como se describe en §10.3.6.</p>
    <p>Si no utiliza módulos, puede cargar un archivo de JavaScript bajo demanda simplemente añadiendo una etiqueta &lt;script> a su documento cuando desee que se cargue el script:</p>
    <pre>
    <code class="language-js">// Asynchronously load and execute a script from a specified URL
    // Returns a Promise that resolves when the script has loaded.
    function importScript(url) &lbrace;
      return new Promise((resolve, reject) => &lbrace;
        let s = document.createElement("script"); // Create a &lt;script> element
        s.onload = () => &lbrace; resolve(); };          // Resolve promise when loaded
        s.onerror = (e) => &lbrace; reject(e); };        // Reject on failure
        s.src = url;                              // Set the script URL
        document.head.append(s);                  // Add &lt;script> to document
      });
    }</code></pre>
    <p>Esta función importScript() utiliza las API del DOM (§15.3) para crear una nueva etiqueta &lt;script> y añadirla al documento &lbrace;head>. Y utiliza manejadores de eventos (§15.2) para determinar cuando el script se ha cargado correctamente o cuando la carga ha fallado.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.2 El modelo de objetos del documento</h2>
    <p>Uno de los objetos más importantes en la programación JavaScript del lado del cliente es el objeto Document, que representa el documento HTML que se muestra en una ventana o pestaña del navegador. La API para trabajar con documentos HTML se conoce como el Modelo de Objetos de Documento, o DOM, y se cubre en detalle en §15.3. Pero el DOM es tan importante para la programación JavaScript del lado del cliente que merece ser introducido aquí.</p>
    <p>Los documentos HTML contienen elementos HTML anidados unos dentro de otros, formando un árbol. Considere el siguiente documento HTML sencillo:</p>
    <pre>
    <code class="language-js">&lt;html>
      &lt;head>
        &lt;title>Sample Document&lt;/title>
      &lt;/head>
      &lt;body>
        &lt;h1>An HTML Document&lt;/h1>
        &lt;p>This is a &lt;i>simple&lt;/i> document.
      &lt;/body>
    &lt;/html></code></pre>
    <p>La etiqueta &lt;html> de nivel superior contiene las etiquetas &lt;head> y &lt;body>. La etiqueta &lt;head> contiene un &lt;title>. Y la etiqueta &lt;body> contiene las etiquetas &lt;h1> y &lt;p>. Las etiquetas &lt;title> y &lt;h1> contienen cadenas de texto, y la etiqueta &lt;p> contiene dos cadenas de texto con una etiqueta &lt;i> entre ellas.</p>
    <p>La API DOM refleja la estructura de árbol de un documento HTML. A cada etiqueta HTML del documento le corresponde un objeto Elemento de JavaScript, y a cada segmento de texto del documento le corresponde un objeto Texto. Los objetos Element y las clases de texto, así como la propia clase Document, son todas subclases de la clase más general Node, y los objetos Node están organizados en una estructura de árbol que JavaScript puede consultar y recorrer utilizando la API DOM. La representación DOM de este documento e s el árbol que se muestra en la Figura 15-1.</p>
    <figure id="figure15-1">
      <img src="/public/javascript/capitulo-15/figure15-1.avif" alt="imagen de consola">
      <figcaption>Figura 15-1. Representación en árbol de un documento HTML</figcaption>
    </figure>
    <p>Si aún no está familiarizado con las estructuras de árbol en programación informática, es útil saber que toman prestada la terminología de los árboles genealógicos. El nodo situado justo encima de un nodo es su padre. Los nodos situados un nivel por debajo de otro nodo son sus hijos. Los nodos del mismo nivel y con el mismo padre son hermanos. El conjunto de nodos situados cualquier número de niveles por debajo de otro nodo son los descendientes de ese nodo. Y el padre, el abuelo y todos los demás nodos situados por encima de un nodo son los antepasados de ese nodo.</p>
    <p>La API DOM incluye métodos para crear nuevos nodos Element y Text, y para insertarlos en el documento como hijos de otros objetos Element. También hay métodos para mover elementos dentro del documento y para eliminarlos por completo. Mientras que una aplicación del lado del servidor puede producir una salida de texto plano escribiendo cadenas con console.log(), una aplicación JavaScript del lado del cliente puede producir una salida HTML formateada construyendo o manipulando el documento del árbol de documentos utilizando la API DOM.</p>
    <p>Hay una clase de JavaScript que corresponde a cada tipo de etiqueta HTML, y cada aparición de la etiqueta en un documento está representada por una instancia de la clase. La etiqueta &lt;body>, por ejemplo, está representada por una instancia de HTMLBodyElement, y una etiqueta &lt;table> está representada por una instancia de HTMLTableElement. Los objetos elemento de JavaScript tienen propiedades que corresponden a los atributos HTML de las etiquetas. En</p>
    <p>Por ejemplo, las instancias de HTMLImageElement, que representan etiquetas &lt;img>, tienen una propiedad src que corresponde al atributo src de la etiqueta. El valor inicial de la propiedad src es el valor del atributo que aparece en la etiqueta HTML, y establecer esta propiedad con JavaScript cambia el valor del atributo HTML (y hace que el navegador cargue y muestre una nueva imagen). La mayoría de las clases de elementos de JavaScript se limitan a reflejar los atributos de una etiqueta HTML, pero algunas definen métodos adicionales. Las clases HTMLAu- dioElement y HTMLVideoElement, por ejemplo, definen métodos como play() y pause() para controlar la reproducción de archivos de audio y vídeo.</p>
  </section>
  <section id="1-3">
    <h2>15.1.3 El objeto global en los navegadores web</h2>
    <p>Existe un objeto global por cada ventana o pestaña del navegador (§3.7). Todo el código JavaScript (excepto el código que se ejecuta en hilos de trabajo; véase §15.13) que se ejecuta en esa ventana comparte este único objeto global. Esto es así independientemente de cuántos scripts o módulos haya en el documento: todos los scripts y módulos de un documento comparten un único objeto global; si un script define una propiedad en ese objeto, esa propiedad es visible también para todos los demás scripts.</p>
    <p>El objeto global es donde se define la biblioteca estándar de JavaScript: la función parseInt(), el objeto Math, la clase Set, etc. En los navegadores web, el objeto global también contiene los principales puntos de entrada de varias API web. Por ejemplo, la propiedad document representa el documento mostrado actualmente, el método fetch() realiza peticiones de red HTTP y el constructor Audio() permite a los programas JavaScript reproducir sonidos.</p>
    <p>En los navegadores web, el objeto global tiene una doble función: además de definir tipos y funciones incorporadas, también representa la ventana actual del navegador web y define propiedades como history (§15.10.2), que representa el historial de navegación de la ventana, e innerWidth, que contiene el ancho de la ventana en píxeles. Una de las propiedades de este objeto global se llama window, y su valor es el propio objeto global. Esto significa que puedes simplemente escribir window para referirte al objeto global en tu código del lado del cliente. Cuando se utilizan características específicas de la ventana, a menudo es una buena idea incluir un prefijo window.: window.innerWidth es más claro que innerWidth, por ejemplo.</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.4 Los scripts comparten un espacio de nombres</h2>
    <p>Con los módulos, las constantes, variables, funciones y clases definidas en el nivel superior (es decir, fuera de cualquier definición de función o clase) del módulo son privadas para el módulo a menos que se exporten explícitamente, en cuyo caso, pueden ser importadas selectivamente por otros módulos. (Tenga en cuenta que esta propiedad de los módulos también es respetada por las herramientas de agrupación de código).</p>
    <p>Sin embargo, con los scripts que no son módulos, la situación es completamente diferente. Si el código de nivel superior de un script define una constante, variable, función o clase, esa declaración será visible para todos los demás scripts del mismo documento. Si un script define una función f() y otro script define una clase c, entonces un tercer script puede invocar la función e instanciar la clase sin tener que realizar ninguna acción para importarlos. Por lo tanto, si no utiliza módulos, los scripts independientes de su documento comparten un único espacio de nombres y se comportan como si formaran parte de un único script mayor. Esto puede ser conveniente para programas pequeños, pero la necesidad de evitar conflictos de nombres puede volverse problemática para programas más grandes, especialmente cuando algunos de los scripts son bibliotecas de terceros.</p>
    <p>Las declaraciones var y function en el nivel superior crean propiedades en el objeto global compartido. Si un script define una función de nivel superior f(), entonces otro script en el mismo documento puede invocar esa función como f() o como window.f(). Por otro lado, las declaraciones const, let y class de ES6, cuando se utilizan en el nivel superior, no crean propiedades en el objeto global. Sin embargo, siguen estando definidas en un espacio de nombres compartido: si un script define una clase C, otros scripts podrán crear instancias de esa clase con new C(), pero no con new window.C().</p>
    <p>En resumen: en los módulos, las declaraciones de nivel superior se aplican al módulo y pueden exportarse explícitamente. En los scripts que no son módulos, sin embargo, las declaraciones de nivel superior se refieren al documento que los contiene, y las declaraciones son compartidas por todos los scripts del documento. Las declaraciones var y function más antiguas se comparten a través de las propiedades del objeto global. Las declaraciones const, let y class más recientes también se comparten y tienen el mismo ámbito de documento, pero no existen como propiedades de ningún objeto al que tenga acceso el código JavaScript.</p>
  </section>
  <section id="1-5">
    <h2>15.1.5 Ejecución de programas JavaScript</h2>
    <p>No existe una definición formal de programa en JavaScript del lado del cliente, pero podemos decir que un programa JavaScript consiste en todo el código JavaScript de un documento o al que se hace referencia desde él. Estas partes separadas de código comparten un único objeto Window global, que les da acceso al mismo objeto Document subyacente que representa el documento HTML. Los scripts que no son módulos comparten además un espacio de nombres de nivel superior.</p>
    <p>Si una página web incluye un marco incrustado (utilizando el elemento &lt;iframe>), el código Java-Script en el documento incrustado tiene un objeto global y un objeto Documento diferentes del código en el documento incrustado, y puede considerarse un programa JavaScript independiente. Recuerde, sin embargo, que no existe una definición formal de cuáles son los límites de un programa JavaScript. Si el documento contenedor y el documento contenido se cargan desde el mismo servidor, el código en un documento puede interactuar con el código en el otro, y puede tratarlos como dos partes interactuantes de un único programa, si lo desea. En §15.13.6 se explica cómo un programa JavaScript puede enviar y recibir mensajes hacia y desde el código JavaScript que se ejecuta en un &lt;iframe>.</p>
    <p>La ejecución de un programa JavaScript puede dividirse en dos fases. En la primera fase, se carga el contenido del documento y se ejecuta el código de los elementos &lt;script> (tanto scripts en línea como scripts externos). Por lo general, los scripts se ejecutan en el orden en que aparecen en el documento, aunque este orden predeterminado puede modificarse mediante los atributos async y defer que hemos descrito. El código JavaScript de cualquier script se ejecuta de arriba abajo, sujeto, por supuesto, a los condicionales, bucles y otras sentencias de control de JavaScript. Algunos scripts no hacen realmente nada durante esta primera fase y se limitan a definir funciones y clases para su uso en la segunda fase. Otros scripts pueden realizar un trabajo importante durante la primera fase y no hacer nada en la segunda. Imagina un script al final de un documento que encuentra todas las etiquetas &lt;h1> y &lt;h2> en el documento y modifica el documento generando e insertando una tabla de contenidos al principio del documento. Esto podría hacerse completamente en la primera fase. (Véase en §15.3.6 un ejemplo que hace exactamente esto).</p>
    <p>Una vez cargado el documento y ejecutados todos los scripts, la ejecución de JavaScript entra en su segunda fase. Esta fase es asíncrona y dirigida por eventos. Si un script va a participar en esta segunda fase, entonces una de las cosas que debe haber hecho durante la primera fase es registrar al menos un manejador de eventos u otra función callback que será invocada de forma asíncrona. Durante esta segunda fase dirigida por eventos, el navegador web invoca funciones manejadoras de eventos y otras retrollamadas en respuesta a eventos que ocurren asincrónicamente. Los manejadores de eventos se invocan más comúnmente en respuesta a la entrada del usuario (clics del ratón, pulsaciones de teclas, etc.), pero también pueden ser activados por la actividad de la red, la carga de documentos y recursos, el tiempo transcurrido, o errores en el código JavaScript. Los eventos y los controladores de eventos se describen con detalle en §15.2.</p>
    <p>Algunos de los primeros eventos que se producen durante la fase dirigida por eventos son los eventos "DOMCon- tentLoaded" y "load". "DOMContentLoaded" se activa cuando el documento HTML ha sido completamente cargado y analizado. El evento "load" se activa cuando todos los recursos externos del documento -como las imágenes- también se han cargado por completo. Los programas Java Script a menudo utilizan uno de estos eventos como disparador o señal de inicio. Es común ver programas cuyos scripts definen funciones pero no realizan otra acción que registrar una función manejadora de eventos para ser activada por el evento "load" al comienzo de la fase de ejecución dirigida por eventos. Es este manejador de eventos "load" el que manipula el documento y hace lo que se supone que debe hacer el programa. Tenga en cuenta que es común en la programación JavaScript que una función manejadora de eventos como el manejador de eventos "load" descrito aquí registre otros manejadores de eventos.</p>
    <p>La fase de carga de un programa JavaScript es relativamente corta: idealmente menos de un segundo. Una vez cargado el documento, la fase basada en eventos dura mientras el navegador muestra el documento. Dado que esta fase es asíncrona y basada en eventos, puede haber largos periodos de inactividad en los que no se ejecute JavaScript, interrumpidos por ráfagas de actividad provocadas por eventos del usuario o de la red. A continuación trataremos estas dos fases con más detalle.</p>
    <p class="title-article text-left">Modelo de subprocesamiento de JavaScript en el cliente</p>
    <p>JavaScript es un lenguaje monohilo, y la ejecución monohilo simplifica mucho la programación: puede escribir código con la seguridad de que nunca se ejecutarán dos controladores de eventos al mismo tiempo. Puedes manipular el contenido de un documento sabiendo que ningún otro hilo está intentando modificarlo al mismo tiempo, y nunca tendrás que preocuparte por bloqueos, puntos muertos o condiciones de carrera al escribir código Java-Script.</p>
    <p>La ejecución monohilo significa que los navegadores dejan de responder a las entradas del usuario mientras se ejecutan los scripts y los controladores de eventos. Esto supone una carga para los programadores de JavaScript: significa que los scripts de JavaScript y los controladores de eventos no deben ejecutarse durante demasiado tiempo. Si un script realiza una tarea de cálculo intensivo, provocará un retraso en la carga del documento, y el usuario no verá el contenido del documento hasta que el script finalice. Si un manejador de eventos realiza una tarea computacionalmente intensiva, el navegador puede dejar de responder, posiblemente haciendo que el usuario piense que se ha bloqueado.</p>
    <p>La plataforma web define una forma controlada de concurrencia llamada "web worker". Un web worker es un hilo en segundo plano para realizar tareas de cálculo intensivo sin congelar la interfaz de usuario. El código que se ejecuta en un hilo web worker no tiene acceso al contenido del documento, no comparte ningún estado con el hilo principal o con otros workers, y sólo puede comunicarse con el hilo principal y con otros workers de a través de eventos de mensajes asíncronos, por lo que la concurrencia no es detectable para el hilo principal, y los web workers no alteran el modelo básico de ejecución de un solo hilo de los programas JavaScript. Véase §15.13 para más detalles sobre el mecanismo de threading seguro de la web.</p>
    <p class="title-article text-left">Línea de tiempo JavaScript del lado del cliente</p>
    <p>Ya hemos visto que los programas JavaScript comienzan en una fase de ejecución de
      secuencias de comandos y luego pasan a una fase de gestión de eventos. Estas dos
      fases pueden dividirse en los siguientes pasos:</p>
    <ul>
      <li class="font-normal">El navegador web crea un objeto Document y comienza a analizar la página web, añadiendo objetos Element y nodos Text al documento a medida que analiza los elementos HTML y su contenido textual. La propiedad document.readyState tiene el valor "loading" en esta etapa.</li>
      <li class="font-normal">Cuando el analizador HTML encuentra una etiqueta &lt;script> que no tiene ninguno de los atributos async, defer o type="module", añade esa etiqueta script al documento y, a continuación, ejecuta el script. El script se ejecuta de forma sincrónica, y el analizador HTML hace una pausa mientras el script se descarga (si es necesario) y se ejecuta. Un script como este puede usar document.write() para insertar texto en el flujo de entrada, y ese texto se convertirá en parte del documento cuando el analizador se reanude. Un script a menudo simplemente define funciones y registra manejadores de eventos para su uso posterior, pero puede recorrer y manipular el árbol del documento tal y como existe en ese momento. Es decir, los scripts no modulares que no tienen un atributo async o defer pueden ver su propia etiqueta &lt;script> y el contenido del documento que le precede.</li>
      <li class="font-normal">Cuando el analizador encuentra un elemento &lt;script> con el atributo async activado, comienza a descargar el texto del script (y si el script es un módulo, también descarga de forma recurrente todas las dependencias del script) y continúa analizando el documento. El script se ejecutará lo antes posible una vez descargado, pero el analizador no se detiene a esperar a que se descargue. Los scripts asíncronos no deben utilizar el método document.write(). Pueden ver su propio &lt;script> y todo el contenido del documento que le precede, y puede o no tener acceso a contenido adicional del documento.</li>
      <li class="font-normal">Cuando el documento está completamente analizado, la propiedad document.readyState cambia a "interactive".</li>
      <li class="font-normal">Cualquier script que tenga el atributo defer (junto con cualquier script de módulo que no tenga un atributo async) se ejecuta en el orden en el que aparece en el documento. Los scripts asíncronos también pueden ejecutarse en este momento. Los scripts diferidos tienen acceso al documento completo y no deben utilizar el método document.write().</li>
      <li class="font-normal">El navegador lanza un evento "DOMContentLoaded" sobre el objeto Document. Esto marca la transición de la fase síncrona de ejecución de scripts a la fase asíncrona, dirigida por eventos, de ejecución del programa. Tenga en cuenta, sin embargo, que todavía puede haber scripts asíncronos que aún no se han ejecutado en este punto.</li>
      <li class="font-normal">El documento está completamente analizado en este punto, pero el navegador aún puede estar esperando a que se cargue contenido adicional, como imágenes. Cuando todo ese contenido termina de cargarse, y cuando todos los scripts asíncronos se han cargado y ejecutado, la propiedad document.readyState cambia a "complete" y el navegador web lanza un evento "load" en el objeto Window.</li>
      <li class="font-normal">A partir de este punto, los manejadores de eventos se invocan de forma asíncrona en respuesta a eventos de entrada de usuario, eventos de red, vencimiento de temporizadores, etc.</li>
    </ul>
  </section>
  <section id="1-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.6 Entrada y salida de programas</h2>
    <p>Como cualquier programa, los programas JavaScript del lado del cliente procesan datos de entrada para producir datos de salida. Hay una gran variedad de entradas disponibles:</p>
    <ul>
      <li class="font-normal">El contenido del propio documento, al que el código JavaScript puede acceder con la API DOM (§15.3).</li>
      <li class="font-normal">Entradas del usuario, en forma de eventos, como clics del ratón (o toques en la pantalla táctil) en elementos HTML &lt;button>, o texto introducido en elementos HTML &lt;textarea>, por ejemplo. En §15.2 se muestra cómo los programas JavaScript pueden responder a este tipo de eventos de usuario.</li>
      <li class="font-normal">La URL del documento que se muestra está disponible para JavaScript del lado del cliente como document.URL. Si pasas esta cadena al constructor URL() (§11.9), puedes acceder fácilmente a las secciones path, query y fragment de la URL.</li>
      <li class="font-normal">El contenido de la cabecera de petición HTTP "Cookie" está disponible para el código del cliente como document.cookie. Las cookies suelen ser utilizadas por el código del servidor para mantener las sesiones de usuario, pero el código del cliente también puede leerlas (y escribirlas) si es necesario. Véase §15.12.2 para más detalles.</li>
      <li class="font-normal">La propiedad global navigator proporciona acceso a información sobre el navegador web, el sistema operativo sobre el que se ejecuta y las capacidades de cada uno. Por ejemplo, navigator.userAgent es una cadena que identifica al navegador web, navigator.lan guage es el idioma preferido del usuario, y navigator.hardwareConcurrency devuelve el número de CPUs lógicas disponibles para el navegador web. Del mismo modo, la propiedad global screen proporciona acceso al tamaño de la pantalla del usuario a través de las propiedades screen.width y screen.height. En cierto sentido, estos objetos navigator y screen son para los navegadores web lo que las variables de entorno son para los programas Node.</li>
    </ul>
    <p>El JavaScript del lado del cliente normalmente produce resultados, cuando es necesario, manipulando el documento HTML con la API DOM (§15.3) o usando un framework de alto nivel como React o Angular para manipular el documento. El código del lado del cliente también puede usar console.log() y métodos relacionados (§11.8) para producir salida. Pero esta salida sólo es visible en la consola del desarrollador web, por lo que es útil cuando se depura, pero no para la salida visible por el usuario.</p>
  </section>
  <section id="1-7">
    <h2>15.1.7 Errores del programa</h2>
    <p>A diferencia de las aplicaciones (como las aplicaciones Node) que se ejecutan directamente sobre el sistema operativo, los programas JavaScript en un navegador web no pueden realmente "bloquearse". Si se produce una excepción mientras se ejecuta su programa JavaScript, y si no tiene una sentencia catch para manejarla, se mostrará un mensaje de error en la consola del desarrollador, pero cualquier manejador de eventos que se haya registrado seguirá ejecutándose y respondiendo a los eventos.</p>
    <p>Si desea definir un manejador de errores de último recurso que se invoque cuando se produzca este tipo de excepción no capturada, establezca la propiedad onerror del objeto Window en una función manejadora de errores. Cuando una excepción no detectada se propaga por toda la cadena y se va a mostrar un mensaje de error en la consola del desarrollador, se invocará a la función window.onerror con tres argumentos de cadena. El primer argumento de window.onerror es un mensaje que describe el error. El segundo argumento es una cadena que contiene la URL del código JavaScript que causó el error. El tercer argumento es el número de línea del documento en el que se ha producido el error. Si el manejador onerror devuelve true, le dice al navegador que el manejador ha manejado el error y que no es necesaria ninguna otra acción-en otras palabras, el navegador no debe mostrar su propio mensaje de error.</p>
    <p>Cuando una Promise es rechazada y no hay una función .catch() para manejarla, esa es una situación muy parecida a una excepción no manejada: un error no anticipado o un error lógico en tu programa. Puedes detectar esto definiendo una función window.onunhandledrejection o usando window.addEventListener() para registrar un manejador de eventos "unhand- ledrejection". El objeto de evento pasado a este manejador tendrá una propiedad promise cuyo valor es el objeto Promise que rechazó y una propiedad reason cuyo valor es lo que se habría pasado a una función .catch(). Al igual que con los manejadores de error descritos anteriormente, si se llama a preventDefault() en el objeto de evento de rechazo no manejado, se considerará manejado y no causará un mensaje de error en la consola del desarrollador.</p>
    <p>A menudo no es necesario definir manejadores onerror o onunhandledrejection, pero puede ser bastante útil como mecanismo de telemetría si quieres informar de errores del lado del cliente al servidor (usando la función fetch() para hacer una petición HTTP POST, por ejemplo) para que puedas obtener información sobre errores inesperados que ocurren en los navegadores de tus usuarios.</p>
  </section>
  <section id="1-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.1.8 El modelo de seguridad web</h2>
    <p>El hecho de que las páginas web puedan ejecutar código JavaScript arbitrario en su dispositivo personal tiene claras implicaciones de seguridad, y los proveedores de navegadores han trabajado duro para equilibrar dos objetivos contrapuestos:</p>
    <ul>
      <li class="font-normal">Definición de potentes API del lado del cliente para crear aplicaciones web útiles</li>
      <li class="font-normal">Evitar que códigos maliciosos lean o alteren sus datos, comprometan su privacidad, le estafen o le hagan perder el tiempo.</li>
    </ul>
    <p>Las subsecciones siguientes ofrecen una rápida visión general de las restricciones y problemas de seguridad que, como programador de JavaScript, debe conocer.</p>
    <p class="title-article text-left">Lo que JavaScript no puede hacer</p>
    <p>La primera línea de defensa de los navegadores web contra el código malicioso es que simplemente no admiten ciertas capacidades. Por ejemplo, JavaScript del lado del cliente no proporciona ninguna forma de escribir o eliminar archivos arbitrarios o listar directorios arbitrarios en el ordenador cliente. Esto significa que un programa JavaScript no puede borrar datos ni plantar virus.</p>
    <p>Del mismo modo, JavaScript del lado del cliente no tiene capacidades de red de propósito general. Un programa JavaScript del lado del cliente puede hacer peticiones HTTP (§15.11.1). Y otro estándar, conocido como WebSockets (§15.11.3), define una API tipo socket para comunicarse con servidores especializados. Pero ninguna de estas API permite el acceso sin intermediarios a la red. Los clientes y servidores de Internet de propósito general no pueden escribirse en JavaScript del lado del cliente.</p>
    <p class="title-article text-left">La política del mismo origen</p>
    <p>La política del mismo origen es una restricción de seguridad radical sobre el contenido web con el que puede interactuar el código Java-Script. Normalmente entra en juego cuando una página web incluye &lt;iframe>. En este caso, la política del mismo origen rige las interacciones del código JavaScript de un marco con el contenido de otros marcos. En concreto, un script sólo puede leer las propiedades de ventanas y documentos que tengan el mismo origen que el documento que contiene el script.</p>
    <p>El origen de un documento se define como el protocolo, el host y el puerto de la URL desde la que se ha cargado el documento. Los documentos cargados desde distintos servidores web tienen orígenes diferentes. Los documentos cargados a través de diferentes puertos del mismo host tienen orígenes diferentes. Y un documento cargado con el protocolo http: tiene un origen distinto que uno cargado con el protocolo https:, aunque procedan del mismo servidor web. Los navegadores suelen tratar cada URL como un origen separado, lo que significa que si está trabajando en un programa que muestra más de un documento del mismo servidor, es posible que no pueda probarlo localmente utilizando file: URL y tendrás que ejecutar un servidor web estático durante el desarrollo.</p>
    <p>Es importante entender que el origen del script en sí no es relevante para la política del mismo origen: lo que importa es el origen del documento en el que está incrustado el script. Supongamos, por ejemplo, que un script alojado en el host A se incluye (utilizando la propiedad src de un elemento &lt;script>) en una página web servida por el host B. El origen de ese script es el host B, y el script tiene pleno acceso al contenido del documento que lo contiene. Si el documento contiene un &lt;iframe> que contiene un segundo documento del host B, entonces el script también tiene acceso completo al contenido de ese segundo documento. Pero si el documento de nivel superior contiene otro &lt;iframe> que muestra un documento del host C (o incluso uno del host A), entonces la política del mismo origen entra en vigor e impide que el script acceda a este documento anidado.</p>
    <p>La política del mismo origen también se aplica a las peticiones HTTP con scripts (véase §15.11.1). El código Java Script puede hacer peticiones HTTP arbitrarias al servidor web desde el que se cargó el documento contenedor, pero no permite que los scripts se comuniquen con otros servidores web (a menos que esos servidores web opten por CORS, como describimos a continuación).</p>
    <p>La política del mismo origen plantea problemas en sitios web de gran tamaño que utilizan múltiples subdominios. Por ejemplo, los scripts con origen pedidos.ejemplo.com pueden necesitar leer propiedades de documentos en ejemplo.com. Para soportar sitios web multidominio de este tipo, los scripts pueden alterar su origen estableciendo document.domain a un sufijo de dominio. Así, un script con origen https://orders.example.com puede cambiar su origen a https://example.com estableciendo document.domain como "ejemplo.com". Pero ese script no puede establecer docu ment.domain a "pedidos.ejemplo", "amplio.com", o "com".</p>
    <p>La segunda técnica para relajar la política del mismo origen es el uso compartido de recursos entre orígenes, o CORS (Cross-Origin Resource Sharing), que permite a los servidores decidir qué orígenes están dispuestos a servir. CORS amplía HTTP con una nueva cabecera de petición Origin: y una nueva cabecera de respuesta Access- Control-Allow-Origin. Permite a los servidores utilizar una cabecera para enumerar explícitamente los orígenes que pueden solicitar un archivo o utilizar un comodín y permitir que un archivo sea solicitado por cualquier sitio. Los navegadores respetan estas cabeceras CORS y no relajan las restricciones del mismo origen a menos que estén presentes.</p>
    <p class="title-article text-left">Secuencias de comandos en sitios cruzados</p>
    <p>Cross-site scripting, o XSS, es una categoría de problemas de seguridad en los que un atacante inyecta etiquetas HTML o scripts en un sitio web. Los programadores de JavaScript del lado del cliente deben conocer y defenderse contra el cross-site scripting.</p>
    <p>Una página web es vulnerable al cross-site scripting si genera dinámicamente el contenido de un documento y basa ese contenido en datos enviados por el usuario sin haber "saneado" previamente esos datos eliminando de ellos cualquier etiqueta HTML incrustada. Como ejemplo trivial, considere la siguiente página web que utiliza JavaScript para saludar al usuario por su nombre:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este script de dos líneas extrae la entrada del parámetro de consulta "nombre" de la URL del documento. A continuación, utiliza la API DOM para inyectar una cadena HTML en la primera etiqueta &lt;h1> del documento. Esta página está pensada para ser invocada con una URL como esta:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Cuando se utiliza así, muestra el texto "Hola David". Pero considere lo que ocurre cuando se invoca con este parámetro de consulta:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Cuando se decodifican los parámetros de la URL, esta URL provoca que se inyecte el siguiente HTML en el documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Una vez cargada la imagen, se ejecuta la cadena de JavaScript del atributo onload. La función global alert() muestra un cuadro de diálogo modal. Un solo cuadro de diálogo es relativamente benigno, pero demuestra que la ejecución de código arbitrario es posible en este sitio porque muestra HTML sin desinfectar.</p>
    <p>Los ataques de secuencias de comandos entre sitios se llaman así porque hay más de un sitio implicado. El sitio B incluye un enlace especialmente diseñado (como el del ejemplo anterior) al sitio A. Si el sitio B puede convencer a los usuarios para que hagan clic en el enlace, serán conducidos al sitio A, pero ese sitio estará ejecutando código del sitio B. Ese código podría desfigurar la página o hacer que funcione mal. Y lo que es más peligroso, el código malicioso podría leer las cookies almacenadas por el sitio A (quizás números de cuenta u otra información de identificación personal) y enviar esos datos de vuelta al sitio B. El código inyectado podría incluso rastrear las pulsaciones de teclado del usuario y enviar esos datos de vuelta al sitio B.</p>
    <p>En general, la forma de prevenir los ataques XSS es eliminar las etiquetas HTML de cualquier dato no fiable antes de utilizarlo para crear contenido de documentos dinámicos. Puede corregir el archivo greet.html mostrado anteriormente sustituyendo los caracteres HTML especiales de la cadena de entrada no fiable por sus entidades HTML equivalentes:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Otra forma de abordar el problema del XSS es estructurar las aplicaciones web de modo que el contenido que no sea de confianza se muestre siempre en un &lt;iframe> con el atributo sandbox configurado para desactivar el scripting y otras capacidades.</p>
    <p>Cross-site scripting es una vulnerabilidad perniciosa cuyas raíces se hunden en lo más profundo de la arquitectura de la web. Merece la pena conocer esta vulnerabilidad en profundidad, pero su análisis va más allá del alcance de este libro. Hay muchos recursos en línea para ayudar a a defenderse contra el cross-site scripting.</p>
  </section>
  <section id="2">
    <h2>15.2 Eventos</h2>
    <p>Los programas JavaScript del lado del cliente utilizan un modelo de programación asíncrono basado en eventos. En este estilo de programación, el navegador web genera un evento cada vez que ocurre algo interesante en el documento o navegador o en algún elemento u objeto asociado a él. Por ejemplo, el navegador genera un evento cuando termina de cargar un documento, cuando el usuario mueve el ratón sobre un hipervínculo o cuando pulsa una tecla del teclado. Si una aplicación JavaScript se preocupa por un tipo particular de evento, puede registrar una o más funciones para que sean invocadas cuando se produzcan eventos de ese tipo. Tenga en cuenta que esto no es exclusivo de la programación web: todas las aplicaciones con interfaces gráficas de usuario están diseñadas de esta manera: se sientan a esperar a que se interactúe con ellas (es decir, esperan a que se produzcan eventos) y luego responden.</p>
    <p>En JavaScript del lado del cliente, los eventos pueden ocurrir en cualquier elemento dentro de un documento HTML, y este hecho hace que el modelo de eventos de los navegadores web sea significativamente más complejo que el modelo de eventos de Node. Comenzamos esta sección con algunas definiciones importantes que ayudan a explicar ese modelo de eventos:</p>
    <p><em>tipo de evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta cadena especifica qué tipo de evento se ha producido. El tipo "mousemove", por ejemplo, significa que el usuario movió el ratón. El tipo "keydown" significa que el usuario pulsó una tecla del teclado hacia abajo. Y el tipo "load" significa que un documento (o algún otro recurso) ha terminado de cargarse desde la red. Como el tipo de un evento es sólo una cadena, a veces se le llama nombre del evento, y de hecho, usamos este nombre para identificar el tipo de evento del que estamos hablando.</p>
    <p><em>objetivo del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Es el objeto en el que se ha producido el suceso o al que está asociado. Cuando hablamos de un evento, debemos especificar tanto el tipo como el destino. Un evento de carga en una ventana, por ejemplo, o un evento de clic en un elemento &lt;button>. Los objetos Window, Document y Element son los destinos de eventos más comunes en las aplicaciones JavaScript del lado del cliente, pero algunos eventos se activan en otros tipos de objetos. Por ejemplo, un objeto Worker (un tipo de hilo, cubierto en §15.13) es un objetivo para eventos "mensaje" que ocurren cuando el hilo worker envía un mensaje al hilo principal.</p>
    <p><em>controlador de eventos o receptor de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta función maneja o responde a un evento.2 Las aplicaciones registran sus funciones manejadoras de eventos con el navegador web, especificando un tipo de evento y un objetivo de evento. Cuando se produce un evento del tipo especificado en el objetivo especificado, el navegador invoca la función manejadora. Cuando los manejadores de eventos son invocados para un objeto, decimos que el navegador ha "disparado" o "despachado" el evento. Hay varias maneras de registrar manejadores de eventos, y los detalles del registro y la invocación de manejadores se explican en §15.2.2 y §15.2.3.</p>
    <p><em>objeto del evento</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este objeto está asociado a un evento concreto y contiene detalles sobre ese evento. Los objetos evento se pasan como argumento a la función manejadora de eventos. Todos los objetos de evento tienen una propiedad type que especifica el tipo de evento y una propiedad target que especifica el objetivo del evento. Cada tipo de evento define un conjunto de propiedades para su objeto de evento asociado. El objeto asociado a un evento de ratón incluye las coordenadas del puntero del ratón, por ejemplo, y el objeto asociado a un evento de teclado contiene detalles sobre la tecla que se pulsó y las teclas modificadoras que se mantuvieron pulsadas. Muchos tipos de eventos sólo definen algunas propiedades estándar -como el tipo y el objetivo- y no contienen mucha más información útil. Para esos eventos, lo que importa es la simple ocurrencia del evento, no los detalles del mismo.</p>
    <p><em>propagación de eventos</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este es el proceso por el cual el navegador decide qué objetos activan los manejadores de eventos. Para los eventos que son específicos de un único objeto -como el evento "load" en el objeto Window o un evento "message" en un objeto Worker- no se requiere ningún proceso. Sin embargo, cuando ciertos tipos de eventos ocurren en elementos dentro del documento HTML, se propagan o "burbujean" hacia arriba en el árbol del documento. Si el usuario mueve el ratón sobre un hipervínculo, el evento mousemove se dispara primero en el elemento &lt;a> que define ese enlace. Luego se dispara sobre los elementos que lo contienen: quizás un elemento &lt;p>, un elemento &lt;section>, y el propio objeto Documento. A veces es más conveniente registrar un único manejador de eventos en un Documento u otro elemento contenedor que registrar manejadores en cada elemento individual en el que estés interesado. Un manejador de eventos puede detener la propagación de un evento para que no continúe burbujeando y no active manejadores en los elementos que lo contienen. Los manejadores hacen esto invocando un método del objeto del evento. En otra forma de propagación de eventos, conocida como captura de eventos, los manejadores especialmente registrados en elementos contenedores tienen la oportunidad de interceptar (o "capturar") eventos antes de que sean enviados a su destino real. El burbujeo y la captura de eventos se tratan en detalle en §15.2.4.</p>
    <p>Algunos eventos tienen asociadas acciones por defecto. Cuando se produce un evento de clic en un hipervínculo, por ejemplo, la acción por defecto es que el navegador siga el enlace y cargue una nueva página. Los manejadores de eventos pueden evitar esta acción por defecto invocando un método del objeto del evento. Esto a veces se llama "cancelar" el evento y se trata en §15.2.5.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.1 Categorías de eventos</h2>
    <p>JavaScript del lado del cliente soporta un número tan grande de tipos de eventos que no hay forma de que este capítulo pueda cubrirlos todos. Puede ser útil, sin embargo, agrupar los eventos en algunas categorías generales, para ilustrar el alcance y la amplia variedad de eventos soportados:</p>
    <p><em>Eventos de entrada dependientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos están directamente vinculados a un dispositivo de entrada específico, como el ratón o el teclado. Incluyen tipos de eventos como "mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "keydown" y "keyup".</p>
    <p><em>Eventos de entrada independientes del dispositivo</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estos eventos de entrada no están directamente vinculados a un dispositivo de entrada específico. El evento "clic", por ejemplo, indica que se ha activado un enlace o un botón (u otro elemento del documento). Esto suele hacerse mediante un clic del ratón, pero también puede hacerse con el teclado o (en dispositivos táctiles) con un toque. El evento "input" es una alternativa independiente del dispositivo al evento "keydown" y admite la entrada por teclado, así como alternativas como cortar y pegar y métodos de entrada utilizados para scripts ideográficos. Los eventos "pointerdown", "pointermove" y "pointerup" son alternativas independientes del dispositivo a los eventos de ratón y táctiles. Funcionan con punteros de tipo ratón, con pantallas táctiles y también con entradas de tipo lápiz o bolígrafo.</p>
    <p><em>Eventos de la interfaz de usuario</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los eventos de interfaz de usuario son eventos de nivel superior, a menudo en elementos de formulario HTML que definen una interfaz de usuario para una aplicación web. Incluyen el evento "focus" (cuando un campo de entrada de texto obtiene el foco del teclado), el evento "change" (cuando el usuario cambia el valor mostrado por un elemento de formulario) y el evento "submit" (cuando el usuario hace clic en un botón Enviar de un formulario).</p>
    <p><em>Cambios de estado</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Algunos eventos no se desencadenan directamente por la actividad del usuario, sino por la actividad de la red o del navegador, e indican algún tipo de cambio relacionado con el ciclo de vida o el estado. Los eventos "load" y "DOMContentLoaded" -provocados en los objetos Window y Document, respectivamente, al final de la carga del documento- son probablemente los más utilizados de estos eventos (ver "Línea de tiempo JavaScript del lado del cliente" en la página 420). Los navegadores disparan eventos "online" y "offline" en el objeto Window cuando la conectividad de la red cambia. El mecanismo de gestión del historial del navegador (§15.10.4) dispara el evento "popstate" en respuesta al botón Atrás del navegador.</p>
    <p><em>Eventos específicos de la API</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Varias API web definidas por HTML y especificaciones relacionadas incluyen sus propios tipos de eventos. Los elementos HTML &lt;video> y &lt;audio> definen una larga lista de tipos de eventos asociados, como "espera", "reproducción", "búsqueda", "cambio de volumen", etc., y puedes utilizarlos para personalizar la reproducción multimedia. En términos generales, las API de plataformas web que son asíncronas y se desarrollaron antes de que se añadieran las promesas a JavaScript se basan en eventos y definen eventos específicos de la API. La API IndexedDB, por ejemplo (§15.12.3), dispara eventos de "éxito" y "error" cuando las peticiones a la base de datos tienen éxito o fallan. Y aunque la nueva API fetch() (§15.11.1) para realizar peticiones HTTP está basada en promesas, la API XMLHttpRequest a la que sustituye define una serie de tipos de eventos específicos de la API.</p>
  </section>
  <section id="2-2">
    <h2>15.2.2 Registro de controladores de eventos</h2>
    <p>Hay dos formas básicas de registrar manejadores de eventos. La primera, desde los primeros días de la web, es establecer una propiedad en el objeto o elemento del documento que es el tar- minador del evento. La segunda técnica (más reciente y general) consiste en pasar el controlador al método addEventListener() del objeto o elemento.</p>
    <p class="title-article text-left">Configuración de las propiedades de los controladores de eventos</p>
    <p>La forma más sencilla de registrar un manejador de eventos es estableciendo una propiedad del tar- gador de eventos en la función deseada del manejador de eventos. Por convención, las propiedades de los manejadores de eventos tienen nombres que consisten en la palabra "on" seguida del nombre del evento: onclick, onchange, onload, onmouseover, etcétera. Tenga en cuenta que los nombres de estas propiedades distinguen entre mayúsculas y minúsculas,3 incluso cuando el tipo de evento (como "mouse- down") consta de varias palabras. El siguiente código incluye dos registros de manejadores de eventos de este tipo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El defecto de las propiedades de los manejadores de eventos es que están diseñadas bajo la suposición de que los objetivos de eventos tendrán como máximo un manejador para cada tipo de evento. En a menudo es mejor registrar manejadores de eventos usando addEventListener() porque esa técnica no sobreescribe ningún manejador previamente registrado.</p>
    <p class="title-article text-left">Establecer atributos del manejador de eventos</p>
    <p>Las propiedades de los manejadores de eventos de los elementos del documento también pueden definirse directamente en el archivo HTML como atributos en la etiqueta HTML correspondiente. (Los manejadores que se registrarían en el elemento Window con JavaScript pueden definirse con atributos en la etiqueta &lt;body> en HTML). Esta técnica es generalmente mal vista en el desarrollo web moderno, pero es posible, y se documenta aquí porque todavía se puede ver en el código existente.</p>
    <p>Cuando se define un manejador de eventos como un atributo HTML, el valor del atributo debe ser una cadena de código JavaScript. Ese código debe ser el cuerpo de la función del manejador de eventos, no una declaración de función completa. Es decir, el código HTML del controlador de eventos no debe estar rodeado de llaves y precedido de la palabra clave function. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si un atributo de controlador de eventos HTML contiene varias sentencias JavaScript, no olvide separarlas con punto y coma o dividir el valor del atributo en varias líneas.</p>
    <p>Cuando se especifica una cadena de código JavaScript como valor de un atributo HTML manejador de eventos, el navegador convierte la cadena en una función que funciona de forma parecida a ésta:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El argumento event significa que el código de su manejador puede referirse al objeto de evento actual como event. Las sentencias with significan que el código de tu manejador puede referirse a las propiedades del objeto destino, al &lt;form> contenedor (si lo hay), y al objeto Documento contenedor directamente, como si fueran variables en scope. La sentencia with está prohibida en modo estricto (§5.6.3), pero el código JavaScript en atributos HTML nunca es estricto. Los manejadores de eventos definidos de esta forma se ejecutan en un entorno en el que se definen variables inesperadas. Esto puede ser una fuente de errores confusos y es una buena razón para evitar escribir manejadores de eventos en HTML.</p>
    <p class="title-article text-left">addEventListener()</p>
    <p>Cualquier objeto que pueda ser objetivo de un evento -esto incluye los objetos Window y Document y todos los Elementos del documento- define un método llamado addEventListener() que puede utilizar para registrar un controlador de eventos para ese objetivo. addEventListener() toma tres argumentos. El primero es el tipo de evento para el que se está registrando el controlador. El tipo de evento (o nombre) es una cadena que no incluye el prefijo "on" utilizado al establecer las propiedades del manejador de eventos. El segundo argumento de addEventListener() es la función que se invocará cuando se produzca el tipo de evento especificado. El tercer argumento es opcional y se explica a continuación.</p>
    <p>El siguiente código registra dos manejadores para el evento "click" en un elemento &lt;button>. Observe las diferencias entre las dos técnicas utilizadas:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Llamar a addEventListener() con "click" como primer argumento no afecta al valor de la propiedad onclick. En este código, un clic de botón registrará dos mensajes en la consola del desarrollador. Y si llamáramos primero a addEventListener() y luego estableciéramos onclick, seguiríamos registrando dos mensajes, sólo que en el orden inverso. Más importante aún, puedes llamar a addEventListener() varias veces para registrar más de una función manejadora para el mismo tipo de evento en el mismo objeto. Cuando ocurre un evento en un objeto, todos los manejadores registrados para ese tipo de evento son invocados en el orden en que fueron registrados. Invocar addEventListener() más de una vez sobre el mismo objeto con los mismos argumentos no tiene ningún efecto - la función manejadora permanece registrada sólo una vez, y la invocación repetida no altera el orden en que los manejadores son invocados.</p>
    <p>addEventListener() está emparejado con un método removeEventListener() que espera los mismos dos argumentos (más un tercero opcional) pero elimina una función manejadora de eventos de un objeto en lugar de añadirla. A menudo es útil registrar temporalmente un controlador de eventos y eliminarlo poco después. Por ejemplo, cuando recibes un evento "mousedown", puedes registrar temporalmente manejadores de eventos "mousemove" y "mouseup" para ver si el usuario arrastra el ratón. A continuación, anularías el registro de estos manejadores cuando llegue el evento "mouseup". En tal situación, tu código de eliminación de manejadores de eventos podría verse así:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El tercer argumento opcional de addEventListener() es un valor booleano o un objeto. Si pasa true, entonces su función manejadora se registra como un manejador de eventos de captura y se invoca en una fase diferente del envío de eventos. Cubriremos la captura de eventos en §15.2.4. Si pasas un tercer argumento de true cuando registras un receptor de eventos, entonces también debes pasar true como tercer argumento a removeEventListener() si quieres eliminar el manejador.</p>
    <p>Registrar un controlador de eventos de captura es sólo una de las tres opciones que admite addEven tListener(), y en lugar de pasar un único valor booleano, también puede pasar un objeto que especifique explícitamente las opciones que desea:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si el objeto Options tiene una propiedad de captura establecida a true, entonces el manejador de eventos será registrado como un manejador de captura. Si esa propiedad es falsa o se omite, entonces el manejador será no capturador.</p>
    <p>Si el objeto Options tiene la propiedad once establecida a true, entonces el manejador de eventos se eliminará automáticamente después de que se active una vez. Si esta propiedad es falsa o se omite, el controlador nunca se eliminará automáticamente.</p>
    <p>Si el objeto Options tiene una propiedad passive establecida a true, indica que el manejador de eventos nunca llamará a preventDefault() para cancelar la acción por defecto (ver §15.2.5). Esto es particularmente importante para eventos táctiles en dispositivos móviles - si los manejadores de eventos "touchmove" pueden prevenir la acción de desplazamiento por defecto del navegador, entonces el navegador no puede implementar un desplazamiento suave. Esta propiedad pasiva proporciona una forma de registrar un controlador de eventos potencialmente perjudicial de este tipo, pero permite que el navegador web sepa que puede iniciar de forma segura su comportamiento predeterminado -como el desplazamiento- mientras se ejecuta el controlador de eventos. El desplazamiento suave es tan importante para una buena experiencia de usuario que Firefox y Chrome hacen que los eventos "touchmove" y "mousewheel" sean pasivos por defecto. Así que si quieres registrar un manejador que llame a preventDefault() para uno de estos eventos, debes establecer explícitamente la propiedad passive a false.</p>
    <p>También puede pasar un objeto Options a removeEventListener(), pero la propiedad capture es la única relevante. No es necesario especificar once o passive al eliminar un listener, y estas propiedades se ignoran.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.3 Invocación del manejador de eventos</h2>
    <p>Una vez que hayas registrado un manejador de eventos, el navegador web lo invocará automáticamente cuando se produzca un evento del tipo especificado en el objeto especificado. Esta sección describe la invocación de manejadores de eventos en detalle, explicando los argumentos de los manejadores de eventos, el contexto de invocación (el valor this), y el significado del valor de retorno de un manejador de eventos.</p>
    <p class="title-article text-left">Argumento del controlador de eventos</p>
    <p>Los controladores de eventos se invocan con un objeto Evento como único argumento. Las propiedades del objeto Evento proporcionan detalles sobre el evento:</p>
    <p><codeinline>type</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Tipo de suceso ocurrido.</p>
    <p><codeinline>target</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El objeto en el que se ha producido el suceso.</p>
    <p><codeinline>currentTarget</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Para los eventos que se propagan, esta propiedad es el objeto en el que se registró el manejador del evento actual.</p>
    <p><codeinline>timeStamp</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una marca de tiempo (en milisegundos) que representa cuándo ocurrió el evento pero que no representa un tiempo absoluto. Puedes determinar el tiempo transcurrido entre dos eventos restando la marca de tiempo del primer evento de la marca de tiempo del segundo.</p>
    <p><codeinline>isTrusted</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad será verdadera si el evento fue enviado por el propio navegador web y falsa si el evento fue enviado por código JavaScript.</p>
    <p>Determinados tipos de eventos tienen propiedades adicionales. Los eventos de ratón y puntero, por ejemplo, tienen propiedades clientX y clientY que especifican las coordenadas de la ventana en la que se produjo el evento.</p>
    <p class="title-article text-left">Contexto del controlador de eventos</p>
    <p>Cuando se registra un manejador de eventos estableciendo una propiedad, parece como si se estuviera definiendo un nuevo método en el objeto de destino:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>No es sorprendente, por tanto, que los manejadores de eventos sean invocados como métodos del objeto sobre el que están definidos. Es decir, dentro del cuerpo de un manejador de eventos, la palabra clave this se refiere al objeto sobre el que se registró el manejador de eventos.</p>
    <p>Los manejadores se invocan con el objetivo como su valor this, incluso cuando se registran usando addEventListener(). Sin embargo, esto no funciona para los manejadores definidos como funciones de flecha: las funciones de flecha siempre tienen el mismo valor this que el ámbito en el que se definen.</p>
    <p class="title-article text-left">Valor de retorno del manipulador</p>
    <p>En el JavaScript moderno, los manejadores de eventos no deberían devolver nada. Puedes ver manejadores de eventos que devuelven valores en código antiguo, y el valor devuelto es típicamente una señal al navegador de que no debe realizar la acción por defecto asociada con el evento. Si el manejador onclick de un botón Enviar en un formulario devuelve false, por ejemplo, entonces el navegador web no enviará el formulario (normalmente porque el manejador de eventos determinó que la entrada del usuario falla la validación del lado del cliente).</p>
    <p>La forma estándar y preferida de evitar que el navegador realice una acción por defecto es llamar al método preventDefault() (§15.2.5) en el objeto Evento.</p>
    <p class="title-article text-left">Orden de invocación</p>
    <p>Un objetivo de evento puede tener más de un manejador de evento registrado para un tipo particular de evento. Cuando ocurre un evento de ese tipo, el navegador invoca todos los manejadores en el orden en que fueron registrados. Curiosamente, esto es cierto incluso si se mezclan manejadores de eventos registrados con addEventListener() con un manejador de eventos registrado en una propiedad de objeto como onclick.</p>
  </section>
  <section id="2-4">
    <h2>15.2.4 Propagación de eventos</h2>
    <p>Cuando el objetivo de un evento es el objeto Window o algún otro objeto independiente, el navegador responde a un evento simplemente invocando los manejadores apropiados en ese objeto. Sin embargo, cuando el objetivo del evento es un Documento o un Elemento del documento, la situación es más complicada.</p>
    <p>Una vez invocados los manejadores de eventos registrados en el elemento de destino, la mayoría de los eventos "burbujean" hacia arriba en el árbol DOM. Se invocan los manejadores de eventos del padre del objetivo. Luego se invocan los manejadores registrados en el abuelo del objetivo. Esto continúa hasta el objeto Documento, y luego más allá hasta el objeto Ventana. El burbujeo de eventos proporciona una alternativa al registro de manejadores en muchos elementos individuales del documento: en su lugar, puedes registrar un único manejador en un elemento ancestro común y manejar los eventos allí. Por ejemplo, puede registrar un controlador de "cambio" en un elemento &lt;form>, en lugar de registrar un controlador de "cambio" para cada elemento del formulario.</p>
    <p>La mayoría de los eventos que se producen en los elementos del documento burbujean. Excepciones notables son los eventos "focus", "blur" y "scroll". El evento "load" de los elementos del documento burbujea, pero deja de burbujear en el objeto Documento y no se propaga al objeto Ventana. (Los manejadores de eventos "load" del objeto Window se disparan sólo cuando todo el documento se ha cargado).</p>
    <p>El burbujeo de eventos es la tercera "fase" de la propagación de eventos. La invocación de los manejadores de eventos del propio objeto de destino es la segunda fase. La primera fase, que ocurre incluso antes de que se invoquen los manejadores de destino, se denomina fase de "captura". Recordemos que addEventListener() toma un tercer argumento opcional. Si ese argumento es verdadero o &lbrace;capture:true}, entonces el manejador de eventos es registrado como un manejador de eventos de captura para invocación durante esta primera fase de propagación de eventos. La fase de captura de la propagación de eventos es como la fase de burbujeo a la inversa. Los manejadores de captura del objeto Window son invocados primero, luego los manejadores de captura del objeto Document, luego del objeto body, y así sucesivamente hacia abajo en el árbol DOM hasta que los manejadores de captura de eventos del padre del objetivo del evento son invocados. Los manejadores de captura de eventos registrados en el propio objetivo del evento no son invocados.</p>
    <p>La captura de eventos proporciona una oportunidad para echar un vistazo a los eventos antes de que sean entregados a su objetivo. Un manejador de eventos de captura puede ser usado para depuración, o puede ser usado junto con la técnica de cancelación de eventos descrita en la siguiente sección para filtrar eventos de manera que los manejadores de eventos de destino nunca sean invocados. Un uso común para la captura de eventos es el manejo de arrastres del ratón, donde los eventos de movimiento del ratón necesitan ser manejados por el objeto que está siendo arrastrado, no por los elementos del documento sobre los que se arrastra.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.2.5 Cancelación de eventos</h2>
    <p>Los navegadores responden a muchos eventos del usuario, aunque tu código no lo haga: cuando el usuario hace clic con el ratón en un hipervínculo, el navegador sigue el enlace. Si un elemento HTML de entrada de texto tiene el foco en el teclado y el usuario teclea una tecla, el navegador introducirá la entrada del usuario. Si el usuario mueve el dedo por un dispositivo de pantalla táctil, el navegador se desplaza. Si registras un manejador de eventos para eventos como estos, puedes evitar que el navegador realice su acción por defecto invocando el método preventDefault() del objeto evento. (A menos que hayas registrado el manejador con la opción pasiva, lo que hace que preventDefault() sea ineficaz).</p>
    <p>Cancelar la acción por defecto asociada a un evento es sólo un tipo de cancelación de eventos. También podemos cancelar la propagación de eventos llamando al método stopPropaga tion() del objeto evento. Si hay otros manejadores definidos en el mismo objeto, el resto de esos manejadores seguirán siendo invocados, pero ningún manejador de evento en cualquier otro objeto será invocado después de llamar a stopPropagation(). stopPropagation() funciona durante la fase de captura, en el propio objetivo del evento, y durante la fase de burbujeo. stopImmediatePropagation() funciona como stopPropagation(), pero también previene la invocación de cualquier manejador de evento posterior registrado en el mismo objeto.</p>
  </section>
  <section id="2-6">
    <h2>15.2.6 Envío de eventos personalizados</h2>
    <p>La API de eventos de JavaScript del lado del cliente es relativamente potente, y puedes utilizarla para definir y enviar tus propios eventos. Supongamos, por ejemplo, que tu programa necesita peri-ódicamente realizar un cálculo largo o hacer una petición a la red y que, mientras esta operación está pendiente, otras operaciones no son posibles. Usted quiere que el usuario lo sepa mostrando "spinners" para indicar que la aplicación está ocupada. Pero el módulo que está ocupado no necesita saber dónde deben estar los mostrado. En su lugar, ese módulo podría enviar un evento para anunciar que está ocupado y luego enviar otro evento cuando ya no lo esté. Entonces, el módulo de interfaz de usuario puede registrar manejadores de eventos para esos eventos y tomar cualquier acción de interfaz de usuario que sea apropiada para notificar al usuario.</p>
    <p>Si un objeto JavaScript tiene un método addEventListener(), entonces es un "objetivo de evento", y esto significa que también tiene un método dispatchEvent(). Puede crear su propio objeto de evento con el constructor CustomEvent() y pasarlo a dispatchEvent(). El primer argumento de CustomEvent() es una cadena que especifica el tipo de tu evento, y el segundo argumento es un objeto que especifica las propiedades del objeto evento. Establezca la propiedad detail de este objeto a una cadena, objeto u otro valor que represente el contenido de su evento. Si planeas enviar tu evento sobre un elemento del documento y quiere que se burbujee hacia arriba en el árbol del documento, añade bubbles:true al segundo argumento:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3 Documentos de secuencias de comandos</h2>
    <p>JavaScript del lado del cliente existe para convertir documentos HTML estáticos en aplicaciones web interactivas. El objetivo principal de JavaScript es crear scripts para el contenido de las páginas web.</p>
    <p>Todo objeto Ventana tiene una propiedad Documento que hace referencia a un objeto Documento. El objeto Documento representa el contenido de la ventana, y es el tema de esta sección. Sin embargo, el objeto Document no es el único. Es el objeto central del DOM para representar y manipular el contenido de los documentos.</p>
    <p>El DOM se introdujo en §15.1.2. Esta sección explica la API en detalle. Abarca:</p>
    <ul>
      <li class="font-normal">Cómo consultar o seleccionar elementos individuales de un documento.</li>
      <li class="font-normal">Cómo recorrer un documento y cómo encontrar los ancestros, hermanos y descendientes de cualquier elemento del documento.</li>
      <li class="font-normal">Cómo consultar y establecer los atributos de los elementos del documento.</li>
      <li class="font-normal">Cómo consultar, fijar y modificar el contenido de un documento.</li>
      <li class="font-normal">Cómo modificar la estructura de un documento creando, insertando y eliminando nodos.</li>
    </ul>
  </section>
  <section id="3-1">
    <h2>15.3.1 Selección de elementos del documento</h2>
    <p>Los programas JavaScript del lado del cliente a menudo necesitan manipular uno o más elementos dentro del documento. La propiedad global document se refiere al objeto Document, y el objeto Document tiene propiedades head y body que se refieren a los objetos Element para las etiquetas &lt;head> y &lt;body>, respectivamente. Pero un programa que quiera manipular un elemento incrustado más profundamente en el documento debe de alguna manera obtener o seleccionar los objetos Element que se refieren a esos elementos del documento.</p>
    <p class="title-article text-left">Seleccionar elementos con selectores CSS</p>
    <p>Las hojas de estilo CSS tienen una sintaxis muy potente, conocida como selectores, para describir elementos o conjuntos de elementos dentro de un documento. Los métodos DOM querySelector() y querySelectorAll() nos permiten encontrar el elemento o elementos dentro de un documento que coinciden con un selector CSS especificado. Antes de cubrir los métodos, comenzaremos con un rápido tutorial sobre la sintaxis de los selectores CSS.</p>
    <p>Los selectores CSS pueden describir elementos por el nombre de la etiqueta, el valor de su atributo id o las palabras de su atributo class:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El carácter # se utiliza para hacer coincidencias basadas en el atributo id, y el carácter . se utiliza para hacer coincidencias basadas en el atributo class. Los elementos también pueden seleccionarse en función de valores de atributo más generales:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observe que estos ejemplos combinan un selector de nombre de etiqueta (o el comodín * de nombre de etiqueta) con un selector de atributo. También son posibles combinaciones más complejas:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los selectores también pueden especificar la estructura del documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si dos selectores están separados por una coma, significa que hemos seleccionado elementos que coinciden con cualquiera de los selectores:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Como puedes ver, los selectores CSS nos permiten referirnos a elementos dentro de un documento por tipo, ID, clase, atributos y posición dentro del documento. El método querySelector() toma una cadena de selector CSS como argumento y devuelve el primer elemento coincidente que encuentra en el documento, o devuelve null si no coincide ninguno:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>querySelectorAll() es similar, pero devuelve todos los elementos coincidentes del documento en lugar de devolver sólo el primero:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El valor devuelto por querySelectorAll() no es un array de objetos Element. En su lugar, es un objeto tipo array conocido como NodeList. Los objetos NodeList tienen una propiedad de longitud y pueden ser indexados como arrays, por lo que se puede hacer un bucle sobre ellos con un bucle for tradicional. Los NodeLists también son iterables, por lo que también puedes usarlos con bucles for/of. Si desea convertir un NodeList en un verdadero array, simplemente páselo a Array.from().</p>
    <p>La NodeList devuelta por querySelectorAll() tendrá una propiedad length establecida a 0 si no hay ningún elemento en el documento que coincida con el selector especificado.</p>
    <p>querySelector() y querySelectorAll() son implementados tanto por la clase Element como por la clase Document. Cuando se invocan sobre un elemento, estos métodos sólo devolverán elementos que sean descendientes de ese elemento.</p>
    <p>Tenga en cuenta que CSS define los pseudoelementos ::first-line y ::first- letter. En CSS, coinciden con partes de nodos de texto y no con elementos reales. No coincidirán si se utilizan con querySelectorAll() o querySelector(). Además, muchos navegadores se negarán a devolver coincidencias para las pseudoclases :link y :visited, ya que esto podría exponer información sobre el historial de navegación del usuario.</p>
    <p>Otro método de selección de elementos basado en CSS es closest(). Este método está definido por la clase Element y toma un selector como único argumento. Si el selector coincide con el elemento sobre el que se invoca, devuelve ese elemento. En caso contrario, devuelve el elemento antecesor más cercano con el que coincida el selector, o devuelve null si no coincide ninguno. En cierto sentido, closest() es lo contrario de querySelector(): closest() comienza en un elemento y busca una coincidencia por encima de él en el árbol, mientras que querySelector() comienza con un elemento y busca una coincidencia por debajo de él en el árbol. closest() puede ser útil cuando se ha registrado un controlador de eventos en un nivel alto en el árbol del documento. Si está manejando un evento "clic", por ejemplo, es posible que desee saber si se trata de un clic en un hipervínculo. El objeto de evento le dirá cuál era el objetivo, pero ese objetivo podría ser el texto dentro de un enlace en lugar de la propia etiqueta &lt;a> del hipervínculo. Tu manejador de eventos podría buscar el hipervínculo contenedor más cercano así:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Esta es otra forma de utilizar closest():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El método relacionado matches() no devuelve ancestros ni descendientes: simplemente comprueba si un elemento coincide con un selector CSS y devuelve true en caso afirmativo y false en caso contrario:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Otros métodos de selección de elementos</p>
    <p>Además de querySelector() y querySelectorAll(), el DOM también define una serie de métodos de selección de elementos más antiguos que ahora están más o menos obsoletos. Sin embargo, es posible que aún se utilicen algunos de estos métodos (especialmente getElementById()):</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Al igual que querySelectorAll(), los métodos de este código devuelven un NodeList (excepto getElementById(), que devuelve un único objeto Element). Sin embargo, a diferencia de querySelectorAll(), los NodeLists devueltos por estos métodos de selección más antiguos son "vivos", lo que significa que la longitud y el contenido de la lista pueden cambiar si cambia el contenido o la estructura del documento.</p>
    <p class="title-article text-left">Elementos preseleccionados</p>
    <p>Por razones históricas, la clase Document define propiedades de acceso directo para acceder a ciertos tipos de nodos. Las propiedades images, forms y links, por ejemplo, facilitan el acceso a los elementos &lt;img>, &lt;form> y &lt;a> (pero sólo a las etiquetas &lt;a> que tienen un atributo href) de un documento. Estas propiedades hacen referencia a objetos HTMLCollection, que son muy parecidos a los objetos NodeList, pero además pueden indexarse por ID o nombre de elemento. Con la propiedad document.forms, por ejemplo, puede acceder a la etiqueta &lt;form id="address"> como:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Una API aún más anticuada para seleccionar elementos es la propiedad document.all, que es como una HTMLCollection para todos los elementos del documento. document.all está obsoleta, y ya no deberías usarla.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.2 Estructura y desplazamiento de documentos</h2>
    <p>Una vez seleccionado un elemento de un documento, a veces es necesario encontrar partes del documento relacionadas estructuralmente (padre, hermanos, hijos). Cuando nos interesan principalmente los Elementos de un documento en lugar del texto que contienen (y los espacios en blanco entre ellos, que también son texto), existe una API de navegación que nos permite tratar un documento como un árbol de objetos Elemento, ignorando los nodos de Texto que también forman parte del documento. Esta API de navegación no implica ningún método; es simplemente un conjunto de propiedades de los objetos Elemento que nos permiten referirnos a los padres, hijos y hermanos de un elemento dado:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta propiedad de un elemento se refiere al padre del elemento, que será otro Elemento o un objeto Documento.</p>
    <p><codeinline>children</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta NodeList contiene los elementos hijos de un elemento, pero excluye los que no lo son, como los nodos de texto (y los nodos de comentario).</p>
    <p><codeinline>childElementCount</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Número de elementos hijos. Devuelve el mismo valor que children.length.</p>
    <p><codeinline>firstElementChild</codeinline>, <codeinline>lastElementChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren al primer y último elemento hijo de un elemento. Son nulas si el elemento no tiene elementos hijos.</p>
    <p><codeinline>nextElementSibling</codeinline>, <codeinline>previousElementSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Estas propiedades se refieren a los elementos hermanos inmediatamente anteriores o posteriores a un elemento, o a null si no hay ningún elemento hermano.</p>
    <p>Utilizando estas propiedades de Elemento, se puede hacer referencia al segundo Elemento hijo del primer Elemento hijo del Documento con cualquiera de estas expresiones:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>(En un documento HTML estándar, ambas expresiones se refieren a la etiqueta &lt;body> del documento).</p>
    <p>A continuación se muestran dos funciones que demuestran cómo se pueden utilizar estas propiedades para realizar de forma recurrente un recorrido en profundidad de un documento invocando una función específica para cada elemento del documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Documentos como árboles de nodos</p>
    <p>Si desea recorrer un documento o alguna parte del mismo y no quiere ignorar los nodos de Texto, puede utilizar un conjunto diferente de propiedades definidas en todos los objetos Nodo. Esto le permitirá ver Elementos, nodos de Texto e incluso nodos de Comentario (que representan comentarios HTML en el documento).</p>
    <p>Todos los objetos Nodo definen las siguientes propiedades:</p>
    <p><codeinline>parentNode</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nodo que es el padre de éste, o null para nodos como el objeto Documento que no tienen padre.</p>
    <p><codeinline>childNodes</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Una NodeList de sólo lectura que contiene todos los hijos (no sólo los hijos del Elemento) del nodo.</p>
    <p><codeinline>firstChild</codeinline>, <codeinline>lastChild</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El primer y último nodo hijo de un nodo, o null si el nodo no tiene hijos.</p>
    <p><codeinline>nextSibling</codeinline>, <codeinline>previousSibling</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Los nodos hermanos siguiente y anterior de un nodo. Estas propiedades
      conectan nodos en una lista doblemente enlazada.</p>
    <p><codeinline>nodeType</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Un número que especifica de qué tipo de nodo se trata. Los nodos documento tienen valor 9. Los nodos Elemento tienen valor 1. Los nodos de texto tienen valor 3. Los nodos de comentario tienen valor 8.</p>
    <p><codeinline>nodeValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El contenido textual de un nodo Texto o Comentario.</p>
    <p><codeinline>nodeName</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nombre de etiqueta HTML de un elemento, convertido a mayúsculas.</p>
    <p>Utilizando estas propiedades de Nodo, se puede hacer referencia al segundo nodo hijo del primer hijo del Documento con expresiones como estas:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Supongamos que el documento en cuestión es el siguiente:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El segundo hijo del primer hijo es el elemento &lt;body>. Tiene un nodeType de 1 y un nodeName de "BODY".</p>
    <p>Tenga en cuenta, sin embargo, que esta API es extremadamente sensible a las variaciones en el texto del documento. Si se modifica el documento insertando una sola nueva línea entre el &lt;html> y el icono&lt;head>, por ejemplo, el nodo Text que representa esa nueva línea se convierte en el primer hijo del primer hijo, y el segundo hijo es el elemento &lt;head> en lugar del elemento &lt;body>.</p>
    <p>Para demostrar esta API de navegación basada en nodos, he aquí una función que devuelve todo e l texto de un elemento o documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Esta función es sólo una demostración-en la práctica, usted simplemente escribiría e.text Content para obtener el contenido textual del elemento e.</p>
  </section>
  <section id="3-3">
    <h2>15.3.3 Atributos</h2>
    <p>Los elementos HTML constan de un nombre de etiqueta y un conjunto de pares nombre/valor conocidos como atributos. El elemento &lt;a> que define un hipervínculo, por ejemplo, utiliza el valor de su atributo href como destino del enlace.</p>
    <p>La clase Element define métodos generales getAttribute(), setAttribute(), hasAttri bute() y removeAttribute() para consultar, establecer, comprobar y eliminar los atributos de un elemento. Pero los valores de los atributos de los elementos HTML (para todos los atributos estándar de los elementos HTML estándar) están disponibles como propiedades de los objetos HTMLElement que representan esos elementos, y normalmente es mucho más fácil trabajar con ellos como propiedades de JavaScript que llamar a getAttribute() y métodos relacionados.</p>
    <p class="title-article text-left">Atributos HTML como propiedades de elementos</p>
    <p>Los objetos Element que representan los elementos de un documento HTML suelen definir propiedades de lectura/escritura que reflejan los atributos HTML de los elementos. Elemento define propiedades para los atributos HTML universales como id, title, lang y dir y propiedades de manejador de eventos como onclick. Los subtipos específicos de elementos definen atributos específicos de esos elementos. Para consultar la URL de una imagen, por ejemplo, puede utilizar la propiedad src del HTMLElement que representa al elemento &lt;img>:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>De forma similar, podrías establecer los atributos de envío de formulario de un elemento &lt;form> con código como este:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Para algunos elementos, como el elemento &lt;input>, algunos nombres de atributos HTML corresponden a propiedades con nombres diferentes. El atributo HTML value de un &lt;input>, por ejemplo, se refleja en la propiedad JavaScript defaultValue. La propiedad JavaScript value del elemento &lt;input> contiene la entrada actual del usuario, pero los cambios en la propiedad value no afectan a la propiedad defaultValue ni al atributo value.</p>
    <p>Los atributos HTML no distinguen entre mayúsculas y minúsculas, pero los nombres de propiedades JavaScript sí. Para convertir un nombre de atributo en una propiedad JavaScript, escríbalo en minúsculas. Sin embargo, si el atributo tiene más de una palabra, ponga la primera letra de cada palabra después de la primera en mayúsculas: defaultChecked y tabIndex, por ejemplo. Sin embargo, las propiedades de controlador de eventos como onclick son una excepción y se escriben en minúsculas.</p>
    <p>Algunos nombres de atributos HTML son palabras reservadas en JavaScript. Para ellos, la regla general es anteponer "html" al nombre de la propiedad. El atributo HTML for (del tipo &lt;label>), por ejemplo, se convierte en la propiedad htmlFor de JavaScript. "class" es una palabra reservada en JavaScript, y el importantísimo atributo HTML class es una excepción a la regla: se convierte en className en código JavaScript.</p>
    <p>Las propiedades que representan atributos HTML suelen tener valores de cadena. Pero cuando el atributo es un valor booleano o numérico (los atributos defaultChecked y maxLength de un elemento &lt;input>, por ejemplo), las propiedades son booleanas o numéricas en lugar de cadenas. Los atributos de manejador de eventos siempre tienen funciones (o null) como valores.</p>
    <p>Tenga en cuenta que esta API basada en propiedades para obtener y establecer valores de atributos no define ninguna forma de eliminar un atributo de un elemento. En particular, el operador delete no puede utilizarse para este propósito. Si necesita eliminar un atributo, utilice el método removeAttribute().</p>
    <p class="title-article text-left">El atributo de clase</p>
    <p>El atributo class de un elemento HTML es especialmente importante. Su valor es una lista separada por espacios de clases CSS que se aplican al elemento y afectan a su estilo con CSS. Como class es una palabra reservada en JavaScript, el valor de este atributo está disponible a través de la propiedad className en los objetos Element. La propiedad className puede establecer y devolver el valor del atributo class como una cadena. Pero la propiedad class está mal nombrado: su valor es una lista de clases CSS, no una sola clase, y es común en la programación JavaScript del lado del cliente querer añadir y eliminar nombres de clases individuales de esta lista en lugar de trabajar con la lista como una sola cadena.</p>
    <p>Por esta razón, los objetos Element definen una propiedad classList que permite tratar el atributo class como una lista. El valor de la propiedad classList es un objeto iterable tipo Array. Aunque el nombre de la propiedad es classList, se comporta más como un conjunto de clases, y define los métodos add(), remove(), contains() y toggle():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Atributos del conjunto de datos</p>
    <p>A veces resulta útil adjuntar información adicional a elementos HTML, normalmente cuando el código JavaScript va a seleccionar esos elementos y manipularlos de alguna manera. En HTML, cualquier atributo cuyo nombre esté en minúsculas y empiece por el prefijo "data-" se considera válido, y puedes utilizarlos para cualquier propósito. Estos "atributos de conjunto de datos" no afectarán a la presentación de los elementos en los que aparecen, y definen una forma estándar de adjuntar datos adicionales sin comprometer la validez del documento.</p>
    <p>En el DOM, los objetos Element tienen una propiedad dataset que hace referencia a un objeto que tiene propiedades que corresponden a los atributos data- con su prefijo eliminado. Así, dataset.x contendría el valor del atributo data-x. Los atributos con guión se asignan a nombres de propiedad en camelCase: el atributo data-section-number se convierte en la propiedad dataset.sectionNumber.</p>
    <p>Supongamos que un documento HTML contiene este texto:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Entonces podrías escribir JavaScript como este para acceder a ese número de sección:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="3-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.4 Elemento Contenido</h2>
    <p>Observe de nuevo el árbol de documentos de la Figura 15-1 y pregúntese cuál es el "contenido" del elemento <p>. Hay dos formas de responder a esta pregunta:</p>
    <ul>
      <li class="font-normal">El contenido es la cadena HTML "Este es un documento &lt;i>simple&lt;/i>".</li>
      <li class="font-normal">El contenido es la cadena de texto plano "This is a simple document".</li>
    </ul>
    <p>Ambas respuestas son válidas, y cada una de ellas es útil a su manera. Las secciones siguientes explican cómo trabajar con la representación HTML y la representación en texto plano del contenido de un elemento.</p>
    <p class="title-article text-left">Contenido del elemento como HTML</p>
    <p>La lectura de la propiedad innerHTML de un elemento devuelve el contenido de ese elemento como una cadena de marcado. Al establecer esta propiedad en un elemento, se invoca el analizador del navegador web y se sustituye el contenido actual del elemento por una representación analizada de la nueva cadena. Puedes probarlo abriendo la consola de desarrollo y escribiendo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Verá que toda la página web desaparece y es sustituida por el encabezado "Oops". Los navegadores web son muy buenos analizando HTML, y establecer innerHTML suele ser bastante eficiente. Tenga en cuenta, sin embargo, que añadir texto a la propiedad innerHTML con el operador += no es eficiente porque requiere un paso de serialización para convertir el contenido del elemento en una cadena y luego un paso de análisis para convertir la nueva cadena de nuevo en contenido del elemento.</p>
    <nota>
      <img class="self-start" src="/public/javascript/nota_warning.svg" alt="Nota de la warning">
      <div class="">
        <p>Cuando utilices estas API HTML, es muy importante que nunca introduzcas datos del usuario en el documento. Si lo hace, permitirá que usuarios malintencionados inyecten sus propios scripts en su aplicación. Consulte "Cross-site scripting" en la página 425 para más detalles.</p>
      </div>
    </nota>
    <p>La propiedad outerHTML de un elemento es como innerHTML, salvo que su valor incluye el propio elemento. Cuando se consulta outerHTML, el valor incluye las etiquetas de apertura y cierre del elemento. Y cuando estableces outerHTML en un elemento, el nuevo contenido sustituye al propio elemento.</p>
    <p>Un método relacionado con Element es insertAdjacentHTML(), que permite insertar una cadena de código HTML arbitraria "adyacente" al elemento especificado. La marca se pasa como segundo argumento a este método, y el significado exacto de "adyacente" depende del valor del primer argumento. Este primer argumento debe ser una cadena con uno de los valores "beforebegin", "afterbegin", "beforeend" o "afterend". Estos valores corresponden a los puntos de inserción que se ilustran en la Figura 15-2.</p>
    <figure id="figure15-2">
      <img src="/public/javascript/capitulo-15/figure15-2.avif" alt="imagen de consola">
      <figcaption>Figura 15-2. Puntos de inserción para insertAdjacentHTML()</figcaption>
    </figure>
    <p class="title-article text-left">Contenido del elemento como texto sin formato</p>
    <p>A veces se desea consultar el contenido de un elemento como texto sin formato o insertar texto sin formato en un documento (sin tener que escapar los corchetes angulares y los ampersands utilizados en el marcado HTML). La forma estándar de hacerlo es con la propiedad textContent:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La propiedad textContent está definida por la clase Node, por lo que funciona tanto para nodos Text como para nodos Element. Para los nodos Elemento, encuentra y devuelve todo el texto en todos los descendientes del elemento.</p>
    <p>La clase Element define una propiedad innerText que es similar a textContent. innerText tiene algunos comportamientos inusuales y complejos, como intentar preservar el formato de tabla. Sin embargo, no está bien especificada ni implementada de forma compatible entre navegadores, por lo que no debería seguir utilizándose.</p>
    <article>
      <p class="title-article">Texto en elementos &lt;script></p>
      <p>Los elementos &lt;script> en línea (es decir, los que no tienen un atributo src) tienen una propiedad text que puede utilizarse para recuperar su texto. El navegador nunca muestra el contenido de un elemento &lt;script>, y el analizador HTML ignora los corchetes angulares y los ampersands dentro de un script. Esto hace que un elemento &lt;script> sea un lugar ideal para incrustar datos textuales arbitrarios para su uso en la aplicación. Basta con establecer el atributo type del elemento en algún valor (como "text/x-custom-data") que deje claro que el script no es código JavaScript ejecutable. Si hace esto, el intérprete de JavaScript ignorará el script, pero el elemento existirá en el árbol del documento, y su propiedad text le devolverá los datos.</p>
    </article>
  </section>
  <section id="3-5">
    <h2>15.3.5 Creación, inserción y supresión de nodos</h2>
    <p>Hemos visto cómo consultar y alterar el contenido de un documento utilizando cadenas de HTML y de texto plano. Y también hemos visto que podemos recorrer un documento para examinar los nodos individuales de Elemento y Texto que lo componen. También es posible alterar un documento a nivel de nodos individuales. La clase Document define métodos para crear objetos Element, y los objetos Element y Text tienen métodos para insertar, borrar y reemplazar nodos en el árbol.</p>
    <p>Crea un nuevo elemento con el método createElement() de la clase Document y añádele cadenas de texto u otros elementos con sus métodos append() y prepend():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>append() y prepend() toman cualquier número de argumentos, que pueden ser objetos Nodo o cadenas. Los argumentos de cadena se convierten automáticamente en nodos de texto. (Se pueden crear nodos de texto explícitamente con document.createTextNode(), pero rara vez hay razón para hacerlo). append() añade los argumentos al elemento al final de la lista hija. prepend() añade los argumentos al principio de la lista hija.</p>
    <p>Si desea insertar un nodo Elemento o Texto en medio de la lista de hijos del elemento contenedor, ni append() ni prepend() funcionarán. En este caso, debe obtener una referencia a un nodo hermano y llamar a before() para insertar el nuevo contenido antes de ese hermano o after() para insertarlo después de ese hermano. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Al igual que append() y prepend(), after() y before() toman cualquier número de argumentos de cadena y elemento y los insertan todos en el documento después de convertir las cadenas en nodos de Texto. append() y prepend() sólo se definen en objetos Elemento, pero after() y before() funcionan tanto en nodos Elemento como Texto: puede utilizarlas para insertar contenido relativo a un nodo Texto.</p>
    <p>Tenga en cuenta que los elementos sólo pueden insertarse en un punto del documento. Si un elemento ya está en el documento y lo insertas en otro lugar, se moverá a la nueva ubicación, no se copiará:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si desea hacer una copia de un elemento, utilice el método cloneNode(), pasando true para copiar todo su contenido:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Puede eliminar un nodo Elemento o Texto del documento llamando a su método remove(), o puede reemplazarlo llamando a replaceWith() en su lugar. remove() no toma argumentos, y replaceWith() toma cualquier número de cadenas y elementos al igual que before() y after():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La API DOM también define una generación anterior de métodos para insertar y eliminar contenido. appendChild(), insertBefore(), replaceChild() y removeChild() son más difíciles de usar que los métodos mostrados aquí y nunca deberían ser necesarios.</p>
  </section>
  <section id="3-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.3.6 Ejemplo: Generación de un índice</h2>
    <p>El Ejemplo 15-1 muestra cómo crear dinámicamente una tabla de contenidos para un documento. Demuestra muchas de las técnicas de scripting de documentos descritas en las secciones anteriores. El ejemplo está bien comentado, y no debería tener problemas para seguir el código.</p>
    <p><em>Ejemplo 15-1. Generación de una tabla de contenidos con la API DOM</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="4">
    <h2>15.4 Secuencias de comandos CSS</h2>
    <p>Hemos visto que JavaScript puede controlar la estructura lógica y el contenido de los documentos HTML. También puede controlar la apariencia visual y el diseño de esos documentos mediante scripts CSS. Las siguientes subsecciones explican algunas técnicas diferentes que el código JavaScript puede utilizar para trabajar con CSS.</p>
    <p>Este es un libro sobre JavaScript, no sobre CSS, y esta sección asume que ya tienes un conocimiento práctico de cómo se usa CSS para dar estilo al contenido HTML. Pero vale la pena mencionar algunos de los estilos CSS que comúnmente se escriben desde JavaScript:</p>
    <ul>
      <li class="font-normal">Al establecer el estilo de visualización en "none" se oculta un elemento. Más adelante podrá mostrar el elemento asignando a display otro valor.</li>
      <li class="font-normal">Puede posicionar elementos dinámicamente estableciendo el estilo de posición en "abso- luto", "relativo" o "fijo" y, a continuación, estableciendo los estilos superior e izquierdo en las coordenadas deseadas. Esto es importante cuando se utiliza JavaScript para mostrar contenido dinámico, como diálogos modales y descripciones emergentes.</li>
      <li class="font-normal">Puede desplazar, escalar y rotar elementos con el estilo de transformación.</li>
      <li class="font-normal">Puede animar los cambios de otros estilos CSS con el estilo de transición. Estas animaciones son manejadas automáticamente por el navegador web y no requieren JavaScript, pero puede utilizar JavaScript para iniciar las animaciones.</li>
    </ul>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.1 Clases de CSS</h2>
    <p>La forma más sencilla de utilizar JavaScript para afectar al estilo del contenido del documento es añadir y eliminar nombres de clases CSS del atributo class de las etiquetas HTML. Esto es fácil de hacer con la propiedad classList de los objetos Element, como se explica en "El atributo class" en la página 445.</p>
    <p>Supongamos, por ejemplo, que la hoja de estilo de su documento incluye una definición para una clase "oculta":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Con este estilo definido, puede ocultar (y luego mostrar) un elemento con código como este:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="4-2">
    <h2>15.4.2 Estilos en línea</h2>
    <p>Siguiendo con el ejemplo anterior, supongamos que el documento está estructurado con un único elemento tooltip y queremos posicionarlo dinámicamente antes de mostrarlo. En general, no podemos crear una clase de hoja de estilo diferente para cada posición posible de la información sobre herramientas, por lo que la propiedad classList no nos ayudará con el posicionamiento.</p>
    <p>En este caso, necesitamos programar el atributo style del elemento tooltip para establecer estilos en línea específicos para ese elemento. El DOM define una propiedad style en todos los objetos Element que corresponde al atributo style. Sin embargo, a diferencia de la mayoría de estas propiedades, , la propiedad style no es una cadena. En su lugar, es un objeto CSSStyleDeclaration: una representación analizada de los estilos CSS que aparecen en forma textual en el atributo style. Para mostrar y establecer la posición de nuestro hipotético tooltip con Java-Script, podríamos utilizar código como este:</p>
    <pre>
    <code class="language-js"></code></pre>
    <article>
      <p class="title-article"></p>
      <p>Muchas propiedades de estilo CSS, como font-size, contienen guiones en sus nombres. En JavaScript, un guión se interpreta como un signo menos y no está permitido en nombres de propiedades u otros identificadores. Por lo tanto, los nombres de las propiedades del objeto CSSStyleDe- claration son ligeramente diferentes de los nombres de las propiedades CSS reales. Si el nombre de una propiedad CSS contiene uno o más guiones, el nombre de la propiedad CSSStyleDeclaration se forma eliminando los guiones y poniendo en mayúscula la letra que sigue inmediatamente a cada guión. Por ejemplo, se accede a la propiedad CSS border-left-width a través de la propiedad JavaScript borderLeftWidth, y la propiedad CSS font-family se escribe como fontFamily en JavaScript.</p>
    </article>
    <p>Cuando trabaje con las propiedades de estilo del objeto CSSStyleDeclaration, recuerde que todos los valores deben especificarse como cadenas. En una hoja de estilo o atributo de estilo, puede escribir:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Para conseguir lo mismo para un elemento e con JavaScript, hay que citar todos los valores:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Tenga en cuenta que los puntos y coma van fuera de las cadenas. Se trata de puntos y comas normales de JavaScript; los puntos y comas que se utilizan en las hojas de estilo CSS no son necesarios como parte de los valores de cadena que se establecen con JavaScript.</p>
    <p>Además, recuerde que muchas propiedades CSS requieren unidades como "px" para píxeles o "pt" para puntos. Por lo tanto, no es correcto establecer la propiedad marginLeft así:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las unidades son necesarias cuando se establecen propiedades de estilo en JavaScript, al igual que cuando se establecen propiedades de estilo en hojas de estilo. La forma correcta de establecer el valor de la propiedad margin Left de un elemento e a 300 píxeles es:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si desea establecer una propiedad CSS en un valor calculado, asegúrese de añadir las unidades al final del cálculo:</p>
    <p>Recuerde que algunas propiedades CSS, como margin, son atajos para otras propiedades, como margin-top, margin-right, margin-bottom y margin-left. El objeto CSSStyle- Declaration tiene propiedades que corresponden a estas propiedades de acceso directo. Por ejemplo, puede establecer la propiedad margin de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>A veces, puede resultar más fácil establecer o consultar el estilo en línea de un elemento como un único valor de cadena en lugar de como un objeto CSSStyleDeclaration. Para ello, puede utilizar los métodos getAttribute() y setAttribute() de Element, o puede utilizar la propiedad cssText del objeto CSSStyleDeclaration:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Cuando consultes la propiedad style de un elemento, ten en cuenta que sólo representa los estilos en línea de un elemento y que la mayoría de los estilos de la mayoría de los elementos se especifican en hojas de estilo en lugar de en línea. Además, los valores que obtenga al consultar la propiedad style utilizarán las unidades y el formato de propiedad abreviada que se utilicen en el atributo HTML, y es posible que el código tenga que realizar un análisis sintáctico sofisticado para interpretarlos. En general, si quieres consultar los estilos de un elemento, probablemente quieras el estilo computado, que se discute a continuación.</p>
  </section>
  <section id="4-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.3 Estilos calculados</h2>
    <p>El estilo calculado para un elemento es el conjunto de valores de propiedad que el navegador deriva (o calcula) a partir del estilo en línea del elemento más todas las reglas de estilo aplicables en todas las hojas de estilo: es el conjunto de propiedades realmente utilizadas para mostrar el elemento. Al igual que los estilos en línea, los estilos calculados se representan con un objeto CSSStyleDeclaration. Sin embargo, a diferencia de los estilos en línea, los estilos computados son de sólo lectura. No puedes establecer estos estilos, pero el objeto CSSStyleDeclaration computado para un elemento te permite determinar qué valores de propiedades de estilo utilizó el navegador al renderizar ese elemento.</p>
    <p>Obtenga el estilo calculado para un elemento con el método getComputedStyle() del objeto Window. El primer argumento de este método es el elemento cuyo estilo calculado se desea obtener. El segundo argumento opcional se utiliza para especificar un pseudoelemento CSS, como "::before" o "::after":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El valor de retorno de getComputedStyle() es un objeto CSSStyleDeclaration que representa todos los estilos que se aplican al elemento (o pseudoelemento) especificado. Hay varias diferencias importantes entre un objeto CSSStyleDeclaration que representa estilos en línea y uno que representa estilos calculados:</p>
    <ul>
      <li class="font-normal">Las propiedades de estilo calculadas son de sólo lectura.</li>
      <li class="font-normal">Las propiedades de estilo calculadas son absolutas: las unidades relativas como porcentajes y puntos se convierten en valores absolutos. Cualquier propiedad que especifique un tamaño (como un tamaño de margen o un tamaño de fuente) tendrá un valor medido en píxeles. Este valor será una cadena con un sufijo "px", por lo que tendrá que analizarlo, pero no tendrá que preocuparse de analizar o convertir otras unidades. Las propiedades cuyos valores sean col- ores se devolverán en formato "rgb()" o "rgba()"</li>
      <li class="font-normal">Las propiedades de acceso directo no se calculan, sólo las propiedades fundamentales en las que se basan. Por ejemplo, no consulte la propiedad margin, sino mar ginLeft, marginTop, etc. Del mismo modo, no consulte border ni siquiera border Width. En su lugar, utilice borderLeftWidth, borderTopWidth, etc.</li>
      <li class="font-normal">La propiedad cssText del estilo calculado no está definida.</li>
    </ul>
    <p>Un objeto CSSStyleDeclaration devuelto por getComputedStyle() generalmente contiene mucha más información sobre un elemento que la CSSStyleDeclaration obtenida de la propiedad de estilo en línea de ese elemento. Pero los estilos calculados pueden ser complicados, y su consulta no siempre proporciona la información que cabría esperar. Considere el atributo font-family: acepta una lista separada por comas de las familias de fuentes deseadas para la portabilidad entre plataformas. Cuando se consulta la propiedad fontFamily de un estilo calculado, simplemente se obtiene el valor del estilo font-family más específico que se aplica al elemento. Esto puede devolver un valor como "arial,helvetica,sans-serif", que no le dice qué tipo de letra está realmente en uso. Del mismo modo, si un elemento no tiene una posición absoluta, al intentar consultar su posición y tamaño a través de las propiedades top y left de su estilo calculado, a menudo se obtiene el valor auto. Este es un valor CSS perfectamente legal, pero probablemente no es lo que estabas buscando.</p>
    <p>Aunque CSS puede utilizarse para especificar con precisión la posición y el tamaño de los elementos del documento, consultar el estilo calculado de un elemento no es la forma preferida de determinar el tamaño y la posición del elemento. Véase §15.5.2 para una alternativa más sencilla y portable.</p>
  </section>
  <section id="4-4">
    <h2>15.4.4 Hojas de estilo de secuencias de comandos</h2>
    <p>Además de programar atributos de clase y estilos en línea, JavaScript también puede manipular las propias hojas de estilo. Las hojas de estilo se asocian a un documento HTML con un atributo &lt;style> o con una etiqueta &lt;link rel="stylesheet">. Ambas son etiquetas HTML normales, por lo que puedes darles ambos atributos id y luego buscarlas con document.querySelector().</p>
    <p>Los objetos Element para las etiquetas &lt;style> y &lt;link> tienen una propiedad disabled que puedes usar para desactivar toda la hoja de estilos. Podrías usarla con código como este:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Otra forma sencilla de programar hojas de estilo es insertar otras nuevas en el documento utilizando las técnicas de manipulación del DOM que ya hemos visto. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>De forma menos sutil, también puedes simplemente insertar una cadena de HTML que contenga una etiqueta &lt;style> en tu documento. Este es un truco divertido, por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre> 
    <p>Los navegadores definen una API que permite a JavaScript mirar dentro de las hojas de estilo para consultar, modificar, insertar y eliminar reglas de estilo en esa hoja de estilo. Esta API es tan especializada que no está documentada aquí. Puedes leer sobre ella en MDN buscando "CSSStyle- Sheet" y "CSS Object Model".</p>
  </section>
  <section id="4-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.4.5 Animaciones y eventos CSS</h2>
    <p>Suponga que tiene las dos clases CSS siguientes definidas en una hoja de estilos:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si aplicas el primer estilo a un elemento, será totalmente transparente y, por tanto, invisible. Pero si aplicas el segundo estilo que indica al navegador que cuando la opacidad del elemento cambie, ese cambio debe ser animado durante un periodo de 0,5 segundos, "ease-in" especifica que la animación del cambio de opacidad debe empezar lentamente y luego acelerarse.</p>
    <p>Suponga ahora que su documento HTML contiene un elemento con la clase "fadeable":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>En JavaScript, puede añadir la clase "transparente":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este elemento está configurado para animar los cambios de opacidad. Al añadir la clase "transparent", cambia la opacidad y se activa una animación: el navegador "desvanece" el elemento para que se vuelva totalmente transparente en un periodo de medio segundo.</p>
    <p>Esto también funciona a la inversa: si elimina la clase "transparente" de un elemento "atenuable", también se produce un cambio de opacidad, y el elemento se atenúa y vuelve a ser visible.</p>
    <p>JavaScript no tiene que hacer ningún trabajo para que se produzcan estas animaciones: son un efecto CSS puro. Pero JavaScript puede utilizarse para activarlas.</p>
    <p>JavaScript también puede utilizarse para controlar el progreso de una transición CSS, ya que el navegador web dispara eventos al inicio y al final de una transición. El evento "transitionrun" se envía cuando la transición se activa por primera vez. Esto puede ocurrir antes de que comiencen los cambios visuales, cuando se ha especificado el estilo "transition-delay". Una vez que comienzan los cambios visuales, se envía un evento "transitionstart", y cuando la animación ha terminado, se envía un evento "transitionend". El objetivo de todos estos eventos es, por supuesto, el elemento animado. El objeto que se pasa a los manejadores de estos eventos es un objeto TransitionEvent. Tiene una propiedad propertyName que especifica la propiedad CSS que se está animando y una propiedad elapsedTime que para los eventos "transitionend" especifica cuántos segundos han pasado desde el evento "transitionstart".</p>
    <p>Además de las transiciones, CSS también admite una forma más compleja de animación conocida simplemente como "Animaciones CSS". Éstas utilizan propiedades CSS como animation- name y animation-duration y una regla especial @keyframes para definir los detalles de la animación. Los detalles de cómo funcionan las animaciones CSS están más allá del alcance de este libro, pero una vez más, si defines todas las propiedades de animación en una clase CSS, entonces puedes utilizar JavaScript para activar la animación simplemente añadiendo la clase al elemento que se va a animar.</p>
    <p>Al igual que las transiciones CSS, las animaciones CSS también activan eventos que tu código JavaScript puede escuchar. El evento "animationstart" se envía cuando comienza la animación, y el evento "ani- mationend" se envía cuando finaliza. Si la animación se repite más de una vez, se envía un evento "animationiteration" después de cada repetición excepto la última. El objetivo del evento es el elemento animado, y el objeto del evento que se pasa a las funciones de control es un objeto AnimationEvent. Estos eventos incluyen una propiedad animationName que especifica la propiedad animation-name que define la animación y una propiedad elapsedTime que especifica cuántos segundos han pasado desde que comenzó la ani- mación.</p>
  </section>
  <section id="5">
    <h2>15.5 Geometría del documento y desplazamiento</h2>
    <p>Hasta ahora, en este capítulo hemos pensado en los documentos como árboles abstractos de elementos y nodos de texto. Pero cuando un navegador renderiza un documento dentro de una ventana, crea una representación visual del documento en la que cada elemento tiene una posición y un tamaño. A menudo, las aplicaciones web pueden tratar los documentos como árboles de elementos y no tener que pensar nunca en cómo se representan esos elementos en pantalla. A veces, sin embargo, es necesario determinar la geometría precisa de un elemento. Si, por ejemplo, quieres usar CSS para posicionar dinámicamente un elemento (como un tooltip) junto a algún elemento posicionado por el navegador, necesitas ser capaz de determinar la localización de ese elemento.</p>
    <p>Las siguientes subsecciones explican cómo se puede ir y venir entre el modelo abstracto, basado en árboles, de un documento y la vista geométrica, basada en coordenadas, del documento tal y como se presenta en una ventana del navegador.</p>
  </section>
  <section id="5-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.1 Coordenadas del documento y coordenadas de la ventana gráfica</h2>
    <p>La posición de un elemento del documento se mide en píxeles CSS, con la coordenada x aumentando hacia la derecha y la coordenada y aumentando a medida que bajamos. Sin embargo, hay dos puntos diferentes que podemos utilizar como origen del sistema de coordenadas: las coordenadas x e y de un elemento pueden ser relativas a la esquina superior izquierda del documento o relativas a la esquina superior izquierda de la ventana gráfica en la que se muestra el documento. En ventanas de nivel superior y pestañas, la "ventana gráfica" es la porción del navegador que realmente muestra el contenido del documento: excluye el "cromo" del navegador, como menús, barras de herramientas, y pestañas. Para los documentos mostrados en etiquetas &lt;iframe>, es el elemento iframe en el DOM el que define la ventana gráfica para el documento anidado. En cualquier caso, cuando hablamos de la posición de un elemento, debemos tener claro si estamos utilizando las coordenadas del documento o las coordenadas de la ventana gráfica. (Ten en cuenta que las coordenadas de la ventana gráfica a veces se denominan "coordenadas de ventana").</p>
    <p>Si el documento es más pequeño que la ventana gráfica, o si no se ha desplazado, la esquina superior izquierda del documento se encuentra en la esquina superior izquierda de la ventana gráfica y los sistemas de coordenadas del documento y de la ventana gráfica coinciden. En general, sin embargo, para convertir entre los dos sistemas de coordenadas, debemos sumar o restar los desplazamientos. Por ejemplo, si un elemento tiene una coordenada y de 200 píxeles en las coordenadas del documento y el usuario se ha desplazado 75 píxeles hacia abajo, ese elemento tiene una coordenada y de 125 píxeles en las coordenadas de la ventana gráfica. Del mismo modo, si un elemento tiene una coordenada x de 400 en las coordenadas de la ventana gráfica después de que el usuario haya desplazado la ventana 200 píxeles horizontalmente, entonces la coordenada x del elemento en las coordenadas del documento es 600.</p>
    <p>Si utilizamos el modelo mental de los documentos impresos en papel, es lógico suponer que cada elemento de un documento debe tener una posición única en las coordenadas del documento, independientemente de cuánto se haya desplazado el usuario por el documento. Esta es una propiedad atractiva de los documentos en papel, y se aplica a los documentos web simples, pero en general, las coordenadas del documento no funcionan realmente en la web. El problema es que la propiedad CSS overflow permite que los elementos de un documento contengan más contenido del que pueden mostrar. Los elementos pueden tener sus propias barras de desplazamiento y servir como ventanas para el contenido que contienen. El hecho de que la Web permita el desplazamiento de elementos dentro de un documento desplazable significa que simplemente no es posible describir la posición de un elemento dentro del documento utilizando un único punto (x,y).</p>
    <p>Dado que las coordenadas del documento no funcionan realmente, el JavaScript del lado del cliente tiende a utilizar coordenadas de la ventana gráfica. Los métodos getBoundingClientRect() y elementFromPoint() que se describen a continuación utilizan coordenadas de la ventana gráfica, por ejemplo, y las propiedades clientX y clientY de los objetos de eventos de ratón y puntero también utilizan este sistema de coordenadas.</p>
    <p>Cuando se posiciona explícitamente un elemento utilizando CSS position:fixed, las propiedades top e left se interpretan en coordenadas de la ventana gráfica. Si utiliza position:rela tive, el elemento se posiciona en relación a donde habría estado si no tuviera la propiedad position establecida. Si utiliza position:absolute, las coordenadas superior e izquierda son relativas al documento o al elemento posicionado más cercano. Esto significa, por ejemplo, que un elemento posicionado absolutamente dentro de un elemento posicionado relativamente se posiciona en relación al elemento contenedor, no en relación al documento en general. A veces es muy útil crear un contenedor relativamente posicionado con las coordenadas superior e izquierda a 0 (para que el contenedor se disponga normalmente) con el fin de establecer un nuevo origen del sistema de coordenadas para los elementos absolutamente posicionados que contiene. Podemos referirnos a este nuevo sistema de coordenadas como "coordenadas del contenedor" para distinguirlo de las coordenadas del documento y de las coordenadas de la ventana gráfica.</p>
    <article>
      <p class="title-article">Píxeles CSS</p>
      <p>Si, como yo, eres lo bastante mayor como para recordar monitores de ordenador con resoluciones de 1024 × 768 y teléfonos con pantalla táctil con resoluciones de 320 × 480, es posible que sigas pensando que la palabra "píxel" se refiere a un único "elemento de imagen" en el hardware. Los monitores 4K y las pantallas "retina" actuales tienen una resolución tan alta que los píxeles de software se han desvinculado de los píxeles de hardware. Un píxel CSS -y, por tanto, un píxel Java-Script del lado del cliente- puede, de hecho, estar formado por varios píxeles de dispositivo. La propiedad devicePixelRatio del objeto Window especifica cuántos píxeles de dispositivo se utilizan para cada píxel de software. Un "dpr" de 2, por ejemplo, significa que cada píxel de software es en realidad un píxel de 2 × 2 de píxeles de hardware. El valor de devicePixelRatio depende del tamaño físico del dispositivo. la resolución de su hardware, la configuración de su sistema operativo y el nivel de zoom de su navegador.</p>
      <p>devicePixelRatio no tiene que ser un número entero. Si está utilizando un tamaño de fuente CSS de "12px" y la relación de píxeles del dispositivo es 2,5, entonces el tamaño real de la fuente, en píxeles del dispositivo, es 30. Dado que los valores de píxel que utilizamos en CSS ya no corresponden directamente a píxeles individuales en la pantalla, las coordenadas de píxel ya no necesitan ser números enteros. Si elRatio del devicePix es 3, entonces una coordenada de 3.33 tiene perfecto sentido. Y si el ratio es en realidad 2, entonces una coordenada de 3.33 se redondeará a 3.5.</p>
    </article>
  </section>
  <section id="5-2">
    <h2>15.5.2 Consulta de la geometría de un elemento</h2>
    <p>Puede determinar el tamaño (incluidos el borde y el relleno CSS, pero no el margen) y la posición (en coordenadas de la ventana gráfica) de un elemento llamando a su método getBoundingClien tRect(). No toma argumentos y devuelve un objeto con las propiedades left, right, top, bottom, width y height. Las propiedades left y top dan las coordenadas x e y de la esquina superior izquierda del elemento, y las propiedades right y bottom dan las coordenadas de la esquina inferior derecha. Las diferencias entre estos valores son las propiedades de anchura y altura.</p>
    <p>Los elementos en bloque, como las imágenes, los párrafos y los elementos &lt;div> son siempre rectangulares cuando el navegador los presenta. Sin embargo, los elementos en línea, como &lt;span>, &lt;code> y &lt;b>, pueden abarcar varias líneas y, por tanto, estar formados por varios recuadros. Imagine, por ejemplo, un texto dentro de las etiquetas &lt;em> y &lt;/em> que se muestra de forma que se extiende a lo largo de dos líneas. Sus rectángulos son el final de la primera línea y el principio de la segunda. Si se llama a getBoundingClientRect() en este elemento, el rectángulo delimitador incluiría toda la anchura de ambas líneas. Si desea consultar los rectángulos individuales de los elementos en línea, llame al método getClien tRects() para obtener un objeto de sólo lectura, tipo matriz, cuyos elementos son objetos rectángulos como los devueltos por getBoundingClientRect().</p>
  </section>
  <section id="5-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.3 Determinación del elemento en un punto</h2>
    <p>El método getBoundingClientRect() nos permite determinar la posición actual de un elemento en una ventana gráfica. A veces queremos ir en la otra dirección y determinar qué elemento está en una posición dada en la ventana gráfica. Puedes determinar esto con el método elementFromPoint() del objeto Document. Llame a este método con las coordenadas x e y de un punto (usando las coordenadas de la ventana gráfica, no las coordenadas del documento: las coordenadas clientX y clientY de un evento de ratón funcionan, por ejemplo). elementFromPoint() devuelve un objeto Elemento que está en la posición especificada. El algoritmo de detección de aciertos para seleccionar el elemento no se especifica con precisión, pero la intención de este método es que devuelva el elemento más interno (anidado más profundamente) y más superior (atributo CSS z-index más alto) en ese punto.</p>
  </section>
  <section id="5-4">
    <h2>15.5.4 Desplazamiento</h2>
    <p>El método scrollTo() del objeto Window toma las coordenadas x e y de un punto (en coordenadas del documento) y las establece como desplazamientos de la barra de desplazamiento. Es decir, desplaza la ventana de modo que el punto especificado se encuentre en la esquina superior izquierda de la ventana. Si especifica un punto que está demasiado cerca de la parte inferior o demasiado cerca del borde derecho del documento, el navegador lo moverá tan cerca como sea posible de la esquina superior izquierda, pero no será capaz de llegar hasta allí. El siguiente código desplaza el navegador para que sea visible la página más inferior del documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El método scrollBy() de Window es similar a scrollTo(), pero sus argumentos son relativos y se añaden a la posición de desplazamiento actual:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si desea desplazarse suavemente con scrollTo() o scrollBy(), pase un único argumento objeto en lugar de dos números, de esta forma:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>A menudo, en lugar de desplazarnos a una ubicación numérica en un documento, sólo queremos desplazarnos para que un determinado elemento del documento sea visible. Puede hacerlo con el método scrol lIntoView() en el elemento HTML deseado. Este método asegura que el elemento sobre el que se invoca es visible en la ventana gráfica. Por defecto, intenta poner el elemento borde superior del elemento en o cerca de la parte superior de la ventana gráfica. Si se pasa false como único argumento, se intentará situar el borde inferior del elemento en la parte inferior de la ventana gráfica. El navegador también desplazará la ventana horizontalmente según sea necesario para hacer visible el elemento.</p>
    <p>También puede pasar un objeto a scrollIntoView(), estableciendo la propiedad behavior: "smooth" para un desplazamiento suave. Puede establecer la propiedad block para especificar dónde debe posicionarse el elemento verticalmente y la propiedad inline para especificar cómo debe posicionarse horizontalmente si se necesita desplazamiento horizontal. Los valores legales para ambas propiedades son start, end, nearest y center.</p>
  </section>
  <section id="5-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.5.5 Tamaño de la ventana, tamaño del contenido y posición de desplazamiento</h2>
    <p>Como ya hemos comentado, las ventanas del navegador y otros elementos HTML pueden mostrar contenido desplazable. Cuando este es el caso, a veces necesitamos conocer el tamaño de la ventana gráfica, el tamaño del contenido y los desplazamientos del contenido dentro de la ventana gráfica. Esta sección cubre estos detalles.</p>
    <p>Para las ventanas del navegador, el tamaño de la ventana gráfica viene dado por las propiedades window.innerWidth y win dow.innerHeight. (Las páginas web optimizadas para dispositivos móviles suelen utilizar una propiedad &lt;meta name="viewport"> en su &lt;head> para establecer el ancho de ventana deseado para la página). El tamaño total del documento es el mismo que el tamaño del elemento &lt;html>, document.documentElement. Puede llamar a getBoundingClientRect() en docu ment.documentElement para obtener la anchura y la altura del documento, o puede utilizar las propiedades offsetWidth y offsetHeight de document.documentElement. Los desplazamientos del documento dentro de su ventana gráfica están disponibles como window.scrollX y window.scrollY. Se trata de propiedades de sólo lectura, por lo que no puede establecerlas para desplazar el documento: utilice window.scrollTo() en su lugar.</p>
    <p>Las cosas son un poco más complicadas para los elementos. Cada objeto Elemento define los siguientes tres grupos de propiedades:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las propiedades offsetWidth y offsetHeight de un elemento devuelven su tamaño en pantalla en píxeles CSS. Los tamaños devueltos incluyen el borde y el relleno del elemento, pero no los márgenes. Las propiedades offsetLeft y offsetTop devuelven las coordenadas x e y del elemento. Para muchos elementos, estos valores son coordenadas del documento. Pero para los descendientes de elementos posicionados y para algunos otros elementos, como las celdas de tabla, estas propiedades devuelven coordenadas que son relativas a un elemento ancestro en lugar de coordenadas relativas a un elemento ancestro. que el propio documento. La propiedad offsetParent especifica a qué elemento son relativas las propiedades. Estas propiedades offset son todas de sólo lectura.</p>
    <p>clientWidth y clientHeight son como offsetWidth y offsetHeight, salvo que no incluyen el tamaño del borde, sólo el área de contenido y su relleno. Las propiedades cli entLeft y clientTop no son muy útiles: devuelven la distancia horizontal y vertical entre el exterior del relleno de un elemento y el exterior de su borde. Normalmente, estos valores son sólo la anchura de los bordes izquierdo y superior. Todas estas propiedades son de sólo lectura. Para elementos en línea como &lt;i>, &lt;code> y &lt;span>, todas devuelven 0.</p>
    <p>scrollWidth y scrollHeight devuelven el tamaño del área de contenido de un elemento más su relleno más cualquier contenido que desborde. Cuando el contenido cabe en el área de contenido sin desbordamiento, estas propiedades son las mismas que clientWidth y clientHeight. Pero cuando hay desbordamiento, incluyen el contenido desbordado y devuelven valores mayores que clientWidth y clientHeight. scrollLeft y scrollTop dan el desplazamiento del contenido del elemento dentro de la ventana gráfica del elemento. A diferencia del resto de propiedades descritas aquí, scrollLeft y scrollTop son propiedades escribibles, y puedes establecerlas para desplazar el contenido dentro de un elemento. (En la mayoría de los navegadores, los objetos Element también tienen métodos scrollTo() y scrollBy() como lo hace el objeto Window, pero estos aún no son soportados universalmente).</p>
  </section>
  <section id="6">
    <h2>15.6 Componentes web</h2>
    <p>HTML es un lenguaje de marcado de documentos que define un rico conjunto de etiquetas con ese fin. En las últimas tres décadas, se ha convertido en un lenguaje que se utiliza para describir las interfaces de usuario de las aplicaciones web, pero las etiquetas HTML básicas como &lt;input> y &lt;button> son inadecuadas para los diseños de interfaz de usuario modernos. Los desarrolladores web son capaces de hacer que funcione, pero sólo mediante el uso de CSS y JavaScript para aumentar la apariencia y el comportamiento de las etiquetas HTML básicas. Considere un componente típico de interfaz de usuario, como el cuadro de búsqueda que se muestra en la Figura 15-3.</p>
    <figure id="figure15-3">
      <img src="/public/javascript/capitulo-15/figure15-3.avif" alt="imagen de consola">
      <figcaption>Figura 15-3. Componente de la interfaz de usuario de un cuadro de búsqueda</figcaption>
    </figure>
    <p>El elemento HTML &lt;input> puede utilizarse para aceptar una sola línea de entrada del usuario, pero no tiene ninguna forma de mostrar iconos como la lupa a la izquierda y la X de cancelación a la derecha. Para implementar un elemento de interfaz de usuario moderno como éste para la web, necesitamos utilizar al menos cuatro elementos HTML: un elemento &lt;input>.para aceptar y mostrar la entrada del usuario, dos elementos &lt;img> (o en este caso, dos elementos &lt;span> que muestran glifos Unicode), y un elemento contenedor &lt;div> para alojar a esos tres hijos. Además, tenemos que utilizar CSS para ocultar el borde predeterminado del elemento &lt;input> y definir un borde para el contenedor. Y necesitamos usar JavaScript para hacer que todos los elementos HTML funcionen juntos. Cuando el usuario hace clic en el icono X, necesitamos un controlador de eventos para borrar la entrada del elemento &lt;input>, por ejemplo.</p>
    <p>Eso es mucho trabajo para hacer cada vez que desee mostrar un cuadro de búsqueda en una aplicación web, y la mayoría de las aplicaciones web de hoy no están escritas usando HTML "crudo". En su lugar, muchos desarrolladores web utilizan frameworks como React y Angular que soportan la creación de componentes de interfaz de usuario reutilizables como el cuadro de búsqueda que se muestra aquí. Web Components es una alternativa nativa del navegador a esos marcos basada en tres adiciones relativamente recientes a los estándares web que permiten a JavaScript ampliar HTML con nuevas etiquetas que funcionan como componentes de interfaz de usuario autónomos y reutilizables.</p>
    <p>Las subsecciones siguientes explican cómo utilizar componentes web definidos por otros desarrolladores en sus propias páginas web, luego explican cada una de las tres tecnologías en las que se basan los componentes web y, finalmente, unen las tres en un ejemplo que implementa el elemento de la caja de búsqueda que se muestra en la Figura 15-3.</p>
  </section>
  <section id="6-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.1 Uso de componentes web</h2>
    <p>Los componentes web se definen en JavaScript, por lo que para utilizar un componente web en su archivo HTML, debe incluir el archivo JavaScript que define el componente. Dado que los componentes web son una tecnología relativamente nueva, a menudo se escriben como módulos de JavaScript, por lo que podría incluir uno en su HTML de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los componentes web definen sus propios nombres de etiquetas HTML, con la importante restricción de que esos nombres de etiquetas deben incluir un guión. (Esto significa que las futuras versiones de HTML pueden introducir nuevas etiquetas sin guiones, y no hay posibilidad de que las etiquetas entren en conflicto con el componente web de nadie). Para utilizar un componente web, basta con utilizar su etiqueta en el archivo HTML:</p>
    <p>Los Web Components pueden tener atributos igual que las etiquetas HTML normales; la documentación del componente que utilice le indicará qué atributos admite. Los Web Components no pueden definirse con etiquetas de cierreautomático. No puede escribir &lt;search-box/>, por ejemplo. Su archivo HTML debe incluir tanto la etiqueta de apertura como la de cierre.</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Al igual que los elementos HTML normales, algunos componentes web se escriben de forma que esperen hijos y otros se escriben de forma que no esperen (y no muestren) hijos. Algunos componentes web se escriben de forma que puedan aceptar opcionalmente hijos especialmente etiquetados que aparecerán en "ranuras" nombradas. El componente &lt;search-box> representado en la Figura 15-3 e implementado en el Ejemplo 15-3 utiliza "ranuras" para los dos iconos que muestra. Si desea utilizar un &lt;search-box> con iconos diferentes, puede utilizar HTML como el siguiente:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El atributo slot es una extensión de HTML que se utiliza para especificar qué hijos deben ir dónde. Los nombres de las ranuras - "izquierda" y "derecha" en este ejemplo- los define el componente web. Si el componente que está utilizando admite ranuras, este hecho debe incluirse en su documentación.</p>
    <p>Anteriormente señalé que los componentes web a menudo se implementan como módulos JavaScript y pueden cargarse en archivos HTML con una etiqueta &lt;script type="module">. Puede que recuerdes del principio de este capítulo que los módulos se cargan después de analizar el contenido del documento, como si tuvieran una etiqueta deferred. Esto significa que un navegador web normalmente analizará y mostrará etiquetas como &lt;search-box> antes de haber ejecutado el código que le dirá qué es un &lt;search-box>. Esto es normal cuando se utilizan componentes web. Los analizadores HTML de los navegadores web son flexibles y muy indulgentes con las entradas que no entienden. Cuando encuentran una etiqueta de componente web antes de que se haya definido el componente, añaden un HTMLElement genérico al árbol DOM aunque no sepan qué hacer con él. Más tarde, cuando se define el elemento personalizado, el elemento genérico se "actualiza" para que tenga el aspecto y el comportamiento deseados.</p>
    <p>Si un componente web tiene hijos, es probable que éstos se muestren incorrectamente antes de que se defina el componente. Puede utilizar este CSS para mantener ocultos los componentes web hasta que estén definidos:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Al igual que los elementos HTML normales, los componentes web pueden utilizarse en JavaScript. Si incluyes una etiqueta &lt;search-box> en tu página web, puedes obtener una referencia a ella con querySelector() y un selector CSS apropiado, igual que harías con cualquier otra etiqueta HTML. Generalmente, sólo tiene sentido hacer esto después de que el módulo que define el componente se haya ejecutado, así que tenga cuidado cuando consulte componentes web que no lo haga demasiado pronto. Las implementaciones de componentes web suelen (aunque no es un requisito) definir una propiedad JavaScript para cada atributo HTML que soportan. Y, al igual que los elementos HTML, también pueden definir métodos útiles. Una vez más, la documentación del componente web que esté utilizando debe especificar qué propiedades y métodos están disponibles para su código JavaScript.</p>
    <p>Ahora que ya sabes cómo utilizar los componentes web, las tres secciones siguientes cubren las tres características del navegador web que nos permiten implementarlos.</p>
    <article>
      <p class="title-article">Nodos de DocumentFragment</p>
      <p>Antes de que podamos cubrir las APIs de componentes web, necesitamos volver brevemente a la API DOM para explicar qué es un DocumentFragment. La API DOM organiza un documento en un árbol de objetos Nodo, donde un Nodo puede ser un Documento, un Elemento, un Nodo de Texto, o incluso un Comentario. Ninguno de estos tipos de nodo permite representar un fragmento de un documento que consista en un conjunto de nodos hermanos sin su padre. Aquí es donde entra DocumentFragment: es otro tipo de Nodo que sirve como padre temporal cuando se desea manipular un grupo de nodos hermanos como una sola unidad. Puedes crear un nodo DocumentFragment con document.createDocumentFragment(). Una vez que tenga un DocumentFragment, puede usarlo como un Elemento y añadirle contenido. Un DocumentFragment es diferente de un Elemento porque no tiene un padre. Pero lo que es más importante, cuando insertas un nodo DocumentFragment en el documento, el DocumentFragment en sí no se inserta. En su lugar, se insertan todos sus hijos.</p>
    </article>
  </section>
  <section id="6-2">
    <h2>15.6.2 Plantillas HTML</h2>
    <p>La etiqueta &lt;template> de HTML sólo está relacionada de forma imprecisa con los componentes web, pero permite una optimización útil de los componentes que aparecen con frecuencia en las páginas web.</p>
    <p>Las etiquetas &lt;template> y sus hijas nunca son renderizadas por un navegador web y sólo son útiles en páginas web que utilizan JavaScript. La idea detrás de esta etiqueta es que cuando una página web contiene múltiples repeticiones de la misma estructura HTML básica (como las filas de una tabla o la implementación interna de un componente web), entonces podemos utilizar una &lt;template> para definir esa estructura de elementos una vez, y luego utilizar JavaScript para duplicar la estructura tantas veces como sea necesario.</p>
    <p>En JavaScript, una etiqueta &lt;template> está representada por un objeto HTMLTemplateElement. Este objeto define una única propiedad de contenido, cuyo valor es un Doc-umentFragment de todos los nodos hijos de &lt;template>. Puede clonar este Docu- mentFragment y luego insertar la copia clonada en su documento según sea necesario. El fragmento en sí no se insertará, pero sí sus hijos. Supongamos que está trabajando con un documento que incluye una etiqueta &lt;table> y   &lt;template id="row"> y que la etiqueta define la estructura de las filas de esa tabla. Puede utilizar la plantilla de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los elementos de plantilla no tienen por qué aparecer literalmente en un documento HTML para ser útiles. Puedes crear una plantilla en tu código JavaScript, crear sus hijos con innerHTML, y luego hacer tantos clones como necesites sin la sobrecarga de análisis de innerHTML. Así es como las plantillas HTML se usan típicamente en componentes web, y el Ejemplo 15-3 demuestra esta técnica.</p>
  </section>
  <section id="6-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.3 Elementos personalizados</h2>
    <p>La segunda característica del navegador web que habilita los componentes web son los "elementos personalizados": la capacidad de asociar una clase JavaScript con un nombre de etiqueta HTML para que cualquiera de esas etiquetas en el documento se convierta automáticamente en instancias de la clase en el árbol DOM. El método customElements.define() toma como primer argumento el nombre de una etiqueta del componente web (recuerde que el nombre de la etiqueta debe incluir un guión) y como segundo argumento una subclase de HTMLElement. Cualquier elemento existente en el documento con ese nombre de etiqueta se "actualiza" a instancias recién creadas de la clase. Y si el navegador analiza cualquier HTML en el futuro, creará automáticamente una instancia de la clase para cada una de las etiquetas que encuentre.</p>
    <p>La clase pasada a customElements.define() debe extender HTMLElement y no un tipo más específico como HTMLButtonElement.4 Recuerde del Capítulo 9 que cuando una clase JavaScript extiende otra clase, la función constructora debe llamar a super() antes de usar la palabra clave this, así que si la clase del elemento personalizado tiene un constructor, debe llamar a super() (sin argumentos) antes de hacer cualquier otra cosa.</p>
    <p>El navegador invocará automáticamente ciertos "métodos del ciclo de vida" de una clase de elemento personalizado. El método connectedCallback() se invoca cuando una instancia del elemento personalizado se inserta en el documento, y muchos elementos utilizan este método para realizar la inicialización. También hay un método disconnectedCallback() que se invoca cuando (y si) el elemento se elimina del documento, aunque se utiliza con menos frecuencia.</p>
    <p>Si una clase de elemento personalizado define una propiedad estática observedAttributes cuyo valor es una matriz de nombres de atributos, y si cualquiera de los atributos nombrados se establece (o cambia) en una instancia del elemento personalizado, el navegador invocará el método attributeChanged Callback(), pasando el nombre del atributo, su valor antiguo y su nuevo valor. Esta llamada de retorno puede tomar los pasos necesarios para actualizar el componente basándose en los valores de sus atributos.</p>
    <p>Las clases de elementos personalizados también pueden definir otras propiedades y métodos que deseen. Normalmente, definirán métodos getter y setter que harán que los atributos del elemento estén disponibles como propiedades JavaScript.</p>
    <p>Como ejemplo de elemento personalizado, supongamos que queremos mostrar círculos dentro de párrafos de texto normal. Nos gustaría poder escribir HTML como éste para representar problemas de historias matemáticas como el que se muestra en la Figura 15-4:</p>
    <pre>
    <code class="language-js"></code></pre>
    <figure id="figure15-4">
      <img src="/public/javascript/capitulo-15/figure15-4.avif" alt="imagen de consola">
      <figcaption>Figura 15-4. Elemento personalizado circular en línea</figcaption>
    </figure>
    <p>Podemos implementar este elemento personalizado &lt;inline-circle> que se muestra en el Ejemplo 15-2:</p>
    <p><em>Ejemplo 15-2. El elemento personalizado &lt;inline-circle>.</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="6-4">
    <h2>15.6.4 DOM en la sombra</h2>
    <p>El elemento personalizado mostrado en el Ejemplo 15-2 no está bien encapsulado. Cuando estableces sus atributos de diámetro o color, responde alterando su propio atributo de estilo, que no es el comportamiento que esperaríamos de un elemento HTML real. Para convertir un elemento personalizado en un verdadero componente web, debería utilizar el potente mecanismo de encapsulación conocido como shadow DOM.</p>
    <p>Shadow DOM permite adjuntar una "raíz sombra" a un elemento personalizado (y también a un &lt;div>, &lt;span>, &lt;body>, &lt;article>, &lt;main>, &lt;nav>, &lt;header>, &lt;footer>, &lt;section>,&lt;p>, &lt;blockquote>, &lt;aside>, o &lt;h1> hasta &lt;h6> elemento) conocido como un "shadow host". Los elementos host sombra, como todos los elementos HTML, ya son la raíz de un árbol DOM nor- mal de elementos descendientes y nodos de texto. Una raíz sombra es la raíz de otro árbol, más privado, de elementos descendientes que brota del shadow host y puede considerarse como un minidocumento distinto.</p>
    <p>La palabra "sombra" en "shadow DOM" se refiere al hecho de que los elementos que descienden de una raíz sombra se "esconden en las sombras": no forman parte del árbol DOM normal, no aparecen en la matriz de hijos de su elemento anfitrión y no son visitados por los métodos normales de recorrido del DOM, como querySelector(). Por contraste, los hijos normales y regulares del DOM de un anfitrión en la sombra a veces se denominan "DOM claro".</p>
    <p>Para entender el propósito de la sombra DOM, imagen del HTML &lt;audio> y &lt;video>: muestran una interfaz de usuario no trivial para controlar la reproducción multimedia, pero los botones de reproducción y pausa y otros elementos de la interfaz de usuario no forman parte del árbol DOM y no pueden manipularse con JavaScript. Dado que los navegadores están diseñados para mostrar HTML, es natural que los proveedores de navegadores quieran mostrar interfaces de usuario como éstas utilizando HTML. De hecho, la mayoría de los navegadores llevan mucho tiempo haciendo algo así, y el shadow DOM lo convierte en una parte estándar de la plataforma web.</p>
    <p class="title-article">Encapsulación DOM en la sombra</p>
    <p>La característica clave del shadow DOM es la encapsulación que proporciona. Los descendientes de una raíz sombra están ocultos -e independientes- del árbol DOM normal, casi como si estuvieran en un documento independiente. Hay tres tipos muy importantes de encapsulación que proporciona el shadow DOM:</p>
    <ul>
      <li class="font-normal">Como ya se ha mencionado, los elementos en el shadow DOM están ocultos a los métodos regulares del DOM como querySelectorAll(). Cuando se crea un shadow root y se adjunta a su shadow host, puede crearse en modo "abierto" o "cerrado". Una raíz sombra cerrada está completamente sellada y es inaccesible. Sin embargo, lo más común es que las raíces sombra se creen en modo "abierto", lo que significa que el shadow host tiene una propiedad shadowRoot que JavaScript puede utilizar para acceder a los elementos de la raíz sombra, si tiene alguna razón para hacerlo.</li>
      <li class="font-normal">Los estilos definidos bajo una raíz sombra son privados para ese árbol y nunca afectarán a los elementos DOM ligeros del exterior. (Una raíz de sombra puede definir estilos predeterminados para su elemento anfitrión, pero éstos serán anulados por los estilos DOM ligeros). Del mismo modo, los estilos DOM ligeros que se aplican al elemento anfitrión de la sombra no afectan a los descendientes de la raíz de la sombra. Los elementos en el DOM de sombra heredarán cosas como el tamaño de la fuente y el color de fondo del DOM de luz, y los estilos en el DOM de sombra pueden optar por utilizar variables CSS definidas en el DOM de luz. Sin embargo, en su mayor p a r t e , los estilos del DOM claro y los estilos del DOM sombreado DOM son completamente independientes: el autor de un componente web y el usuario de un componente web no tienen que preocuparse por colisiones o conflictos entre sus hojas de estilo. Poder "abarcar" CSS de esta manera es quizá la característica más importante del shadow DOM.</li>
      <li class="font-normal">Algunos eventos (como "load") que ocurren dentro del shadow DOM se limitan al shadow DOM. Otros, como los eventos de foco, ratón y teclado, se propagan hacia arriba y hacia afuera. Cuando un evento que se origina en el DOM sombra cruza el límite y comienza a propagarse en el DOM luz, su propiedad de destino se cambia al elemento anfitrión sombra, por lo que parece haberse originado directamente en ese elemento.</li>
    </ul>
    <p class="title-article">Ranuras DOM de sombra e hijos DOM de luz</p>
    <p>Un elemento HTML que es un shadow host tiene dos árboles de descendientes. Uno
      es la matriz children[] -los descendientes DOM normales y claros del elemento
      anfitrión- y el otro es la raíz sombra y todos sus descendientes, y puede que te estés
      preguntando cómo pueden mostrarse dos árboles de contenido distintos dentro del
      mismo elemento anfitrión. Así es como funciona:</p>
    <ul>
      <li class="font-normal">Los descendientes de la raíz sombra siempre se muestran dentro del host sombra.</li>
      <li class="font-normal">Si esos descendientes incluyen un elemento &lt;slot>, entonces los hijos regulares light DOM del elemento host se muestran como si fueran hijos de ese &lt;slot>, reemplazando cualquier contenido shadow DOM en el slot. Si el shadow DOM no incluye un elemento &lt;slot>, no se mostrará ningún contenido light DOM del host. Si el shadow DOM tiene una &lt;slot>, pero el shadow host no tiene hijos light DOM, entonces el contenido shadow DOM de la ranura se muestra por defecto.</li>
      <li class="font-normal">Cuando el contenido light DOM se muestra dentro de un espacio shadow DOM, decimos que esos elementos han sido "distribuidos", pero es importante entender que los elementos no se convierten realmente en parte del shadow DOM. Aún pueden consultarse con querySelector() y siguen apareciendo en el DOM claro como hijos o descendientes del elemento anfitrión.</li>
      <li class="font-normal">Si el shadow DOM define más de una &lt;slot> y nombra esas ranuras con un atributo name, los hijos del shadow host pueden especificar en qué ranura les gustaría aparecer especificando un atributo slot="slotname". Vimos un ejemplo de este uso en §15.6.1 cuando demostramos cómo personalizar los iconos que muestra el componente &lt;search-box>.</li>
    </ul>
    <p class="title-article">API DOM en la sombra</p>
    <p>A pesar de toda su potencia, Shadow DOM no dispone de una API JavaScript. Para convertir un elemento DOM claro en un host de sombra, basta con llamar a su método attachShadow(), pasando &lbrace;mode: "open"} como único argumento. Este método devuelve un objeto shadow root y también establece ese objeto como valor de la propiedad shadowRoot del anfitrión. El objeto shadow root es un DocumentFragment, y puedes usar métodos DOM para añadirle contenido o simplemente establecer su propiedad innerHTML a una cadena HTML.</p>
    <p>Si su componente web necesita saber cuándo ha cambiado el contenido DOM de luz de una &lt;ranura> DOM de sombra, puede registrar un oyente para eventos "slotchanged" directamente en el elemento &lt;ranura>.</p>
  </section>
  <section id="6-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.6.5 Ejemplo: un componente web &lt;search-box>.</h2>
    <p>La Figura 15-3 ilustra un componente web &lt;search-box>. El ejemplo 15-3 muestra las tres tecnologías que definen los componentes web: implementa la tecnología El componente &lt;search-box> es un elemento personalizado que utiliza una etiqueta &lt;template> para mayor eficien- cia y una raíz sombra para la encapsulación.</p>
    <p>Este ejemplo muestra cómo utilizar directamente las API de bajo nivel de los componentes web. En la práctica, muchos componentes web desarrollados hoy en día los crean utilizando bibliotecas de alto nivel como "lit-element". Una de las razones para usar una librería es que crear componentes reutilizables y personalizables es bastante difícil de hacer bien, y hay muchos detalles que corregir. El ejemplo 15-3 demuestra componentes web y hace algunos manejos básicos de enfoque de teclado, pero por lo demás ignora la accesibilidad y no hace ningún intento de usar atributos ARIA apropiados para hacer que el componente funcione con lectores de pantalla y otra tecnología de asistencia.</p>
    <p><em>Ejemplo 15-3. Implementación de un componente web</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="7">
    <h2>15.7 SVG: gráficos vectoriales escalables</h2>
    <p>SVG (scalable vector graphics) es un formato de imagen. La palabra "vector" en su nombre indica que es fundamentalmente diferente de los formatos de imagen de trama, como GIF, JPEG y PNG, que especifican una matriz de valores de píxeles. En su lugar, una "imagen" SVG es una descripción precisa e independiente de la resolución (de ahí lo de "escalable") de los pasos necesarios para dibujar el gráfico deseado. Las imágenes SVG se describen mediante archivos de texto que utilizan el lenguaje de marcado XML, bastante similar al HTML.</p>
    <p>Existen tres formas de utilizar SVG en los navegadores web:</p>
    <ul>
      <li class="font-normal">Puede utilizar archivos de imagen .svg con etiquetas HTML &lt;img> normales, del mismo modo que utilizaría una imagen .png o .jpeg.</li>
      <li class="font-normal">Dado que el formato SVG basado en XML es tan similar al HTML, puede incrustar etiquetas SVG directamente en sus documentos HTML. Si lo hace, el analizador HTML del navegador le permitirá omitir los espacios de nombres XML y tratar las etiquetas SVG como si fueran etiquetas HTML.</li>
      <li class="font-normal">Puede utilizar la API DOM para crear dinámicamente elementos SVG que generen imágenes bajo demanda.</li>
    </ul>
    <p>Las subsecciones siguientes muestran el segundo y tercer uso de SVG. Tenga en cuenta, sin embargo, que SVG tiene una gramática amplia y moderadamente compleja. Además de las sencillas primitivas de dibujo de formas, incluye soporte para curvas arbitrarias, texto y ani- mación. Los gráficos SVG pueden incluso incorporar scripts JavaScript y hojas de estilo CSS para añadir información de comportamiento y presentación. Una descripción completa de SVG va mucho más allá del alcance de este libro. El objetivo de esta sección es sólo para mostrar cómo se puede utilizar SVG en sus documentos HTML y la secuencia de comandos con JavaScript.</p>
  </section>
  <section id="7-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.1 SVG en HTML</h2>
    <p>Por supuesto, las imágenes SVG pueden mostrarse mediante etiquetas HTML &lt;img>. Pero también puede incrustar SVG directamente en HTML. Y si lo hace, puede incluso utilizar hojas de estilo CSS para especificar cosas como fuentes, colores y anchos de línea. Aquí tiene, por ejemplo, un archivo HTML que utiliza SVG para mostrar la esfera de un reloj analógico:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observará que los descendientes de la etiqueta &lt;svg> no son etiquetas HTML normales. Sin embargo, las etiquetas &lt;circle>, &lt;line> y &lt;text> tienen propósitos obvios y debería estar claro cómo funciona este gráfico SVG. Hay muchas otras etiquetas SVG, sin embargo, y usted tendrá que consultar una referencia SVG para aprender más. También puede observar que la hoja de estilo es extraña. Los estilos fill, stroke-width y text-anchor no son propiedades de estilo CSS normales. En este caso, CSS se utiliza esencialmente para establecer los atributos de las etiquetas SVG que aparecen en el documento. Tenga en cuenta también que la propiedad CSS font shorthand no funciona para las etiquetas SVG, y debe establecer explícitamente font-family, font-size y font-weight como propiedades de estilo independientes.</p>
  </section>
  <section id="7-2">
    <h2>15.7.2 Secuencias de comandos SVG</h2>
    <p>Una de las razones para incrustar SVG directamente en sus archivos HTML (en lugar de utilizar sólo estática &lt;img>) es que si lo hace, puede utilizar la API DOM para manipular la imagen SVG. Supongamos que utiliza SVG para mostrar iconos en su aplicación web. Puede incrustar SVG en una etiqueta &lt;template> (§15.6.2) y clonar el contenido de la plantilla cuando necesite insertar una copia de ese icono en la interfaz de usuario. Y si quieres que el icono responda a la actividad del usuario -por ejemplo, cambiando de color cuando el usuario pasa el puntero por encima-, a menudo puedes conseguirlo con CSS.</p>
    <p>También es posible manipular dinámicamente gráficos SVG directamente incrustados en HTML. El ejemplo de la esfera del reloj de la sección anterior muestra un reloj estático con las manecillas de la hora y los minutos mirando hacia arriba y mostrando la hora del mediodía o la medianoche. Pero habrá notado que el archivo HTML incluye una etiqueta &lt;script>. Ese script ejecuta una función periódicamente para comprobar la hora y transformar las manecillas de las horas y los minutos girándolas el número apropiado de grados para que el reloj muestre realmente la hora actual, como se muestra en la Figura 15-5.</p>
    <figure id="figure15-5">
      <img src="/public/javascript/capitulo-15/figure15-5.avif" alt="imagen de consola">
      <figcaption>Figura 15-5. Un reloj analógico SVG con guión</figcaption>
    </figure>
    <p>El código para manipular el reloj es sencillo. Determina el ángulo adecuado de las manecillas de las horas y los minutos en función de la hora actual, luego utiliza querySelector() para buscar los elementos SVG que muestran esas manecillas, y luego les asigna un atributo transform para girarlas alrededor del centro de la esfera del reloj. La función utiliza setTi meout() para asegurarse de que se ejecuta una vez por minuto:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="7-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.7.3 Creación de imágenes SVG con JavaScript</h2>
    <p>Además de simplemente programar imágenes SVG incrustadas en sus documentos HTML, también puede crear imágenes SVG desde cero, lo que puede ser útil para crear visualizaciones de datos cargados dinámicamente, por ejemplo. El Ejemplo 15-4 muestra cómo utilizar JavaScript para crear gráficos circulares SVG, como el que se muestra en la Figura 15-6.</p>
    <p>Aunque las etiquetas SVG pueden incluirse en documentos HTML, técnicamente son etiquetas XML, no HTML, y si desea crear elementos SVG con la API DOM de Java Script, no puede utilizar la función normal createElement() que se introdujo en §15.3.5. En su lugar, debe utilizar createElementNS(), que toma una cadena de espacio de nombres XML como primer argumento. En su lugar, debe utilizar createElementNS(), que toma una cadena de espacio de nombres XML como primer argumento. Para SVG, ese espacio de nombres es la cadena literal "http://www.w3.org/2000/svg".</p>
    <figure id="figure15-5">
      <img src="/public/javascript/capitulo-15/figure15-5.avif" alt="imagen de consola">
      <figcaption>Figura 15-6. Un gráfico circular SVG construido con JavaScript (datos de la encuesta de desarrolladores de 2018 de Stack Overflow sobre las tecnologías más populares)</figcaption>
    </figure>
    <p>Aparte del uso de createElementNS(), el código para dibujar el gráfico circular del Ejemplo 15-4 es relativamente sencillo. Hay un poco de matemática para convertir los datos que se grafican en ángulos de cortes circulares. La mayor parte del ejemplo, sin embargo, es código DOM que crea elementos SVG y establece atributos en esos elementos.</p>
    <p>La parte más opaca de este ejemplo es el código que dibuja las porciones de tarta. El elemento utilizado para mostrar cada porción es &lt;path>. Este elemento SVG describe formas arbitrarias compuestas por líneas y curvas. La descripción de la forma se especifica mediante el atributo d del elemento &lt;path>. El valor de este atributo utiliza una gramática compacta de códigos de letras y números que especifican coordenadas, ángulos y otros valores. La letra M, por ejemplo, significa "mover a" y va seguida de las coordenadas x e y. La letra L significa "línea a" y dibuja una línea desde el punto actual hasta las coordenadas que le siguen. Este ejemplo también utiliza la letra A para dibujar un arco. Esta letra va seguida de siete números que describen el arco, y puedes buscar la sintaxis en Internet si quieres saber más.</p>
    <p><em>Ejemplo 15-4. Dibujo de un gráfico circular con JavaScript y SVG</em></p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El gráfico circular de la Figura 15-6 se creó utilizando la función pieChart() Ejemplo 15-4, de esta manera:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="8">
    <h2>15.8 Gráficos en un &lt;canvas></h2>
    <p>El elemento &lt;canvas> no tiene apariencia propia, sino que crea una superficie de dibujo dentro del documento y expone una potente API de dibujo a JavaScript del lado del cliente. La principal diferencia entre la API &lt;canvas> y SVG es que con el lienzo se crean dibujos llamando a métodos, y con SVG se crean dibujos construyendo un árbol de elementos XML. Estos dos enfoques son equivalentemente potentes: cualquiera de ellos puede simularse con el otro. Sin embargo, a primera vista son bastante diferentes y cada uno tiene sus puntos fuertes y débiles. Un dibujo SVG, por ejemplo, se edita fácilmente eliminando elementos de su descripción. Para eliminar un elemento del mismo gráfico en un &lt;canvas>, a menudo es necesario borrar el dibujo y volver a dibujarlo desde cero. Dado que la API de dibujo Canvas está basada en JavaScript y es relativamente compacta (a diferencia de la gramática SVG), se documenta con más detalle en este libro.</p>
    <article>
      <p class="title-article">Gráficos 3D en un lienzo</p>
      <p>También puede llamar a getContext() con la cadena "webgl" para obtener un objeto de contexto que le permita dibujar gráficos 3D utilizando la API WebGL. WebGL es una API grande, complicada y de bajo nivel que permite a los programadores de JavaScript acceder a la GPU, escribir sombreadores de usuario y realizar otras operaciones gráficas muy potentes. Sin embargo, WebGL no se documenta en este libro: es más probable que los desarrolladores web utilicen librerías de utilidades creadas sobre WebGL que la API WebGL directamente.</p>
    </article>
    <p>La mayor parte de la API de dibujo del lienzo no se define en el elemento &lt;canvas> en sí, sino en un objeto "contexto de dibujo" que se obtiene con el método getContext() del lienzo. Llame a getContext() con el argumento "2d" para obtener un objeto CanvasRenderingCon- text2D que puede utilizar para dibujar gráficos bidimensionales en el lienzo.</p>
    <p>Como ejemplo sencillo de la API Canvas, el siguiente documento HTML utiliza &lt;canvas> y algo de JavaScript para mostrar dos formas simples:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Hemos visto que SVG describe formas complejas como un "camino" de líneas y curvas que se pueden dibujar o rellenar. La API Canvas también utiliza la noción de trazado. En lugar de describir un trazado como una cadena de letras y números, un trazado se define mediante una serie de llamadas a métodos, como las invocaciones a beginPath() y arc() del código anterior. Una vez definido el recorrido, otros métodos, como fill(), actúan sobre él. Varias propiedades del objeto de contexto, como fillStyle, especifican cómo se realizan estas operaciones.</p>
    <p>Las subsecciones que siguen demuestran los métodos y propiedades de la API Can- vas 2D. Gran parte del código de ejemplo que sigue opera sobre una variable c. Esta variable contiene el objeto CanvasRenderingContext2D del lienzo, pero el código para inicializar esa variable a veces no se muestra. Para que estos ejemplos funcionen, tendrías que añadir marcado HTML para definir un lienzo con los atributos de anchura y altura apropiados, y luego añadir código como éste para inicializar la variable c:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.1 Trayectorias y polígonos</h2>
    <p>Para dibujar líneas en un lienzo y rellenar las áreas delimitadas por esas líneas, se empieza por definir un trazado. Un trayecto es una secuencia de uno o más subtrayectos. Un subtrayecto es una secuencia de dos o más puntos conectados por segmentos de línea (o, como veremos más adelante, por segmentos de curva). Inicie un nuevo trayecto con el método beginPath(). Comenzar un nuevo con el método moveTo(). Una vez que haya establecido el punto de partida de un subtrayecto con moveTo(), puede conectar ese punto a un nuevo punto con una línea recta llamando a lineTo(). El siguiente código define un camino que incluye dos segmentos de línea:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este código simplemente define un trazado; no dibuja nada en el lienzo. Para dibujar (o "trazar") los dos segmentos de línea del trazado, llame al método stroke(), y para rellenar el área definida por esos segmentos de línea, llame a fill():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este código (junto con algún código adicional para establecer los anchos de línea y los colores de relleno) produjo el dibujo que se muestra en la Figura 15-7.</p>
    <figure id="figure15-7">
      <img src="/public/javascript/capitulo-15/figure15-7.avif" alt="imagen de consola">
      <figcaption>Figura 15-7. Una trayectoria simple, rellenada y trazada</figcaption>
    </figure>
    <p>Observa que el subcamino definido en la Figura 15-7 es "abierto". Consta de sólo dos segmentos de línea, y el punto final no está conectado al punto inicial. Esto significa que no encierra una región. El método fill() rellena subtrayectorias abiertas actuando como si una línea recta conectara el último punto de la subtrayectoria con el primer punto de la subtrayectoria. Por eso este código rellena un triángulo, pero traza sólo dos lados del triángulo.</p>
    <p>Si quisieras trazar los tres lados del triángulo que acabamos de mostrar, llamarías al método closePath() para conectar el punto final del subtrayecto con el punto inicial. (También podría llamar a lineTo(100,100), pero entonces acabaría con tres segmentos de línea que comparten un punto inicial y final pero que no están realmente cerrados. Cuando se dibuja con líneas anchas, los resultados visuales son mejores si se utiliza closePath()).</p>
    <p>Hay otros dos puntos importantes a tener en cuenta sobre stroke() y fill(). Primero, ambos métodos operan en todos los subcaminos del camino actual. Supongamos que hemos añadido otro subtrayecto en el código anterior:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si entonces llamáramos a stroke(), dibujaríamos dos aristas conectadas de un triángulo y una línea vertical desconectada.</p>
    <p>El segundo punto a tener en cuenta sobre stroke() y fill() es que ninguno altera el trazado actual: puede llamar a fill() y el trazado seguirá ahí cuando llame a stroke(). Cuando haya terminado con un trazado y quiera comenzar otro, debe recordar llamar a beginPath(). Si no lo hace, acabará añadiendo nuevos subtrayectos al trazado existente, y puede acabar dibujando esos viejos subtrayectos una y otra vez.</p>
    <p>El Ejemplo 15-5 define una función para dibujar polígonos regulares y demuestra el uso de moveTo(), lineTo(), y closePath() para definir subtrayectorias y de fill() y stroke() para dibujar esas trayectorias. Produce el dibujo mostrado en la Figura 15-8.</p>
    <figure id="figure15-8">
      <img src="/public/javascript/capitulo-15/figure15-8.avif" alt="imagen de consola">
      <figcaption>Figura 15-8. Polígonos regulares</figcaption>
    </figure>
    <p><em>Ejemplo 15-5. Polígonos regulares con moveTo(), lineTo() y closePath()</em></p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observa que este ejemplo dibuja un hexágono con un cuadrado en su interior. El cuadrado y el hexágono son subtrayectorias separadas, pero se solapan. Cuando esto ocurre (o cuando un subtrayecto se cruza a sí mismo), el lienzo necesita ser capaz de determinar qué regiones están dentro del trazado y cuáles están fuera. Para ello, el lienzo utiliza una prueba denominada "regla de enrollamiento no nulo". En este caso, el interior del cuadrado no está relleno porque el cuadrado y el hexágono se dibujaron en direcciones opuestas: los vértices del hexágono se conectaron con segmentos de línea que se movían en el sentido de las agujas del reloj alrededor del círculo. Los vértices del cuadrado se conectaron en sentido contrario a las agujas del reloj. Si el cuadrado también se hubiera dibujado en el sentido de las agujas del reloj, la llamada a fill() también habría rellenado el interior del cuadrado .</p>
  </section>
  <section id="8-2">
    <h2>15.8.2 Dimensiones y coordenadas del lienzo</h2>
    <p>Los atributos width y height del elemento &lt;canvas> y las correspondientes propiedades width y height del objeto Canvas especifican las dimensiones del lienzo. El sistema de coordenadas predeterminado del lienzo sitúa el origen (0,0) en la esquina superior izquierda del lienzo. Las coordenadas x aumentan hacia la derecha y las coordenadas y aumentan a medida que se desciende por la pantalla. Los puntos del lienzo pueden especificarse utilizando valores de coma flotante.</p>
    <p>Las dimensiones de un lienzo no pueden alterarse sin restablecer completamente el can- vas. Al establecer las propiedades de anchura o altura de un lienzo (incluso al establecerlas en su valor actual) se borra el lienzo, se borra la ruta actual y se restablecen todos los atributos gráficos (incluida la transformación actual y la región de recorte) a su estado original.</p>
    <p>Los atributos de anchura y altura de un lienzo especifican el número real de píxeles en los que el lienzo puede dibujar. Se asignan cuatro bytes de memoria por cada píxel, por lo que si la anchura y la altura se establecen en 100, el lienzo asigna 40.000 bytes para representar 10.000 píxeles.</p>
    <p>Los atributos de anchura y altura también especifican el tamaño predeterminado (en píxeles CSS) con el que se mostrará el lienzo en la pantalla. Si window.devicePixelRatio es 2, entonces 100 × 100 píxeles CSS son en realidad 40.000 píxeles de hardware. Cuando el contenido del lienzo se dibuje en la pantalla, los 10.000 píxeles de la memoria tendrán que ampliarse para cubrir los 40.000 píxeles físicos de la pantalla, lo que significa que los gráficos no serán tan nítidos como podrían ser.</p>
    <p>Para obtener una calidad de imagen óptima, no debe utilizar los atributos de anchura y altura para establecer el tamaño en pantalla del lienzo. En su lugar, establezca el tamaño de píxel CSS en pantalla deseado del lienzo con los atributos de estilo CSS width y height. A continuación, antes de empezar a dibujar en el código JavaScript, establezca las propiedades width y height del objeto canvas en el número de píxeles CSS multiplicado por window.devicePixelRatio. Siguiendo con el ejemplo anterior, esta técnica haría que el lienzo se mostrara con 100 × 100 píxeles CSS, pero asignando memoria para 200 × 200 píxeles. (Incluso con esta técnica, el usuario puede ampliar el lienzo y ver gráficos borrosos o pixelados si lo hace. Esto contrasta con los gráficos SVG, que permanecen nítidos sin importar el tamaño en pantalla o el nivel de zoom).</p>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.3 Atributos gráficos</h2>
    <p>El Ejemplo 15-5 establece las propiedades fillStyle, strokeStyle y lineWidth en el objeto con- texto del lienzo. Estas propiedades son atributos gráficos que especifican el color a utilizar por fill() y por stroke(), y la anchura de las líneas a dibujar por stroke(). Observe que estos parámetros no se pasan a los métodos fill() y stroke(), sino que forman parte del estado gráfico general del lienzo. Si defines un método que dibuja una forma y no estableces estas propiedades, el que llama a tu método puede definir el color de la forma estableciendo las propiedades strokeStyle y fill Style antes de llamar a tu método. Esta separación entre el estado de los gráficos y los comandos de dibujo es fundamental para la API Canvas y es similar a la separación entre la presentación y el contenido que se consigue aplicando hojas de estilo CSS a los documentos HTML.</p>
    <p>Hay una serie de propiedades (y también algunos métodos) en el objeto contexto que afectan al estado gráfico del lienzo. Se detallan a continuación.</p>
    <p class="title-article">Estilos de línea</p>
    <p>La propiedad lineWidth especifica cómo de anchas (en píxeles CSS) serán las líneas dibujadas por stroke(). El valor por defecto es 1. Es importante entender que la anchura de la línea viene determinada por la propiedad lineWidth en el momento en que se llama a stroke(), no en el momento en que se llama a lineTo() y otros métodos de construcción de trazados. Para entender completamente la propiedad lineWidth, es importante visualizar los trazados como líneas unidimensionales infinitamente finas. Las líneas y curvas dibujadas por el método stroke() están centradas sobre el trazado, con la mitad del ancho de línea a cada lado. Si estás trazando una y sólo desea que la línea aparezca fuera del trazado, trace primero el trazado y luego rellene con un color opaco para ocultar la parte del trazado que aparece dentro del trazado. O si sólo desea que la línea aparezca dentro de un trazado cerrado, llame primero a los métodos save() y clip(), y luego llame a stroke() y restore(). (Los métodos save(), restore() y clip() se describen más adelante).</p>
    <p>Cuando se dibujan líneas que tienen más de dos píxeles de ancho, las propiedades lineCap y lineJoin pueden tener un impacto significativo en la apariencia visual de los extremos de una ruta y los vértices en los que se encuentran dos segmentos de ruta. La Figura 15-9 ilustra los valores y el aspecto gráfico resultante de lineCap y lineJoin.</p>
    <figure id="figure15-9">
      <img src="/public/javascript/capitulo-15/figure15-9.avif" alt="imagen de consola">
      <figcaption>Figura 15-9. Atributos lineCap y lineJoin Atributos lineCap y lineJoin</figcaption>
    </figure>
    <p>El valor por defecto para lineCap es "butt". El valor por defecto para lineJoin es "inglete". Tenga en cuenta, sin embargo, que si dos líneas se unen en un ángulo muy estrecho, entonces el inglete resultante puede llegar a ser bastante largo y distraer visualmente. Si el inglete en un vértice dado fuera más largo que la mitad del ancho de la línea multiplicado por la propiedad miterLimit, ese vértice se dibujará con una unión biselada en lugar de una unión a inglete. El valor por defecto de miterLimit es 10.</p>
    <p>El método stroke() puede dibujar líneas discontinuas y punteadas así como líneas sólidas, y el estado gráfico de un lienzo incluye una matriz de números que sirve como "patrón de guiones" especificando cuántos píxeles dibujar, y luego cuántos omitir. A diferencia de otras propiedades de dibujo de líneas, el patrón de guiones se establece y consulta con los métodos setLine Dash() y getLineDash() en lugar de con una propiedad. Para especificar un patrón de guiones punteados, puede utilizar setLineDash() de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Por último, la propiedad lineDashOffset especifica a qué distancia debe comenzar el dibujo del patrón de guiones. El valor predeterminado es 0. Las rutas trazadas con el patrón de guiones mostrado aquí comienzan con un guión de 18 píxeles, pero si lineDashOffset se establece en 21, entonces esa misma ruta comenzaría con un punto seguido de un espacio y un guión.</p>
    <p class="title-article">Colores, motivos y degradados</p>
    <p>Las propiedades fillStyle y strokeStyle especifican cómo se rellenan y se trazan los trazados. La palabra "estilo" a menudo significa color, pero estas propiedades también pueden utilizarse para especificar un degradado de color o una imagen que se utilizará para el relleno y el trazo. (Tenga en cuenta que dibujar una línea es básicamente lo mismo que rellenar una región estrecha a ambos lados de la línea, y rellenar y trazar son fundamentalmente la misma operación).</p>
    <p>Si desea rellenar o trazar con un color sólido (o un color translúcido), simplemente establezca estas propiedades a una cadena de color CSS válida. No se requiere nada más.</p>
    <p>Para rellenar (o trazar) con un gradiente de color, establezca fillStyle (o strokeStyle) en un objeto Canvas- Gradient devuelto por los métodos createLinearGradient() o createRadialGradi ent() del contexto. Los argumentos de createLinearGradient() son las coordenadas de dos puntos que definen una línea (no es necesario que sea horizontal o vertical) a lo largo de la cual variarán los colores. Los argumentos de createRadialGradient() especifican los centros y radios de dos círculos. (No es necesario que sean concéntricos, pero el primer círculo suele estar completamente dentro del segundo). Las áreas dentro del círculo más pequeño o fuera del más grande se rellenarán con colores sólidos; las áreas entre los dos se rellenarán con un gradiente de color.</p>
    <p>Después de crear el objeto CanvasGradient que define las regiones del lienzo que serán rellenadas, debe definir los colores del gradiente llamando al método addColorStop() del CanvasGradient. El primer argumento de este método es un número entre 0.0 y 1.0. El segundo argumento es una especificación de color CSS. Debe llamar a este método al menos dos veces para definir un gradiente de color simple, pero puede llamarlo más veces. El color en 0.0 aparecerá al principio del gradiente, y el color en 1.0 aparecerá al final. Si especifica colores adicionales, aparecerán en la posición fraccional especificada dentro del degradado. Entre los puntos que especifique, los colores se interpolarán suavemente. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Un punto importante que hay que entender sobre los degradados es que no son independientes de la posición. Cuando se crea un degradado, se especifican los límites del mismo. Si luego intenta rellenar un área fuera de esos límites, obtendrá el color sólido definido en uno u otro extremo del degradado.</p>
    <p>Además de colores y degradados de color, también puede rellenar y trazar utilizando imágenes. Para ello, establezca fillStyle o strokeStyle a un CanvasPattern devuelto por el método createPat tern() del objeto context. El primer argumento de este método debe ser un &lt;img> o &lt;canvas> que contiene la imagen que desea rellenar o trazar. (Tenga en cuenta que no es necesario insertar la imagen o el lienzo de origen en el documento para poder utilizarlos de este modo). El segundo argumento de createPattern() es la cadena "repeat", "repeat-x", "repeat-y" o "no-repeat", que especifica si las imágenes de fondo se repiten (y en qué dimensiones).</p>
    <p class="title-article">Estilos de texto</p>
    <p>La propiedad font especifica la fuente que utilizarán los métodos de dibujo de texto fill Text() y strokeText() (véase "Texto" en la página 498). El valor de la propiedad font debe ser una cadena con la misma sintaxis que el atributo font de CSS.</p>
    <p>La propiedad textAlign especifica cómo debe alinearse horizontalmente el texto con respecto a la coordenada X pasada a fillText() o strokeText(). Los valores legales son "start", "left", "center", "right" y "end". El valor por defecto es "inicio", que, para texto de izquierda a derecha, tiene el mismo significado que "izquierda".</p>
    <p>La propiedad textBaseline especifica cómo debe alinearse verticalmente el texto con respecto a la coordenada y. El valor por defecto es "alfabético", y es apropiado para alfabetos latinos y similares. El valor "ideographic" está pensado para escrituras como la china y la japonesa. El valor "colgante" está pensado para su uso con Devana- gari y escrituras similares (que se utilizan para muchas de las lenguas de la India). Las líneas de base "superior", "media" e "inferior" son líneas de base puramente geométricas, basadas en el "cuadrado em" de la fuente.</p>
    <p class="title-article">Sombras</p>
    <p>Cuatro propiedades del objeto de contexto controlan el dibujo de sombras paralelas. Si establece estas propiedades adecuadamente, cualquier línea, área, texto o imagen que dibuje recibirá una sombra, que hará que parezca que flota sobre la superficie del lienzo.</p>
    <p>La propiedad shadowColor especifica el color de la sombra. Por defecto es negro totalmente transparente, y las sombras nunca aparecerán a menos que establezca esta propiedad a un color translúcido u opaco. Esta propiedad sólo puede establecerse a una cadena de color: los patrones y degradados no están permitidos para las sombras. El uso de un color de sombra translúcido produce los efectos de sombra más realistas, ya que permite que se vea el fondo.</p>
    <p>Las propiedades shadowOffsetX y shadowOffsetY especifican los desplazamientos X e Y de la sombra. El valor predeterminado para ambas propiedades es 0, que sitúa la sombra directamente debajo del dibujo, donde no es visible. Si establece ambas propiedades a un valor positivo, las sombras aparecerán debajo y a la derecha de lo que dibuje, como si hubiera un fuente de luz situada por encima y a la izquierda, que incide sobre el lienzo desde el exterior de la pantalla del ordenador. Los desplazamientos mayores producen sombras más grandes y hacen que los objetos dibujados parezcan flotar "más alto" sobre el lienzo. Estos valores no se ven afectados por las transformaciones de coordenadas (§15.8.5): la dirección de la sombra y la "altura" permanecen constantes incluso cuando las formas se giran y escalan.</p>
    <p>La propiedad shadowBlur especifica el grado de desenfoque de los bordes de la sombra. El valor por defecto es 0, que produce sombras nítidas y sin desenfoque. Valores mayores producen más desenfoque, hasta un límite superior definido por la implementación.</p>
    <p class="title-article">Translucidez y composición</p>
    <p>Si desea trazar o rellenar un trazado utilizando un color translúcido, puede definir strokeStyle o fillStyle utilizando una sintaxis de color CSS como "rgba(...)" que admita la transparencia alfa. La "a" en "RGBA" significa "alfa" y es un valor entre 0 (totalmente transparente) y 1 (totalmente opaco). Pero la API del lienzo ofrece otra forma de trabajar con colores translúcidos. Si no quieres especificar explícitamente un canal alfa para cada color, o si quieres añadir translucidez a imágenes o patrones opacos, puedes establecer la propiedad globalAlpha. Cada píxel que dibujes tendrá su valor alfa multiplicado por globalAlpha. El valor por defecto es 1, que no añade transparencia. Si estableces globalAlpha a 0, todo lo que dibujes será completamente transparente, y nada aparecerá en el lienzo. Pero si estableces esta propiedad a 0.5, entonces los píxeles que habrían sido opacos serán opacos al 50%, y los píxeles que habrían sido opacos al 50% serán opacos al 25%.</p>
    <p>Cuando trazas líneas, rellenas regiones, dibujas texto o copias imágenes, generalmente esperas que los nuevos píxeles se dibujen encima de los píxeles que ya están en el lienzo. Si estás dibujando píxeles opacos, simplemente reemplazan a los píxeles que ya están ahí. Si dibuja con píxeles translúcidos, el píxel nuevo ("origen") se combina con el píxel antiguo ("destino") de modo que el píxel antiguo se muestra a través del píxel nuevo en función de lo transparente que sea ese píxel.</p>
    <p>Este proceso de combinar píxeles de origen nuevos (posiblemente translúcidos) con píxeles de destino existentes (posiblemente translúcidos) se denomina composición, y el proceso de composición descrito anteriormente es la forma predeterminada en que la API Canvas combina los píxeles. Pero puede establecer la propiedad globalCompositeOperation para especificar otras formas de combinar píxeles. El valor predeterminado es "source-over", lo que significa que los píxeles de origen se dibujan "sobre" los píxeles de destino y se combinan con ellos si el origen es translúcido. Pero si establece globalCompositeOperation como "destination-over", el lienzo combinará los píxeles como si los nuevos píxeles de origen se dibujaran debajo de los píxeles de destino existentes. Si el destino es translúcido o transparente, parte o la totalidad del color del píxel de origen será visible en el color resultante. Como otro ejemplo, el modo de composición "source-atop" combina los píxeles de origen con la transparencia de los píxeles de destino para que no se dibuje nada en las partes del lienzo que ya son transparentes totalmente transparente. Existen varios valores legales para globalCompositeOperation, pero la mayoría sólo tienen usos especializados y no se tratan aquí.</p>
    <p class="title-article">Guardar y restaurar el estado de los gráficos</p>
    <p>Dado que la API Canvas define atributos gráficos en el objeto contexto, podría verse tentado a llamar a getContext() varias veces para obtener varios objetos contexto. Si pudieras hacer esto, podrías definir diferentes atributos en cada contexto: cada contexto sería entonces como un pincel diferente y pintaría con un color diferente o dibujaría líneas de diferentes anchos. Desafortunadamente, no puede utilizar el lienzo de esta manera. Cada &lt;canvas> tiene un único objeto de contexto, y cada llamada a getContext() devuelve el mismo objeto CanvasRenderingContext2D.</p>
    <p>Aunque la API Canvas sólo permite definir un único conjunto de atributos gráficos a la vez, permite guardar el estado actual de los gráficos para poder modificarlo y restaurarlo fácilmente más tarde. El mé todo save() coloca el estado actual de los gráficos en una pila de estados guardados. El mé todo restore() abre la pila y restaura el último estado guardado. Todas las propiedades que se han descrito en esta sección forman parte del estado guardado, así como la transformación actual y la región de recorte (ambas se explican más adelante). Es importante destacar que la ruta definida actualmente y el punto actual no forman parte del estado de los gráficos y no pueden guardarse y restaurarse.</p>
  </section>
  <section id="8-4">
    <h2>15.8.4 Operaciones de dibujo en el lienzo</h2>
    <p>Ya hemos visto algunos métodos básicos del lienzo: beginPath(), moveTo(), lineTo(), closePath(), fill() y stroke()-para definir, rellenar y dibujar líneas y polígonos. Pero la API Canvas también incluye otros métodos de dibujo.</p>
    <p class="title-article text-left">Rectangles</p>
    <p>CanvasRenderingContext2D define cuatro métodos para dibujar rectángulos. Los cuatro métodos de rectángulo esperan dos argumentos que especifiquen una esquina del rectángulo seguida de la anchura y la altura del rectángulo. Normalmente, se especifica la esquina superior izquierda y luego se pasa una anchura positiva y una altura positiva, pero también se pueden especificar otras esquinas y pasar dimensiones negativas.</p>
    <p>fillRect() rellena el rectángulo especificado con el fillStyle actual. strokeRect() traza el contorno del rectángulo especificado utilizando el strokeStyle actual y otros atributos de línea. clearRect() es como fillRect(), pero ignora el estilo de relleno actual y rellena el rectángulo con píxeles negros transparentes (el color por defecto de todos los lienzos en blanco). Lo importante de estos tres métodos es que no afectan al trazado actual ni al punto actual dentro de ese trazado.</p>
    <p>El último método de rectángulo se llama rect(), y afecta al trazado actual: añade el rectángulo especificado, en un subtrazado propio, al trazado. Al igual que otros métodos de definición de rutas, no rellena ni traza nada por sí mismo.</p>
    <p class="title-article text-left">Curves</p>
    <p>Un camino es una secuencia de subcaminos, y un subcamino es una secuencia de puntos conectados. En los trazados que definimos en §15.8.1, esos puntos estaban conectados con segmentos de líneas rectas, pero no tiene por qué ser siempre así. El objeto CanvasRenderingContext2D define un número de métodos que añaden un nuevo punto al subtrayecto y conectan el punto actual a ese nuevo punto con una curva:</p>
    <p><codeinline>arc()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método añade un círculo, o una parte de un círculo (un arco), a la trayectoria. El arco a dibujar se especifica con seis parámetros: las coordenadas x e y del centro del círculo, el radio del círculo, los ángulos inicial y final del arco, y la dirección (en el sentido de las agujas del reloj o en sentido contrario) del arco entre esos dos ángulos. Si hay un punto actual en la trayectoria, este método conecta el punto actual con el inicio del arco mediante una línea recta (lo que resulta útil para dibujar cuñas o porciones de tarta) y, a continuación, conecta el inicio del arco con el final del arco mediante una porción de círculo, dejando el final del arco como nuevo punto actual. Si no hay punto actual cuando se llama a este método, entonces sólo añade el arco circular a la ruta.</p>
    <p><codeinline>ellipse()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método es muy parecido a arc() excepto en que añade una elipse o una porción de elipse a la trayectoria. En lugar de un radio, tiene dos: un radio en el eje x y un radio en el eje y. Además, como las elipses no son radialmente simétricas, este método toma otro argumento que especifica el número de radianes en los que la elipse gira en el sentido de las agujas del reloj alrededor de su centro.</p>
    <p><codeinline>arcTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método dibuja una línea recta y un arco circular igual que el método arc(), pero especifica el arco a dibujar utilizando parámetros diferentes. Los argumentos de arcTo() especifican los puntos P1 y P2 y un radio. El arco que se añade a la trayectoria tiene el radio especificado. Comienza en el punto tangente con la línea (imaginaria) desde el punto actual a P1 y termina en el punto tangente con la línea (imaginaria) entre P1 y P2. Este método de especificar arcos, que parece poco habitual, es bastante útil para dibujar formas con esquinas redondeadas. Si especifica un radio de 0, este método dibuja una línea recta desde el punto actual hasta P1. Con un radio distinto de cero, sin embargo, dibuja una línea recta desde el punto actual en la dirección de P1, luego curva esa línea en un círculo hasta que se dirige en la dirección de P2.</p>
    <p><codeinline>bezierCurveTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método añade un nuevo punto P a la subtrayectoria y lo conecta al punto actual con una curva cúbica de Bézier. La forma de la curva se especifica mediante dos "puntos de control", C1 y C2. Al principio de la curva (en el punto actual), la curva se dirige en la dirección de C1. Al final de la curva (en el punto P), la curva llega desde la dirección de C2. Entre estos puntos, la dirección de la curva varía suavemente. El punto P se convierte en el nuevo punto actual del subtrayecto./p>
    <p><codeinline>quadraticCurveTo()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método es como bezierCurveTo(), pero utiliza una curva de Bezier cuadrática en lugar de una curva de Bezier cúbica y sólo tiene un único punto de control.</p>
    <p>Puede utilizar estos métodos para dibujar trazados como los de la Figura 15-10.</p>
    <figure id="figure15-10">
      <img src="/public/javascript/capitulo-15/figure15-10.avif" alt="imagen de consola">
      <figcaption>Figura 15-10. Trayectorias curvas en un lienzo</figcaption>
    </figure>
    <p>El Ejemplo 15-6 muestra el código utilizado para crear la Figura 15-10. Los métodos demostrados en este código son algunos de los más complicados de la API Canvas. Los métodos demostrados en este código son algunos de los más complicados de la API Canvas; consulte una referencia en línea para obtener detalles completos sobre los métodos y sus argumentos.</p>
    <p><em>Ejemplo 15-6. Añadir curvas a un trazado</em></p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Texto</p>
    <p>Para dibujar texto en un lienzo, normalmente se utiliza el método fillText(), que dibuja el texto utilizando el color (o gradiente o patrón) especificado por la propiedad fillStyle. Para obtener efectos especiales en tamaños de texto grandes, puede utilizar strokeText() para dibujar el contorno de los glifos individuales de la fuente. Ambos métodos toman el texto a dibujar como primer argumento y las coordenadas x e y del texto como segundo y tercer argumento. Ningún método afecta al trazado actual o al punto actual.</p>
    <p>fillText() y strokeText() toman un cuarto argumento opcional. Si se da, este argumento especifica la anchura máxima del texto a mostrar. Si el texto fuera más ancho que el valor especificado cuando se dibuja utilizando la propiedad de fuente, el lienzo hará que quepa escalándolo o utilizando una fuente más estrecha o más pequeña.</p>
    <p>Si necesita medir el texto usted mismo antes de dibujarlo, páselo al método measureText(). Este método devuelve un objeto TextMetrics que especifica las medidas del texto cuando se dibuja con la fuente actual. En el momento de escribir esto, la única "métrica" contenida en el objeto TextMetrics es la anchura. Consulte la anchura en pantalla de una cadena de este modo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Esto es útil si desea centrar una cadena de texto dentro de un lienzo, por ejemplo.</p>
    <p class="title-article text-left">Images</p>
    <p>Además de gráficos vectoriales (trazados, líneas, etc.), la API Lienzo también admite imágenes de mapa de bits. El método drawImage() copia los píxeles de una imagen de origen (o de un rectángulo dentro de la imagen de origen) en el lienzo, escalando y rotando los píxeles de la imagen según sea necesario.</p>
    <p>drawImage() puede invocarse con tres, cinco o nueve argumentos. En todos los casos, el primer argumento es la imagen de origen de la que se van a copiar los píxeles. Este argumento de imagen suele ser un elemento &lt;img>, pero también puede ser otro elemento &lt;canvas> o incluso un elemento &lt;video> (del que se copiará un único fotograma). Si especifica un elemento &lt;img> o &lt;video> que todavía está cargando sus datos, la llamada a drawImage() no hará nada.</p>
    <p>En la versión de tres argumentos de drawImage(), el segundo y tercer argumento especifican las coordenadas x e y en las que se dibujará la esquina superior izquierda de la imagen. En esta versión del método, toda la imagen de origen se copia en el lienzo. Las coordenadas x e y se interpretan en el sistema de coordenadas actual, y la imagen se escala y rota si es necesario, dependiendo de la transformación del lienzo actualmente en efecto.</p>
    <p>La versión de cinco argumentos de drawImage() añade argumentos de anchura y altura a los argumentos x e y descritos anteriormente. Estos cuatro argumentos definen un recuadro de destino dentro del lienzo. La esquina superior izquierda de la imagen de origen va en (x,y), y la esquina inferior derecha va en (x+ancho, y+alto). De nuevo, toda la se copia la imagen. Con esta versión del método, la imagen de origen se escalará para ajustarse al rectángulo de destino.</p>
    <p>La versión de nueve argumentos de drawImage() especifica un rectángulo de origen y un rectángulo de destino y copia sólo los píxeles dentro del rectángulo de origen. Los argumentos dos a cinco especifican el rectángulo de origen. Se miden en píxeles CSS. Si la imagen de origen es otro lienzo, el rectángulo de origen utiliza el sistema de coordenadas predeterminado para ese lienzo e ignora cualquier transformación que se haya especificado. Los argumentos del seis al nueve especifican el rectángulo de destino en el que se dibuja la imagen y están en el sistema de coordenadas actual del lienzo, no en el sistema de coordenadas por defecto.</p>
    <p>Además de dibujar imágenes en un lienzo, también podemos extraer el contenido de un canvas como una imagen utilizando el método toDataURL(). A diferencia de todos los demás métodos descritos aquí, toDataURL() es un método del propio elemento Canvas, no del objeto contexto. Normalmente se invoca a toDataURL() sin argumentos, y devuelve el contenido del lienzo como una imagen PNG, codificada como una cadena utilizando una dirección data: URL. La URL devuelta es adecuada para su uso con un elemento &lt;img>, y puede hacer una instantánea estática de un lienzo con código como este:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="8-5" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.5 Transformaciones de sistemas de coordenadas</h2>
    <p>Como hemos señalado, el sistema de coordenadas por defecto de un lienzo sitúa el origen en la esquina superior izquierda, tiene coordenadas x que aumentan hacia la derecha y coordenadas y que aumentan hacia abajo. En este sistema por defecto, las coordenadas de un punto se asignan directamente a un píxel CSS (que a su vez se asigna directamente a uno o más píxeles del dispositivo). Ciertas operaciones y atributos can- vas (como la extracción de valores de píxel sin procesar y la configuración de desplazamientos de sombra) utilizan siempre este sistema de coordenadas predeterminado. Sin embargo, además del sistema de coordenadas por defecto, cada lienzo tiene una "matriz de transformación actual" como parte de su estado gráfico. Esta matriz define el sistema de coordenadas actual del lienzo. En la mayoría de las operaciones del lienzo, cuando se especifican las coordenadas de un punto, se toma como un punto en el sistema de coordenadas actual, no en el sistema de coordenadas por defecto. La matriz de transformación actual se utiliza para convertir las coordenadas especificadas en coordenadas equivalentes en el sistema de coordenadas por defecto.</p>
    <p>El método setTransform() permite establecer directamente la matriz de transformación de un lienzo, pero las transformaciones del sistema de coordenadas suelen ser más fáciles de especificar como una secuencia de traslaciones, rotaciones y operaciones de escalado. La Figura 15-11 ilustra estas operaciones y su efecto en el sistema de coordenadas del lienzo. El programa que produjo la figura dibujó el mismo conjunto de ejes siete veces seguidas. Lo único que que cambiaba cada vez era la transformación actual. Observe que las transformaciones afectan tanto al texto como a las líneas que se dibujan.</p>
    <figure id="figure15-11">
      <img src="/public/javascript/capitulo-15/figure15-11.avif" alt="imagen de consola">
      <figcaption>Figura 15-11. Transformaciones de sistemas de coordenadas</figcaption>
    </figure>
    <p>El método translate() simplemente mueve el origen del sistema de coordenadas a la izquierda, derecha, arriba o abajo. El método rotate() rota los ejes en el sentido de las agujas del reloj en el ángulo especificado. (La API Canvas siempre especifica los ángulos en radianes. Para convertir grados a radianes, divida por 180 y multiplique por Math.PI). El método scale() amplía o reduce las distancias a lo largo de los ejes x o y.</p>
    <p>Pasando un factor de escala negativo al método scale() se invierte ese eje a través del origen, como si se reflejara en un espejo. Esto es lo que se hizo en la parte inferior izquierda de la Figura 15-11: se utilizó translate() para mover el origen a la esquina inferior izquierda del lienzo, luego se utilizó scale() para voltear el eje y de modo que las coordenadas y aumenten a medida que subimos por la página. Un sistema de coordenadas invertidas como este es familiar de la clase de álgebra y puede ser útil para trazar puntos de datos en gráficos. Tenga en cuenta, sin embargo, que hace que el texto sea difícil de leer.</p>
    <p class="title-article text-left">Comprender matemáticamente las transformaciones</p>
    <p>Me resulta más fácil entender las transformaciones geométricamente, pensando en translate(), rotate() y scale() como transformaciones de los ejes del sistema de coordenadas, tal como se ilustra en la Figura 15-11. También es posible entender las transformaciones algebraicamente como ecuaciones que asignan las coordenadas de un punto (x,y) en el sistema de coordenadas transformado a las coordenadas (x',y') del mismo punto en el sistema de coordenadas anterior.</p>
    <p>La llamada al método c.translate(dx,dy) puede describirse con estas ecuaciones:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las operaciones de escala tienen ecuaciones igualmente sencillas. Una llamada c.scale(sx,sy) puede describirse así:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las rotaciones son más complicadas. La llamada c.rotate(a) se describe mediante estas ecuaciones trigonométricas:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Fíjate en que el orden de las transformaciones importa. Supongamos que empezamos con el sistema de coordenadas por defecto de un lienzo, luego lo trasladamos y luego lo escalamos. Para mapear el punto (x,y) en el sistema de coordenadas actual de vuelta al punto (x'',y'') en el sistema de coordenadas por defecto, primero debemos aplicar las ecuaciones de escalado para mapear el punto a un punto intermedio (x',y') en el sistema de coordenadas trasladado pero sin escalar, luego usar las ecuaciones de traslación para mapear desde este punto intermedio a (x'',y''). El resultado es el siguiente:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si, por otro lado, hubiéramos llamado a scale() antes de llamar a translate(), las ecuaciones resultantes serían diferentes:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La clave que hay que recordar cuando se piensa algebraicamente en secuencias de transformaciones es que hay que trabajar hacia atrás desde la última transformación (la más reciente) hasta la primera. Sin embargo, cuando se piensa geométricamente sobre ejes transformados, se trabaja hacia adelante desde la primera transformación hasta la última.</p>
    <p>Las transformaciones soportadas por el lienzo se conocen como transformaciones afines. Las transformaciones afines pueden modificar las distancias entre puntos y los ángulos entre líneas, pero las líneas paralelas siempre permanecen paralelas después de una transformación afín; no es posible, por ejemplo, especificar una distorsión de lente ojo de pez con una transformación afín. En una transformación afín arbitraria puede describirse mediante los seis parámetros de a a f de estas ecuaciones:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Puede aplicar una transformación arbitraria al sistema de coordenadas actual pasando esos seis parámetros al método transform(). La Figura 15-11 ilustra dos tipos de transformaciones-cizallas y rotaciones alrededor de un punto especificado- que puedes implementar con el método transform() de esta manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El método setTransform() toma los mismos argumentos que transform(), pero en lugar de transformar el sistema de coordenadas actual, ignora el sistema actual, trans- forma el sistema de coordenadas por defecto, y hace que el resultado sea el nuevo sistema de coordenadas actual. setTransform() es útil para restablecer temporalmente el lienzo a su sistema de coordenadas por defecto:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Ejemplo de transformación</p>
    <p>El Ejemplo 15-7 demuestra el poder de las transformaciones del sistema de coordenadas utilizando los métodos translate(), rotate(), y scale() recursivamente para dibujar un fractal de copos de nieve Koch- . La salida de este ejemplo aparece en la Figura 15-12, que muestra copos de nieve Koch con 0, 1, 2, 3 y 4 niveles de recursión.</p>
    <figure id="figure15-12">
      <img src="/public/javascript/capitulo-15/figure15-12.avif" alt="imagen de consola">
      <figcaption>Figura 15-12. Copos de nieve de Koch</figcaption>
    </figure>
    <p>El código que produce estas figuras es elegante, pero su uso de transformaciones recursivas del sistema de coordenadas lo hace algo difícil de entender. Aunque no entienda todos los matices, tenga en cuenta que el código sólo incluye una invocación al método lineTo(). Cada segmento de línea en la Figura 15-12 se dibuja así:</p>
    <p>El valor de la variable len no cambia durante la ejecución del programa, por lo que la posición, orientación y longitud de cada uno de los segmentos de línea viene determinada por traslaciones, rotaciones y operaciones de escalado.</p>
    <p><em>Ejemplo 15-7. Un copo de nieve Koch con transformaciones</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="8-6">
    <h2>15.8.6 Recorte</h2>
    <p>Después de definir un trazado, normalmente se llama a stroke() o fill() (o ambos). También puede llamar al método clip() para definir una región de recorte. Una vez definida una región de recorte, no se dibujará nada fuera de ella. La Figura 15-13 muestra un dibujo complejo producido utilizando regiones de recorte. La franja vertical que corre por el centro y el texto a lo largo de la parte inferior de la figura fueron trazados sin región de recorte y luego rellenados después de que la región de recorte triangular fuera definida.</p>
    <figure id="figure15-13">
      <img src="/public/javascript/capitulo-15/figure15-13.avif" alt="imagen de consola">
      <figcaption>Figura 15-13. Trazos sin recortar y rellenos recortados</figcaption>
    </figure>
    <p>La Figura 15-13 fue generada utilizando el método polygon() del Ejemplo 15-5 y el siguiente código:</p>
    <pre>
    <code class="language-js"></code></pre> 
    <p>Es importante tener en cuenta que cuando se llama a clip(), el trazado actual se recorta a sí mismo en la región de recorte actual, y luego ese trazado recortado se convierte en la nueva región de recorte. Esto significa que el método clip() puede reducir la región de recorte pero nunca puede ampliarla. No existe ningún método para restablecer la región de recorte, por lo que antes de llamar a clip(), debería llamar a save() para poder restaurar() más tarde la región sin recortar.</p>
  </section>
  <section id="8-7" class="py-4 xs:py-5 sm:py-6">
    <h2>15.8.7 Manipulación de píxeles</h2>
    <p>El método getImageData() devuelve un objeto ImageData que representa los píxeles en bruto (como componentes R, G, B y A) de una región rectangular de su lienzo. Puede crear objetos ImageData vacíos con createImageData(). Los píxeles de un objeto ImageData son escribibles, por lo que puede configurarlos como desee y luego copiarlos de nuevo en el lienzo con putImageData().</p>
    <p>Estos métodos de manipulación de píxeles proporcionan un acceso de muy bajo nivel al lienzo. El rectángulo que se pasa a getImageData() está en el sistema de coordenadas por defecto: sus dimensiones se miden en píxeles CSS, y no se ve afectado por la transformación actual. Cuando llame a putImageData(), la posición que especifique también se medirá en el sistema de coordenadas por defecto. Además, putImageData() ignora todos los gráficos atributos. No realiza ninguna composición, no multiplica píxeles por Alfa global y no dibuja sombras.</p>
    <p>Los métodos de manipulación de píxeles son útiles para implementar el procesamiento de imágenes. El Ejemplo 15-8 muestra cómo crear un desenfoque de movimiento simple o efecto "smear" como el que se muestra en la Figura 15-14.</p>
    <figure id="figure15-14">
      <img src="/public/javascript/capitulo-15/figure15-14.avif" alt="imagen de consola">
      <figcaption>Figura 15-14. Efecto de desenfoque de movimiento creado por procesamiento de imágenes</figcaption>
    </figure>
    <p>El siguiente código demuestra getImageData() y putImageData() iterar y modificar los valores de píxel en un objeto ImageData.</p>
    <p><em>Ejemplo 15-8. Desenfoque de movimiento con ImageData</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="9">
    <h2>15.9 API de audio</h2>
    <p>Las etiquetas HTML &lt;audio> y &lt;video> permiten incluir fácilmente sonido y vídeos en las páginas web. Se trata de elementos complejos con importantes API e interfaces de usuario no triviales. Puede controlar la reproducción multimedia con los métodos play() y pause(). Puede establecer las propiedades volume y playbackRate para controlar el volumen de audio y la velocidad de reproducción. Y puede saltar a un momento determinado dentro del medio estableciendo la propiedad currentTime</p>
    <p>Sin embargo, no trataremos aquí en detalle las etiquetas &lt;audio> y &lt;video>. Las siguientes subsecciones muestran dos formas de añadir efectos de sonido con guión a las páginas web.</p>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h2>15.9.1 El constructor Audio()</h2>
    <p>No es necesario incluir una etiqueta &lt;audio> en el documento HTML para incluir efectos de sonido en las páginas web. Puede crear dinámicamente elementos &lt;audio> con el método normal DOM document.createElement() o, como método abreviado, puede utilizar simplemente el constructor Audio(). No es necesario añadir el elemento creado al documento para reproducirlo. Basta con llamar a su método play():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observe el uso de cloneNode() aquí. Si el usuario hace clic en el ratón rápidamente, queremos ser capaces de tener múltiples copias superpuestas del efecto de sonido reproduciéndose al mismo tiempo. Para ello, necesitamos múltiples elementos Audio. Como los elementos Audio no se añaden al documento, serán recolectados cuando terminen de reproducirse.</p>
  </section>
  <section id="9-2">
    <h2>15.9.2 La API WebAudio</h2>
    <p>Además de la reproducción de sonidos grabados con elementos Audio, los navegadores web también permiten generar y reproducir sonidos sintetizados con la API WebAudio. Utilizar la API WebAudio es como conectar un sintetizador electrónico antiguo con cables de conexión. Con WebAudio, se crea un conjunto de objetos AudioNode, que representan fuentes, transformaciones o destinos de formas de onda, y luego se conectan estos nodos en una red para producir sonidos. La API no es particularmente compleja, pero una explicación completa requiere una comprensión de la música electrónica y los conceptos de procesamiento de señales que están más allá del alcance de este libro.</p>
    <p>El siguiente código utiliza la API WebAudio para sintetizar un acorde corto que se desvanece en aproximadamente un segundo. Este ejemplo muestra los fundamentos de la API WebAu- dio. Si le interesa, puede encontrar más información sobre esta API en Internet:</p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10 Localización, navegación e historia</h2>
    <p>La propiedad location de los objetos Window y Document hace referencia al objeto Location, que representa la URL actual del documento mostrado en la ventana, y que también proporciona una API para cargar nuevos documentos en la ventana.</p>
    <p>El objeto Location es muy parecido a un objeto URL (§11.9), y puede utilizar propiedades como protocolo, nombre de host, puerto y ruta para acceder a las distintas partes de la URL del documento actual. La propiedad href devuelve la URL completa como una cadena, al igual que el método toString().</p>
    <p>Las propiedades hash y search del objeto Location son interesantes. La propiedad hash devuelve la parte del "identificador de fragmento" de la URL, si existe: una almohadilla (#) seguida de un ID de elemento. La propiedad de búsqueda es similar. Devuelve la parte de la URL que comienza con un signo de interrogación: a menudo algún tipo de cadena de consulta. En general, esta parte de una URL se utiliza para parametrizar la URL y proporciona una forma de incrustar argumentos en ella. Aunque estos argumentos suelen estar destinados a scripts que se ejecutan en un servidor, no hay ninguna razón por la que no puedan utilizarse también en páginas habilitadas para JavaScript.</p>
    <p>Los objetos URL tienen una propiedad searchParams que es una representación analizada de la propiedad search. El objeto Location no tiene una propiedad searchParams, pero si desea analizar window.location.search, puede crear un objeto URL a partir del objeto Location y utilizar los searchParams de la URL:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Además del objeto Location al que puedes referirte como window.location o docu ment.location, y el constructor URL() que usamos antes, los navegadores también definen una propiedad document.URL. Sorprendentemente, el valor de esta propiedad no es un objeto URL, sino simplemente una cadena. La cadena contiene la URL del documento actual.</p>
  </section>
  <section id="10-1">
    <h2>15.10.1 Carga de nuevos documentos</h2>
    <p>Si asignas una cadena a window.location o a document.location, esa cadena se interpreta como una URL y el navegador la carga, sustituyendo el documento actual por uno nuevo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>También puede asignar URL relativas a la ubicación. Se resuelven en relación con la URL actual:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Un identificador de fragmento desnudo es un tipo especial de URL relativa que no hace que el navegador cargue un nuevo documento, sino que simplemente se desplaza para que el elemento del documento con id o nombre que coincide con el fragmento sea visible en la parte superior de la ventana del navegador. Como caso especial, el identificador de fragmento #top hace que el navegador salte al principio del documento (suponiendo que ningún elemento tenga un atributo id="top"):</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las propiedades individuales del objeto Location son escribibles, y establecerlas cambia la URL de localización y también hace que el navegador cargue un nuevo documento (o, en el caso de la propiedad hash, que navegue dentro del documento actual):</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>También puede cargar una nueva página pasando una nueva cadena al método assign() del objeto Location. Esto es lo mismo que asignar la cadena a la propiedad location, sin embargo, por lo que no es particularmente interesante.</p>
    <p>Por otro lado, el método replace() del objeto Location es bastante útil. Cuando se pasa una cadena a replace(), se interpreta como una URL y hace que el navegador cargue una nueva página, igual que hace assign(). La diferencia es que replace() reemplaza el documento actual en el historial del navegador. Si un script en el documento A establece la propiedad location o llama a assign() para cargar el documento B y luego el usuario pulsa el botón Atrás, el navegador volverá al documento A. Si en cambio utiliza replace(), el documento A se borra del historial del navegador, y cuando el usuario pulsa el botón Atrás, el navegador vuelve al documento que se mostraba antes del documento A.</p>
    <p>Cuando un script carga incondicionalmente un nuevo documento, el método replace() es una mejor opción que assign(). De lo contrario, el botón Atrás llevaría al navegador de vuelta al documento original, y el mismo script volvería a cargar el nuevo documento. Supongamos que tiene una versión mejorada con JavaScript de su página y una versión estática que no utiliza JavaScript. Si determina que el navegador del usuario no admiten las API de la plataforma web que desea utilizar, podría utilizar loca tion.replace() para cargar la versión estática:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Observe que la URL pasada a replace() es relativa. Las URL relativas se interpretan en relación con la página en la que aparecen, igual que si se utilizaran en un hipervínculo.</p>
    <p>Además de los métodos assign() y replace(), el objeto Location también define reload(), que simplemente hace que el navegador recargue el documento.</p>
  </section>
  <section id="10-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.2 Historial de navegación</h2>
    <p>La propiedad history del objeto Window hace referencia al objeto History de la ventana. El objeto History modela el historial de navegación de una ventana como una lista de documentos y estados de documentos. La propiedad length del objeto History especifica el número de elementos de la lista del historial de navegación, pero por razones de seguridad, los scripts no pueden acceder a las URL almacenadas. (Si pudieran, cualquier script podría husmear en tu historial de navegación).</p>
    <p>El objeto History tiene métodos back() y forward() que se comportan como los botones Back y Forward del navegador: hacen que el navegador retroceda o avance un paso en su historial de navegación. Un tercer método, go(), toma un argumento entero y puede saltar cualquier número de páginas hacia adelante (para argumentos positivos) o hacia atrás (para argumentos negativos) en la lista del historial:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si una ventana contiene ventanas hijas (como elementos &lt;iframe>), los historiales de navegación de las ventanas hijas se intercalan cronológicamente con el historial de la ventana principal. Esto significa que una llamada a history.back() (por ejemplo) en la ventana principal puede hacer que una de las ventanas secundarias vuelva a un documento previamente reproducido, pero deja la ventana principal en su estado actual.</p>
    <p>El objeto History descrito aquí se remonta a los primeros días de la web, cuando los documentos eran pasivos y todo el cálculo se realizaba en el servidor. Hoy en día, las aplicaciones web a menudo generan o cargan contenido dinámicamente y muestran nuevos estados de la aplicación sin cargar realmente nuevos documentos. Este tipo de aplicaciones deben realizar su propia gestión del historial si quieren que el usuario pueda utilizar los botones Atrás y Adelante (o los gestos equivalentes) para navegar de un estado de la aplicación a otro de forma intuitiva. Hay dos formas de conseguirlo, que se describen en las dos secciones siguientes.</p>
  </section>
  <section id="10-3">
    <h2>15.10.3 Gestión del historial con hashchange Events</h2>
    <p>Una técnica de gestión del historial implica location.hash Estos son los datos clave que debes conocer para entender esta técnica</p>
    <ul>
      <li class="font-normal">La propiedad location.hash establece el identificador de fragmento de la URL y se utiliza tradicionalmente para especificar el ID de una sección del documento a la que desplazarse. Pero loca tion.hash no tiene por qué ser el ID de un elemento: puedes ponerle cualquier cadena. Mientras ningún elemento tenga esa cadena como ID, el navegador no se desplazará cuando establezcas la propiedad hash de esta forma.</li>
      <li class="font-normal">Al establecer la propiedad location.hash se actualiza la URL que aparece en la barra de direcciones y, lo que es muy importante, se añade una entrada al historial del navegador.</li>
      <li class="font-normal">Cada vez que cambia el identificador de fragmento del documento, el navegador dispara un evento "hashchange" en el objeto Window. Si estableces location.hash explícitamente, se dispara un evento "hashchange". Y, como hemos mencionado, este cambio en el objeto Location crea una nueva entrada en el historial de navegación del navegador. Así que si el usuario ahora pulsa el botón Atrás, el navegador volverá a su URL anterior antes de que establecieras location.hash. Pero esto significa que el identificador del fragmento ha cambiado de nuevo, por lo que en este caso se dispara otro evento "hashchange". Esto significa que mientras puedas crear un identificador de fragmento único para cada posible estado de tu aplicación, los eventos "hashchange" te notificarán si el usuario retrocede y avanza en su historial de navegación.</li>
    </ul>
    <p>Para utilizar este mecanismo de gestión del historial, tendrás que ser capaz de codificar la información de estado necesaria para representar una "página" de tu aplicación en una cadena de texto relativamente corta que sea adecuada para su uso como identificador de fragmento. Y tendrás que escribir una función para convertir el estado de la página en una cadena y otra función para analizar la cadena y recrear el estado de la página que representa.</p>
    <p>Una vez que hayas escrito esas funciones, el resto es fácil. Define una función window.onhash change (o registra un "hashchange" listener con addEventListener()) que lea location.hash, convierta esa cadena en una representación del estado de tu aplicación, y luego tome las acciones que sean necesarias para mostrar ese nuevo estado de la aplicación.</p>
    <p>Cuando el usuario interactúa con tu aplicación (por ejemplo, haciendo clic en un enlace) de forma que la aplicación entra en un nuevo estado, no renderices el nuevo estado directamente. En su lugar, codifica el nuevo estado deseado como una cadena y establece location.hash a esa cadena. Esto activará un evento "hashchange", y tu manejador para ese evento mostrará el nuevo estado. El uso de esta técnica indirecta garantiza que el nuevo estado se inserte en el historial de navegación para que los botones Atrás y Adelante sigan funcionando.</p>
  </section>
  <section id="10-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.10.4 Gestión del historial con pushState()</h2>
    <p>La segunda técnica para gestionar el historial es algo más compleja, pero menos complicada que el evento "hashchange". Esta técnica más robusta de gestión del historial se basa en el método history.pushState() y el evento "popstate". Cuando una aplicación web entra en un nuevo estado, llama a history.pushState() para añadir un objeto que representa el estado al historial del navegador. Si el usuario pulsa el botón Atrás, el navegador lanza un evento "popstate" con una copia de ese objeto de estado guardado, y la aplicación utiliza ese objeto para recrear su estado anterior. Además del objeto de estado guardado, las aplicaciones también pueden guardar una URL con cada estado, lo que es importante si quieres que los usuarios puedan marcar y compartir enlaces a los estados internos de la aplicación.</p>
    <p>El primer argumento de pushState() es un objeto que contiene toda la información de estado necesaria para restaurar el estado actual del documento. Este objeto se guarda utilizando el algoritmo de clonado estructurado de HTML, que es más versátil que JSON.stringify() y puede admitir objetos Map, Set y Date, así como matrices tipadas y ArrayBuffers.</p>
    <p>El segundo argumento estaba pensado para ser una cadena de título para el estado, pero la mayoría de los navegadores no lo soportan, y deberías pasar simplemente una cadena vacía. El tercer argumento es una URL opcional que se mostrará en la barra de direcciones inmediatamente y también si el usuario vuelve a este estado a través de los botones Atrás y Adelante. Las URL relativas se resuelven contra la ubicación actual del documento. Asociar una URL a cada estado permite al usuario marcar estados internos de su aplicación. Recuerda, sin embargo, que si el usuario guarda un marcador y lo visita un día después, no recibirás un evento "pop- state" sobre esa visita: tendrás que restaurar el estado de tu aplicación analizando la URL.</p>
    <article>
      <p class="title-article">El algoritmo del clon estructurado</p>
      <p>El método history.pushState() no utiliza JSON.stringify() (§11.6) para serializar los datos de estado. En su lugar, utiliza (al igual que otras APIs del navegador que veremos más adelante) una técnica de serialización más robusta conocida como algoritmo de clonación estructurada, definida por el estándar HTML.</p>
      <p>El algoritmo de clonado estructurado puede serializar cualquier cosa que JSON.stringify() pueda, pero además, permite la serialización de la mayoría de los otros tipos de JavaScript, incluyendo Map, Set, Date, RegExp, y arrays tipados, y puede manejar estructuras de datos que incluyen referencias circulares. Sin embargo, el algoritmo de clonación estructurada no puede serializar funciones o clases. Al clonar objetos no copia el objeto prototipo, los getters y set- ters, ni las propiedades no enumerables. Aunque el algoritmo de clonación estructurada puede clonar la mayoría de los tipos incorporados de JavaScript, no puede copiar tipos definidos por el entorno host, como los objetos document Element.</p>
      <p>Esto significa que el objeto de estado que se pasa a history.pushState() no tiene por qué limitarse a los objetos, matrices y valores primitivos que admite JSON.stringify(). Nota, Sin embargo, si pasas una instancia de una clase que has definido, esa instancia se serializará como un objeto JavaScript ordinario y perderá su prototipo.</p>
    </article>
    <p>Además del método pushState(), el objeto Historial también define replaceS tate(), que toma los mismos argumentos pero reemplaza el estado actual del historial en lugar de añadir un nuevo estado al historial de navegación. Cuando se carga por primera vez una aplicación que utiliza push State(), suele ser una buena idea llamar a replaceState() para definir un objeto de estado para este estado inicial de la aplicación.</p>
    <p>Cuando el usuario navega a los estados guardados del historial usando los botones Atrás o Adelante, el navegador dispara un evento "popstate" en el objeto Window. El objeto de evento asociado con el evento tiene una propiedad llamada state, que contiene una copia (otro clon estructurado) del objeto state que pasaste a pushState().</p>
    <p>El Ejemplo 15-9 es una aplicación web sencilla -el juego de adivinar números de la Figura 15-15- que utiliza pushState() para guardar su historial, permitiendo al usuario "ir atrás" para revisar o rehacer sus conjeturas.</p>
    <figure id="figure15-15">
      <img src="/public/javascript/capitulo-15/figure15-15.avif" alt="imagen de consola">
      <figcaption>Figura 15-15. Un juego de adivinanzas numéricas</figcaption>
    </figure>
    <p><em>Ejemplo 15-9. Gestión del historial con pushState()</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="11" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11 Networking</h2>
    <p>Cada vez que se carga una página web, el navegador realiza peticiones de red -utilizando los protocolos HTTP y HTTPS- para un archivo HTML, así como para las imágenes, fuentes, scripts y hojas de estilo de los que depende el archivo. Pero además de ser capaces de hacer peticiones de red en respuesta a las acciones del usuario, los navegadores web también exponen APIs de JavaScript para la creación de redes.</p>
    <p>Esta sección cubre tres APIs de red:</p>
    <ul>
      <li class="font-normal">El método fetch() define una API basada en promesas para realizar peticiones HTTP y HTTPS. La API fetch() simplifica las solicitudes GET básicas, pero cuenta con un amplio conjunto de funciones que también admite prácticamente cualquier caso de uso HTTP posible.</li>
      <li class="font-normal">La API Server-Sent Events (o SSE) es una práctica interfaz basada en eventos para las técnicas HTTP de "sondeo prolongado", en las que el servidor web mantiene abierta la conexión de red para poder enviar datos al cliente cuando lo desee.</li>
      <li class="font-normal">WebSockets es un protocolo de red que no es HTTP, sino que está diseñado para interactuar con HTTP. Define una API asíncrona de transmisión de mensajes en la que clientes y servidores pueden enviar y recibir mensajes entre sí de forma similar a los sockets de red TCP.</li>
    </ul>
  </section>
  <section id="11-1">
    <h2>15.11.1 fetch()</h2>
    <p>Para peticiones HTTP básicas, el uso de fetch() es un proceso de tres pasos:</p>
    <ul>
      <li class="font-normal">Llame a fetch(), pasando la URL cuyo contenido desea recuperar.</li>
      <li class="font-normal">Obtener el objeto de respuesta que es devuelto asíncronamente por el paso 1 cuando la respuesta HTTP comienza a llegar y llamar a un método de este objeto de respuesta para pedir el cuerpo de la respuesta.</li>
      <li class="font-normal">Obtén el objeto cuerpo devuelto de forma asíncrona en el paso 2 y procésalo como quieras.</li>
    </ul>
    <p>La API fetch() está completamente basada en promesas, y hay dos pasos asíncronos aquí, por lo que típicamente se esperan dos llamadas then() o dos expresiones await cuando se usa fetch(). (Y si has olvidado lo que son, puede que quieras releer el Capítulo 13 antes de continuar con esta sección).</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Este es el aspecto de una solicitud fetch() si utiliza then() y espera que la respuesta del servidor a su solicitud tenga formato JSON:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>A continuación se muestra una solicitud similar realizada utilizando las palabras clave y await a una API que devuelve una cadena sin formato en lugar de un objeto async JSON:</p>
    <p>Si entiende estos dos ejemplos de código, entonces conoce el 80% de lo que necesita saber para utilizar la API fetch(). Las subsecciones que siguen demostrarán cómo hacer peticiones y recibir respuestas que son algo más complicadas que las mostradas aquí.</p>
    <article>
      <p class="title-article">Adiós a XMLHttpRequest</p>
      <p>La API fetch() sustituye a la barroca y engañosamente llamada API XMLHttpRequest (que no tiene nada que ver con XML). Puede que aún veas XHR (como se abrevia a menudo) en código existente, pero hoy en día no hay razón para usarlo en código nuevo, y no está documentado en este capítulo. Sin embargo, hay un ejemplo de XMLHttpRequest en este libro, y puedes consultar §13.1.3 si quieres ver un ejemplo de redes JavaScript al viejo estilo.</p>
    </article>
    <p class="title-article text-left">Códigos de estado HTTP, cabeceras de respuesta y errores de red</p>
    <p>El proceso fetch() de tres pasos mostrado en §15.11.1 elude todo el código de gestión de errores. He aquí una versión más realista:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La promesa devuelta por fetch() resuelve a un objeto Response. La propiedad status de este objeto es el código de estado HTTP, como 200 para peticiones exitosas o 404 para respuestas "No Encontrado". (statusText proporciona el texto estándar en inglés que acompaña al código de estado numérico). Convenientemente, la propiedad ok de una Respuesta es verdadera si el estado es 200 o cualquier código entre 200 y 299 y es falsa para cualquier otro código.</p>
    <p>fetch() resuelve su Promise cuando la respuesta del servidor comienza a llegar, tan pronto como el estado HTTP y las cabeceras de respuesta están disponibles, pero normalmente antes de que el cuerpo completo de la respuesta haya llegado. Aunque el cuerpo no esté disponible todavía, puedes examinar las cabeceras en este segundo paso del proceso de obtención. La propiedad headers de un objeto Response es un objeto Headers. Utilice su método has() para comprobar la presencia de una cabecera, o utilice su método get() para obtener el valor de una cabecera. Los nombres de cabecera HTTP no distinguen entre mayúsculas y minúsculas, por lo que puede pasar nombres de cabecera en minúsculas o mixtos a estas funciones.</p>
    <p>El objeto Headers también es iterable por si alguna vez necesita hacerlo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si un servidor web responde a la solicitud de fetch(), la promesa devuelta se cumplirá con un objeto Response, incluso si la respuesta del servidor es un error 404 Not Found o un error 500 Internal Server Error. fetch() sólo rechaza la promesa devuelta si no puede ponerse en contacto con el servidor web. Esto puede ocurrir si el ordenador del usuario está desconectado, el servidor no responde o la URL especifica un nombre de host que no existe. Debido a que estas cosas pueden ocurrir en cualquier petición de red, siempre es una buena idea incluir una cláusula .catch() cada vez que hagas una llamada a fetch().</p>
    <p class="title-article text-left">Configuración de los parámetros de la solicitud</p>
    <p>A veces se desea pasar parámetros adicionales junto con la URL cuando se hace una petición. Esto se puede hacer añadiendo pares nombre/valor al final de una URL después de un ?. Las clases URL y URLSearchParams (que se trataron en §11.9) facilitan la construcción de URLs de esta forma, y la función fetch() acepta objetos URL como primer argumento, por lo que se pueden incluir parámetros de petición en una petición fetch() como ésta:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Establecer cabeceras de solicitud</p>
    <p>A veces es necesario establecer cabeceras en las peticiones fetch(). Por ejemplo, si realiza solicitudes de API web que requieren credenciales, puede que necesite incluir una cabecera Authorization que contenga dichas credenciales. Para ello, puede utilizar la versión de dos argumentos de fetch(). Como antes, el primer argumento es una cadena o un objeto URL que especifica la URL a obtener. El segundo argumento es un objeto que puede proporcionar opciones adicionales, incluyendo cabeceras de petición:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Hay otras opciones que se pueden especificar en el segundo argumento de fetch(), y lo volveremos a ver más adelante. Una alternativa a pasar dos argumentos a fetch() es pasar los mismos dos argumentos al constructor de Request() y luego pasar el objeto Request resultante a fetch():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Análisis de los cuerpos de respuesta</p>
    <p>En el proceso fetch() de tres pasos que hemos demostrado, el segundo paso termina llamando a los métodos json() o text() del objeto Response y devolviendo el objeto Promise que esos métodos devuelven. Luego, el tercer paso comienza cuando esa Promesa se resuelve con el cuerpo de la respuesta analizado como un objeto JSON o simplemente como una cadena de texto.</p>
    <p>Estos son probablemente los dos escenarios más comunes, pero no son las únicas formas de obtener el cuerpo de la respuesta de un servidor web. Además de json() y text(), el objeto Response también tiene estos métodos:</p>
    <p><codeinline>arrayBuffer()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve a un ArrayBuffer. Esto es útil cuando la respuesta contiene datos binarios. Puedes utilizar el ArrayBuffer para crear un array tipado (§11.2) o un objeto DataView (§11.2.5) del que puedas leer los datos binarios.</p>
    <p><codeinline>blob()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve un objeto Blob. Los objetos Blob no se tratan en detalle en este libro, pero su nombre significa "Binary Large Object", y son útiles cuando se esperan grandes cantidades de datos binarios. Si pides el cuerpo de la respuesta como un Blob, la implementación del navegador puede transmitir los datos de la respuesta a un archivo temporal y luego devolver un objeto Blob que representa ese archivo temporal. Los objetos Blob, por lo tanto, no permiten el acceso aleatorio al cuerpo de la respuesta de la misma forma que un ArrayBuffer. Una vez que tenga un Blob, puede crear una URL que haga referencia a él con URL.createObjectURL(), o puede utilizar la API FileReader basada en eventos para obtener de forma asíncrona el contenido del Blob como una cadena o un ArrayBuffer. En el momento de escribir esto, algunos navegadores también definen métodos text() y arrayBuffer() basados en promesas que ofrecen una ruta más directa para obtener el contenido de un Blob.</p>
    <p><codeinline>formData()</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este método devuelve una Promise que resuelve a un objeto FormData. Debería utilizar este método si espera que el cuerpo de la respuesta esté codificado en formato "multi-parte/form-data". Este formato es común en las solicitudes POST realizadas a un servidor, pero poco común en las respuestas del servidor, por lo que este método no se utiliza con frecuencia.</p>
    <p class="title-article text-left">Organismos de respuesta en tiempo real</p>
    <p>Además de los cinco métodos de respuesta que devuelven de forma asíncrona alguna forma del cuerpo de respuesta completo, también hay una opción para transmitir el cuerpo de respuesta, que es útil si hay algún tipo de procesamiento que puede hacer en los trozos del cuerpo de respuesta a medida que llegan a través de la red. Pero transmitir la respuesta también es útil si quieres mostrar una barra de progreso para que el usuario pueda ver el progreso de la descarga.</p>
    <p>La propiedad body de un objeto Response es un objeto ReadableStream. Si ya ha llamado a un método de respuesta como text() o json() que lee, analiza y devuelve el cuerpo, entonces bodyUsed será true para indicar que el flujo del cuerpo ya ha sido leído. Sin embargo, si bodyUsed es false, entonces el flujo aún no ha sido leído. En este caso, puede llamar a getReader() sobre response.body para obtener un flujo y utilizar el método read() de este objeto lector para leer asíncronamente trozos de texto del flujo. El método read() devuelve una Promise que resuelve a un objeto con las propiedades done y value. done será true si se ha leído todo el cuerpo o si se ha cerrado el flujo. Y value será el siguiente trozo de , como un Uint8Array, o undefined si no hay más trozos.</p>
    <p>Esta API de streaming es relativamente sencilla si usas async y await pero es sorprendentemente compleja si intentas usarla con Promises sin procesar. El Ejemplo 15-10 demuestra la API definiendo una función streamBody(). Suponga que quiere descargar un archivo JSON grande y reportar el progreso de la descarga al usuario. No puede hacer eso con el método json() del objeto Response, pero podría hacerlo con la función streamBody(), así (asumiendo que una función updateProgress() está definida para establecer el atributo value en un elemento HTML &lt;progress>):</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La función streamBody() puede ser implementada como se muestra en el Ejemplo 15- 10.</p>
    <p><em>Ejemplo 15-10. Transmisión del cuerpo de la respuesta de una petición fetch()</em></p>
    <p>Esta API de streaming es nueva en el momento de escribir este artículo y se espera que evolucione. En particular, está previsto que los objetos ReadableStream sean iterables de forma asíncrona para que puedan utilizarse con bucles for/await (§13.4.1).</p>
    <p class="title-article text-left">Especificar el método y el cuerpo de la solicitud</p>
    <p>En cada uno de los ejemplos de fetch() mostrados hasta ahora, hemos realizado una petición HTTP (o HTTPS) GET. Si desea utilizar un método de solicitud diferente (como POST, PUT o DELETE), simplemente utilice la versión de dos argumentos de fetch(), pasando un objeto Options con un parámetro de método:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Las peticiones POST y PUT suelen tener un cuerpo de petición que contiene los datos que se enviarán al servidor. Siempre que la propiedad method no sea "GET" o "HEAD" (que no admiten cuerpos de petición), puede especificar un cuerpo de petición estableciendo la propiedad body del objeto Options:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Cuando se especifica un cuerpo de petición, el navegador añade automáticamente una cabecera "Content-Length" apropiada a la petición. Cuando el cuerpo es una cadena, como en el ejemplo anterior, el navegador añade por defecto a la cabecera "Content-Type" "text/ plain;charset=UTF-8". Es posible que tenga que anular este valor predeterminado si especifica un cuerpo de cadena de algún tipo más específico, como "text/html" o "application/json":</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La propiedad body del objeto fetch() options no tiene por qué ser una cadena. Si tiene datos binarios en un array tipado o un objeto DataView o un ArrayBuffer, puede establecer la propiedad body a ese valor y especificar una cabecera "Content- Type" apropiada. Si tiene datos binarios en forma de Blob, puede simplemente establecer body al Blob. Los Blobs tienen una propiedad type que especifica su tipo de contenido, y el valor de esta propiedad se utiliza como valor por defecto de la cabecera "Content-Type".</p>
    <p>Con las peticiones POST, es algo común pasar un conjunto de parámetros nombre/valor en el cuerpo de la petición (en lugar de codificarlos en la parte de consulta de la URL). Hay dos formas de hacerlo:</p>
    <ul>
      <li class="font-normal">Con las peticiones POST, es algo común pasar un conjunto de parámetros nombre/valor en el cuerpo de la petición (en lugar de codificarlos en la parte de consulta de la URL). Hay dos formas de hacerlo:</li>
      <li class="font-normal">Si, por el contrario, especifica los nombres y valores de los parámetros con un objeto FormData, el cuerpo utilizará una codificación multiparte más detallada y "Content-Type" se establecerá como "multipart/form-data; boundary=..." con una cadena límite única que coincida con el cuerpo. El uso de un objeto FormData es particularmente útil cuando los valores que desea cargar son largos, o son objetos File o Blob que pueden tener cada uno su propio "Content-Type". Los objetos FormData se pueden crear e inicializar con valores pasando un elemento &lt;form> al constructor FormData(). Pero también se pueden crear cuerpos de petición "multipart/form-data" invocando al constructor FormData() sin argumentos e inicializando los pares nombre/valor que representa con los métodos set() y append().</li>
    </ul>
    <p class="title-article text-left">Carga de archivos con fetch()</p>
    <p>Cargar archivos desde el ordenador de un usuario a un servidor web es una tarea común y puede llevarse a cabo utilizando un objeto FormData como cuerpo de la petición. Una forma común de obtener un objeto File es mostrar un elemento &lt;input type="file"> en su página web y escuchar eventos "change" en ese elemento. Cuando se produce un evento "change", el array files del elemento input debe contener al menos un objeto File. Los objetos File también están disponibles a través de la API HTML drag-and-drop. Esta API no está cubierta en este libro, pero puedes obtener archivos de la matriz dataTransfer.files del objeto de evento pasado a un escuchador de eventos para eventos "drop".</p>
    <p>Recuerda también que los objetos File son un tipo de Blob, y a veces puede ser útil cargar Blobs. Supongamos que has escrito una aplicación web que permite al usuario crear dibujos en un elemento &lt;canvas>. Puede cargar los dibujos del usuario como archivos PNG con código como el siguiente:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Solicitudes de origen cruzado</p>
    <p>Las aplicaciones web suelen utilizar fetch() para solicitar datos a su propio servidor web. Este tipo de peticiones se conocen como peticiones del mismo origen porque la URL que se pasa a fetch() tiene el mismo origen (protocolo más nombre de host más puerto) que el documento que contiene el script que realiza la petición.</p>
    <p>Por razones de seguridad, los navegadores web no suelen permitir (aunque hay excepciones para imágenes y scripts) las peticiones de red de origen cruzado. Sin embargo, el uso compartido de recursos entre orígenes, o CORS, permite realizar peticiones seguras entre orígenes. Cuando se utiliza fetch() con una URL de origen cruzado, el navegador añade una cabecera "Origen" a la petición (y no permite que se sobrescriba mediante la propiedad headers) para notificar al servidor web que la petición procede de un documento con un origen diferente. Si el servidor responde a la petición con una cabecera "Access-Control-Allow-Origin" apropiada, entonces se procede con la petición. En caso contrario, si el servidor no permite explícitamente la solicitud, se rechaza la Promise devuelta por fetch().</p>
    <p class="title-article text-left">Abortar una solicitud</p>
    <p>A veces es posible que desee abortar una solicitud fetch() que ya ha emitido, tal vez porque el usuario ha pulsado un botón Cancelar o porque la solicitud está tardando demasiado. La API fetch permite abortar peticiones mediante las clases AbortController y AbortSig- nal. (Estas clases definen un mecanismo de interrupción genérico que también pueden utilizar otras API).</p>
    <p>Si desea tener la opción de abortar una petición fetch(), cree un objeto Abort- Controller antes de iniciar la petición. La propiedad signal del objeto controlador es un objeto AbortSignal. Pase este objeto señal como valor de la propiedad signal del objeto options que pase a fetch(). Una vez hecho esto, puede llamar al método abort() del objeto controlador para abortar la petición, lo que hará que cualquier objeto Promise relacionado con la petición fetch sea rechazado con una excepción.</p>
    <p>A continuación se muestra un ejemplo de uso del mecanismo AbortController para imponer un tiempo de espera para las solicitudes de obtención:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Opciones varias de solicitud</p>
    <p>Hemos visto que se puede pasar un objeto Options como segundo argumento a fetch() (o como segundo argumento al constructor Request()) para especificar el método de petición, las cabeceras y el cuerpo de la petición. También admite otras opciones, entre las que se incluyen las siguientes:</p>
    <p><codeinline>cache</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Utilice esta propiedad para anular el comportamiento de caché por defecto del navegador. La caché HTTP es un tema complejo que está más allá del alcance de este libro, pero si sabes algo acerca de cómo funciona, puedes utilizar los siguientes valores legales de caché:</p>
    <p><codeinline>"default"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor especifica el comportamiento predeterminado de la caché. Las respuestas frescas en la caché se sirven directamente desde la caché, y las respuestas obsoletas se revalidan antes de ser servidas.</p>
    <p><codeinline>"no-store"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor hace que el navegador ignore su caché. La caché no se comprueba en busca de coincidencias cuando se realiza la solicitud y no se actualiza cuando llega la respuesta.</p>
    <p><codeinline>"reload"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor indica al navegador que realice siempre una petición de red normal, ignorando la caché. Sin embargo, cuando llega la respuesta, se almacena en la caché.</p>
    <p><codeinline>"no-cache"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este (engañosamente llamado) valor le dice al navegador que no sirva valores frescos de la caché. Los valores frescos o antiguos de la caché se revalidan antes de ser devueltos.</p>
    <p><codeinline>"force-cache"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor indica al navegador que sirva las respuestas de la caché aunque estén obsoletas.</p>
    <p><codeinline>redirect</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9"> Esta propiedad controla cómo maneja el navegador las respuestas de redirección del servidor. Los tres valores legales son:</p>
    <p><codeinline>"follow"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este es el valor por defecto, y hace que el navegador siga las redirecciones automáticamente. Si utiliza este valor por defecto, los objetos Response que obtenga con fetch() nunca deberían tener un estado en el rango 300 a 399.</p>
    <p><codeinline>"error"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor hace que fetch() rechace su Promise devuelta si el servidor devuelve una respuesta de redirección.</p>
    <p><codeinline>"manual"</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este valor significa que usted quiere manejar manualmente las respuestas de redirección, y la Promesa devuelta por fetch() puede resolver a un objeto Respuesta con un estado en el rango 300 a 399. En este caso, tendrá que utilizar la cabecera "Loca- tion" de la Respuesta para seguir manualmente la redirección.</p>
    <p><codeinline>referrer</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Puede establecer esta propiedad a una cadena que contenga una URL relativa para especificar el valor de la cabecera HTTP "Referer" (que históricamente se escribe mal con tres erres en lugar de cuatro). Si establece esta propiedad a una cadena vacía, la cabecera "Referer" se omitirá en la petición.</p>
  </section>
  <section id="11-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.11.2 Eventos enviados por el servidor</h2>
    <p>Una característica fundamental del protocolo HTTP en el que se basa la web es que los clientes inician las peticiones y los servidores responden a ellas. Sin embargo, a algunas aplicaciones web les resulta útil que el servidor les envíe notificaciones cuando se producen eventos. Esto no es algo natural en HTTP, pero la técnica que se ha ideado es que el cliente haga una petición al servidor y luego ni el cliente ni el servidor cierren la conexión. Cuando el servidor tiene algo que comunicar al cliente, escribe datos en la conexión pero la mantiene abierta. El efecto es como si el cliente hiciera una petición a la red y el servidor respondiera de forma lenta y a ráfagas, con pausas significativas entre las ráfagas de actividad. Las conexiones de red de este tipo no suelen permanecer abiertas para siempre, pero si el cliente detecta que la conexión se ha cerrado, puede simplemente hacer otra petición para reabrir la conexión.</p>
    <p>Esta técnica para permitir que los servidores envíen mensajes a los clientes es sorprendentemente eficaz (aunque puede ser costosa en el lado del servidor porque éste debe mantener una conexión activa con todos sus clientes). Dado que es un patrón de programación útil, JavaScript del lado del cliente lo soporta con la API EventSource. Para crear este tipo de conexión de petición de larga duración a un servidor web, simplemente pasa una URL al constructor Even tSource(). Cuando el servidor escribe datos (con el formato adecuado) en la conexión, el objeto EventSource los traduce en eventos que puedes escuchar:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El objeto de evento asociado con un evento de mensaje tiene una propiedad data que contiene la cadena que el servidor envió como carga útil para este evento. El objeto evento también tiene una propiedad type, como todos los objetos evento, que especifica el nombre del evento. El servidor determina el tipo de los eventos que se generan. Si el servidor omite un nombre de evento en los datos que escribe, entonces el tipo de evento por defecto es "mensaje".</p>
    <p>El protocolo Server-Sent Event es sencillo. El cliente inicia una conexión con el servidor (cuando crea el objeto EventSource), y el servidor mantiene esta conexión abierta. Cuando ocurre un evento, el servidor escribe líneas de texto en la conexión. Si se omitieran los comentarios, un evento transmitido por cable podría tener este aspecto:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Existen algunos detalles adicionales en el protocolo que permiten asignar identificadores a los eventos y que permiten a un cliente que se vuelve a conectar indicar al servidor el identificador del último evento que recibió, de modo que el servidor pueda volver a enviar los eventos que se haya perdido. Sin embargo, estos detalles son invisibles para el cliente y no se tratan aquí.</p>
    <p>Una aplicación obvia para los Eventos Enviados por el Servidor es para colaboraciones multiusuario como el chat online. Un cliente de chat puede usar fetch() para enviar mensajes a la sala de chat y suscribirse al flujo de conversaciones con un objeto EventSource. El Ejemplo 15-11 demuestra lo fácil que es escribir un cliente de chat como este con EventSource.</p>
    <p><em>Ejemplo 15-11. Un cliente de chat simple usando EventSource</em></p>
    <pre>
    <code class="language-js"></code></pre>
    <p>El código del lado del servidor para este programa de chat no es mucho más complicado que el código del lado del cliente. El Ejemplo 15-12 es un simple servidor HTTP Node. Cuando un cliente solicita la URL raíz "/", envía el código de cliente de chat mostrado en el Ejemplo 15-11. Cuando un cliente hace una petición GET para la URL "/chat", guarda el objeto respuesta y mantiene esa conexión abierta. Y cuando un cliente hace una petición POST a "/chat", usa el cuerpo de la petición como un mensaje de chat y lo escribe, usando el formato "text/event- stream" a cada uno de los objetos de respuesta guardados. El código del servidor escucha en el puerto 8080, así que después de ejecutarlo con Node, apunta tu navegador a http://localhost:8080 para conectarte y empezar a chatear contigo mismo.</p>
    <p><em>Ejemplo 15-12. Un servidor de chat de Eventos Enviados por el Servidor</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="11-3">
    <h2>15.11.3 WebSockets</h2>
    <p>La API WebSocket es una interfaz sencilla para un complejo y potente protocol de red. Los WebSockets permiten al código JavaScript del navegador intercambiar fácilmente mensajes de texto y binarios con un servidor. Al igual que con los eventos enviados por el servidor, el cliente debe establecer la conexión, pero una vez establecida, el servidor puede enviar mensajes al cliente de forma asíncrona. A diferencia de SSE, los mensajes binarios están soportados, y los mensajes pueden ser enviados en ambas direcciones, no sólo de servidor a cliente.</p>
    <p>El protocolo de red que permite WebSockets es una especie de extensión de HTTP. Aunque la API WebSocket recuerda a los sockets de red de bajo nivel, los puntos finales de conexión no se identifican por dirección IP y puerto. En su lugar, cuando se quiere conectar a un servicio mediante el protocolo WebSocket, se especifica el servicio con una URL, igual que se haría con un servicio web. Sin embargo, las URL de WebSocket empiezan por wss:// en lugar de https://. (Los navegadores suelen restringir los WebSockets para que sólo funcionen en páginas cargadas a través de conexiones seguras https://).</p>
    <p>Para establecer una conexión WebSocket, el navegador establece primero una conexión HTTP y envía al servidor una cabecera Upgrade: websocket solicitando que la conexión pase del protocolo HTTP al protocolo WebSocket. Lo que esto significa es que para utilizar WebSockets en su JavaScript del lado del cliente, necesitará trabajar con un servidor web que también hable el protocolo WebSocket, y necesitará tener código del lado del servidor escrito para enviar y recibir datos utilizando ese protocolo. Si tu servidor está configurado de esta manera, entonces esta sección explicará todo lo que necesitas saber para manejar el lado cliente de la conexión. Si su servidor no soporta el protocolo WebSocket, considere usar Eventos Enviados por el Servidor (§15.11.2) en su lugar.</p>
    <p class="title-article text-left">Creación, conexión y desconexión de WebSockets</p>
    <p>Si desea comunicarse con un servidor habilitado para WebSocket, cree un objeto WebSocket, especificando la URL wss:// que identifica el servidor y el servicio que desea utilizar:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Cuando se crea un WebSocket, el proceso de conexión comienza automáticamente. Pero un WebSocket recién creado no se conectará cuando se devuelva por primera vez.</p>
    <p>La propiedad readyState del socket especifica en qué estado se encuentra la conexión. Esta propiedad puede tener los siguientes valores:</p>
    <p><codeinline>WebSocket.CONNECTING</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket se está conectando.</p>
    <p><codeinline>WebSocket.OPEN</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket está conectado y listo para la comunicación.</p>
    <p><codeinline>WebSocket.CLOSING</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Esta conexión WebSocket se está cerrando.</p>
    <p><codeinline>WebSocket.CLOSED</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Este WebSocket se ha cerrado; no es posible ninguna otra comunicación. Este estado también puede ocurrir cuando falla el intento de conexión inicial.</p>
    <p>Cuando un WebSocket pasa del estado CONNECTING al estado OPEN, lanza un evento "open", y usted puede escuchar este evento estableciendo la propiedad onopen del WebSocket o llamando a addEventListener() en ese objeto.</p>
    <p>Si se produce un error de protocolo o de otro tipo en una conexión WebSocket, el objeto WebSocket lanza un evento "error". Puede definir un controlador con onerror o, alternativamente, utilizar addEventListener().</p>
    <p>Cuando haya terminado con un WebSocket, puede cerrar la conexión llamando al método close() del objeto WebSocket. Cuando un WebSocket cambia al estado CERRADO, dispara un evento "close", y puedes establecer la propiedad onclose para escuchar este evento.</p>
    <p class="title-article text-left">Envío de mensajes a través de un WebSocket</p>
    <p>Para enviar un mensaje al servidor en el otro extremo de una conexión WebSocket, simplemente invoque el método send() del objeto WebSocket. send() espera un único argumento de mensaje, que puede ser una cadena, Blob, ArrayBuffer, matriz tipada u objeto DataView.</p>
    <p>El método send() almacena en búfer el mensaje especificado que se va a transmitir y devuelve antes de que el mensaje se envíe realmente. La propiedad bufferedAmount del objeto WebSocket especifica el número de bytes que están almacenados en el buffer pero que aún no han sido enviados. (Sorprendentemente, los WebSockets no disparan ningún evento cuando este valor llega a 0).</p>
    <p class="title-article text-left">Recepción de mensajes de un WebSocket</p>
    <p>Para recibir mensajes de un servidor a través de un WebSocket, registre un manejador de eventos para los eventos "message" de , bien estableciendo la propiedad onmessage del objeto WebSocket, bien llamando a addEventListener(). El objeto asociado a un evento "message" es una instancia de MessageEvent con una propiedad data que contiene el mensaje del servidor. Si el servidor envió texto codificado en UTF-8, entonces event.data será una cadena conteniendo ese texto.</p>
    <p>Si el servidor envía un mensaje que consiste en datos binarios en lugar de texto, entonces la propiedad data será (por defecto) un objeto Blob representando esos datos. Si prefiere recibir mensajes binarios como ArrayBuffers en lugar de Blobs, establezca la propiedad binaryType del objeto WebSocket a la cadena "arraybuffer".</p>
    <p>Existen varias APIs Web que utilizan objetos MessageEvent para el intercambio de mensajes. Algunas de estas APIs utilizan el algoritmo del clon estructurado (ver "El Algoritmo del Clon Estructurado" en la página 513) para permitir estructuras de datos complejas como carga de mensajes. WebSockets no es una de esas APIs: los mensajes intercambiados a través de un WebSocket son una única cadena de caracteres Unicode o una única cadena de bytes (representada como un Blob o un ArrayBuffer).</p>
    <p class="title-article text-left">Negociación de protocolos</p>
    <p>El protocolo WebSocket permite el intercambio de mensajes de texto y binarios, pero no dice nada en absoluto sobre la estructura o el significado de esos mensajes. Las aplicaciones que utilizan WebSockets deben construir su propio protocolo de comunicación sobre este sencillo mecanismo de intercambio de mensajes. El uso de URLs wss:// ayuda con esto: cada URL tendrá típicamente sus propias reglas sobre cómo deben intercambiarse los mensajes. Si escribes código para conectarte a wss://ejemplo.com/stockticker, entonces probablemente sepas que vas a recibir mensajes sobre los precios de las acciones.</p>
    <p>Sin embargo, los protocolos tienden a evolucionar. Si se actualiza un protocolo hipotético de cotización de acciones, puede definir una nueva URL y conectarse al servicio actualizado como wss://exam ple.com/stockticker/v2. Sin embargo, el versionado basado en URL no siempre es suficiente. Con protocolos complejos que han evolucionado con el tiempo, es posible que acabe con servidores desplegados que admiten varias versiones del protocolo y clientes desplegados que admiten un conjunto diferente de versiones del protocolo.</p>
    <p>Anticipándose a esta situación, el protocolo WebSocket y la API incluyen una función de negociación de protocolo a nivel de aplicación. Cuando se llama al constructor WebSocket(), la URL wss:// es el primer argumento, pero también se puede pasar una matriz de cadenas como segundo argumento. Si hace esto, está especificando una lista de protocolos de aplicación que sabe cómo manejar y pidiendo al servidor que elija uno. Durante el proceso de conexión, el servidor elegirá uno de los protocolos (o fallará con un error si no soporta alguna de las opciones del cliente). Una vez establecida la conexión, la propiedad protocol del objeto WebSocket especifica qué versión de protocolo ha elegido el servidor .</p>
  </section>
  <section id="12" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12 Almacenamiento</h2>
    <p>Las aplicaciones web pueden utilizar las API del navegador para almacenar datos localmente en el ordenador del usuario. Este almacenamiento del lado del cliente sirve para dotar al navegador web de memoria. Las aplicaciones web pueden almacenar las preferencias del usuario, por ejemplo, o incluso guardar su estado completo, de modo que puedan reanudar la navegación exactamente donde la dejó al final de su última visita. El almacenamiento del lado del cliente está segregado por origen, de modo que las páginas de un sitio no pueden leer los datos almacenados por las páginas de otro sitio. Pero dos páginas del mismo sitio pueden compartir el almacenamiento y utilizarlo como mecanismo de comunicación. Por ejemplo, los datos introducidos en un formulario de una página pueden mostrarse en una tabla de otra página. Las aplicaciones web pueden elegir el tiempo de vida de los datos que almacenan: los datos pueden almacenarse temporalmente para que sólo se conserven hasta que se cierre la ventana o salga el navegador, o pueden guardarse en el ordenador del usuario y almacenarse de forma permanente para que estén disponibles meses o años después.</p>
    <p>Existen varias formas de almacenamiento del lado del cliente:</p>
    <p><em>Almacenamiento web</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La API de Almacenamiento Web consiste en los objetos localStorage y sessionStorage, que son esencialmente objetos persistentes que asignan claves de cadena a valores de cadena. Web Storage es muy fácil de usar y resulta adecuado para almacenar grandes (pero no enormes) cantidades de datos.</p>
    <p><em>Cookies</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Las cookies son un viejo mecanismo de almacenamiento del lado del cliente que fue diseñado para ser utilizado por scripts del lado del servidor. Una complicada API de JavaScript hace que las cookies se puedan utilizar en el cliente, pero son difíciles de usar y sólo sirven para almacenar pequeñas cantidades de datos textuales. Además, cualquier dato almacenado como cookie se transmite siempre al servidor con cada petición HTTP, incluso si los datos sólo interesan al cliente.</p>
    <p><em>IndexedDB</em></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">IndexedDB es una API asíncrona para una base de datos de objetos que admite indexación.</p>
    <article>
      <p class="title-article">Almacenamiento, seguridad y privacidad</p>
      <p>Los navegadores web a menudo ofrecen recordar las contraseñas web por ti, y las almacenan de forma segura y encriptada en el dispositivo. Pero ninguna de las formas de almacenamiento de datos del lado del cliente descritas en este capítulo implica cifrado: debes asumir que cualquier cosa que tus aplicaciones web guarden reside en el dispositivo del usuario de forma no cifrada. Por lo tanto, los datos almacenados son accesibles a usuarios curiosos que compartan el acceso al dispositivo y a software malicioso (como spyware) que exista en el dispositivo. Por esta razón, nunca se debe utilizar ninguna forma de almacenamiento del lado del cliente para contraseñas, números de cuentas financieras u otra información sensible similar.</p>
    </article>
  </section>
  <section id="12-1">
    <h2>15.12.1 localStorage y sessionStorage</h2>
    <p>Las propiedades localStorage y sessionStorage del objeto Window hacen referencia a objetos Storage. Un objeto Storage se comporta de forma muy similar a un objeto JavaScript normal, con la salvedad de que:</p>
    <ul>
      <li class="font-normal">Los valores de las propiedades de los objetos Storage deben ser cadenas.</li>
      <li class="font-normal">Las propiedades almacenadas en un objeto Storage persisten. Si establece una propiedad del objeto local- Storage y luego el usuario recarga la página, el valor que guardó en esa propiedad sigue estando disponible para su programa.</li>
    </ul>
    <p>Por ejemplo, puedes utilizar el objeto localStorage de la siguiente manera:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Puede utilizar el operador delete para eliminar propiedades de localStorage y sesionStorage, y puede utilizar un bucle for/in o Object.keys() para enumerar las propiedades de un objeto Storage. Si desea eliminar todas las propiedades de un objeto Storage, llame al método clear():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los objetos de almacenamiento también definen los métodos getItem(), setItem() y deleteItem(), que puede utilizar en lugar del acceso directo a propiedades y el operador delete si lo desea.</p>
    <p>Tenga en cuenta que las propiedades de los objetos Storage sólo pueden almacenar cadenas. Si quieres almacenar y recuperar otro tipo de datos, tendrás que codificarlos y descodificarlos tú mismo.</p>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Duración y alcance del almacenamiento</p>
    <p>La diferencia entre localStorage y sessionStorage tiene que ver con la duración y el alcance del almacenamiento. Los datos almacenados a través de localStorage son permanentes: no caducan y permanecen almacenados en el dispositivo del usuario hasta que una aplicación web los elimina o el usuario pide al navegador (a través de alguna interfaz de usuario específica del navegador) que los elimine.</p>
    <p>localStorage se refiere al origen del documento. Como se explica en "La política del mismo origen" en la página 424, el origen de un documento se define por su protocolo, nombre de host y puerto. Todos los documentos con el mismo origen comparten los mismos datos de localStorage (independientemente del origen de los scripts que realmente acceden a localStorage). Pueden leer los datos de los demás, y pueden sobrescribir los datos de los demás. Pero los documentos con orígenes diferentes nunca pueden leer o sobrescribir los datos de los demás (incluso si ambos están ejecutando un script desde el mismo servidor de terceros).</p>
    <p>Tenga en cuenta que localStorage también depende de la implementación del navegador. Si visitas un sitio con Firefox y luego vuelves a visitarlo con Chrome (por ejemplo), los datos almacenados durante la primera visita no estarán accesibles durante la segunda.</p>
    <p>Los datos almacenados a través de sessionStorage tienen un tiempo de vida diferente al de los datos almacenados a través de localStorage: tienen el mismo tiempo de vida que la ventana de nivel superior o la pestaña del navegador en la que se está ejecutando el script que los almacenó. Cuando la ventana o pestaña se cierra permanentemente, cualquier dato almacenado a través de sessionStorage se borra. (Ten en cuenta, sin embargo, que los navegadores modernos tienen la capacidad de reabrir las pestañas cerradas recientemente y restaurar la última sesión de navegación, por lo que el tiempo de vida de estas pestañas y su sessionStorage asociado puede ser más largo de lo que parece).</p>
    <p>Al igual que localStorage, sessionStorage se asigna al origen del documento, de modo que documentos con orígenes diferentes nunca compartirán sessionStorage. Pero sessionStorage también se asigna a cada ventana. Si un usuario tiene dos pestañas en el navegador mostrando documentos del mismo origen, esas dos pestañas tienen datos sessionStorage separados: los scripts que se ejecutan en una pestaña no pueden leer o sobrescribir los datos escritos por los scripts en la otra pestaña, incluso si ambas pestañas están visitando exactamente la misma página y están ejecutando exactamente los mismos scripts.</p>
    <p class="title-article text-left">Eventos de almacenamiento</p>
    <p>Cada vez que los datos almacenados en localStorage cambian, el navegador dispara un evento "storage" en cualquier otro objeto Window al que esos datos sean visibles (pero no en el win- dow que hizo el cambio). Si un navegador tiene dos pestañas abiertas a páginas con el mismo origen, y una de esas páginas almacena un valor en localStorage, la otra pestaña recibirá un evento "storage".</p>
    <p>Registre un controlador para los eventos de "almacenamiento", ya sea estableciendo window.onstorage o llamando a window.addEventListener() con el tipo de evento "almacenamiento".</p>
    <p>El objeto de evento asociado a un evento "almacenamiento" tiene algunas propiedades importantes:</p>
    <p><codeinline>key</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El nombre o la clave del elemento que se ha establecido o eliminado. Si se llamó al método clear(), esta propiedad será nula.</p>
    <p><codeinline>newValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Contiene el nuevo valor del elemento, si existe. Si se ha llamado a removeItem(), esta propiedad no estará presente.</p>
    <p><codeinline>oldValue</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Mantiene el valor antiguo de un elemento existente que cambió o fue eliminado. Si se añade una nueva propiedad (sin valor antiguo), esta propiedad no estará presente en el objeto de evento.</p>
    <p><codeinline>storageArea</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El objeto Storage que ha cambiado. Suele ser el objeto localStorage.</p>
    <p><codeinline>url</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La URL (como cadena) del documento cuyo script realizó este cambio de almacenamiento.</p>
    <p>Tenga en cuenta que localStorage y el evento "storage" pueden servir como un mecanismo de difusión por el cual un navegador envía un mensaje a todas las ventanas que están visitando el mismo sitio web. Si un usuario solicita que un sitio web deje de realizar animaciones, por ejemplo, el sitio podría almacenar esa preferencia en localStorage para poder respetarla en futuras visitas. Y al almacenar la preferencia, genera un evento que permite a otras ventanas que muestren el mismo sitio web respetar también la petición.</p>
    <p>Como otro ejemplo, imagine una aplicación web de edición de imágenes que permite al usuario mostrar paletas de herramientas en ventanas separadas. Cuando el usuario selecciona una herramienta, la aplicación utiliza localStorage para guardar el estado actual y generar una notificación a otras ventanas de que se ha seleccionado una nueva herramienta.</p>
  </section>
  <section id="12-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.12.2 Cookies</h2>
    <p>Una cookie es una pequeña cantidad de datos almacenados por el navegador y asociados a una página o sitio web concreto. Las cookies se diseñaron para la programación del lado del servidor y, en el nivel más bajo, se implementan como una extensión del protocolo HTTP. Los datos de las cookies se transmiten automáticamente entre el navegador y el servidor web, por lo que los scripts del lado del servidor pueden leer y escribir valores de cookies almacenados en el cliente. Esta sección demuestra cómo los scripts del lado del cliente también pueden manipular cookies utilizando la propiedad cookie del objeto Document.</p>
    <article>
      <p class="title-article">¿Por qué "Cookie"?</p>
      <p>El nombre "cookie" no tiene mucho significado, pero no se utiliza sin premeditación. En los anales de la historia de la informática, el término "cookie" o "cookie mágica" se ha utilizado para referirse a un pequeño fragmento de datos, en particular un fragmento de datos privilegiados o secretos, similares a una contraseña, que prueban la identidad o permiten el acceso. En JavaScript, las cookies se utilizan para guardar el estado y pueden establecer una especie de identidad para un navegador web. Las cookies en JavaScript no utilizan ningún tipo de criptografía, sin embargo, y no son seguras de ninguna manera (aunque transmitirlas a través de una conexión https: ayuda).</p>
    </article>
    <p>La API para manipular cookies es antigua y críptica. No hay métodos implicados: las cookies se consultan, establecen y eliminan leyendo y escribiendo la propiedad cookie del objeto Document utilizando cadenas con un formato especial. El tiempo de vida y el alcance de cada cookie pueden especificarse individualmente con atributos de cookie. Estos atributos también se especifican con cadenas especialmente formateadas en la misma propiedad cookie.</p>
    <p>Las subsecciones siguientes explican cómo consultar y establecer los valores y atributos de las cookies.</p>
    <p class="title-article text-left">Galletas de lectura</p>
    <p>Cuando se lee la propiedad document.cookie, devuelve una cadena que contiene todas las cookies que se aplican al documento actual. La cadena es una lista de pares nombre/valor separados entre sí por un punto y coma y un espacio. El valor de la cookie es sólo el valor en sí mismo y no incluye ninguno de los atributos que puedan estar asociados a esa cookie. (Hablaremos de los atributos más adelante.) Para hacer uso de la propiedad docu ment.cookie, normalmente debe llamar al método split() para dividirla en pares nombre/valor individuales.</p>
    <p>Una vez que haya extraído el valor de una cookie de la propiedad cookie, debe interpretar ese valor basándose en cualquier formato o codificación que haya utilizado el creador de la cookie. Por ejemplo, puede pasar el valor de la cookie a decodeURIComponent() y luego a JSON.parse().</p>
    <p>El código que sigue define una función getCookie() que analiza la propiedad docu ment.cookie y devuelve un objeto cuyas propiedades especifican los nombres y valores de las cookies del documento:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p class="title-article text-left">Galletas de lectura</p>
    <p>Atributos de las cookies: vida útil y alcance</p>
    <p>Además de un nombre y un valor, cada cookie tiene atributos opcionales que controlan su duración y alcance. Antes de describir cómo establecer cookies con JavaScript, debemos explicar los atributos de las cookies.</p>
    <p>Las cookies son transitorias por defecto; los valores que almacenan duran lo que dura la sesión del navegador web, pero se pierden cuando el usuario sale del navegador. Si desea que una cookie dure más allá de una única sesión de navegación, debe indicar al navegador cuánto tiempo (en segundos) desea que retenga la cookie especificando un atributo max-age. Si especifica un tiempo de vida, el navegador almacenará las cookies en un archivo y las borrará sólo cuando caduquen.</p>
    <p>La visibilidad de las cookies está determinada por el origen del documento, como ocurre con localStorage y sessionStorage, pero también por la ruta del documento. Este ámbito es configurable a través de los atributos de cookie path y domain. Por defecto, una cookie está asociada con, y accesible a, la página web que la creó y cualquier otra página web en el mismo directorio o cualquier subdirectorio de ese directorio. Si la página web example.com/catalog/index.html crea una cookie, por ejemplo, esa cookie también es visible para example.com/catalog/order.html y exam.com/catalog/widgets/index.html, pero no es visible para example.com/about.html.</p>
    <p>Este comportamiento de visibilidad por defecto es a menudo exactamente lo que usted desea. A veces, sin embargo, querrá utilizar los valores de las cookies en todo el sitio web, independientemente de la página que cree la cookie. Por ejemplo, si el usuario introduce su dirección de correo en un formulario de una página, es posible que desee guardar esa dirección para utilizarla como predeterminada la próxima vez que vuelva a la página y también como predeterminada en un formulario no relacionado de otra página en el que se le pida que introduzca una dirección de facturación. Para permitir este uso, especifique una ruta para la cookie. Entonces, cualquier página web del mismo servidor web cuya URL comience con el prefijo de ruta que ha especificado puede compartir la cookie. Por ejemplo, si una cookie establecida por example.com/catalog/widgets/index.html tiene su ruta establecida en "/catalog", esa cookie también es visible para example.com/catalog/order.html. O, si la ruta se establece en "/", la cookie es visible para cualquier página en el dominio example.com, dando a la cookie un alcance como el de localStorage.</p>
    <p>Por defecto, las cookies se clasifican según el origen del documento. Sin embargo, los sitios web grandes pueden querer que las cookies se compartan entre subdominios. Por ejemplo, el servidor de order.example.com puede necesitar leer valores de cookies establecidos desde catalog.example.com. Aquí es donde entra en juego el atributo de dominio. Si una cookie creada por una página en catalog.example.com establece su atributo path en "/" y su atributo domain en ".example.com", esa cookie estará disponible para todas las páginas web en catalog.example.com, pedidos.example.com y cualquier otro servidor en el dominio example.com. Tenga en cuenta que no puede establecer el dominio de una cookie en un dominio que no sea el dominio principal de su servidor.</p>
    <p>El último atributo de las cookies es un atributo booleano llamado secure que especifica cómo se transmiten los valores de las cookies a través de la red. Por defecto, las cookies son inseguras, lo que significa que se transmiten a través de una conexión HTTP normal e insegura. Sin embargo, si una cookie está marcada como segura, sólo se transmite cuando el navegador y el servidor están conectados a través de HTTPS u otro protocolo seguro.</p>
    <article>
      <p class="title-article">Limitaciones de las cookies</p>
      <p>Las cookies están pensadas para almacenar pequeñas cantidades de datos mediante scripts en el servidor, y esos datos se transfieren al servidor cada vez que se solicita una URL relevante. La norma que define las cookies anima a los fabricantes de navegadores a permitir un número ilimitado de cookies de tamaño ilimitado, pero no exige que los navegadores retengan más de 300 cookies en total, 20 cookies por servidor web o 4 KB de datos por cookie (tanto el nombre como el valor cuentan para este límite de 4 KB). En la práctica, los navegadores permiten muchas más de 300 cookies en total, pero es posible que algunos sigan aplicando el límite de 4 KB.</p>
    </article>
    <p class="title-article text-left">Almacenar cookies</p>
    <p>Para asociar un valor de cookie transitorio al documento actual, basta con establecer el parámetro a una cadena name=value. Por ejemplo:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La próxima vez que lea la propiedad cookie, el par nombre/valor almacenado se incluirá en la lista de cookies del documento. Los valores de las cookies no pueden incluir puntos y comas ni espacios en blanco. Por esta razón, es posible que desee utilizar la función global del núcleo Java Script encodeURIComponent() para codificar el valor antes de almacenarlo en la cookie. Si hace esto, tendrá que usar la función correspondiente decodeURICompo nent() cuando lea el valor de la cookie.</p>
    <p>Una cookie escrita con un simple par nombre/valor dura toda la sesión de navegación actual, pero se pierde cuando el usuario sale del navegador. Para crear una cookie que pueda durar a través de las sesiones del navegador, especifique su tiempo de vida (en segundos) con un atributo max-age. Puede hacer esto estableciendo la propiedad cookie a una cadena de la forma: name=value; max- age=seconds. La siguiente función establece una cookie con un atributo opcional max-age:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>De forma similar, puede establecer los atributos de ruta y dominio de una cookie añadiendo cadenas de la forma ;ruta=valor o ;dominio=valor a la cadena que estableció en la propiedad docu ment.cookie. Para establecer la propiedad secure, simplemente añada ;secure.</p>
    <p>Para cambiar el valor de una cookie, establezca su valor de nuevo utilizando el mismo nombre, ruta y dominio junto con el nuevo valor. Puede cambiar el tiempo de vida de una cookie cuando cambie su valor especificando un nuevo atributo max-age.</p>
    <p>Para eliminar una cookie, configúrela de nuevo utilizando el mismo nombre, ruta y dominio, especificando un valor arbitrario (o vacío) y un atributo max-age de 0.</p>
  </section>
  <section id="12-3">
    <h2>15.12.3 IndexedDB</h2>
    <p>Tradicionalmente, la arquitectura de las aplicaciones web se ha basado en HTML, CSS y JavaScript en el cliente y una base de datos en el servidor. Por tanto, puede que te sorprenda saber que la plataforma web incluye una sencilla base de datos de objetos con una API JavaScript para almacenar de forma persistente objetos JavaScript en el ordenador del usuario y recuperarlos cuando sea necesario.</p>
    <p>IndexedDB es una base de datos de objetos, no una base de datos relacional, y es mucho más simple que las bases de datos que soportan consultas SQL. Sin embargo, es más potente, eficiente y robusta que el almacenamiento clave/valor proporcionado por localStorage. Al igual que el localStorage, las bases de datos IndexedDB tienen como ámbito el origen del documento que las contiene: dos páginas web con el mismo origen pueden acceder a los datos de la otra, pero las páginas web de orígenes diferentes no pueden.</p>
    <p>Cada origen puede tener cualquier número de bases de datos IndexedDB. Cada una tiene un nombre que debe ser único dentro del origen. En la API IndexedDB, una base de datos es simplemente una colección de almacenes de objetos con nombre. Como su nombre indica, un almacén de objetos almacena objetos. Los objetos se serializan en el almacén de objetos utilizando el algoritmo de clonación estructurada (véase "El algoritmo de clonación estructurada" en la página 513), lo que significa que los objetos almacenados pueden tener propiedades cuyos valores sean Mapas, Conjuntos o matrices tipadas. Cada objeto debe tener una clave que permita ordenarlo y recuperarlo del almacén. Las claves deben ser únicas -dos objetos del mismo almacén no pueden tener la misma clave- y deben tener un orden natural para que puedan ordenarse. Cadenas, números y Los objetos de fecha son claves válidas. Una base de datos IndexedDB puede generar automáticamente una clave única para cada objeto que inserte en la base de datos. Sin embargo, a menudo los objetos que se insertan en un almacén de objetos ya tienen una propiedad que puede utilizarse como clave. En este caso, se especifica una "ruta de clave" para esa propiedad cuando se crea el almacén de objetos. Conceptualmente, una ruta de clave es un valor que indica a la base de datos cómo extraer la clave de un objeto.</p>
    <p>Además de recuperar objetos de un almacén de objetos por su valor de clave principal, es posible que desee poder buscar basándose en el valor de otras propiedades del objeto. Para poder hacer esto, puedes definir cualquier número de índices en el almacén de objetos. (La capacidad de indexar un almacén de objetos explica el nombre "IndexedDB".) Cada índice define una clave secundaria para los objetos almacenados. Estos índices no suelen ser únicos, y varios objetos pueden coincidir con un mismo valor de clave.</p>
    <p>IndexedDB ofrece garantías de atomicidad: las consultas y actualizaciones de la base de datos se agrupan dentro de una transacción, de modo que todas tienen éxito juntas o todas fallan juntas y nunca dejan la base de datos en un estado indefinido, parcialmente actualizado. Las transacciones en IndexedDB son más sencillas que en muchas API de bases de datos; volveremos a mencionarlas más adelante.</p>
    <p>Conceptualmente, la API IndexedDB es bastante sencilla. Para consultar o actualizar una base de datos, primero se abre la base de datos deseada (especificándola por su nombre). A continuación, se crea un objeto de transacción y se utiliza dicho objeto para buscar el almacén de objetos deseado dentro de la base de datos, también por su nombre. Por último, se busca un objeto llamando al método get() del almacén de objetos o se almacena un nuevo objeto llamando a put() (o llamando a add(), si se quiere evitar sobrescribir objetos existentes).</p>
    <p>Si desea buscar los objetos de un rango de claves, cree un objeto IDBRange que especifique los límites superior e inferior del rango y páselo a los métodos getAll() o openCursor() del almacén de objetos.</p>
    <p>Si desea realizar una consulta utilizando una clave secundaria, busque el índice con nombre del almacén de objetos y, a continuación, llame a los métodos get(), getAll() o openCursor() del objeto índice, pasándole una única clave o un objeto IDBRange.</p>
    <p>Esta simplicidad conceptual de la API IndexedDB se complica, sin embargo, por el hecho de que la API es asíncrona (para que las aplicaciones web puedan utilizarla sin bloquear el hilo principal de la interfaz de usuario del navegador). IndexedDB se definió antes de que las promesas estuvieran ampliamente soportadas, por lo que la API está basada en eventos en lugar de en promesas, lo que significa que no funciona con async y await.</p>
    <p>La creación de transacciones y la consulta de almacenes de objetos e índices son operaciones síncronas. Pero abrir una base de datos, actualizar un almacén de objetos y consultar un almacén o índice son operaciones asíncronas. Todos estos métodos asíncronos devuelven inmediatamente un objeto de petición. El navegador lanza un evento de éxito o error en el objeto request cuando la petición tiene éxito o falla, y puedes definir manejadores con las propiedades onsuccess y onerror. Dentro de un manejador onsuccess, el resultado de la operación está disponible como propiedad de resultado del objeto de solicitud. Otro evento útil es el evento "completo" que se envía a los objetos de transacción cuando una transacción se ha completado con éxito.</p>
    <p>Una característica conveniente de esta API asíncrona es que simplifica la gestión de transacciones. La API IndexedDB obliga a crear un objeto de transacción p a r a obtener el almacén de objetos sobre el que realizar consultas y actualizaciones. En una API sincrónica, se esperaría marcar explícitamente el final de la transacción llamando a un método commit(). Pero con IndexedDB, las transacciones se consignan automáticamente (si no se cancelan explícitamente) cuando todos los controladores de eventos onsuccess se han ejecutado y no hay más peticiones asíncronas pendientes que hagan referencia a esa transacción.</p>
    <p>Hay un evento más que es importante para la API de IndexedDB. Cuando abres una base de datos por primera vez, o cuando incrementas el número de versión de una base de datos existente, IndexedDB lanza un evento "upgradeneed" en el objeto request devuelto por la llamada indexedDB.open(). El trabajo del manejador de eventos "upgradeneeded" es definir o actualizar el esquema para la nueva base de datos (o la nueva versión de la base de datos existente). Para bases de datos IndexedDB, esto significa crear almacenes de objetos y definir índices en esos almacenes de objetos. De hecho, la única vez que la API IndexedDB permite crear un almacén de objetos o un índice es en respuesta a un evento "upgradenee- ded".</p>
    <p>Con esta visión general de IndexedDB en mente, debería ser capaz de entender el Ejemplo 15-13. Este ejemplo utiliza IndexedDB para crear y consultar una base de datos que mapea los códigos postales de EE.UU. con las ciudades de EE.UU. Este ejemplo utiliza IndexedDB para crear y consultar una base de datos que mapea códigos postales de EE.UU. con ciudades de EE.UU. Demuestra muchas, aunque no todas, de las características básicas de IndexedDB. Demuestra muchas, pero no todas, las características básicas de IndexedDB. El ejemplo 15-13 es largo, pero está bien comentado.</p>
    <p><em>Ejemplo 15-13. Una base de datos IndexedDB de códigos postales de EE.UU.</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="13" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13 Hilos de trabajo y mensajería</h2>
    <p>Una de las características fundamentales de JavaScript es que es monohilo: un navegador nunca ejecutará dos manejadores de eventos al mismo tiempo, y nunca activará un temporizador mientras se esté ejecutando un manejador de eventos, por ejemplo. Las actualizaciones concurrentes del estado de la aplicación o del documento simplemente no son posibles, y los programadores del lado del cliente no necesitan pensar en la programación concurrente, ni siquiera entenderla. Un corolario es que las funciones JavaScript del lado del cliente no deben ejecutarse demasiado tiempo; de lo contrario, atascarán el bucle de eventos y el navegador web dejará de responder a la entrada del usuario. Esta es la razón por la que fetch() es una función asíncrona, por ejemplo.</p>
    <p>Los navegadores web relajan cuidadosamente el requisito de un único hilo con la clase Worker: las instancias de esta clase representan hilos que se ejecutan simultáneamente con el hilo principal y el bucle de eventos. Los trabajadores viven en un entorno de ejecución autónomo con un objeto global completamente independiente y sin acceso a los objetos Window o Docu- ment. Los Workers sólo pueden comunicarse con el hilo principal mediante el paso asíncrono de mensajes. Esto significa que las modificaciones concurrentes del DOM siguen siendo imposibles, pero también significa que puedes escribir funciones de larga duración que no bloqueen el bucle de eventos y cuelguen el navegador. Crear un nuevo trabajador no es una operación pesada como abrir una nueva ventana del navegador, pero los trabajadores tampoco son "fibras" de peso mosca, y no tiene sentido crear nuevos trabajadores para realizar operaciones triviales. Las aplicaciones web complejas pueden encontrar útil crear decenas de trabajadores, pero es poco probable que una aplicación con cientos o miles de trabajadores sea práctica.</p>
    <p>Los workers son útiles cuando tu aplicación necesita realizar tareas computacionalmente intensivas, como el procesamiento de imágenes. El uso de un worker desplaza este tipo de tareas del hilo principal para que el navegador no deje de responder. Además, los workers ofrecen la posibilidad de dividir el trabajo entre varios subprocesos. Pero los workers también son útiles cuando tienes que realizar frecuentemente cálculos moderadamente intensivos. Supongamos, por ejemplo, que estás implementando un sencillo editor de código en el navegador y quieres incluir resaltado de sintaxis. Para que el resaltado sea correcto, tienes que analizar el código en cada pulsación de tecla. Pero si lo haces en el hilo principal, es probable que el código de análisis impida que los controladores de eventos que responden a las pulsaciones de teclas del usuario se ejecuten con prontitud y la experiencia de escritura del usuario sea lenta.</p>
    <p>Como con cualquier API de hilos, hay dos partes en la API Worker. La primera es el objeto Worker: este es el aspecto que tiene un worker desde el exterior, para el hilo que lo crea. La segunda es el WorkerGlobalScope: este es el objeto global para un nuevo worker, y es lo que un hilo worker parece, por dentro, a sí mismo.</p>
    <p>Las siguientes secciones cubren Worker y WorkerGlobalScope y también explican la API de paso de mensajes que permite a los trabajadores comunicarse con el hilo principal y entre sí. La misma API de comunicación se utiliza para intercambiar mensajes entre un y los elementos &lt;iframe> contenidos en el documento, y esto también se trata en las secciones siguientes.</p>
  </section>
  <section id="13-1">
    <h2>15.13.1 Objetos de trabajo</h2>
    <p>Para crear un nuevo trabajador, llame al constructor Worker(), pasando una URL que especifique el código JavaScript que el trabajador debe ejecutar:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Si especifica una URL relativa, se resuelve en relación a la URL del documento que contiene el script que llamó al constructor Worker(). Si especifica una URL absoluta, debe tener el mismo origen (mismo protocolo, host y puerto) que el documento que la contiene.</p>
    <p>Una vez que tenga un objeto Worker, puede enviarle datos con postMessage(). El valor que pases a postMessage() será copiado utilizando el algoritmo de clonación estructurada (ver "El algoritmo de clonación estructurada" en la página 513), y la copia resultante será entregada al trabajador a través de un evento de mensaje:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Aquí sólo estamos pasando un único mensaje de cadena, pero también puede utilizar objetos, matrices, matrices tipadas, mapas, conjuntos, etc. Puedes recibir mensajes de un trabajador buscando eventos "mensaje" en el objeto Trabajador:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Como todos los destinos de eventos, los objetos Worker definen las funciones addEventListener() y removeEventListener(), y puede utilizarlos en lugar de onmessage.</p>
    <p>Además de postMessage(), los objetos Worker sólo tienen otro método, termi nate(), que fuerza a un hilo worker a dejar de ejecutarse.</p>
  </section>
  <section id="13-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.2 El objeto global en los trabajadores</h2>
    <p>Cuando se crea un nuevo trabajador con el constructor Worker(), se especifica la URL de un archivo de código JavaScript. Ese código se ejecuta en un nuevo entorno de ejecución JavaScript prístino, aislado del script que creó el trabajador. El objeto global para ese nuevo entorno de ejecución es un objeto WorkerGlobalScope. Un WorkerGlobalScope es algo más que el objeto global de JavaScript, pero menos que un objeto Window del lado del cliente.</p>
    <p>El objeto WorkerGlobalScope tiene un método postMessage() y un método onmessage que son iguales que los del objeto Worker pero funcionan en el modo</p>
    <p>dirección opuesta: llamar a postMessage() dentro de un worker genera un evento de mensaje fuera del worker, y los mensajes enviados desde fuera del worker se convierten en eventos y se entregan al manejador onmessage. Debido a que el WorkerGlobalScope es el objeto global para un worker, postMessage() y onmessage parecen una función global y variable global para el código del worker.</p>
    <p>Si pasas un objeto como segundo argumento al constructor Worker(), y si ese objeto tiene una propiedad name, entonces el valor de esa propiedad se convierte en el valor de la propiedad name en el objeto global del worker. Un trabajador puede incluir este nombre en cualquier mensaje que imprima con console.warn() o console.error().</p>
    <p>La función close() permite que un trabajador se termine a sí mismo, y es similar en efecto al método terminate() de un objeto Worker.</p>
    <p>Dado que WorkerGlobalScope es el objeto global para los trabajadores, tiene todas las propiedades del objeto global del núcleo de JavaScript, como el objeto JSON, la función isNaN() y el constructor Date(). Además, sin embargo, WorkerGlobalScope también tiene las siguientes propiedades del objeto Window del lado del cliente:</p>
    <ul>
      <li class="font-normal">self es una referencia al propio objeto global. WorkerGlobalScope no es un objeto Win- dow y no define una propiedad de ventana.</li>
      <li class="font-normal">Los métodos de temporizador setTimeout(), clearTimeout(), setInterval(), y clear Interval().</li>
      <li class="font-normal">Una propiedad de ubicación que describe la URL que se pasó al constructor Worker(). Esta propiedad se refiere a un objeto Location, al igual que la propiedad location de una ventana. El objeto Location tiene las propiedades href, protocol, host, hostname, port, pathname, search y hash. En un trabajador, estas propiedades son de sólo lectura.</li>
      <li class="font-normal">Una propiedad del navegador que hace referencia a un objeto con propiedades como las del objeto Navegador de una ventana. El objeto Navigator de un trabajador tiene las propiedades app Name, appVersion, platform, userAgent y onLine.</li>
      <li class="font-normal">Los métodos habituales de destino de eventos addEventListener() y removeEventLis tener().</li>
    </ul>
    <p>Por último, el objeto WorkerGlobalScope incluye importantes API JavaScript del lado del cliente, como el objeto Console, la función fetch() y la API IndexedDB. Work- erGlobalScope también incluye el constructor Worker(), lo que significa que los hilos worker pueden crear sus propios workers.</p>
  </section>
  <section id="13-3">
    <h2>15.13.3 Importar código a un trabajador</h2>
    <p>Los workers se definieron en los navegadores web antes de que JavaScript tuviera un sistema de módulos, por lo que los workers tienen un sistema único para incluir código adicional. WorkerGlobalScope define importScripts() como una función global a la que todos los workers tienen acceso:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>importScripts() toma uno o más argumentos de URL, cada uno de los cuales debe referirse a un archivo de código JavaScript. Las URL relativas se resuelven en relación con la URL que se pasó al constructor Worker() (no en relación con el documento contenedor). importScripts() carga y ejecuta de forma sincrónica estos archivos uno tras otro, en el orden en que se especificaron. Si la carga de un script causa un error de red, o si la ejecución arroja un error de cualquier tipo, ninguno de los scripts subsiguientes es cargado o ejecutado. Un script cargado con importScripts() puede llamar a su vez a importScripts() para cargar los archivos de los que depende. Tenga en cuenta, sin embargo, que importScripts() no intenta realizar un seguimiento de los scripts que ya se han cargado y no hace nada para evitar los ciclos de dependencia.</p>
    <p>importScripts() es una función síncrona: no retorna hasta que todos los scripts se han cargado y ejecutado. Puede empezar a usar los scripts que ha cargado tan pronto como importScripts() devuelva: no hay necesidad de una llamada de retorno, manejador de eventos, método then() o await. Una vez que se ha interiorizado la naturaleza asíncrona de JavaScript del lado del cliente, resulta extraño volver a la programación simple y síncrona. Pero esa es la belleza de los hilos: se puede utilizar una llamada a una función de bloqueo en un trabajador sin bloquear el bucle de eventos en el hilo principal, y sin bloquear los cálculos que se realizan simultáneamente en otros trabajadores.</p>
    <article>
      <p class="title-article">Módulos en Trabajadores</p>
      <p>Para utilizar módulos en los workers, debes pasar un segundo argumento al constructor Worker(). Este segundo argumento debe ser un objeto con una propiedad type establecida a la cadena "module". Pasar una opción type: "module" al constructor Worker() es muy parecido a usar el atributo type="module" en una etiqueta HTML &lt;script>: significa que el código debe ser interpretado como un módulo y que las declaraciones de importación están permitidas.</p>
      <p>Cuando un trabajador carga un módulo en lugar de un script tradicional, el WorkerGlobalScope no define la función importScripts().</p>
      <p>Tenga en cuenta que a principios de 2020, Chrome es el único navegador que soporta verdaderos módulos y declaraciones de importación en los trabajadores.</p>
    </article>
  </section>
  <section id="13-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.4 Modelo de ejecución de los trabajadores</h2>
    <p>Los hilos de trabajo ejecutan su código (y todos los scripts o módulos importados) de forma sincrónica de arriba a abajo, y luego entran en una fase asincrónica en la que responden a eventos y temporizadores. Si un worker registra un manejador de eventos "mensaje", nunca saldrá mientras exista la posibilidad de que sigan llegando eventos mensaje. Pero si un trabajador no escucha mensajes, se ejecutará hasta que no haya más tareas pendientes (como promesas fetch() y temporizadores) y todas las llamadas de retorno relacionadas con la tarea hayan sido llamadas. Una vez que todos los callbacks registrados han sido llamados, no hay manera de que un trabajador pueda comenzar una nueva tarea, por lo que es seguro para el hilo salir, lo que hará automáticamente. Un worker también puede cerrarse explícitamente llamando a la función global close(). Ten en cuenta que no hay propiedades o métodos en el objeto Worker que especifiquen si un hilo worker sigue ejecutándose o no, por lo que los workers no deberían cerrarse a sí mismos sin coordinarlo de alguna manera con su hilo padre.</p>
    <p class="title-article text-left">Errores en los trabajadores</p>
    <p>Si se produce una excepción en un trabajador y no es capturada por ninguna cláusula catch, se lanza un evento "error" en el objeto global del trabajador. Si este evento es manejado y el manejador llama al método preventDefault() del objeto evento, la propagación del error termina. En caso contrario, el evento "error" se dispara sobre el objeto Worker. Si se llama allí a preventDefault(), la propagación termina. En caso contrario, se imprime un mensaje de error en la consola del desarrollador y se invoca al manejador onerror (§15.1.7) del objeto Window.</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Al igual que windows, los workers pueden registrar un manejador para ser invocado cuando una Promise es rechazada y no hay una función .catch() para manejarla. Dentro de un worker puedes detectar esto definiendo una función self.onunhandledrejection o utilizando addEventLis tener() para registrar un manejador global para eventos "unhandledrejection". El objeto de evento pasado a este manejador tendrá una propiedad promise cuyo valor es el objeto Promise que rechazó y una propiedad reason cuyo valor es lo que se habría pasado a una función .catch().</p>
  </section>
  <section id="13-5">
    <h2>15.13.5 postMessage(), MessagePorts y MessageChannels</h2>
    <p>El método postMessage() del objeto Worker y la función global postMesage() definida dentro de un worker funcionan invocando los métodos postMessage() de un par de objetos MessagePort que se crean automáticamente junto con el worker. JavaScript del lado del cliente no puede acceder directamente a estos objetos MessagePort creados automáticamente, pero puede crear nuevos pares de puertos conectados con el constructor MessageChannel():</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Un MessageChannel es un objeto con propiedades port1 y port2 que hacen referencia a un par de objetos MessagePort conectados. Un MessagePort es un objeto con un método postMessage() y una propiedad manejadora de eventos onmessage. Cuando se llama a postMessage() en un puerto de un par conectado, se dispara un evento "mensaje" en el otro puerto del par. Puedes recibir estos eventos "mensaje" estableciendo la propiedad onmessage o utilizando addEventListener() para registrar un receptor de eventos "mensaje".</p>
    <p>Los mensajes enviados a un puerto se ponen en cola hasta que se define la propiedad onmessage o hasta que se llama al método start() en el puerto. Esto evita que los mensajes enviados por un extremo del canal sean perdidos por el otro extremo. Si utiliza addEventListener() con un MessagePort, no olvide llamar a start() o puede que nunca vea un mensaje entregado.</p>
    <p>Todas las llamadas a postMessage() que hemos visto hasta ahora han tomado un único argumento de mensaje. Pero el método también acepta un segundo argumento opcional. Este segundo argumento es un array de elementos que van a ser transferidos al otro extremo del canal en lugar de tener una copia enviada a través del canal. Los valores que pueden ser transferidos en lugar de copiados son MessagePorts y ArrayBuffers. (Algunos navegadores también implementan otros tipos transferibles, como ImageBitmap y OffscreenCanvas. Sin embargo, éstos no están soportados universalmente y no se tratan en este libro). Si el primer argumento de postMessage() incluye un MessagePort (anidado en cualquier lugar dentro del objeto mensaje), entonces ese MessagePort debe aparecer también en el segundo argumento. Si hace esto, entonces el MessagePort estará disponible para el otro extremo del canal e inmediatamente dejará de ser funcional en su extremo. Supongamos que ha creado un trabajador y desea tener dos canales para comunicarse con él: un canal para el intercambio de datos ordinarios y un canal para mensajes de alta prioridad. En el hilo principal, puede crear un MessageChannel, luego llamar a postMessage() en el trabajador para pasarle uno de los MessagePorts:</p>
    <pre>
    <code class="language-js"></code></pre>
    <p>Los MessageChannels también son útiles si creas dos workers y quieres permitirles comunicarse directamente entre ellos en lugar de requerir código en el hilo principal para retransmitir mensajes entre ellos.</p>
    <p>El otro uso del segundo argumento de postMessage() es transferir ArrayBuffers entre workers sin tener que copiarlos. Esta es una importante mejora de rendimiento para grandes ArrayBuffers como los utilizados para contener datos de imagen. Cuando un ArrayBuffer se transfiere a través de un MessagePort, el ArrayBuffer se vuelve inutilizable en el hilo original, por lo que no hay posibilidad de acceso concurrente a su contenido. Si el primer argumento de postMessage() incluye un ArrayBuffer, o cualquier valor (como un array tipado) que tenga un ArrayBuffer, entonces ese buffer puede aparecer como un elemento de array en el segundo argumento de postMessage(). Si aparece, se transferirá sin copiar. Si no, entonces el ArrayBuffer será copiado en lugar de transferido. El Ejemplo 15-14 demostrará el uso de esta técnica de transferencia con ArrayBuffers.</p>
  </section>
  <section id="13-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.13.6 Mensajería entre orígenes con postMessage()</h2>
    <p>Hay otro caso de uso para el método postMessage() en JavaScript del lado del cliente. Se trata de ventanas en lugar de trabajadores, pero hay suficientes similitudes entre los dos casos que vamos a describir el método postMessage() del objeto Window aquí.</p>
    <p>Cuando un documento contiene un elemento &lt;iframe>, ese elemento actúa como una ventana incrustada pero independiente. El objeto Element que representa el &lt;iframe> tiene una propiedad con tentWindow que es el objeto Window para el documento incrustado. Y para los scripts que se ejecutan dentro de ese iframe anidado, la propiedad window.parent hace referencia al objeto Window que lo contiene. Cuando dos ventanas muestran documentos con el mismo origen, los scripts de cada una de esas ventanas tienen acceso al contenido de la otra ventana. Pero cuando los documentos tienen orígenes diferentes, la política del mismo origen del navegador impide que el JavaScript de una ventana acceda al contenido de otra ventana.</p>
    <p>Para workers, postMessage() proporciona una forma segura para que dos hilos independientes se comuniquen sin compartir memoria. Para ventanas, postMessage() proporciona una forma controlada para que dos orígenes independientes intercambien mensajes de forma segura. Incluso si la política del mismo origen impide que tu script vea el contenido de otra ventana, aún puede llamar a postMessage() en esa ventana, y al hacerlo se disparará un evento "mensaje" en esa ventana, donde podrá ser visto por los manejadores de eventos en los scripts de esa ventana.</p>
    <p>Sin embargo, el método postMessage() de una Ventana es un poco diferente al método postMessage() de un Trabajador. El primer argumento sigue siendo un mensaje arbitrario que será copiado por el algoritmo de clonado estructurado. Pero el segundo argumento opcional que lista los objetos a ser transferidos en lugar de copiados se convierte en un tercer argumento opcional. El método postMessage() de una ventana toma una cadena como segundo argumento obligatorio. Este segundo argumento debe ser un origen (un protocolo, nombre de host y puerto opcional) que especifique quién se espera que reciba el mensaje. Si pasas la cadena "https://good.example.com" como segundo argumento, pero la ventana en la que estás enviando el mensaje en realidad contiene contenido de "https://malware.exam- ple.com", entonces el mensaje que has enviado no será entregado. Si estás dispuesto a enviar tu mensaje a contenidos de cualquier origen, entonces puedes pasar el comodín "*" como segundo argumento.</p>
    <p>El código JavaScript que se ejecuta dentro de una ventana o &lt;iframe> puede recibir mensajes enviados a esa ventana o marco definiendo la propiedad onmessage de esa ventana o llamando a addEventListener() para los eventos "message". Al igual que con los workers, cuando se recibe un evento "message" para una ventana, la propiedad data del objeto de evento es el mensaje que se envió. Sin embargo, además, los eventos "mensaje" enviados a ventanas también definen las propiedades source y origin. La propiedad source especifica el objeto Window que envió el evento, y puede utilizar event.source.postMessage() para enviar una respuesta. La propiedad origin especifica el origen del contenido en la ventana fuente. Esto no es algo que el emisor del mensaje pueda falsificar, y cuando recibas un evento "mensaje", normalmente querrás verificar que proviene de un origen que esperas.</p>
  </section>
  <section id="14">
    <h2>15.16 Ejemplo: El conjunto de Mandelbrot</h2>
    <p>Este capítulo sobre JavaScript del lado del cliente culmina con un largo ejemplo que demuestra el uso de workers y mensajería para paralelizar tareas de cálculo intensivo. Pero está escrito para ser una aplicación web atractiva, del mundo real y también demuestra una serie de otras APIs demostradas en este capítulo, incluyendo la gestión de la historia, el uso de la clase ImageData con un &lt;canvas>, y el uso del teclado, puntero, y eventos de cambio de tamaño. También demuestra importantes características básicas de JavaScript, incluyendo generadores y un uso sofisticado de Promises.</p>
    <p>El ejemplo es un programa para visualizar y explorar el conjunto de Mandelbrot, un fractal complejo que incluye bellas imágenes como la que se muestra en la Figura 15- 16.</p>
    <figure id="figure15-16">
      <img src="/public/javascript/capitulo-15/figure15-16.avif" alt="imagen de consola">
      <figcaption>Figura 15-16. Una porción del conjunto de Mandelbrot</figcaption>
    </figure>
    <p>El conjunto de Mandelbrot se define como el conjunto de puntos del plano complejo que, cuando se someten a un proceso repetido de multiplicación y suma compleja, producen un valor cuya magnitud permanece acotada. Los contornos del conjunto son sorprendentemente complejos, y calcular qué puntos son miembros del conjunto y cuáles no lo son exige un gran esfuerzo informático: para producir una imagen de 500×500 del conjunto de Mandelbrot, hay que calcular individualmente la pertenencia de cada uno de los 250.000 píxeles de la imagen. Y para verificar que el valor asociado a cada píxel sigue estando acotado, puede que tenga que repetir el proceso de multiplicación compleja 1.000 veces o más. (Con más iteraciones se obtienen límites más definidos para el conjunto; con menos iteraciones se obtienen límites más difusos). Con hasta 250 millones de pasos de aritmética compleja necesarios para producir una imagen de alta calidad del conjunto de Mandelbrot, se puede entender por qué el uso de trabajadores es una técnica valiosa. El ejemplo 15- 14 muestra el código worker que utilizaremos. Este archivo es relativamente compacto: es sólo el músculo computacional en bruto para el programa más grande. Sin embargo, vale la pena destacar dos cosas:</p>
    <ul>
      <li class="font-normal">El trabajador crea un objeto ImageData para representar la cuadrícula rectangular de píxeles para los que está calculando la pertenencia al conjunto de Mandelbrot. Pero en lugar de almacenar los valores reales de los píxeles en ImageData, utiliza una matriz personalizada para tratar cada píxel como un entero de 32 bits. En esta matriz almacena el número de iteraciones necesarias para cada píxel. Si la magnitud del número complejo calculado para cada píxel es mayor que cuatro, entonces está matemáticamente garantizado que crecerá sin límites a partir de ese momento, y decimos que ha "escapado". Así que el valor que este trabajador devuelve para cada píxel es el número de iteraciones antes de que el valor haya escapado. Le decimos al trabajador el número máximo de iteraciones que debe intentar para cada valor, y los píxeles que alcanzan este número máximo se consideran dentro del conjunto.</li>
      <li class="font-normal">El trabajador transfiere el ArrayBuffer asociado con el ImageData de vuelta al hilo principal para que la memoria asociada a él no tenga que ser copiada.</li>
    </ul>
    <p><em>Ejemplo 15-14. Código de trabajo para calcular las regiones del conjunto de Mandelbrot</em></p>
    <pre>
    <code class="language-js"></code></pre>
    <p>La aplicación de visualización del conjunto de Mandelbrot que utiliza ese código de trabajador se muestra en el Ejemplo 15-15. Ahora que casi has llegado al final de este capítulo, este largo ejemplo es algo así como una experiencia de culminación que reúne una serie de importantes características y APIs del núcleo y del lado del cliente de JavaScript. El código está minuciosamente comentado, y te animo a que lo leas con atención.</p>
    <p><em>Ejemplo 15-15. Una aplicación web para visualizar y explorar el conjunto de Mandelbrot</em></p>
    <pre>
    <code class="language-js"></code></pre>
  </section>
  <section id="15" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15 Resumen y sugerencias de lecturas complementarias</h2>
    <p>Este largo capítulo ha cubierto los fundamentos de la programación JavaScript del lado del cliente:</p>
    <ul>
      <li class="font-normal">Cómo se incluyen los scripts y módulos JavaScript en las páginas web y cómo y cuándo se ejecutan.</li>
      <li class="font-normal">El modelo de programación asíncrona y basada en eventos de JavaScript del lado del cliente.</li>
      <li class="font-normal">El Modelo de Objetos del Documento (DOM) que permite al código JavaScript inspeccionar y modificar el contenido HTML del documento en el que está incrustado. Esta API DOM es el corazón de toda la programación JavaScript del lado del cliente.</li>
      <li class="font-normal">Cómo el código JavaScript puede manipular los estilos CSS que se aplican al contenido dentro del documento.</li>
      <li class="font-normal">Cómo el código JavaScript puede obtener las coordenadas de los elementos del documento en la ventana del navegador y dentro del propio documento.</li>
      <li class="font-normal">Cómo crear "componentes web" de interfaz de usuario reutilizables con JavaScript, HTML y CSS utilizando las API de elementos personalizados y Shadow DOM.</li>
      <li class="font-normal">Cómo mostrar y generar gráficos dinámicamente con SVG y HTML Elemento &lt;canvas>.</li>
      <li class="font-normal">Cómo añadir efectos de sonido con guión (tanto grabados como sintetizados) a tus páginas web.</li>
      <li class="font-normal">Cómo JavaScript puede hacer que el navegador cargue nuevas páginas, retroceda y avance en el historial de navegación del usuario e incluso añada nuevas entradas al historial de navegación.</li>
      <li class="font-normal">Cómo los programas JavaScript pueden intercambiar datos con servidores web utilizando los protocolos HTTP y WebSocket.</li>
      <li class="font-normal">Cómo los programas JavaScript pueden almacenar datos en el navegador del usuario.</li>
      <li class="font-normal">Cómo los programas JavaScript pueden utilizar hilos de trabajo para lograr una forma segura de concurrencia.</li>
    </ul>
    <p>Éste ha sido, con diferencia, el capítulo más largo del libro. Pero no puede ni acercarse a cubrir todas las APIs disponibles para los navegadores web. La plataforma web es extensa y está en constante evolución, y mi objetivo en este capítulo era presentar las API básicas más importantes. Con los conocimientos adquiridos en este libro, estarás bien equipado para aprender y utilizar nuevas API a medida que las necesites. Pero no puedes aprender sobre una nueva API si no sabes que existe, así que las breves secciones que siguen terminan el capítulo con una lista rápida de características de la plataforma web que quizás quieras investigar en el futuro.</p>
  </section>
  <section id="15-1">
    <h2>15.15.1 HTML y CSS</h2>
    <p>La web se basa en tres tecnologías clave: HTML, CSS y JavaScript, y el conocimiento de JavaScript sólo puede llevarte muy lejos como desarrollador web a menos que también desarrolles tu experiencia con HTML y CSS. Es importante saber utilizar Java-Script para manipular elementos HTML y estilos CSS, pero ese conocimiento es mucho más útil si también sabes qué elementos HTML y qué estilos CSS utilizar.</p>
    <p>Así que antes de empezar a explorar más API de JavaScript, te animo a que inviertas algo de tiempo en dominar las demás herramientas de un desarrollador web. Los formularios HTML y los elementos de entrada, por ejemplo, tienen un comportamiento sofisticado que es importante comprender, y los modos de diseño flexbox y grid de CSS son increíblemente potentes.</p>
    <p>Dos temas a los que merece la pena prestar especial atención en este ámbito son la accesibilidad (incluidos los atributos ARIA) y la internacionalización (incluida la compatibilidad con direcciones de escritura de derecha a izquierda).</p>
  </section>
  <section id="15-2" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.2 Rendimiento</h2>
    <p>Una vez que has escrito una aplicación web y la has lanzado al mundo, comienza la interminable búsqueda para hacerla más rápida. Sin embargo, es difícil optimizar cosas que no se pueden medir, por lo que merece la pena familiarizarse con las API de rendimiento. La propiedad performance del objeto ventana es el principal punto de entrada a esta API. Incluye una fuente de tiempo de alta resolución performance.now(), y métodos perfor mance.mark() y performance.measure() para marcar puntos críticos en su código y medir el tiempo transcurrido entre ellos. Al llamar a estos métodos se crean objetos Per- formanceEntry a los que puede acceder con performance.getEntries(). Los navegadores añaden sus propios objetos PerformanceEntry cada vez que el navegador carga una nueva página o recupera un archivo a través de la red, y estos objetos PerformanceEntry creados automáticamente incluyen detalles de tiempo granulares del rendimiento de la red de su aplicación. La clase PerformanceObserver permite especificar una función que se invocará cuando se creen nuevos objetos PerformanceEntry.</p>
  </section>
  <section id="15-3">
    <h2>15.15.3 Seguridad</h2>
    <p>Este capítulo ha introducido la idea general de cómo defenderse contra las vulnerabilidades de seguridad cross-site scripting (XSS) en sus sitios web, pero no hemos entrado en muchos detalles. El tema de la seguridad web es importante, y puede que quiera dedicar algo de tiempo a aprender más sobre él. Además de XSS, merece la pena aprender sobre la cabecera HTTP Content- Security-Policy y entender cómo CSP le permite pedir al navegador web que restrinja las capacidades que concede al código JavaScript. También es importante entender CORS (Cross- Origin Resource Sharing).</p>
  </section>
  <section id="15-4" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.4 WebAssembly</h2>
    <p>WebAssembly (o "wasm") es un formato de código de bytes de máquina virtual de
      bajo nivel diseñado para integrarse bien con los intérpretes de JavaScript de los
      navegadores web. Existen compiladores que permiten compilar programas C, C++ y
      Rust a bytecode WebAssembly y ejecutarlos en navegadores web a una velocidad
      cercana a la nativa, sin romper el sandbox del navegador ni el modelo de seguridad.
      WebAssembly puede exportar funciones que pueden ser invocadas por programas
      JavaScript. Un caso típico de uso de WebAssembly sería compilar la biblioteca
      estándar de compresión zlib en lenguaje C para que el código JavaScript tenga acceso
      a algoritmos de compresión y descompresión de alta velocidad. Más información en
      https://webassembly.org.</p>
  </section>
  <section id="15-5">
    <h2>15.15.5 Más funciones para documentos y ventanas</h2>
    <p>Los objetos Ventana y Documento tienen una serie de características que no se han
      tratado en este capítulo:</p>
    <ul>
      <li class="font-normal">El objeto Window define los métodos alert(), confirm() y prompt() que muestran diálogos modales simples al usuario. Estos métodos bloquean el hilo principal. El método confirm() devuelve de forma sincrónica un valor booleano, y prompt() devuelve de forma sincrónica una cadena de texto introducida por el usuario. No son adecuados para uso productivo, pero pueden ser útiles para proyectos y prototipos sencillos.</li>
      <li class="font-normal">Las propiedades Navegador y Pantalla del objeto Ventana se mencionaron de pasada al principio de este capítulo, pero los objetos Navegador y Pantalla a los que hacen referencia tienen algunas características que no se describieron aquí y que pueden resultarle útiles.</li>
      <li class="font-normal">El método requestFullscreen() de cualquier objeto Element solicita que ese elemento (un elemento &lt;video> o &lt;canvas>, por ejemplo) se muestre en modo de pantalla completa. El método exitFullscreen() del documento vuelve al modo de visualización normal.</li>
      <li class="font-normal">El método requestAnimationFrame() del objeto Window toma una función como argumento y la ejecuta cuando el navegador se prepara para renderizar el siguiente fotograma. Cuando se realizan cambios visuales (especialmente repetidos o animados), envolver el código con una llamada a requestAnimationFrame() puede ayudar a asegurar que los cambios se renderizan sin problemas y de forma optimizada por el navegador.</li>
      <li class="font-normal">Si el usuario selecciona texto dentro de su documento, puede obtener detalles de esa selección con el método getSelection() de Window y obtener el texto seleccionado con getSelection().toString(). En algunos navegadores, navigator.clipboard es un objeto con una API asíncrona para leer y establecer el contenido del sistema portapapeles para permitir interacciones de copiar y pegar con aplicaciones fuera del navegador.</li>
      <li class="font-normal">Una característica poco conocida de los navegadores web es que los elementos HTML con un atributo contente ditable="true" permiten editar su contenido. El método document.exe cCommand() habilita las funciones de edición de texto enriquecido para contenido editable.</li>
      <li class="font-normal">Un MutationObserver permite a JavaScript monitorizar los cambios en, o por debajo de, un elemento específico del documento. Cree un MutationObserver con el constructor MutationOb server(), pasando la función callback que debe ser llamada cuando se realicen cambios. A continuación, llame al método observe() del MutationObserver para especificar qué partes de qué elemento deben ser monitorizadas.</li>
      <li class="font-normal">Un IntersectionObserver permite a JavaScript determinar qué elementos del documento están en la pantalla y cuáles están cerca de estarlo. Resulta especialmente útil para aplicaciones que desean cargar contenido de forma dinámica a medida que el usuario se desplaza.</li>
    </ul>
  </section>
  <section id="15-6" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.6 Eventos</h2>
    <p>La gran cantidad y diversidad de eventos que admite la plataforma web puede resultar desalentadora. En este capítulo se han tratado diversos tipos de eventos, pero aquí te ofrecemos algunos más que pueden resultarte útiles:</p>
    <ul>
      <li class="font-normal">Los navegadores disparan eventos "online" y "offline" en el objeto Window cuando el navegador obtiene o pierde una conexión a Internet.</li>
      <li class="font-normal">Los navegadores disparan un evento "visiblitychange" en el objeto Document cuando un documento se vuelve visible o invisible (normalmente porque un usuario ha cambiado de pestaña). JavaScript puede comprobar document.visibilityState para determinar si su documento es actualmente "visible" u "oculto".</li>
      <li class="font-normal">Los navegadores disponen de una complicada API que permite arrastrar y soltar interfaces de usuario y facilita el intercambio de datos con aplicaciones externas al navegador. Esta API incluye una serie de eventos, como "dragstart", "dragover", "dragend" y "drop". Esta API es complicada de utilizar correctamente, pero útil cuando se necesita. Es una API importante que debes conocer si quieres permitir a los usuarios arrastrar archivos desde su escritorio a tu aplicación web.</li>
      <li class="font-normal">La API de bloqueo del puntero permite a JavaScript ocultar el puntero del ratón y obtener eventos de ratón sin procesar como cantidades de movimiento relativas en lugar de posiciones absolutas en la pantalla. Esto suele ser útil para los juegos. Llame a requestPointerLock() en el elemento al que desea que se dirijan todos los eventos del ratón. Después de hacer esto, los eventos "mousemove" enviados a ese elemento tendrán las propiedades movementX y movementY.</li>
      <li class="font-normal">La API Gamepad añade soporte para mandos de juegos. Utilice navigator.getGame pads() para obtener objetos Gamepad conectados, y escuche los eventos "gamepadconnected" en el objeto Window para ser notificado cuando se conecte un nuevo mando. El objeto Gamepad define una API para consultar el estado actual de los botones del mando.</li>
    </ul>
  </section>
  <section id="15-7">
    <h2>15.15.7 Aplicaciones web progresivas y Service Workers</h2>
    <p>El término Aplicaciones Web Progresivas, o PWA, es una palabra de moda que describe las aplicaciones web que se construyen utilizando algunas tecnologías clave. Una documentación cuidadosa de estas tecnologías clave requeriría un libro propio, y no las he cubierto en este capítulo, pero deberías ser consciente de todas estas APIs. Vale la pena señalar que las API modernas y potentes como éstas están diseñadas normalmente para funcionar sólo en conexiones HTTPS seguras. Los sitios web que aún utilicen URLs http:// no podrán aprovecharlas:</p>
    <ul>
      <li class="font-normal">Un ServiceWorker es un tipo de hilo trabajador con la capacidad de interceptar, inspeccionar y responder a peticiones de red de la aplicación web a la que "sirve". Cuando una aplicación web registra un trabajador de servicio, el código de ese trabajador se vuelve persistente en el almacenamiento local del navegador, y cuando el usuario vuelve a visitar el sitio web asociado, el trabajador de servicio se reactiva. Los service workers pueden almacenar en caché las respuestas de la red (incluidos los archivos de código JavaScript), lo que significa que las aplicaciones web que utilizan service workers pueden instalarse en el ordenador del usuario para un inicio rápido y un uso sin conexión. El Service Worker Cookbook en https://serviceworke.rs es un valioso recurso para aprender sobre service workers y sus tecnologías relacionadas.</li>
      <li class="font-normal">La API de caché está diseñada para ser utilizada por los trabajadores de servicio (pero también está disponible para código JavaScript regu- lar fuera de los trabajadores). Funciona con los objetos Request y Response definidos por la API fetch() e implementa una caché de pares Request/Response. La API de caché permite a un trabajador de servicios almacenar en caché los scripts y otros activos de la aplicación web que sirve y también puede ayudar a permitir el uso sin conexión de la aplicación web (que es particularmente importante para los dispositivos móviles).</li>
      <li class="font-normal">Un manifiesto web es un archivo con formato JSON que describe una aplicación web e incluye un nombre, una URL y enlaces a iconos de distintos tamaños. Si tu aplicación web utiliza un service worker e incluye una etiqueta &lt;link rel="manifest"> que haga referencia a un archivo .web manifest, los navegadores (especialmente los navegadores de dispositivos móviles) pueden ofrecerte la opción de añadir un icono de la aplicación web a tu escritorio o pantalla de inicio.</li>
      <li class="font-normal">La API de notificaciones permite a las aplicaciones web mostrar notificaciones utilizando el sistema de notificaciones nativo del sistema operativo, tanto en dispositivos móviles como de sobremesa. Las notificaciones pueden incluir una imagen y texto, y su código puede recibir un evento si el usuario hace clic en en la notificación. El uso de esta API se complica por el hecho de que primero debe solicitar el permiso del usuario para mostrar notificaciones.</li>
      <li class="font-normal">La API Push permite a las aplicaciones web que disponen de un service worker (y que cuentan con el permiso del usuario) suscribirse a las notificaciones de un servidor y mostrarlas incluso cuando la propia aplicación no se está ejecutando. Las notificaciones Push son habituales en los dispositivos móviles, y la API Push acerca las aplicaciones web a la paridad de prestaciones con las aplicaciones nativas en móviles.</li>
    </ul>
  </section>
  <section id="15-8" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.8 API para dispositivos móviles</h2>
    <p>Hay una serie de API web que son útiles principalmente para aplicaciones web que se ejecutan en dispositivos móviles. (Por desgracia, varias de estas API solo funcionan en dispositivos Android y no en iOS).</p>
    <ul>
      <li class="font-normal">La API de geolocalización permite a JavaScript (con el permiso del usuario) determinar la ubicación física del usuario. Es compatible con dispositivos móviles y de escritorio, incluidos los dispositivos iOS. Utilice navigator.geolocation.getCurrentPosition() para solicitar la posición actual del usuario y utilice navigator.geolocation.watchPosi tion() para registrar una llamada de retorno a la que llamar cuando cambie la posición del usuario.</li>
      <li class="font-normal">El método navigator.vibrate() hace que un dispositivo móvil (pero no iOS) vibre. A menudo esto sólo se permite en respuesta a un gesto del usuario, pero llamar a este método permitirá a su aplicación para proporcionar retroalimentación silenciosa que un gesto ha sido reconocido.</li>
      <li class="font-normal">La API ScreenOrientation permite a una aplicación web consultar la orientación actual de la pantalla de un dispositivo móvil y también bloquearse en la orientación horizontal o vertical.</li>
      <li class="font-normal">Los eventos "devicemotion" y "deviceorientation" del objeto ventana informan de los datos del acelerómetro y el magnetómetro del dispositivo, lo que permite determinar cómo se acelera el dispositivo y cómo lo orienta el usuario en el espacio. (Estos eventos sí funcionan en iOS).</li>
      <li class="font-normal">La API de sensores aún no es ampliamente compatible más allá de Chrome en dispositivos Android, pero permite a JavaScript acceder a todo el conjunto de sensores de dispositivos móviles, incluidos el acelerómetro, el giroscopio, el magnetómetro y el sensor de luz ambiental. Estos sensores permiten a JavaScript determinar en qué dirección mira un usuario o detectar, por ejemplo, si el usuario agita el teléfono.</li>
    </ul>
  </section>
  <section id="15-9">
    <h2>15.15.9 API binarias</h2>
    <p>Las matrices tipadas, ArrayBuffers y la clase DataView (todas ellas tratadas en §11.2) permiten a Java-Script trabajar con datos binarios. Como se ha descrito anteriormente en este capítulo, la API fetch() permite a los programas JavaScript cargar datos binarios a través de la red. Otra fuente de datos binarios son los archivos del sistema de archivos local del usuario. Por razones de seguridad, JavaScript no puede leer sólo archivos locales. Pero si el usuario selecciona un archivo para cargarlo (usando un elemento de formulario &lt;input type="file>) o usa arrastrar y soltar para soltar un archivo en su aplicación web, entonces JavaScript puede acceder a ese archivo como un objeto File.</p>
    <p>File es una subclase de Blob, y como tal, es una representación opaca de un trozo de datos. Puedes utilizar una clase FileReader para obtener de forma asíncrona el contenido de un archivo como un ArrayBuffer o una cadena. (En algunos navegadores, puedes omitir el FileReader y en su lugar utilizar los métodos text() y arrayBuffer() basados en Promise definidos por la clase Blob, o el método stream() para el acceso en streaming al contenido del archivo).</p>
    <p>Cuando se trabaja con datos binarios, especialmente en streaming de datos binarios, puede ser necesario decodificar bytes en texto o codificar texto como bytes. Las clases TextEncoder y TextDecoder ayudan en esta tarea.</p>
  </section>
  <section id="15-10" class="py-4 xs:py-5 sm:py-6">
    <h2>15.15.10 API multimedia</h2>
    <p>La función navigator.mediaDevices.getUserMedia() permite a JavaScript solicitar acceso al micrófono y/o cámara de vídeo del usuario. Si la solicitud tiene éxito, se obtiene un objeto MediaStream. Las secuencias de vídeo pueden mostrarse en una etiqueta &lt;video> (estableciendo la propiedad srcObject en la secuencia). Los fotogramas del vídeo se pueden capturar en un &lt;canvas> fuera de pantalla con la función canvas drawImage(), lo que da como resultado una fotografía de relativamente baja resolución. Los flujos de audio y video devueltos por getUserMedia() pueden ser grabados y codificados en un Blob con un objeto MediaRecorder.</p>
    <p>La API WebRTC, más compleja, permite la transmisión y recepción de flujos multimedia a través de la red, lo que posibilita, por ejemplo, las videoconferencias entre iguales.</p>
  </section>
  <section id="15-11" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>15.15.11 Criptografía y API relacionadas</h2>
    <p>La propiedad crypto del objeto Window expone un método getRandomValues() para números pseudoaleatorios criptográficamente seguros. Otros métodos de cifrado, descifrado, generación de claves, firmas digitales, etc. están disponibles a través de crypto.subtle. El nombre de esta propiedad es una advertencia a todos los que utilizan estos métodos de que el uso adecuado de algoritmos criptográficos es difícil y que no se deben utilizar estos métodos a menos que realmente sepas lo que estás haciendo. Además, los métodos de crypto.subtle sólo están disponibles para el código JavaScript que se ejecuta dentro de documentos que se cargaron a través de una conexión HTTPS segura.</p>
    <p>La API de gestión de credenciales y la API de autenticación web permiten que JavaScript genere, almacene y recupere credenciales de clave pública (y de otros tipos) y permite la creación de cuentas y el inicio de sesión sin contraseñas. La API de JavaScript consiste principalmente en las funciones navigator.credentials.create() y navigator.creden tials.get(), pero se requiere una infraestructura importante en el lado del servidor para que estos métodos funcionen. Estas API aún no están soportadas universalmente, pero tienen el potencial de revolucionar la forma en que iniciamos sesión en los sitios web.</p>
    <p>La API de solicitud de pago añade soporte de navegador para realizar pagos con tarjeta de crédito en la web. Permite a los usuarios almacenar sus datos de pago de forma segura en el navegador para que no tengan que teclear el número de su tarjeta de crédito cada vez que realicen una compra. Las aplicaciones web que desean solicitar un pago crean un objeto PaymentRequest y llaman a su método show() para mostrar la solicitud al usuario.</p>
  </section>
</Layoutjavascript>