---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-10" capSiguiente="capitulo-12" />
  <section class="fadeIn">
    <h1>La biblioteca estándar de JavaScript</h1>
    <p>Algunos tipos de datos, como los números y las cadenas (<a href="capitulo-3">Capítulo 3</a>), los objetos (<a href="capitulo-6">Capítulo 6</a>) y las matrices (<a href="capitulo-7">Capítulo 7</a>), son tan fundamentales para JavaScript que podemos considerarlos parte del propio lenguaje. Este capítulo cubre otras API importantes pero menos fundamentales que pueden considerarse como la definición de la "biblioteca estándar" de JavaScript: se trata de clases y funciones útiles que están integradas en JavaScript y disponibles para todos los programas Java-Script tanto en navegadores web como en Node.<sup>1</sup></p>
    <p>Las secciones de este capítulo son independientes entre sí y puede leerlas en cualquier orden. Abarcan:</p>
    <ul>
      <li class="font-normal">Las clases Set y Map para representar conjuntos de valores y mapeos de un conjunto de valores a otro conjunto de valores.</li>
      <li class="font-normal">Objetos tipo array conocidos como TypedArrays que representan arrays de datos binarios, junto con una clase relacionada para extraer valores de datos binarios no arrays.</li>
      <li class="font-normal">Las expresiones regulares y la clase RegExp, que definen patrones textuales y son útiles para el tratamiento de textos. Esta sección también cubre en detalle la sintaxis de las expresiones regulares.</li>
      <li class="font-normal">La clase Date para representar y manipular fechas y horas.</li>
      <li class="font-normal">La clase Error y sus diversas subclases, cuyas instancias se lanzan cuando se producen errores en los programas JavaScript.</li>
      <li class="font-normal">El objeto JSON, cuyos métodos admiten la serialización y deserialización de estructuras de datos JavaScript compuestas por objetos, matrices, cadenas, números y booleanos.</li>
      <li class="font-normal">El objeto Intl y las clases que define que pueden ayudarle a localizar sus programas JavaScript.</li>
      <li class="font-normal">El objeto Console, cuyos métodos producen cadenas de salida que son particularmente útiles para depurar programas y registrar el comportamiento de esos programas.</li>
      <li class="font-normal">La clase URL, que simplifica la tarea de analizar y manipular URLs. Esta sección también cubre funciones globales para codificar y decodificar URLs y sus partes componentes.</li>
      <li class="font-normal"><codeinline>setTimeout()</codeinline> y funciones relacionadas para especificar el código que se ejecutará una vez transcurrido un intervalo de tiempo determinado.</li>
    </ul>
    <p>Algunas de las secciones de este capítulo -en particular, las secciones sobre arrays tipados y expresiones regulares- son bastante largas porque hay información de fondo importante que debe comprender antes de poder utilizar esos tipos de forma eficaz. Muchas de las otras secciones, sin embargo, son cortas: simplemente introducen una nueva API y muestran algunos ejemplos de su uso.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>11.1 Conjuntos y mapas</h2>
    <p>El tipo Object de JavaScript es una estructura de datos versátil que puede utilizarse para asignar cadenas (los nombres de las propiedades del objeto) a valores arbitrarios. Y cuando el valor al que se asigna es algo fijo como <codeinline>true</codeinline>, entonces el objeto es efectivamente un conjunto de cadenas.</p>
    <p>En realidad, los objetos se utilizan como mapas y conjuntos de forma bastante habitual en la programación JavaScript, pero esto se ve limitado por la restricción a las cadenas y complicado por el hecho de que los objetos normalmente heredan propiedades con nombres como "toString", que no suelen estar pensadas para formar parte del mapa o conjunto.</p>
    <p>Por esta razón, ES6 introduce las verdaderas clases Set y Map, que trataremos en las subsecciones siguientes.</p>
  </section>
  <section id="1-1">
    <h2>11.1.1 La clase Set</h2>
    <p>Un conjunto es una colección de valores, como una matriz. Sin embargo, a diferencia de las matrices, los conjuntos no están ordenados ni indexados, y no admiten duplicados: un valor o es miembro de un conjunto o no lo es; no es posible preguntar cuántas veces aparece un valor en un conjunto.</p>
    <p>Crea un objeto Set con el constructor <codeinline>Set()</codeinline>:</p>
    <pre>
    <code class="language-js">let s = new Set();       // Un nuevo, set vacio
    let t = new Set([1, s]); // Un nuevo set con 2 miembros</code></pre>
    <p>No es necesario que el argumento del constructor <codeinline>Set()</codeinline> cualquier objeto iterable (incluidos otros objetos Set):</p>
    <pre>
    <code class="language-js">let t = new Set(s);         // A new set that copies the elements of s.
    let unique = new Set("Mississippi"); // 4 elements: "M", "i", "s", and "p"</code></pre>
    <p>La propiedad <codeinline>size</codeinline> de un conjunto es como la propiedad <codeinline>length</codeinline> de un array indica cuántos valores contiene el  conjunto:</p>
    <pre>
    <code class="language-js">unique.size // => 4</code></pre>
    <p>Los conjuntos no necesitan inicializarse cuando se crean. Puede añadir y eliminar elementos en cualquier momento con <codeinline>add()</codeinline>, <codeinline>delete()</codeinline> y <codeinline>clear()</codeinline>. Recuerde que los conjuntos no pueden contener duplicados, por lo que añadir un valor a un conjunto cuando ya contiene ese valor no tiene ningún efecto:</p>
    <pre>
    <code class="language-js">let s = new Set();  // Start empty
    s.size              // => 0
    s.add(1);           // Add a number
    s.size              // => 1; now the set has one member
    s.add(1);           // Add the same number again
    s.size              // => 1; the size does not change
    s.add(true);        // Add another value; note that it is fine to mix types
    s.size              // => 2
    s.add([1,2,3]);     // Add an array value
    s.size              // => 3; the array was added, not its elements
    s.delete(1)         // => true: successfully deleted element 1
    s.size              // => 2: the size is back down to 2
    s.delete("test")    // => false: "test" was not a member, deletion failed
    s.delete(true)      // => true: delete succeeded
    s.delete([1,2,3])   // => false: the array in the set is different
    s.size              // => 1: there is still that one array in the set
    s.clear();          // Remove everything from the set
    s.size              // => 0</code></pre>
    <p>Hay algunos puntos importantes a tener en cuenta sobre este código:</p>
    <ul>
      <li class="font-normal">El método <codeinline>add()</codeinline> toma un único argumento; si pasas un array, añade el propio array al conjunto, no los elementos individuales del array. Sin embargo, <codeinline>add()</codeinline> siempre devuelve el conjunto sobre el que se invoca, así que si quieres añadir múltiples valores a un conjunto, puedes usar llamadas encadenadas a métodos como <codeinline>s.add('a').add('b').add('c');</codeinline>.</li>
      <li class="font-normal">El método <codeinline>delete()</codeinline> también elimina un único elemento del conjunto cada vez. Sin embargo, a diferencia de <codeinline>add()</codeinline>, <codeinline>delete()</codeinline> devuelve un valor booleano. Si el valor especificado era realmente un miembro del conjunto, <codeinline>delete()</codeinline> lo elimina y devuelve <codeinline>true</codeinline>. En caso contrario, no hace nada y devuelve <codeinline>false</codeinline>.</li>
      <li class="font-normal">Por último, es muy importante entender que la pertenencia a un conjunto se basa en comprobaciones de igualdad estrictas, como las que realiza el operador <codeinline>===</codeinline>. Un conjunto puede contener tanto el número <codeinline>1</codeinline> como la cadena <codeinline>"1"</codeinline>, porque los considera valores distintos. Cuando los valores son objetos (o matrices o funciones), también se comparan como si fueran con <codeinline>===</codeinline> Esta es la razón por la que no pudimos eliminar el elemento del array del conjunto en este código. Añadimos un array al conjunto y luego intentamos eliminarlo pasando un array <em>diferente</em> (aunque con los mismos elementos) al método <codeinline>delete()</codeinline>. Para que esto funcionara, tendríamos que haber pasado una referencia exactamente al mismo array.</li>
    </ul>
    <nota>
      <img class="self-start" src="/public/javascript/nota_gral.png" alt="Nota de la grandesa">
      <div class="">
        <p>Los programadores de Python toman nota: ésta es una diferencia significativa entre los conjuntos de JavaScript y los de Python. Los conjuntos de Python comparan los miembros por igualdad, no por identidad, pero la contrapartida es que los conjuntos de Python sólo permiten miembros inmutables, como las tuplas, y no permiten añadir listas y dicts a los conjuntos.</p>
      </div>
    </nota>
    <p>En la práctica, lo más importante que hacemos con los conjuntos no es añadir y eliminar elementos de ellos, sino comprobar si un valor especificado es miembro del conjunto. Esto se hace con el método <codeinline>has()</codeinline>:</p>
    <pre>
      <code class="language-js">let oneDigitPrimes = new Set([2,3,5,7]);
      oneDigitPrimes.has(2)   // => true: 2 is a one-digit prime number
      oneDigitPrimes.has(3)   // => true: so is 3
      oneDigitPrimes.has(4)   // => false: 4 is not a prime
      oneDigitPrimes.has("5") // => false: "5" is not even a number</code></pre>
    <p>Lo más importante que hay que entender sobre los conjuntos es que están optimizados para la comprobación de miembros, y no importa cuántos miembros tenga el conjunto, el método <codeinline>has()</codeinline> será muy rápido. El método <codeinline>includes()</codeinline> de un array también realiza pruebas de pertenencia, pero el tiempo que tarda es proporcional al tamaño del array, y usar un array como set puede ser mucho, mucho más lento que usar un objeto Set real.</p>
    <p>La clase Set es iterable, lo que significa que puede utilizar un bucle <codeinline>for/of</codeinline> para enumerar todos los elementos de un conjunto:</p>
    <pre>
    <code class="language-js">let sum = 0;
    for(let p of oneDigitPrimes) &lbrace; // Loop through the one-digit primes
      sum += p;                    // and add them up
    }
    sum                            // => 17: 2 + 3 + 5 + 7</code></pre>
    <p>Dado que los objetos Set son iterables, puede convertirlos en matrices y listas de argumentos con el operador de extensión <codeinline>...</codeinline>:</p>
    <pre>
    <code class="language-js">[...oneDigitPrimes]         // => [2,3,5,7]: the set converted to an Array
    Math.max(...oneDigitPrimes) // => 7: set elements passed as function arguments</code></pre>
    <p>Los conjuntos se describen a menudo como "colecciones desordenadas". Sin embargo, esto no es exactamente cierto para la clase Set de Java Script. Un conjunto JavaScript no está indexado: no se puede preguntar por el primer o tercer elemento de un conjunto como se hace con un array. Pero la clase Set de JavaScript siempre recuerda el orden en el que se insertaron los elementos, y siempre utiliza este orden cuando iteras un conjunto: el primer elemento insertado será el primero iterado (suponiendo que no lo hayas borrado antes), y el elemento insertado más recientemente será el último iterado.<sup>2</sup></p>
    <p>Además de ser iterable, la clase Set también implementa un método <codeinline>forEach()</codeinline> que es similar al método array del mismo nombre:</p>
    <pre>
    <code class="language-js">let product = 1;
    oneDigitPrimes.forEach(n => &lbrace; product *= n; });
    product // => 210: 2 * 3 * 5 * 7</code></pre>
    <p>El método <codeinline>forEach()</codeinline> de una matriz pasa los índices de la matriz como segundo argumento de la función especificada. Los conjuntos no tienen índices, por lo que la versión de la clase Set de este método simplemente pasa el valor del elemento como primer y segundo argumento.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>11.1.2 La clase Map</h2>
    <p>Un objeto Map representa un conjunto de valores conocidos como <em>claves</em>, donde cada clave tiene otro valor asociado (o "mapeado"). En cierto sentido, un mapa es como un array, pero en lugar de utilizar un conjunto de enteros secuenciales como claves, los mapas nos permiten utilizar valores arbitrarios como "índices". Al igual que las matrices, los mapas son rápidos: buscar el valor asociado a una clave será rápido (aunque no tanto como indexar una matriz) independientemente de lo grande que sea el mapa.</p>
    <p>Crea un nuevo mapa con el constructor <codeinline>Map()</codeinline>:</p>
    <pre>
    <code class="language-js">let m = new Map(); // Create a new, empty map
    let n = new Map([  // A new map initialized with string keys mapped to numbers
      ["one", 1],
      ["two", 2]
    ]);</code></pre>
    <p>El argumento opcional del constructor <codeinline>Map()</codeinline> debe ser un objeto iterable que produzca matrices de dos elementos <codeinline>[clave, valor]</codeinline>. En la práctica, esto significa que si desea inicializar un mapa al crearlo, normalmente escribirá las claves deseadas y los valores asociados como una matriz de matrices. Pero también puedes utilizar el constructor <codeinline>Map()</codeinline> para copiar otros mapas o para copiar los nombres y valores de las propiedades de un objeto existente:</p>
    <pre>
    <code class="language-js">let copy = new Map(n); // A new map with the same keys and values as map n
    let o = &lbrace; x: 1, y: 2}; // An object with two properties
    let p = new Map(Object.entries(o)); // Same as new map([["x", 1], ["y", 2]])</code></pre>
    <p>Una vez creado un objeto Map, puede consultar el valor asociado a una clave dada con <codeinline>get()</codeinline> y puede añadir un nuevo par clave/valor con <codeinline>set()</codeinline>. Recuerda, sin embargo, que un mapa es un conjunto de claves, cada una de las cuales tiene un valor asociado. Esto no es exactamente lo mismo que un conjunto de pares clave/valor. Si llamas a <codeinline>set()</codeinline> con una clave que ya existe en el mapa, cambiarás el valor asociado a esa clave, no añadirás un nuevo mapeo clave/valor. Además de <codeinline>get()</codeinline> y <codeinline>set()</codeinline>, la clase Map también define métodos que son como los métodos Set: utilizar <codeinline>has()</codeinline> para comprobar si un mapa incluye la clave especificada; utilizar <codeinline>delete()</codeinline> para eliminar una clave (y su valor asociado) del mapa; utilizar <codeinline>clear()</codeinline> para eliminar todos los pares clave/valor del mapa; y utilizar la propiedad <codeinline>size</codeinline> para averiguar cuántas claves contiene un mapa.</p>
    <pre>
    <code class="language-js">let m = new Map();  // Start with an empty map
    m.size              // => 0: empty maps have no keys
    m.set("one", 1);    // Map the key "one" to the value 1
    m.set("two", 2);    // And the key "two" to the value 2.
    m.size              // => 2: the map now has two keys
    m.get("two")        // => 2: return the value associated with key "two"
    m.get("three")      // => undefined: this key is not in the set
    m.set("one", true); // Change the value associated with an existing key
    m.size              // => 2: the size doesn't change
    m.has("one")        // => true: the map has a key "one"
    m.has(true)         // => false: the map does not have a key true
    m.delete("one")     // => true: the key existed and deletion succeeded
    m.size              // => 1
    m.delete("three")   // => false: failed to delete a nonexistent key
    m.clear();          // Remove all keys and values from the map</code></pre>
    <p>Al igual que el método <codeinline>add()</codeinline> de Set, el método <codeinline>set()</codeinline> de Map puede encadenarse, lo que permite inicializar mapas sin utilizar matrices de matrices:</p>
    <pre>
    <code class="language-js">let m = new Map().set("one", 1).set("two", 2).set("three", 3);
    m.size        // => 3
    m.get("two")  // => 2</code></pre>
    <p>Al igual que con Set, cualquier valor JavaScript puede utilizarse como clave o valor en Map. Esto incluye <codeinline>null</codeinline>, <codeinline>undefined</codeinline> y <codeinline>NaN</codeinline>, así como tipos de referencia como objetos y matrices. Y al igual que con la clase Set, Map compara las claves por identidad, no por igualdad, por lo que si se utiliza un objeto o matriz como clave, se considerará diferente de cualquier otro objeto y matriz, incluso de aquellos que tengan exactamente las mismas propiedades o elementos:</p>
    <pre>
    <code class="language-js">let m = new Map();   // Start with an empty map.
    m.set(&lbrace;}, 1);        // Map one empty object to the number 1.
    m.set(&lbrace;}, 2);        // Map a different empty object to the number 2.
    m.size               // => 2: there are two keys in this map
    m.get(&lbrace;})            // => undefined: but this empty object is not a key
    m.set(m, undefined); // Map the map itself to the value undefined.
    m.has(m)             // => true: m is a key in itself
    m.get(m)             // => undefined: same value we'd get if m wasn't a key</code></pre>
    <p>Los objetos Map son iterables, y cada valor iterado es un array de dos elementos donde el primer elemento es una clave y el segundo elemento es el valor asociado a esa clave. Si utilizas el operador spread con un objeto Map, obtendrás un array de arrays como los siguientes que pasamos al constructor <codeinline>Map()</codeinline>. Y al iterar un mapa con un bucle <codeinline>for/of</codeinline>, es idiomático utilizar la asignación de desestructuración para asignar la clave y el valor a variables separadas:</p>
    <pre>
    <code class="language-js">let m = new Map([["x", 1], ["y", 2]]);
    [...m] // => [["x", 1], ["y", 2]]

    for(let [key, value] of m) &lbrace;
      // On the first iteration, key will be "x" and value will be 1
      // On the second iteration, key will be "y" and value will be 2
    }</code></pre>
    <p>Al igual que la clase Set, la clase Map itera en orden de inserción. El primer par clave/valor iterado será el que se haya añadido menos recientemente al mapa, y el último par iterado será el que se haya añadido más recientemente.</p>
    <p>Si desea iterar sólo las claves o sólo los valores asociados de un mapa, utilice los métodos <codeinline>keys()</codeinline> y <codeinline>values()</codeinline>: éstos devuelven objetos iterables que iteran claves y valores, en orden de inserción. (El método <codeinline>entries()</codeinline> devuelve un objeto iterable que itera pares clave/valor, pero esto es exactamente lo mismo que iterar el mapa directamente).</p>
    <pre>
    <code class="language-js">[...m.keys()]     // => ["x", "y"]: just the keys
    [...m.values()]   // => [1, 2]: just the values
    [...m.entries()]  // => [["x", 1], ["y", 2]]: same as [...m]</code></pre>
    <p>Los objetos Map también pueden ser iterados utilizando el método <codeinline>forEach()</codeinline> que fue implementado por primera vez por la clase Array.</p>
    <pre>
    <code class="language-js">m.forEach((value, key) => &lbrace; // note value, key NOT key, value
      // On the first invocation, value will be 1 and key will be "x"
      // On the second invocation, value will be 2 and key will be "y"
    });</code></pre>
    <p>Puede parecer extraño que el parámetro valor vaya antes que el parámetro clave en el código anterior, ya que con la iteración <codeinline>for/of</codeinline>, la clave va primero. Como se indicó al principio de esta sección, se puede pensar en un mapa como una matriz generalizada en la que los índices enteros de la matriz se sustituyen por valores clave arbitrarios. El método <codeinline>forEach()</codeinline> de los arrays pasa el elemento del array primero y el índice del array después, así que, por analogía, el método <codeinline>forEach()</codeinline> de un mapa pasa el valor del mapa primero y la clave del mapa después.</p>
  </section>
  <section id="1-3">
    <h2>11.1.3 WeakMap y WeakSet</h2>
    <p>La clase WeakMap es una variante (pero no una subclase real) de la clase Map que no impide que sus valores clave sean recolectados por la basura. La recolección de basura es el proceso por el cual el intérprete de JavaScript recupera la memoria de los objetos que ya no son "accesibles" y no pueden ser utilizados por el programa. Un mapa normal mantiene referencias "fuertes" a sus valores clave, y siguen siendo accesibles a través del mapa, incluso si todas las demás referencias a ellos han desaparecido. El WeakMap, por el contrario, mantiene referencias " débiles" a sus valores clave para que no sean accesibles a través del WeakMap, y su presencia en el mapa no impida que se recupere su memoria.</p>
    <p>El constructor <codeinline>WeakMap()</codeinline> es igual que el constructor <codeinline>Map()</codeinline>, pero hay algunas diferencias significativas entre WeakMap y Map:</p>
    <ul>
      <li class="font-normal">Las claves de WeakMap deben ser objetos o matrices; los valores primitivos no están sujetos a la recolección de basura y no pueden utilizarse como claves.</li>
      <li class="font-normal">WeakMap sólo implementa los métodos <codeinline>get()</codeinline>, <codeinline>set()</codeinline>, <codeinline>has()</codeinline> y <codeinline>delete()</codeinline>. En particular, WeakMap no es iterable y no define <codeinline>keys()</codeinline>, <codeinline>values()</codeinline>, o <codeinline>forEach()</codeinline>. Si WeakMap fuera iterable, sus claves serían alcanzables y no sería débil.</li>
      <li class="font-normal">Del mismo modo, WeakMap no implementa la propiedad <codeinline>size</codeinline> porque el tamaño de un WeakMap podría cambiar en cualquier momento a medida que los objetos son recolectados.</li>
    </ul>
    <p>El uso previsto de WeakMap es permitirle asociar valores con objetos sin causar fugas de memoria. Supongamos, por ejemplo, que estás escribiendo una función que toma como argumento un objeto y necesita realizar algún cálculo que consume tiempo en ese objeto. Por eficiencia, te gustaría almacenar en caché el valor calculado para reutilizarlo más tarde. Si utilizas un objeto Map para implementar la caché, impedirás q u e cualquiera de los objetos sea recuperado, pero si utilizas un WeakMap, evitarás este problema. (A menudo se puede conseguir un resultado similar utilizando una propiedad Symbol privada para almacenar en caché el valor compuesto directamente en el objeto. Véase <a href="capitulo-6#10-3">§6.10.3</a>.)</p>
    <p>WeakSet implementa un conjunto de objetos que no impide que dichos objetos sean recolectados. El constructor <codeinline>WeakSet()</codeinline> funciona como el constructor <codeinline>Set()</codeinline>, pero los objetos WeakSet difieren de los objetos Set de la misma forma que los objetos WeakMap difieren de los objetos Map:</p>
    <ul>
      <li class="font-normal">WeakSet no permite valores primitivos como miembros.</li>
      <li class="font-normal">WeakSet sólo implementa los métodos <codeinline>add()</codeinline>, <codeinline>has()</codeinline> y <codeinline>delete()</codeinline> y no es iterable.</li>
      <li class="font-normal">WeakSet no tiene una propiedad de <codeinline>size</codeinline>.</li>
    </ul>
    <p>WeakSet no se utiliza con frecuencia: sus casos de uso son como los de WeakMap. Por ejemplo, si desea marcar (o "marcar") un objeto como poseedor de alguna propiedad o tipo especial, puede añadirlo a un WeakSet. Luego, cuando quiera comprobar esa propiedad o tipo, puede comprobar si pertenece a ese WeakSet. Hacer esto con un conjunto regular impediría que todos los objetos marcados fueran recolectados, pero esto no es un problema cuando se utiliza WeakSet.</p>
  </section>
  <section id="2" class="py-4 xs:py-5 sm:py-6">
    <h2>11.2 Matrices tipificadas y datos binarios</h2>
    <p>Las matrices normales de JavaScript pueden tener elementos de cualquier tipo y crecer o decrecer dinámicamente. Las implementaciones de JavaScript realizan muchas optimizaciones, por lo que los usos típicos de las matrices de JavaScript son muy rápidos. Sin embargo, siguen siendo bastante diferentes de los tipos de arrays de lenguajes de bajo nivel como C y Java. Los <em>arrays tipados</em>, que son nuevos en ES6,<sup>3</sup> son mucho más parecidos a los arrays de bajo nivel de esos lenguajes. Los arrays tipados no son técnicamente arrays (<codeinline>Array.isArray()</codeinline> devuelve <codeinline>false</codeinline> para ellos), pero implementan todos los métodos de arrays descritos en <a href="capitulo-7#8">§7.8</a> más algunos propios. Sin embargo, difieren de las matrices normales en algunos aspectos muy importantes:</p>
    <ul>
      <li class="font-normal">Los elementos de una matriz tipada son todos números. Sin embargo, a diferencia de los números normales de JavaScript, las matrices tipadas permiten especificar el tipo (enteros con y sin signo y coma flotante IEEE-754) y el tamaño (de 8 a 64 bits) de los números que se almacenarán en la matriz.</li>
      <li class="font-normal">Debes especificar la longitud de un array tipado cuando lo creas, y esa longitud nunca puede cambiar.</li>
      <li class="font-normal">Los elementos de un array tipado siempre se inicializan a 0 cuando se crea el array.</li>
    </ul>
  </section>
  <section id="2-1">
    <h2>11.2.1 Tipos de matrices tipificadas</h2>
    <p>JavaScript no define una clase TypedArray. En su lugar, existen 11 clases de arrays tipados, cada una con un tipo de elemento y un constructor diferentes:</p>
    <div id="tabla11-0" class="flex flex-col items-center">
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">ConstructorTipo</td>
            <td class="max-w-lg pl-4">numérico</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Int8Array()</codeinline></td>
              <td class="max-w-lg px-4">bytes con signo</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Uint8Array()</codeinline></td>
              <td class="max-w-lg px-4">bytes sin signo</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Uint8ClampedArray()</codeinline></td>
              <td class="max-w-lg px-4">bytes sin signo sin rollover</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Int16Array()</codeinline></td>
              <td class="max-w-lg px-4">enteros cortos de 16 bits con signo</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Uint16Array()</codeinline></td>
              <td class="max-w-lg px-4">enteros cortos de 16 bits sin signo</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Int32Array()</codeinline></td>
              <td class="max-w-lg px-4">enteros de 32 bits con signo</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Uint32Array()</codeinline></td>
              <td class="max-w-lg px-4">enteros de 32 bits sin signo</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">BigInt64Array()</codeinline></td>
              <td class="max-w-lg px-4">valores BigInt de 64 bits con signo (ES2020)</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">BigUint64Array() </codeinline></td>
              <td class="max-w-lg px-4">valores BigInt de 64 bitssin signo (ES2020)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Float32Array()</codeinline></td>
              <td class="max-w-lg px-4">valor en coma flotantede de 32 bits</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">Float64Array()</codeinline></td>
              <td class="max-w-lg px-4">valor de coma flotante de 64 bits: un número normal de JavaScript</td>
            </tr>
        </tbody>
      </table>
    </div>
    <p>Los tipos cuyo nombre comienza por <codeinline>Int</codeinline> contienen enteros con signo de 1, 2 ó 4 bytes (8, 16 ó 32 bits). Los tipos cuyo nombre comienza por <codeinline>Uint</codeinline> contienen enteros sin signo de la misma longitud. Los tipos "BigInt" y "BigUint" contienen enteros de 64 bits, representados en JavaScript como valores BigInt (véase <a href="capitulo-3#2-5">§3.2.5</a>). Los tipos que empiezan por <codeinline>Float</codeinline> contienen números de coma flotante. Los elementos de un <codeinline>Float64Array</codeinline> son del mismo tipo que los números normales de Java-Script. Los elementos de un <codeinline>Float32Array</codeinline> tienen menor precisión y un rango más pequeño, pero requieren sólo la mitad de memoria. (Este tipo se denomina <codeinline>float</codeinline> en C y Java).</p>
    <p><codeinline>Uint8ClampedArray</codeinline> es una variante especial de <codeinline>Uint8Array</codeinline>. Ambos tipos contienen bytes sin signo y pueden representar números entre 0 y 255. Con <codeinline>Uint8Array</codeinline>, si almacenas un valor mayor que 255 o menor que cero en un elemento del array, éste se "envuelve" y obtienes otro valor. Así es como funciona la memoria del ordenador a bajo nivel, por lo que es muy rápido. <codeinline>Uint8ClampedArray</codeinline> realiza una comprobación de tipo adicional para que, si almacenas un valor mayor que 255 o menor que 0, se "sujete" a 255 o 0 y no se desplace. (Este comportamiento de sujeción es requerido por la API de bajo nivel del elemento HTML <codeinline>&lt;canvas></codeinline> para manipular los colores de los píxeles).</p>
    <p>Cada uno de los constructores de array tipados tiene una propiedad <codeinline>BYTES_PER_ELEMENT</codeinline> con el valor 1, 2, 4 u 8, dependiendo del tipo.</p>
  </section>
  <section id="2-2" class="py-4 xs:py-5 sm:py-6">
    <h2>11.2.2 Creación de Arrays tipados</h2>
    <p>La forma más sencilla de crear un array tipado es llamar al constructor apropiado con un argumento numérico que especifique el número de elementos que quieres en el array:</p>
    <pre>
    <code class="language-js">let bytes = new Uint8Array(1024);     // 1024 bytes
    let matrix = new Float64Array(9);     // A 3x3 matrix
    let point = new Int16Array(3);        // A point in 3D space
    let rgba = new Uint8ClampedArray(4);  // A 4-byte RGBA pixel value
    let sudoku = new Int8Array(81);       // A 9x9 sudoku board</code></pre>
    <p>Cuando se crean arrays tipados de esta forma, se garantiza que todos los elementos del array se inicializan a <codeinline>0</codeinline>, <codeinline>0n</codeinline>, o <codeinline>0.0</codeinline>. Pero si conoces los valores que quieres en tu array tipado, también puedes especificar esos valores cuando crees el array. Cada uno de los constructores de matrices tipadas tiene métodos de fábrica estáticos <codeinline>from()</codeinline> y <codeinline>of()</codeinline> que funcionan como <codeinline>Array.from()</codeinline> y <codeinline>Array.of()</codeinline>:</p>
    <pre>
    <code class="language-js">let white = Uint8ClampedArray.of(255, 255, 255, 0); // RGBA opaque white</code></pre>
    <p>Recordemos que el método de fábrica <codeinline>Array.from()</codeinline> espera un objeto iterable o similar a un array como primer argumento. Lo mismo ocurre con las variantes tipadas de array, excepto que el objeto iterable o tipo array también debe tener elementos numéricos. Las cadenas son iterables, por ejemplo, pero no tendría sentido pasarlas al método de fábrica <codeinline>from()</codeinline> de un array tipado.</p>
    <p>Si sólo está utilizando la versión de un argumento de <codeinline>from()</codeinline>, puede omitir el <codeinline>.from</codeinline> y pasar su objeto iterable o tipo array directamente a la función constructora, que se comporta exactamente igual. Tenga en cuenta que tanto el constructor como el método de fábrica <codeinline>from()</codeinline> le permiten copiar matrices tipadas existentes, aunque posiblemente cambiando el tipo:</p>
    <pre>
    <code class="language-js">let ints = Uint32Array.from(white); // The same 4 numbers, but as ints</code></pre>
    <p>Cuando se crea un nuevo array tipado a partir de un array, iterable u objeto tipo array existente, los valores pueden truncarse para ajustarse a las restricciones de tipo del array. No hay advertencias ni errores cuando esto ocurre:</p>
    <pre>
    <code class="language-js">// Floats truncated to ints, longer ints truncated to 8 bits
    Uint8Array.of(1.23, 2.99, 45000) // => new Uint8Array([1, 2, 200])</code></pre>
    <p>Por último, hay otra forma de crear matrices tipadas que implica el tipo ArrayBuffer. Un ArrayBuffer es una referencia opaca a un trozo de memoria. Puedes crear uno con el constructor; sólo tienes que pasar el número de bytes de memoria que deseas asignar:</p>
    <pre>
    <code class="language-js">let buffer = new ArrayBuffer(1024*1024);
    buffer.byteLength // => 1024*1024; one megabyte of memory</code></pre>
    <p>La clase ArrayBuffer no permite leer ni escribir ninguno de los bytes que tiene asignados. Pero puedes crear arrays tipados que utilicen la memoria del buffer y que sí te permitan leer y escribir esa memoria. Para hacer esto, llama al constructor de arrays tipados con un ArrayBuffer como primer argumento, un desplazamiento de bytes dentro del buffer del array como segundo argumento, y la longitud del array (en elementos, no en bytes) como tercer argumento. El segundo y el tercer argumento son opcionales. Si omite ambos, la matriz utilizará toda la memoria del búfer de la matriz. Si sólo omite el argumento longitud, la matriz utilizará toda la memoria disponible entre la posición de inicio y el final de la matriz. Una cosa más a tener en cuenta sobre esta forma del constructor de array tipado: los arrays deben estar alineados con la memoria, por lo que si especifica un desplazamiento de byte, el valor debe ser un múltiplo del tamaño de su tipo. El constructor <codeinline>Int32Array()</codeinline> requiere un múltiplo de cuatro, por ejemplo, y <codeinline>Float64Array()</codeinline> requiere un múltiplo de ocho.</p>
    <p>Dado el ArrayBuffer creado anteriormente, podrías crear arrays tipados como estos:</p>
    <pre>
    <code class="language-js">let asbytes = new Uint8Array(buffer);           // Viewed as bytes
    let asints = new Int32Array(buffer);            // Viewed as 32-bit signed ints
    let lastK = new Uint8Array(buffer, 1023*1024);  // Last kilobyte as bytes
    let ints2 = new Int32Array(buffer, 1024, 256);  // 2nd kilobyte as 256 integers</code></pre>
    <p>Estos cuatro arrays tipados ofrecen cuatro vistas diferentes de la memoria representada por el ArrayBuffer. Es importante entender que todos los arrays tipados tienen un ArrayBuffer subyacente, incluso si no se especifica explícitamente. Si llamas a un constructor de arrays tipados sin pasarle un objeto buffer, se creará automáticamente un <codeinline>buffer</codeinline> del tamaño apropiado. Como se describe más adelante, la propiedad buffer de cualquier array tipado se refiere a su objeto subyacente ArrayBuffer. La razón para trabajar directamente con objetos ArrayBuffer es que a veces puedes querer tener múltiples vistas de matrices tipadas de un único buffer.</p>
  </section>
  <section id="2-3">
    <h2>11.2.3 Uso de matrices tipadas</h2>
    <p>Una vez creado un array tipado, puedes leer y escribir sus elementos con la notación normal de corchetes, como harías con cualquier otro objeto tipo array:</p>
    <pre>
    <code class="language-js">// Return the largest prime smaller than n, using the sieve of Eratosthenes
    function sieve(n) &lbrace;
      let a = new Uint8Array(n+1);        // a[x] will be 1 if x is composite
      let max = Math.floor(Math.sqrt(n)); // Don't do factors higher than this
      let p = 2;                          // 2 is the first prime
      while(p &lt;= max) &lbrace;                   // For primes less than max
        for(let i = 2*p; i &lt;= n; i += p)  // Mark multiples of p as composite
          a[i] = 1;
        while(a[++p])        /* empty */; // The next unmarked index is prime
      }
      while(a[n]) n--;       // Loop backward to find the last prime
      return n;              // And return it
    }</code></pre>
    <p>Esta función calcula el mayor número primo menor que el número especificado. El código es exactamente el mismo que con una matriz JavaScript normal, pero el uso de <codeinline>Uint8Array()</codeinline> en lugar de <codeinline>Array()</codeinline> hace que el código se ejecute más de cuatro veces más rápido y utilice ocho veces menos memoria en mis pruebas.</p>
    <p>Las matrices tipadas no son verdaderas matrices, pero reimplementan la mayoría de los métodos de matrices, por lo que se pueden utilizar prácticamente igual que las matrices normales:</p>
    <pre>
    <code class="language-js">let ints = new Int16Array(10);    // 10 short integers
    ints.fill(3).map(x=>x*x).join("") // => "9999999999"</code></pre>
    <p>Recuerde que los arrays tipados tienen longitudes fijas, por lo que la propiedad length es de sólo lectura, y los métodos que cambian la longitud del array (como <codeinline>push()</codeinline>, <codeinline>pop()</codeinline>, <codeinline>unshift()</codeinline>, <codeinline>shift()</codeinline>, y <codeinline>splice()</codeinline>) no están implementados para arrays tipados. Los métodos que alteran el contenido de una matriz sin cambiar su longitud (como <codeinline>sort()</codeinline>, <codeinline>reverse()</codeinline> y <codeinline>fill()</codeinline>) están implementados. Los métodos como <codeinline>map()</codeinline> y <codeinline>slice()</codeinline> que devuelven nuevas matrices, devuelven una matriz tipada del mismo tipo que aquella a la que se llama.</p>
  </section>
  <section id="2-4" class="py-4 xs:py-5 sm:py-6">
    <h2>11.2.4 Métodos y propiedades de matrices tipificadas</h2>
    <p>Además de los métodos estándar de las matrices, las matrices tipadas también implementan algunos métodos propios. El método <codeinline>set()</codeinline> establece múltiples elementos de una matriz tipada a la vez copiando los elementos de una matriz normal o tipada en una matriz tipada:</p>
    <pre>
    <code class="language-js">let bytes = new Uint8Array(1024);        // A 1K buffer
    let pattern = new Uint8Array([0,1,2,3]); // An array of 4 bytes
    bytes.set(pattern);       // Copy them to the start of another byte array
    bytes.set(pattern, 4);    // Copy them again at a different offset
    bytes.set([0,1,2,3], 8);  // Or just copy values direct from a regular array
    bytes.slice(0, 12)        // => new Uint8Array([0,1,2,3,0,1,2,3,0,1,2,3])</code></pre>
    <p>El método <codeinline>set()</codeinline> toma un array o un array tipado como primer argumento y un desplazamiento de elemento como segundo argumento opcional, que por defecto es 0 si no se especifica. Si está copiando valores de una matriz tipada a otra, es probable que la operación sea extremadamente rápida.</p>
    <p>Los arrays tipados también tienen un método <codeinline>subarray</codeinline> que devuelve una parte del array sobre el que se llama:</p>
    <pre>
    <code class="language-js">let ints = new Int16Array([0,1,2,3,4,5,6,7,8,9]);      // 10 short integers
    let last3 = ints.subarray(ints.length-3, ints.length); // Last 3 of them
    last3[0]          // => 7: this is the same as ints[7]</code></pre>
    <p><codeinline>subarray()</codeinline> toma los mismos argumentos que el método <codeinline>slice()</codeinline> y parece funcionar de la misma manera. Pero hay una diferencia importante. <codeinline>slice()</codeinline> devuelve los elementos especificados en una nueva matriz de tipo independiente que no comparte memoria con la matriz original. <codeinline>subarray()</codeinline> no copia ninguna memoria; sólo devuelve una nueva vista de los mismos valores subyacentes:</p>
    <pre>
    <code class="language-js">ints[9] = -1; // Change a value in the original array and...
    last3[2]      // => -1: it also changes in the subarray</code></pre>
    <p>El hecho de que el método <codeinline>subarray()</codeinline> devuelva una nueva vista de un array existente nos devuelve al tema de los ArrayBuffers. Cada array tipado tiene tres propiedades que se relacionan con el buffer subyacente:</p>
    <pre>
    <code class="language-js">last3.buffer                 // The ArrayBuffer object for a typed array
    last3.buffer === ints.buffer // => true: both are views of the same buffer
    last3.byteOffset             // => 14: this view starts at byte 14 of the buffer
    last3.byteLength             // => 6: this view is 6 bytes (3 16-bit ints) long
    last3.buffer.byteLength      // => 20: but the underlying buffer has 20 bytes</code></pre>
    <p>La propiedad <codeinline>buffer</codeinline> es el ArrayBuffer del array. <codeinline>byteOffset</codeinline> es la posición inicial de los datos del array dentro del buffer subyacente. Y <codeinline>byteLength</codeinline> es la longitud de los datos del array en bytes. Para cualquier tipo de array, a, esta invariante debe ser siempre verdadera:</p>
    <pre>
    <code class="language-js">a.length * a.BYTES_PER_ELEMENT === a.byteLength // => true</code></pre>
    <p>Los ArrayBuffers son simplemente trozos opacos de bytes. Puedes acceder a esos bytes con arrays tipados, pero un ArrayBufffer no es en sí mismo un array tipado. Ten cuidado, sin embargo: puedes usar indexación numérica de arrays con ArrayBuffers igual que con cualquier objeto JavaScript. Hacerlo no te da acceso a los bytes del buffer, pero puede causar errores de confusión:</p>
    <pre>
    <code class="language-js">let bytes = new Uint8Array(8);
    bytes[0] = 1;          // Set the first byte to 1
    bytes.buffer[0]        // => undefined: buffer doesn't have index 0
    bytes.buffer[1] = 255; // Try incorrectly to set a byte in the buffer
    bytes.buffer[1]        // => 255: this just sets a regular JS property
    bytes[1]               // => 0: the line above did not set the byte</code></pre>
    <p>Anteriormente vimos que se puede crear un ArrayBuffer con el constructor <codeinline>ArrayBuffer()</codeinline> y luego crear arrays tipados que utilicen ese buffer. Otro enfoque es crear un array tipado inicial, y luego usar el buffer de ese array para crear otras vistas:</p>
    <pre>
    <code class="language-js">let bytes = new Uint8Array(1024);             // 1024 bytes
    let ints = new Uint32Array(bytes.buffer);     // or 256 integers
    let floats = new Float64Array(bytes.buffer);  // or 128 doubles</code></pre>
  </section>
  <section id="2-5">
    <h2>11.2.5 DataView y Endianness</h2>
    <p>Las matrices tipadas permiten ver la misma secuencia de bytes en trozos de 8, 16, 32 o 64 bits. De este modo, queda al descubierto la "endianidad": el orden en que los bytes se organizan en palabras más largas. En aras de la eficiencia, las matrices tipadas utilizan el "endianness" nativo del hardware subyacente. En los sistemas little-endian, los bytes de un número se ordenan en un Array-Buffer de menor a mayor significación. En las plataformas big-endian, los bytes se ordenan del más significativo al menos significativo. Usted puede determinar el endian- ness de la plataforma subyacente con código como este:</p>
    <pre>
    <code class="language-js">// If the integer 0x00000001 is arranged in memory as 01 00 00 00, then
    // we're on a little-endian platform. On a big-endian platform, we'd get
    // bytes 00 00 00 01 instead.
    let littleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;</code></pre>
    <p>Hoy en día, las arquitecturas de CPU más comunes son little-endian. Sin embargo, muchos protocolos de red y algunos formatos de archivos binarios requieren un orden de bytes big-endian. Si estás usando matrices tipadas con datos que provienen de la red o de un archivo, no puedes asumir que el orden de la plataforma coincide con el orden de los bytes de los datos. En general, cuando se trabaja con datos externos, puede utilizar Int8Array y Uint8Array para ver los datos como una matriz de bytes individuales, pero no debe utilizar las otras matrices tipadas con tamaños de palabra multibyte. En su lugar, puedes utilizar la clase DataView, que define métodos para leer y escribir valores desde un ArrayBuffer con un orden de bytes explícitamente especificado:</p>
    <pre>
    <code class="language-js">// Assume we have a typed array of bytes of binary data to process. First,
    // we create a DataView object so we can flexibly read and write
    // values from those bytes
    let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    
    let int = view.getInt32(0);    // Read big-endian signed int from byte 0
    int = view.getInt32(4, false); // Next int is also big-endian
    int = view.getUint32(8, true); // Next int is little-endian and unsigned
    view.setUint32(8, int, false); // Write it back in big-endian format</code></pre>
    <p>DataView define 10 métodos <codeinline>get</codeinline> para cada una de las 10 clases de matrices tipadas (excluyendo Uint8ClampedArray). Tienen nombres como <codeinline>getInt16()</codeinline>, <codeinline>getUint32()</codeinline>, <codeinline>getBigInt64()</codeinline>, y <codeinline>getFloat64()</codeinline>. El primer argumento es el desplazamiento de bytes dentro del ArrayBuffer en el que comienza el valor. Todos estos métodos getter, excepto <codeinline>getInt8()</codeinline> y <codeinline>getUint8()</codeinline>, aceptan un valor booleano opcional como segundo argumento. Si el segundo argumento se omite o es <codeinline>false</codeinline>, se utiliza el orden big- endian. Si el segundo argumento es <codeinline>true</codeinline>, se utiliza el orden little-endian.</p>
    <p>DataView también define 10 métodos Set correspondientes que escriben valores en el ArrayBuffer subyacente. El primer argumento es el offset en el que comienza el valor. El segundo argumento es el valor a escribir. Cada uno de los métodos, excepto <codeinline>setInt8()</codeinline> y <codeinline>setUint8()</codeinline>, acepta un tercer argumento opcional. Si el argumento se omite o es <codeinline>false</codeinline>, el valor se escribe en formato big-endian con el byte más significativo primero. Si el argumento es <codeinline>true</codeinline>, el valor se escribe en formato little-endian con el byte menos significativo primero.</p>
    <p>Las matrices tipadas y la clase DataView le proporcionan todas las herramientas necesarias para procesar datos binarios y le permiten escribir programas JavaScript que hagan cosas como descomprimir archivos ZIP o extraer metadatos de archivos JPEG.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>11.3 Comparación de patrones con expresiones regulares</h2>
    <p>Una <em>expresión regular</em> es un objeto que describe un patrón textual. La clase RegExp de JavaScript representa expresiones regulares, y tanto String como RegExp definen métodos que utilizan expresiones regulares para realizar potentes funciones de concordancia de patrones y de búsqueda y reemplazo en texto. Sin embargo, para utilizar la API RegExp con eficacia, también debes aprender a describir patrones de texto utilizando la gramática de expresiones regulares, que es esencialmente un mini lenguaje de programación propio. Afortunadamente, la gramática de expresiones regulares de JavaScript es bastante similar a la gramática utilizada por muchos otros lenguajes de programación, por lo que es posible que ya esté familiarizado con ella. (Y si no lo está, el esfuerzo que invierta en aprender las expresiones regulares de JavaScript probablemente le será útil también en otros contextos de programación).</p>
    <p>Las subsecciones que siguen describen primero la gramática de las expresiones regulares, y luego, después de explicar cómo escribir expresiones regulares, explican cómo puedes usarlas con los métodos de las clases String y RegExp.</p>
  </section>
  <section id="3-1">
    <h2>11.3.1 Definición de expresiones regulares</h2>
    <p>En JavaScript, las expresiones regulares se representan mediante objetos RegExp. Los objetos RegExp pueden crearse con el constructor <codeinline>RegExp()</codeinline>, por supuesto, pero suelen crearse utilizando una sintaxis literal especial. Así como los literales de cadena se especifican como caracteres entre comillas, los literales de expresión regular se especifican como caracteres dentro de un par de caracteres de barra (<codeinline>/</codeinline>). Así, su código JavaScript puede contener líneas como ésta:</p>
    <pre>
    <code class="language-js">let pattern = /s$/;</code></pre>
    <p>Esta línea crea un nuevo objeto RegExp y lo asigna a la variable <codeinline>pattern</codeinline>. Este objeto RegExp en particular coincide con cualquier cadena que termine con la letra "s". Este regular podría haberse definido de forma equivalente con el constructor <codeinline>RegExp()</codeinline>, de esta forma:</p>
    <pre>
    <code class="language-js">let pattern = new RegExp("s$");</code></pre>
    <p>Las especificaciones de patrones de expresiones regulares consisten en una serie de caracteres. La mayoría de los caracteres, incluidos todos los alfanuméricos, describen simplemente los caracteres que deben coincidir literalmente. Así, la expresión regular <codeinline>/java/</codeinline> coincide con cualquier cadena que contenga la subcadena "java". Otros caracteres de las expresiones regulares no se comparan literalmente, pero tienen un significado especial. Por ejemplo, la expresión regular <codeinline>/s$/</codeinline> contiene dos caracteres. El primero, "s", coincide literalmente. El segundo, "$", es un metacarácter especial que coincide con el final de una cadena. Así, esta expresión regular coincide con cualquier cadena que contenga la letra "s" como último carácter.</p>
    <p>Como veremos, las expresiones regulares también pueden tener uno o más caracteres de bandera que afectan a su funcionamiento. Los indicadores se especifican a continuación del segundo carácter de barra en las literales RegExp, o como un segundo argumento de cadena para el constructor <codeinline>RegExp()</codeinline>. Si, por ejemplo, quisiéramos buscar cadenas que terminen en "s" o "S", podríamos utilizar la bandera <codeinline>i</codeinline> con nuestra expresión regular para indicar que queremos que no se distinga entre mayúsculas y minúsculas:</p>
    <pre>
    <code class="language-js">let pattern = /s$/i;</code></pre>
    <p>Las siguientes secciones describen los distintos caracteres y metacaracteres utilizados en las expresiones regulares de JavaScript.</p>
    <p class="title-article text-left">Caracteres literales</p>
    <p>Todos los caracteres alfabéticos y dígitos coinciden literalmente en las expresiones regulares. La sintaxis de las expresiones regulares de JavaScript también admite determinados caracteres no alfabéticos mediante secuencias de escape que comienzan con una barra invertida (<codeinline>\</codeinline>). Por ejemplo, la secuencia <codeinline>\n</codeinline> coincide con un carácter literal de nueva línea en una cadena. La <a href="#tabla11-1">Tabla 11-1</a> enumera estos caracteres.</p>
    <div id="tabla11-1" class="flex flex-col items-center">
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">Carácter</td>
            <td class="max-w-lg pl-4">Partidos</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2">Carácter alfanumérico</td>
              <td class="max-w-lg px-4">Itself</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\0</codeinline></td>
              <td class="max-w-lg px-4">El carácter NUL (<codeinline class="md:text-base bg-transparent">\u0000</codeinline>)</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\t</codeinline></td>
              <td class="max-w-lg px-4">Tab (<codeinline class="md:text-base bg-transparent">\u0009</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\n</codeinline></td>
              <td class="max-w-lg px-4">Nueva línea (<codeinline class="md:text-base bg-transparent">\u000A</codeinline>)</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\v</codeinline></td>
              <td class="max-w-lg px-4">Pestaña vertical (<codeinline class="md:text-base bg-transparent">\u000B</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\f</codeinline></td>
              <td class="max-w-lg px-4">Alimentación del formulario (<codeinline class="md:text-base bg-transparent">\u000C</codeinline>)</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\r</codeinline></td>
              <td class="max-w-lg px-4">Retorno de carro (<codeinline class="md:text-base bg-transparent">\u000D</codeinline>)</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\xnn</codeinline></td>
              <td class="max-w-lg px-4">El carácter latino especificado por el número hexadecimal <em>nn</em>; por ejemplo, <codeinline class="md:text-base bg-transparent">\x0A</codeinline> es lo mismo que <codeinline class="md:text-base bg-transparent">\n</codeinline>.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\uxxxx </codeinline></td>
              <td class="max-w-lg px-4">El carácter Unicode especificado por el número hexadecimal <em>xxxx</em>; por ejemplo, <codeinline class="md:text-base bg-transparent">\u0009</codeinline> es lo mismo que <codeinline class="md:text-base bg-transparent">\t</codeinline>.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\u&lbrace;n} </codeinline></td>
              <td class="max-w-lg px-4">El carácter Unicode especificado por el punto de código <em>n</em>, donde <em>n</em> es de uno a seis dígitos hexadecimales entre 0 y 10FFFF. Tenga en cuenta que esta sintaxis sólo se admite en expresiones regulares que utilizan el indicador <em>u</em>.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\cX</codeinline></td>
              <td class="max-w-lg px-4">El carácter de control <em>^X</em>; por ejemplo, <codeinline class="md:text-base bg-transparent">\cJ</codeinline> equivale al carácter de nueva línea <codeinline class="md:text-base bg-transparent">\n</codeinline></td>
            </tr>
        </tbody>
      </table>
    </div>
    <p>Algunos caracteres de puntuación tienen un significado especial en las expresiones regulares. Estos son:</p>
    <pre class="language-js">
    ^ $ . ¡* + ? = ! : | \ / ( ) [ ] &lbrace; }</pre>
    <p>Los significados de estos caracteres se tratan en las secciones siguientes. Algunos de estos caracteres tienen un significado especial sólo en determinados contextos de una expresión regular y se tratan literalmente en otros contextos. Sin embargo, como regla general, s i desea incluir cualquiera de estos caracteres de puntuación literalmente en una expresión regular, debe precederlos de un <codeinline>\</codeinline>. Otros caracteres de puntuación, como las comillas y <codeinline>@</codeinline>, no tienen un significado especial y simplemente coinciden literalmente en una expresión regular.</p>
    <p>Si no recuerda exactamente qué caracteres de puntuación deben escaparse con una barra invertida, puede colocar una barra invertida antes de cualquier carácter de puntuación. Por otro lado, tenga en cuenta que muchas letras y números tienen un significado especial cuando van precedidos de una barra invertida, por lo que las letras o números que desee que coincidan literalmente no deben escaparse con una barra invertida. Para incluir un carácter de barra invertida literalmente en una expresión regular, debe escaparlo con una barra invertida, por supuesto. Por ejemplo, la siguiente expresión regular coincide con cualquier cadena que incluya una barra invertida: <codeinline>/\\/</codeinline>. (Y si usa el constructor <codeinline>RegExp()</codeinline>, tenga en cuenta que cualquier barra invertida en su expresión regular debe ser duplicada, ya que las cadenas también usan barras invertidas como carácter de escape).</p>
    <p class="title-article text-left">Clases de personajes</p>
    <p>Los caracteres literales individuales pueden combinarse en <em>clases de caracteres</em> colocándolos entre corchetes. Una clase de caracteres coincide con cualquier carácter contenido en ella. Así, la expresión regular <codeinline>/[abc]/</codeinline> coincide con cualquiera de las letras a, b o c. También se pueden definir clases de caracteres negados, que coinciden con cualquier carácter excepto los que están entre corchetes. Una clase de caracteres negada se especifica colocando un signo de caret (<codeinline>^</codeinline>) como primer carácter dentro del corchete izquierdo. La RegExp <codeinline>/[^abc]/</codeinline> coincide con cualquier carácter que no sea a, b o c. Las clases de caracteres pueden usar un guión para indicar un rango de caracteres. Para coincidir con cualquier carácter en minúscula del alfabeto latino, use <codeinline>/[a-z]/</codeinline>, y para coincidir con cualquier letra o dígito del alfabeto latino, use <codeinline>/[a-zA- Z0-9]/</codeinline>. (Y si desea incluir un guión real en su clase de caracteres, simplemente hágalo el último carácter antes del corchete derecho).</p>
    <p>Debido a que ciertas clases de caracteres se utilizan comúnmente, la sintaxis de expresiones regulares de JavaScript incluye caracteres especiales y secuencias de escape para representar estas clases comunes. Por ejemplo, <codeinline>\s</codeinline> coincide con el carácter de espacio, el carácter de tabulación y cualquier otro carácter de espacio en blanco Unicode; <codeinline>\S</codeinline> coincide con cualquier carácter que <em>no</em> sea un espacio en blanco Unicode. La <a href="#tabla11-2">Tabla 11-2</a> enumera estos caracteres y resume la sintaxis de las clases de caracteres. (Tenga en cuenta que varias de estas secuencias de escape de clases de caracteres sólo coinciden con caracteres ASCII y no se han ampliado para funcionar con caracteres Unicode. Sin embargo, puede definir explícitamente sus propias clases de caracteres Unicode; por ejemplo, <codeinline>/[\u0400-\u04FF]/</codeinline> coincide con cualquier carácter cirílico).</p>
    <div id="tabla11-2" class="flex flex-col items-center">
      <p><em>Tabla 11-2. Clases de caracteres de expresiones regulares</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">Character</td>
            <td class="max-w-lg pl-4">Matches</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">[...]</codeinline></td>
              <td class="max-w-lg px-4">Un carácter cualquiera entre los corchetes.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">[^...]</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter que no esté entre paréntesis.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">.</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter excepto nueva línea u otro terminador de línea Unicode. O, si la RegExp utiliza el indicador <codeinline class="md:text-base bg-transparent">s</codeinline>, entonces un punto coincide con cualquier carácter, incluidos los terminadores de línea.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\w</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter ASCII de palabra. Equivale a <codeinline class="md:text-base bg-transparent">[a-zA-Z0-9_]</codeinline>.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\W</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter que no sea un carácter de palabra ASCII. Equivale a <codeinline class="md:text-base bg-transparent">[^a-zA-Z0-9_]</codeinline>.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\s</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter Unicode de espacio en blanco.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\S</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter que no sea un espacio en blanco Unicode.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\d</codeinline></td>
              <td class="max-w-lg px-4">Cualquier dígito ASCII. Equivale a <codeinline class="md:text-base bg-transparent">[0-9]</codeinline>.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\D</codeinline></td>
              <td class="max-w-lg px-4">Cualquier carácter que no sea un dígito ASCII. Equivale a <codeinline class="md:text-base bg-transparent">[^0-9]</codeinline>.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">[\b]</codeinline></td>
              <td class="max-w-lg px-4">Un retroceso literal (caso especial).</td>
            </tr>
        </tbody>
      </table>
    </div>
    <p>Tenga en cuenta que los escapes especiales de clase de caracteres pueden utilizarse entre corchetes. <codeinline>\s</codeinline> coincide con cualquier carácter de espacio en blanco, y <codeinline>\d</codeinline> coincide con cualquier dígito, por lo que <codeinline>/[\s\d]/</codeinline> coincide con cualquier carácter de espacio en blanco o dígito. Tenga en cuenta que hay un caso especial. Como verás más adelante, el escape <codeinline>\b</codeinline> tiene un significado especial. Sin embargo, cuando se usa dentro de una clase de caracteres, representa el carácter de retroceso. Así, para representar un carácter de retroceso literalmente en una expresión regular, utilice la clase de caracteres con un elemento: <codeinline>/[\b]/</codeinline>.</p>
    <article>
      <p class="title-article">Clases de caracteres Unicode</p>
      <p>En ES2018, si una expresión regular utiliza el indicador u, se admiten las clases de caracteres <codeinline>\p&lbrace;...}</codeinline> y su negación <codeinline>\P&lbrace;...}</codeinline>. (A partir de principios de 2020, esto se implementa en Node, Chrome, Edge y Safari, pero no en Firefox). Estas clases de caracteres se basan en propiedades definidas por el estándar Unicode, y el conjunto de caracteres que representan puede cambiar a medida que Unicode evoluciona.</p>
      <p>En el momento de escribir este artículo, a principios de 2020, los guiones bajos en literales numéricos aún no están formalmente estandarizados como parte de JavaScript. Pero se encuentran en fases avanzadas del proceso de estandarización y están implementados por los principales navegadores y por Node.</p>
      <p>La clase de caracteres <codeinline>\d</codeinline> sólo coincide con dígitos ASCII. Si desea que coincida con un dígito decimal de cualquiera de los sistemas de escritura del mundo, puede utilizar <codeinline>/\p&lbrace;Decimal_Number}/u</codeinline>.</p>
      <p>Y si quieres que coincida con cualquier carácter que <em>no</em> sea un dígito decimal en cualquier idioma puede escribir la <codeinline>p</codeinline> en mayúsculas y <codeinline>\P&lbrace;Número_Decimal}</codeinline>. Si desea que coincida con cualquier carácter numérico, incluyendo fracciones y números romanos, puede utilizar <codeinline>\p&lbrace;Número}</codeinline>. Tenga en cuenta que "Decimal_Number" y "Number" no son específicos de Java-Script o de la gramática de expresiones regulares: es el nombre de una categoría de caracteres definida por el estándar Unicode.</p>
      <p>La clase de caracteres <codeinline>\w</codeinline> sólo funciona para texto ASCII, pero con <codeinline>\p</codeinline>, podemos aproximarnos a una versión internacionalizada como ésta:</p>
    <pre>
    <code class="language-js">/[\p&lbrace;Alphabetic}\p&lbrace;Decimal_Number}\p&lbrace;Mark}]/u</code></pre>
      <p>(Aunque para ser totalmente compatibles con la complejidad de las lenguas del mundo, realmente necesitamos añadir también las categorías "Conector_Puntuación" y "Join_Control").</p>
      <p>Como último ejemplo, la sintaxis <codeinline>\p</codeinline> también nos permite definir expresiones regulares que coincidan con caracteres de un alfabeto o escritura concretos:</p>
    <pre>
    <code class="language-js">let greekLetter = /\p&lbrace;Script=Greek}/u;
    let cyrillicLetter = /\p&lbrace;Script=Cyrillic}/u;</code></pre>
    </article>
    <p class="title-article text-left">Repetición</p>
    <p>Con la sintaxis de expresiones regulares que ha aprendido hasta ahora, puede describir un número de dos dígitos como <codeinline>/\d\d/</codeinline> y un número de cuatro dígitos como <codeinline>/\d\d\d\d/</codeinline>. Pero no tienes forma de describir, por ejemplo, un número que puede tener cualquier número de dígitos o una cadena de tres letras seguidas de un dígito opcional. Estos patrones más complejos utilizan una sintaxis de expresión regular que especifica cuántas veces se puede repetir un elemento de una expresión regular.</p>
    <p>Los caracteres que especifican la repetición siguen siempre el patrón al que se aplican. Dado que ciertos tipos de repetición se utilizan con bastante frecuencia, existen caracteres especiales para representar estos casos. Por ejemplo, <codeinline>+</codeinline> coincide con una o más repeticiones del patrón anterior.</p>
    <p>La <a href="#tabla11-3">Tabla 11-3</a> resume la sintaxis de repetición.</p>
    <div id="tabla11-3" class="flex flex-col items-center">
      <p><em>Tabla 11-3. Caracteres de repetición de expresiones regulares</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">Carácter</td>
            <td class="max-w-lg pl-4">Significado</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">&lbrace;n,m}</codeinline></td>
              <td class="max-w-lg px-4">Coincide con el elemento anterior al menos <em>n</em> veces pero no más de <em>m</em> veces.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">&lbrace;n,}</codeinline></td>
              <td class="max-w-lg px-4">Coincide con el elemento anterior <em>n</em> o más veces.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">&lbrace;n}</codeinline></td>
              <td class="max-w-lg px-4">Coincide exactamente con <em>n</em> ocurrencias del elemento anterior.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">?</codeinline></td>
              <td class="max-w-lg px-4">Coincide con cero o una ocurrencia del elemento anterior. Es decir, el elemento anterior es opcional. Equivale a <codeinline class="md:text-base bg-transparent">&lbrace;0,1}</codeinline>.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">+</codeinline></td>
              <td class="max-w-lg px-4">Coincide con una o más ocurrencias del elemento anterior. Equivale a <codeinline class="md:text-base bg-transparent">&lbrace;1,}</codeinline>.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">*</codeinline></td>
              <td class="max-w-lg px-4">Coincide con cero o más apariciones del elemento anterior. Equivalente a <codeinline class="md:text-base bg-transparent">&lbrace;0,}</codeinline>.</td>
            </tr>
        </tbody>
      </table>
    </div>
    <p>Las siguientes líneas muestran algunos ejemplos:</p>
    <pre>
    <code class="language-js">let r = /\d&lbrace;2,4}/; // Match between two and four digits
    r = /\w&lbrace;3}\d?/;    // Match exactly three word characters and an optional digit
    r = /\s+java\s+/;  // Match "java" with one or more spaces before and after
    r = /[^(]*/;       // Match zero or more characters that are not open parens</code></pre>
    <p>Tenga en cuenta que en todos estos ejemplos, los especificadores de repetición se aplican al único carácter o clase de caracteres que los precede. Si desea hacer coincidir repeticiones de expresiones más complicadas, tendrá que definir un grupo con paréntesis, que se explican en las secciones siguientes.</p>
    <p>Tenga cuidado al utilizar los caracteres de repetición <codeinline>*</codeinline> y <codeinline>?</codeinline> Dado que estos caracteres pueden coincidir con cero apariciones de lo que les precede, se permite que no coincidan con nada. Por ejemplo, la expresión regular <codeinline>/a*/</codeinline> en realidad coincide con la cadena "bbbb", ¡porque la cadena contiene cero apariciones de la letra a!</p>
    <p class="title-article text-left">Repetición no codiciosa</p>
    <p>Los caracteres de repetición enumerados en la <a href="#tabla11-3">Tabla 11-3</a> coinciden tantas veces como sea posible, permitiendo al mismo tiempo que coincidan las siguientes partes de la expresión regular. Decimos que esta repetición es "codiciosa". También es posible especificar que la repetición se haga de forma no codiciosa. Basta con que el carácter o caracteres de repetición vayan seguidos de un signo de interrogación: <codeinline>??, +?, *?</codeinline>, o incluso <codeinline>&lbrace;1,5}?</codeinline>. Por ejemplo, la expresión regular <codeinline>/a+/</codeinline> coincide con una o más apariciones de la letra a. Cuando se aplica a la cadena "aaa", coincide con las tres letras. Sin embargo, <codeinline>/a+?/</codeinline> coincide con una o varias apariciones de la letra a, con el menor número de caracteres necesario. Cuando se aplica a la misma cadena, este patrón sólo coincide con la primera letra a.</p>
    <p>El uso de la repetición no ávida no siempre produce los resultados esperados. Consideremos el patrón <codeinline>/a+b/</codeinline>, que coincide con una o más a seguidas de la letra b. Cuando se aplica a la cadena "aaab", coincide con toda la cadena. Utilicemos ahora la versión no codiciosa: <codeinline>/a+?b/</codeinline>. Debería coincidir con la letra b precedida por el menor número posible de aes. Cuando se aplica a la misma cadena "aaab", se podría esperar que coincidiera sólo con una a y la última letra b. Sin embargo, en realidad, este patrón coincide con toda la cadena, igual que la versión codiciosa del patrón. Esto se debe a que la coincidencia de patrones de expresiones regulares se realiza encontrando la primera posición en la cadena en la que es posible una coincidencia. Como la coincidencia es posible a partir del primer carácter de la cadena, las coincidencias más cortas a partir de los caracteres siguientes ni siquiera se tienen en cuenta.</p>
    <p class="title-article text-left">Alternancia, agrupación y referencias</p>
    <p>La gramática de las expresiones regulares incluye caracteres especiales para especificar alternativas, agrupar subexpresiones y hacer referencia a subexpresiones anteriores. El carácter <codeinline>|</codeinline> separa alternativas. Por ejemplo, <codeinline>/ab|cd|ef/</codeinline> coincide con la cadena "ab" o la cadena la cadena "cd" o la cadena "ef ". Y <codeinline>/\d&lbrace;3}|[a-z]&lbrace;4}/</codeinline> coincide con tres dígitos o cuatro letras minúsculas.</p>
    <p>Tenga en cuenta que las alternativas se consideran de izquierda a derecha hasta que se encuentra una coincidencia. Si la alternativa de la izquierda coincide, la de la derecha se ignora, aunque hubiera producido una coincidencia "mejor". Así, cuando el patrón <codeinline>/a|ab/</codeinline> se aplica a la cadena "ab", sólo coincide con la primera letra.</p>
    <p>Los paréntesis tienen varias finalidades en las expresiones regulares. Uno de ellos es agrupar elementos separados en una única subexpresión para que los elementos puedan tratarse como una sola unidad mediante <codeinline>|, * , +, ?</codeinline>, etc. Por ejemplo, <codeinline>/java(script)?/</codeinline> coincide con "java" seguido de "script" opcional. Y <codeinline>/(ab|cd)+|ef/</codeinline> coincide con la cadena "ef " o con una o más repeticiones de cualquiera de las cadenas "ab" o "cd".</p>
    <p>Otra finalidad de los paréntesis en las expresiones regulares es definir subpatrones dentro del patrón completo. Cuando una expresión regular se compara con éxito con una cadena objetivo, es posible extraer las partes de la cadena objetivo que coinciden con cualquier sub-patrón entre paréntesis. (Verá cómo se obtienen estas subcadenas coincidentes más adelante en esta sección). Por ejemplo, suponga que está buscando una o más letras minúsculas seguidas de uno o más dígitos. Puede utilizar el patrón <codeinline>/[a-z]+\d+/</codeinline>. . Pero supongamos que sólo le interesan los dígitos del final de cada coincidencia. Si pone esa parte del patrón entre paréntesis (<codeinline>/[a-z]+(\d+)/</codeinline>), podrá extraer los dígitos de cualquier coincidencia que encuentre, como se explica más adelante.</p>
    <p>Un uso relacionado de las subexpresiones entre paréntesis es permitirle referirse a una subexpresión más adelante en la misma expresión regular. Esto se hace siguiendo un carácter <codeinline>\</codeinline> por un dígito o dígitos. Los dígitos se refieren a la posición de la subexpresión entre paréntesis dentro de la expresión regular. Por ejemplo, <codeinline>\1</codeinline> se refiere a la primera subexpresión, y <codeinline>\3</codeinline> a la tercera. Tenga en cuenta que, como las subexpresiones pueden estar anidadas dentro de otras, lo que se cuenta es la posición del paréntesis izquierdo. En la siguiente expresión regular, por ejemplo, la subexpresión anidada (<codeinline>[Ss]cript</codeinline>) se denomina <codeinline>\2</codeinline>:</p>
    <pre>
    <code class="language-js">/([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/</code></pre>
    <p>Una referencia a una subexpresión anterior de una expresión regular <em>no</em> se refiere al patrón de esa subexpresión, sino al texto que coincide con el patrón. Por lo tanto, las referencias se pueden utilizar para imponer la restricción de que partes separadas de una cadena contengan exactamente los mismos caracteres. Por ejemplo, la siguiente expresión regular coincide con cero o más caracteres entre comillas simples o dobles. Sin embargo, no requiere que las comillas de apertura y cierre coincidan (es decir, ambas comillas simples o ambas comillas dobles):</p>
    <pre>
    <code class="language-js">/['"][^'"]*['"]/</code></pre>
    <p>Para que las comillas coincidan, utilice una referencia:</p>
    <pre>
    <code class="language-js">/(['"])[^'"]*\1/</code></pre>
    <p>El <codeinline>\1</codeinline> coincide con lo que coincida con la primera subexpresión entre paréntesis. En este ejemplo, impone la restricción de que la comilla de cierre coincida con la comilla de apertura. Esta expresión regular no permite comillas simples dentro de cadenas con comillas dobles o viceversa. (No es legal utilizar una referencia dentro de una clase de caracteres, por lo que no puede escribir: <codeinline>/(['"])[^\1]*\1/</codeinline>.)</p>
    <p>Cuando cubramos la API RegExp más adelante, verás que este tipo de referencia a una subexpresión de tamaño par es una poderosa característica de las operaciones de búsqueda y reemplazo de expresiones regulares.</p>
    <p>También es posible agrupar elementos en una expresión regular sin crear una referencia numerada a dichos elementos. En lugar de agrupar simplemente los elementos dentro de ( y ), comience el grupo con (<codeinline>?:</codeinline> y termínelo con ). Considere el siguiente patrón:</p>
    <pre>
    <code class="language-js">/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/</code></pre>
    <p>En este ejemplo, la subexpresión (<codeinline>?:[Ss]cript</codeinline>) se utiliza simplemente para agrupar, por lo que el carácter de repetición <codeinline>?</codeinline> puede aplicarse al grupo. Estos paréntesis modificados no producen una referencia, por lo que en esta expresión regular, <codeinline>\2</codeinline> se refiere al texto coincidente con (<codeinline>fun\w*</codeinline>).</p>
    <p>La <a href="#tabla11-3">Tabla 11-4</a> resume los operadores de alternancia, agrupación y referenciación de expresiones regulares.</p>
    <div id="tabla11-4" class="flex flex-col items-center">
      <p><em>Tabla 11-4. Caracteres de alternancia, agrupación y referencia de expresiones regulares</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">Carácter</td>
            <td class="max-w-lg pl-4">Significado</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">|</codeinline></td>
              <td class="max-w-lg px-4">Alternancia: coincide con la subexpresión de la izquierda o con la subexpresión de la derecha.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">(...)</codeinline></td>
              <td class="max-w-lg px-4">Agrupación: agrupa los elementos en una sola unidad que puede utilizarse con *
                , +, ?, |, etc. Recuerde
                también los caracteres que coinciden con este grupo para utilizarlos con referencias posteriores.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">(?:...)</codeinline></td>
              <td class="max-w-lg px-4">Sólo agrupación: agrupa los elementos en una sola unidad, pero no recuerda los caracteres que coinciden con este grupo.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\n</codeinline></td>
              <td class="max-w-lg px-4">Coinciden con los mismos caracteres que coincidieron cuando el grupo número <em>n</em> coincidió por primera vez. Los grupos son subexpresiones dentro de paréntesis (posiblemente anidados). Los números de grupo se asignan contando los paréntesis d e izquierda a derecha. Los grupos formados con (<codeinline class="md:text-base bg-transparent">?:</codeinline> no se numeran.</td>
            </tr>
        </tbody>
      </table>
    </div>
    <article>
      <p class="title-article">Grupos de captura con nombre</p>
      <p>EES2018 estandariza una nueva característica que puede hacer que las expresiones regulares sean más autodocumentables y fáciles de entender. Esta nueva característica se conoce como "grupos de captura con nombre" y nos permite asociar un nombre a cada paréntesis izquierdo de una expresión regular para que podamos referirnos al texto coincidente por su nombre en lugar de por su número. Igualmente importante: el uso de nombres permite que alguien que lea el código comprenda más fácilmente el propósito de esa parte de la expresión regular. A principios de 2020, esta función está implementada en Node, Chrome, Edge y Safari, pero aún no en Firefox.</p>
      <p>Para nombrar un grupo, utilice <codeinline>(?&lt;...></codeinline> en lugar de <codeinline>(</codeinline> y ponga el nombre entre el ángulo corchetes. Por ejemplo, he aquí una expresión regular que podría utilizarse para comprobar el formato de la última línea de una dirección postal de EE.UU:</p>
    <pre>
    <code class="language-js">/(?&lt;city>\w+) (?&lt;state>[A-Z]&lbrace;2}) (?&lt;zipcode>\d&lbrace;5})(?<zip9>-\d&lbrace;4})?/</code></pre>
      <p>Observe cuánto contexto proporcionan los nombres de grupo para hacer la expresión regular más fácil de entender. En <a href="#3-2">§11.3.2</a>, cuando discutamos los métodos String <codeinline>replace()</codeinline> y <codeinline>match()</codeinline> y el método RegExp <codeinline>exec()</codeinline>, verá cómo la API RegExp le permite referirse al texto que coincide con cada uno de estos grupos por su nombre en lugar de por su posición.</p>
      <p>Si desea hacer referencia a un grupo de captura con nombre dentro de una expresión regular, también puede hacerlo por nombre. En el ejemplo anterior, pudimos usar una expresión regular "backreference" para escribir una RegExp que coincidiera con una cadena entre comillas simples o dobles donde las comillas de apertura y cierre tuvieran que coincidir. Podríamos reescribir esta RegExp usando un grupo de captura con nombre y una backreference con nombre como esta:</p>
    <pre>
    <code class="language-js">/(?&lt;quote>['"])[^'"]*\k&lt;quote>/</code></pre>
      <p>El <codeinline>\k&lt;quote></codeinline> es una referencia al grupo con nombre que captura la comilla abierta.</p>
    </article>
    <p class="title-article text-left">Especificación de la posición del partido</p>
    <p>Como se ha descrito anteriormente, muchos elementos de una expresión regular coinciden con un único carácter de una cadena. Por ejemplo, <codeinline>\s</codeinline> coincide con un único carácter de espacio en blanco. Otros elementos de expresiones regulares coinciden con las posiciones entre caracteres en lugar de con caracteres reales. <codeinline>\b</codeinline>, por ejemplo, coincide con un límite de palabra ASCII -el límite entre un <codeinline>\w</codeinline> (carácter de palabra ASCII) y un <codeinline>\W</codeinline> (carácter no-palabra), o el límite entre un carácter de palabra ASCII y el principio o final de una cadena.<sup>4</sup> Elementos como <codeinline>\b</codeinline> no especifican ningún carácter a utilizar en una cadena coincidente; lo que sí especifican, sin embargo, son posiciones legales en las que puede ocurrir una coincidencia. A veces, estos elementos se denominan <em>anclas de expresión regular</em> porque anclan el patrón a una posición específica en la cadena de búsqueda. Los elementos de anclaje más utilizados son <codeinline>^</codeinline>, que ancla el patrón al principio de la cadena, y <codeinline>$</codeinline>, que ancla el patrón al final de la cadena.</p>
    <p>Por ejemplo, para buscar la palabra "JavaScript" sola en una línea, puede utilizar la expresión regu- lar <codeinline>/^JavaScript$/</codeinline>. Si desea buscar "Java" como palabra en sí misma (no como prefijo, como ocurre con "JavaScript"), puede probar con el patrón <codeinline>/\sJava\s/</codeinline>, que requiere un espacio antes y después de la palabra. Pero esta solución tiene dos problemas. En primer lugar, no coincide con "Java" al principio o al final de una cadena, sino sólo si aparece con un espacio a cada lado. En segundo lugar, cuando este patrón encuentra una coincidencia, el que devuelve tiene espacios iniciales y finales, que no es exactamente lo que se necesita. Así que en lugar de coincidir con los caracteres de espacio reales con <codeinline>\s</codeinline>, coincide (o ancla a) los límites de la palabra con <codeinline>\b</codeinline>. La expresión resultante es <codeinline>/\bJava\b/</codeinline>. El elemento <codeinline>\B</codeinline> ancla la coincidencia a un lugar que no es un límited e palabra. Así, el patrón <codeinline>/\B[Ss]cript/</codeinline> coincide con "JavaScript" y "postscript", pero no con "script" o "Scripting".</p>
    <p>También puede utilizar expresiones regulares arbitrarias como condiciones de anclaje. Si incluye una expresión dentro de caracteres (<codeinline>?=</codeinline> y ), se trata de una aserción lookahead, y especifica que los caracteres incluidos deben coincidir, sin coincidir realmente con ellos. Por ejemplo, para que coincida con el nombre de un lenguaje de programación común, pero sólo si va seguido de dos puntos, puede utilizar <codeinline>/[Jj]ava([Ss]cript)?(?=\:)/</codeinline>. Este patrón coincide con la palabra "JavaScript" en "JavaScript: The Definitive Guide", pero no coincide con "Java" en "Java in a Nutshell" porque no va seguida de dos puntos.</p>
    <p>Si, por el contrario, introduce una aserción con <codeinline>(?!</codeinline>, se trata de una aserción lookahead negativa, que especifica que los caracteres siguientes no deben coincidir. Por ejemplo, <codeinline>/Java(?! Script)([A-Z]\w*)/</codeinline> coincide con "Java" seguido de una letra mayúscula y cualquier número de caracteres ASCII adicionales, siempre que "Java" no vaya seguido de "Script". Coincide con "JavaBeans" pero no con "Javanese", y coincide con "JavaScrip" pero no con "Java- Script" o "JavaScripter". En la Tabla <a href="#tabla11-5">11-5</a> se resumen las anclas de expresiones regulares.</p>
    <div id="tabla11-5" class="flex flex-col items-center">
      <p><em>Tabla 11-5. Caracteres de anclaje de expresiones regulares</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg pl-4">Carácter</td>
            <td class="max-w-lg pl-4">Significado</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">^</codeinline></td>
              <td class="max-w-lg px-4">Coincide con el principio de la cadena o, con el indicador <codeinline class="md:text-base bg-transparent">m</codeinline>, con el principio de una línea.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">$</codeinline></td>
              <td class="max-w-lg px-4">Coincide con el final de la cadena y, con la bandera <codeinline class="md:text-base bg-transparent">m</codeinline>, con el final de una línea.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\b</codeinline></td>
              <td class="max-w-lg px-4">Coincide con el límite de una palabra. Es decir, coincide con la posición entre un carácter <codeinline class="md:text-base bg-transparent">\w</codeinline> y un carácter <codeinline class="md:text-base bg-transparent">\W</codeinline> o entre un carácter <codeinline class="md:text-base bg-transparent">\w</codeinline> y el principio o el final de una cadena. (Tenga en cuenta, sin embargo, que <codeinline class="md:text-base bg-transparent">[\b]</codeinline> coincide con retroceso).</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">\B</codeinline></td>
              <td class="max-w-lg px-4">Coincide con una posición que no es un límite de palabra.</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">(?=p)</codeinline></td>
              <td class="max-w-lg px-4">Una aserción de búsqueda positiva. Requiere que los siguientes caracteres coincidan con el patrón <em>p</em>, pero no los incluye en la coincidencia.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-2"><codeinline class="md:text-base bg-transparent">(?!p)</codeinline></td>
              <td class="max-w-lg px-4">Una aserción lookahead negativa. Requiere que los siguientes caracteres no coincidan con el patrón <em>p</em>.</td>
            </tr>
        </tbody>
      </table>
    </div>
    <article>
      <p class="title-article">Aserciones Lookbehind</p>
      <p>ES2018 amplía la sintaxis de las expresiones regulares para permitir aserciones "lookbehind". Son como las aserciones lookahead, pero se refieren al texto anterior a la posición de coincidencia actual. A principios de 2020, se implementarán en Node, Chrome y Edge, pero no en Firefox ni Safari.</p>
      <p>Especifique una aserción lookbehind positiva con <codeinline>(?&lt;=...)</codeinline> y una aserción lookbehind negativa con <codeinline>(?&lt;!...)</codeinline>. Por ejemplo, si trabaja con el correo de EE.UU.puede coincidir con un código postal de 5 dígitos, pero sólo si sigue a un código de dos letras. abreviatura del estado, así:</p>
    <pre>
    <code class="language-js">/(?&lt;= [A-Z]&lbrace;2} )\d&lbrace;5}/</code></pre>
      <p>Y podría hacer coincidir una cadena de dígitos que no esté precedida por un símbolo de moneda Unicode con una aserción lookbehind negativa como ésta:</p>
    <pre>
    <code class="language-js">/(?&lt;![\p&lbrace;Currency_Symbol}\d.])\d+(\.\d+)?/u</code></pre>
    </article>
    <p class="title-article text-left">Flags</p>
    <p>Cada expresión regular puede tener uno o varios indicadores asociados para modificar su comportamiento. JavaScript define seis indicadores posibles, cada uno de los cuales se representa con una sola letra. Los indicadores se especifican después del segundo carácter <codeinline>/</codeinline> de una expresión regular literal o como una cadena que se pasa como segundo argumento al constructor <codeinline>RegExp()</codeinline>. Los indicadores admitidos y sus significados son:</p>
    <p><codeinline>g</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La bandera <codeinline>g</codeinline> indica que la expresión regular es "global"-es decir, que pretendemos usarla para encontrar todas las coincidencias dentro de una cadena en lugar de sólo encontrar la primera coincidencia. Esta bandera no altera la forma en que se realiza la concordancia de patrones, pero, como veremos más adelante, sí altera el comportamiento del método String <codeinline>match()</codeinline> y del método RegExp <codeinline>exec()</codeinline> de forma importante.</p>
    <p><codeinline>i</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La bandera <codeinline>i</codeinline> especifica que la coincidencia de patrones no debe distinguir entre mayúsculas y minúsculas.</p>
    <p><codeinline>m</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">El indicador <codeinline>m</codeinline> especifica que la búsqueda debe realizarse en modo "multilínea". Indica que la RegExp se utilizará con cadenas multilínea y que las anclas <codeinline>^</codeinline> y <codeinline>$</codeinline> deben coincidir tanto con el principio y el final de la cadena como con el principio y el final de líneas individuales dentro de la cadena.</p>
    <p><codeinline>s</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">Al igual que el indicador <codeinline>m</codeinline>, el indicador <codeinline>s</codeinline> también es útil cuando se trabaja con texto que incluye líneas nuevas. Normalmente, una "." en una expresión regular coincide con cualquier carácter excepto con un terminador de línea. Sin embargo, cuando se utiliza el indicador <codeinline>s</codeinline>, "." coincide con cualquier carácter, incluidos los terminadores de línea. La bandera <codeinline>s</codeinline> se añadió a JavaScript en ES2018 y, desde principios de 2020, es compatible con Node, Chrome, Edge y Safari, pero no con Firefox.</p>
    <p><codeinline>u</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La bandera <codeinline>u</codeinline> significa Unicode, y hace que la expresión regular coincida con puntos de código Unicode completos en lugar de coincidir con valores de 16 bits. Esta bandera fue introducida en ES6, y debería acostumbrarse a usarla en todas las expresiones regulares a menos que tenga alguna razón para no hacerlo. Si no usa esta bandera, sus RegExps serán no funciona bien con texto que incluya emoji y otros caracteres (incluidos muchos caracteres chinos) que requieran más de 16 bits. Sin el indicador <codeinline>u</codeinline>, el carácter "." coincide con cualquier valor UTF-16 de 16 bits. Sin embargo, con el indicador, "." coincide con un punto de código Unicode, incluidos los que tienen más de 16 bits. Establecer el indicador <codeinline>u</codeinline> en una RegExp también le permite usar la nueva secuencia de escape <codeinline>\u&lbrace;...}</codeinline> para caracteres Unicode y también habilita la notación <codeinline>\p&lbrace;...}</codeinline> para clases de caracteres Unicode.</p>
    <p><codeinline>y</codeinline></p>
    <p class="pl-6 xs:pl-7 sm:pl-8 md:pl-9">La bandera <codeinline>y</codeinline> indica que la expresión regular es "pegajosa" y debe coincidir al principio de una cadena o en el primer carácter después de la coincidencia anterior. Cuando se utiliza con una expresión regular diseñada para encontrar una única coincidencia, trata dicha expresión regular como si empezara por <codeinline>^</codeinline> para anclarla al principio de la cadena. Esta bandera es más útil con expresiones regulares que se utilizan repetidamente para encontrar todas las coincidencias dentro de una cadena. En este caso, provoca un comportamiento especial del método String <codeinline>match()</codeinline> y del método RegExp <codeinline>exec()</codeinline> para forzar que cada coincidencia subsiguiente se ancle a la posición de la cadena en la que terminó la última.</p>
    <p>Estos indicadores pueden especificarse en cualquier combinación y en cualquier orden. Por ejemplo, si desea que su expresión regular sea compatible con Unicode para que no distinga entre mayúsculas y minúsculas y desea utilizarla para encontrar múltiples coincidencias dentro de una cadena, deberá especificar los indicadores <codeinline>uig</codeinline>, <codeinline>gui</codeinline> o cualquier otra permutación de estas tres letras.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>11.3.2 Métodos de cadena para la concordancia de patrones</h2>
    <p>Hasta ahora, hemos estado describiendo la gramática usada para definir expresiones regulares, pero no explicando cómo esas expresiones regulares pueden usarse realmente en código JavaScript. Ahora pasamos a cubrir la API para usar objetos RegExp. Esta sección comienza explicando los métodos de cadena que usan expresiones regulares para realizar operaciones de coincidencia de patrones y de buscar y reemplazar. Las secciones que siguen a esta continúan la discusión de la concordancia de patrones con expresiones regulares de JavaScript discutiendo el objeto RegExp y sus métodos y propiedades.</p>
    <p class="title-article text-left">search()</p>
    <p>Las cadenas admiten cuatro métodos que utilizan expresiones regulares. El más sencillo es <codeinline>search()</codeinline>. Este método toma un argumento de expresión regular y devuelve la posición del carácter del inicio de la primera subcadena coincidente o -1 si no hay coincidencia:</p>
    <pre>
    <code class="language-js">"JavaScript".search(/script/ui) // => 4
    "Python".search(/script/ui) // => -1</code></pre>
    <p>Si el argumento de <codeinline>search()</codeinline> no es una expresión regular, primero se convierte en una pasándola al constructor <codeinline>RegExp</codeinline>. <codeinline>search()</codeinline> no admite búsquedas globales; ignora la bandera <codeinline>g</codeinline> de su argumento de expresión regular.</p>
    <p class="title-article text-left">replace()</p>
    <p>El método replace() realiza una operación de búsqueda y sustitución. Toma una expresión regular como primer argumento y una cadena de sustitución como segundo. Busca en la cadena a la que se llama coincidencias con el patrón especificado. Si la expresión regular tiene el indicador g activado, el método replace() sustituye todas las coincidencias de la cadena por la cadena de sustitución; en caso contrario, sólo sustituye la primera coincidencia que encuentra. Si el primer argumento de replace() es una cadena en lugar de una expresión regular, el método busca esa cadena literalmente en lugar de convertirla en una expresión regular con el constructor RegExp(), como hace search(). Como ejemplo, puede utilizar replace() de la siguiente manera para proporcionar mayúsculas y minúsculas uniformes de la palabra "JavaScript" a lo largo de una cadena de texto:</p>
    <pre>
    <code class="language-js">// No matter how it is capitalized, replace it with the correct capitalization
    text.replace(/javascript/gi, "JavaScript");</code></pre>
    <p>Sin embargo, replace() es más potente que esto. Recuerde que las subexpresiones entre paréntesis de una expresión regular se numeran de izquierda a derecha y que la expresión regular recuerda el texto con el que coincide cada subexpresión. Si en la cadena de sustitución aparece un $ seguido de un dígito, replace() sustituye esos dos caracteres por el texto que coincide con la subexpresión especificada. Se trata de una función muy útil. Puede utilizarla, por ejemplo, para sustituir las comillas de una cadena por otros caracteres:</p>
    <pre>
    <code class="language-js">// A quote is a quotation mark, followed by any number of
    // nonquotation mark characters (which we capture), followed
    // by another quotation mark.
    let quote = /"([^"]*)"/g;
    // Replace the straight quotation marks with guillemets
    // leaving the quoted text (stored in $1) unchanged.
    'He said "stop"'.replace(quote, '«$1»') // => 'He said «stop»'</code></pre>
    <p>Si su RegExp utiliza grupos de captura con nombre, entonces puede referirse al texto coincidente por nombre en lugar de por número:</p>
    <pre>
    <code class="language-js">let quote = /"(?<quotedText>[^"]*)"/g;
    'He said "stop"'.replace(quote, '«$<quotedText>»') // => 'He said «stop»'</code></pre>
    <p>En lugar de pasar una cadena de sustitución como segundo argumento a replace(), también puede pasar una función que se invocará para calcular el valor de sustitución. La función de sustitución se invoca con varios argumentos. El primero es el texto completo. A continuación, si la RegExp tiene grupos de captura, se pasan como argumentos las subcadenas capturadas por esos grupos. El siguiente argumento es la posición dentro de la cadena en la que se encontró la coincidencia. A continuación, se pasa la cadena completa sobre la que se llamó a replace(). Y finalmente, si la RegExp contenía algún nombre grupos de captura, el último argumento de la función de sustitución es un objeto cuyos nombres de propiedad coinciden con los nombres de los grupos de captura y cuyos valores son el texto coincidente. Como ejemplo, he aquí un código que utiliza una función de sustitución para convertir enteros decimales de una cadena a hexadecimal:</p>
    <pre>
    <code class="language-js">let s = "15 times 15 is 225";
    s.replace(/\d+/gu, n => parseInt(n).toString(16)) // => "f times f is e1"</code></pre>
    <p class="title-article text-left">match()</p>
    <p>El método match() es el más general de los métodos de expresión regular de cadenas. Toma una expresión regular como único argumento (o convierte su argumento en una expresión regular pasándolo al constructor RegExp()) y devuelve una matriz que contiene los resultados de la coincidencia, o null si no se encuentra ninguna coincidencia. Si la expresión regular tiene el indicador g activado, el método devuelve una matriz con todas las coincidencias que aparecen en la cadena. Por ejemplo:</p>
    <pre>
    <code class="language-js">"7 plus 8 equals 15".match(/\d+/g) // => ["7", "8", "15"]</code></pre>
    <p>Si la expresión regular no tiene activada la bandera g, match() no realiza una búsqueda global; simplemente busca la primera coincidencia. En este caso no global, match() sigue devolviendo una matriz, pero los elementos de la matriz son completamente diferentes. Sin el indicador g, el primer elemento de la matriz devuelta es la cadena coincidente, y los elementos restantes son las subcadenas que coinciden con los grupos de captura entre paréntesis de la expresión regular. Así, si match() devuelve una matriz a, a[0] contiene la coincidencia completa, a[1] contiene la subcadena que coincide con la primera expresión entre paréntesis, y así sucesivamente. Para establecer un paralelismo con el método replace(), a[1] es la misma cadena que $1, a[2] es la misma que $2, y así sucesivamente.</p>
    <p>Por ejemplo, analice una URL5 con el siguiente código:</p>
    <pre>
    <code class="language-js">// A very simple URL parsing RegExp
    let url = /(\w+):\/\/([\w.]+)\/(\S*)/;
    let text = "Visit my blog at http://www.example.com/~david";
    let match = text.match(url);
    let fullurl, protocol, host, path;
    if (match !== null) &lbrace;
      fullurl = match[0]; // fullurl == "http://www.example.com/~david"
      protocol = match[1]; // protocol == "http"
      host = match[2]; // host == "www.example.com"
      path = match[3]; // path == "~david"
    }</code></pre>
    <p>En este caso no global, la matriz devuelta por match() también tiene algunas propiedades de objeto además de los elementos numerados de la matriz. La propiedad input se refiere a la cadena sobre la que se ha llamado a match(). La propiedad index es la posición dentro de esa cadena en la que comienza la coincidencia. Y si la expresión regular contiene grupos de captura con nombre, entonces el array devuelto también tiene una propiedad groups cuyo valor es un objeto. Las propiedades de este objeto coinciden con los nombres de los grupos nombrados, y los valores son el texto coincidente. Podríamos reescribir el ejemplo anterior de análisis de URL, por ejemplo, así:</p>
    <pre>
    <code class="language-js">let url = /(?&lt;protocol>\w+):\/\/(?&lt;host>[\w.]+)\/(?&lt;path>\S*)/;
    let text = "Visit my blog at http://www.example.com/~david";
    let match = text.match(url);
    match[0] // => "http://www.example.com/~david"
    match.input // => text
    match.index // => 17
    match.groups.protocol // => "http"
    match.groups.host // => "www.example.com"
    match.groups.path // => "~david"</code></pre>
    <p>Hemos visto que match() se comporta de forma bastante diferente dependiendo de si la RegExp tiene el indicador g activado o no. También hay diferencias importantes pero menos dramáticas en el comportamiento cuando la bandera y está activada. Recuerde que la bandera y hace que una expresión regular sea "pegajosa" al restringir en qué parte de la cadena pueden comenzar las coincidencias. Si una RegExp tiene los indicadores g e y activados, match() devuelve una matriz de cadenas coincidentes, igual que cuando g está activada sin y. Pero la primera coincidencia debe comenzar al principio de la cadena, y cada coincidencia posterior debe comenzar en el carácter inmediatamente posterior a la coincidencia anterior.</p>
    <p>Si el indicador y se establece sin g, entonces match() intenta encontrar una única coincidencia y, por defecto, esta coincidencia se limita al inicio de la cadena. Sin embargo, puede cambiar esta posición de inicio por defecto, estableciendo la propiedad lastIndex del objeto RegExp en el índice en el que desea encontrar la coincidencia. Si se encuentra una coincidencia, entonces este lastIndex se actualizará automáticamente al primer carácter después de la coincidencia, de modo que si vuelve a llamar a match(), en este caso, buscará una coincidencia posterior. (lastIndex puede parecer un nombre extraño para una propiedad que especifica la posición en la que comenzar la siguiente coincidencia. Lo veremos de nuevo cuando cubramos el método RegExp exec(), y su nombre puede tener más sentido en ese contexto).</p>
    <pre>
    <code class="language-js">let vowel = /[aeiou]/y; // Sticky vowel match
    "test".match(vowel) // => null: "test" does not begin with a vowel
    vowel.lastIndex = 1; // Specify a different match position
    "test".match(vowel)[0] // => "e": we found a vowel at position 1
    vowel.lastIndex // => 2: lastIndex was automatically updated
    "test".match(vowel) // => null: no vowel at position 2
    vowel.lastIndex // => 0: lastIndex gets reset after failed match</code></pre>
    <p>Cabe señalar que pasar una expresión regular no global al mé todo match() de una cadena es lo mismo que pasar la cadena al método exec() de la expresión regular: la matriz devuelta y sus propiedades son las mismas en ambos casos.</p>
    <p class="title-article text-left">matchAll()</p>
    <p>El método matchAll() está definido en ES2020, y desde principios de 2020 está implementado por los navegadores web modernos y Node. matchAll() espera una RegExp con la bandera g activada. Sin embargo, en lugar de devolver una matriz de subcadenas coincidentes como hace match(), devuelve un iterador que devuelve el tipo de objetos coincidentes que devuelve match() cuando se usa con una RegExp no global. Esto hace que matchAll() sea la forma más sencilla y general de recorrer todas las coincidencias de una cadena.</p>
    <p>Puede utilizar matchAll() para recorrer en bucle las palabras de una cadena de texto como ésta:</p>
    <pre>
    <code class="language-js">// One or more Unicode alphabetic characters between word boundaries
    const words = /\b\p&lbrace;Alphabetic}+\b/gu; // \p is not supported in Firefox yet
    const text = "This is a naïve test of the matchAll() method.";
    for(let word of text.matchAll(words)) &lbrace;
      console.log(`Found '$&lbrace;word[0]}' at index $&lbrace;word.index}.`);
    }</code></pre>
    <p>Puede establecer la propiedad lastIndex de un objeto RegExp para decirle a matchAll() en qué índice de la cadena debe empezar a coincidir. Sin embargo, a diferencia de los otros métodos de concordancia de patrones, matchAll() nunca modifica la propiedad lastIndex del RegExp al que se llama, y esto hace que sea mucho menos probable que cause errores en el código.</p>
    <p class="title-article text-left">split()</p>
    <p>El último de los métodos de expresión regular del objeto String es split(). Este método divide la cadena sobre la que se llama en una matriz de subcadenas, utilizando el argumento como separador. Puede utilizarse con un argumento de cadena como éste:</p>
    <pre>
    <code class="language-js">"123,456,789".split(",") // => ["123", "456", "789"]</code></pre>
    <p>El método split() también puede tomar una expresión regular como argumento, lo que permite especificar separadores más generales. Aquí lo llamamos con un separador que incluye una cantidad arbitraria de espacios en blanco a cada lado:</p>
    <pre>
    <code class="language-js">"1, 2, 3,\n4, 5".split(/\s*,\s*/) // => ["1", "2", "3", "4", "5"]</code></pre>
    <p>Sorprendentemente, si llama a split() con un delimitador RegExp y la expresión regular incluye grupos de captura, el texto que coincida con los grupos de captura se incluirá en la matriz devuelta. Por ejemplo:</p>
    <pre>
    <code class="language-js">const htmlTag = /&lt;([^>]+)>/; // &lt; followed by one or more non->, followed by >
    "Testing<br/>1,2,3".split(htmlTag) // => ["Testing", "br/", "1,2,3"]</code></pre>
  </section>
  <section id="3-3">
    <h2>11.3.3 La clase RegExp</h2>
    <p>Esta sección documenta el constructor RegExp(), las propiedades de las instancias RegExp y dos importantes métodos de concordancia de patrones definidos por la clase RegExp</p>
    <p>El constructor RegExp() toma uno o dos argumentos de cadena y crea un nuevo objeto RegExp. El primer argumento de este constructor es una cadena que contiene el cuerpo de la expresión regular-el texto que aparecería entre barras en un literal de expresión regular. Tenga en cuenta que tanto los literales de cadena como las expresiones regulares utilizan el carácter \ para las secuencias de escape, por lo que cuando pase una expresión regular a RegExp() como un literal de cadena, debe sustituir cada carácter \ por \\. El segundo argumento de RegExp() es opcional. Si se proporciona, indica los indicadores de la expresión regular. Debe ser g, i, m, s, u, y, o cualquier combinación de estas letras.</p>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js">// Find all five-digit numbers in a string. Note the double \\ in this case.
    let zipcode = new RegExp("\\d&lbrace;5}", "g");</code></pre>
    <p>El constructor RegExp() es útil cuando una expresión regular se crea dinámicamente y, por tanto, no puede representarse con la sintaxis literal de expresión regular. Por ejemplo, para buscar una cadena introducida por el usuario, debe crearse una expresión regular en tiempo de ejecución con RegExp().</p>
    <p>En lugar de pasar una cadena como primer argumento a RegExp(), también puede pasar un objeto RegExp. Esto le permite copiar una expresión regular y cambiar sus indicadores:</p>
    <pre>
    <code class="language-js">let exactMatch = /JavaScript/;
    let caseInsensitive = new RegExp(exactMatch, "i");</code></pre>
    <p class="title-article text-left">Propiedades RegExp</p>
    <p><codeinline>source</codeinline></p>
    <p>Esta propiedad de sólo lectura es el texto fuente de la expresión regular: los caracteres que aparecen entre las barras en un literal RegExp.</p>
    <p><codeinline>flags</codeinline></p>
    <p>Esta propiedad de sólo lectura es una cadena que especifica el conjunto de letras que representan las banderas para la RegExp.</p>
    <p><codeinline>global</codeinline></p>
    <p>Propiedad booleana de sólo lectura que es verdadera si el indicador g está activado.</p>
    <p><codeinline>ignoreCase</codeinline></p>
    <p>Propiedad booleana de sólo lectura que es verdadera si el indicador i está activado.</p>
    <p><codeinline>multiline</codeinline></p>
    <p>Propiedad booleana de sólo lectura que es verdadera si el indicador m está activado.</p>
    <p><codeinline>dotAll</codeinline></p>
    <p>Una propiedad booleana de sólo lectura que es verdadera si el indicador s está activado.</p>
    <p><codeinline>unicode</codeinline></p>
    <p>Propiedad booleana de sólo lectura que es verdadera si el indicador u está activado.</p>
    <p><codeinline>unicode</codeinline></p>
    <p>Una propiedad booleana de sólo lectura que es verdadera si el indicador y está activado.</p>
    <p><codeinline>lastIndex</codeinline></p>
    <p>Esta propiedad es un entero de lectura/escritura. Para los patrones con los indicadores g o y, especifica la posición del carácter en la que debe comenzar la siguiente búsqueda. Es utilizada por los métodos exec() y test(), descritos en las dos subsecciones siguientes.</p>
    <p class="title-article text-left">test()</p>
    <p>El método test() de la clase RegExp es la forma más sencilla de utilizar una expresión regular. Toma un único argumento de cadena y devuelve verdadero si la cadena coincide con el patrón o falso si no coincide.</p>
    <p>test() funciona simplemente llamando al método exec() (mucho más complicado) descrito en la siguiente sección y devolviendo true si exec() devuelve un valor no nulo. Debido a esto, si usa test() con un RegExp que usa las banderas g o y, entonces su comportamiento depende del valor de la propiedad lastIndex del objeto RegExp, que puede cambiar inesperadamente. Vea "La propiedad lastIndex y la reutilización de RegExp" en la página 299 para más detalles.</p>
    <p class="title-article text-left">exec()</p>
    <p>El método RegExp exec() es la forma más general y potente de utilizar expresiones regulares. Toma un único argumento de cadena y busca una coincidencia en esa cadena. Si no encuentra ninguna, devuelve null. Sin embargo, si se encuentra una coincidencia, devuelve una matriz igual a la devuelta por el método match() para búsquedas no globales. El elemento 0 de la matriz contiene la cadena que coincide con la expresión regular, y cualquier elemento subsiguiente de la matriz contiene las subcadenas que coinciden con cualquier grupo de captura. La matriz devuelta también tiene propiedades con nombre: la propiedad index contiene la posición del carácter en la que se produjo la coincidencia, y la propiedad input especifica la cadena en la que se buscó, y la propiedad groups, si está definida, se refiere a un objeto que contiene las subcadenas que coinciden con cualquier grupo de captura con nombre.</p>
    <p>A diferencia del método String match(), exec() devuelve el mismo tipo de matriz tanto si la expresión regular tiene el indicador global g como si no. Recuerde que match() devuelve una matriz de coincidencias cuando se le pasa una expresión regular global. exec(), por el contrario, siempre devuelve una única coincidencia y proporciona información completa sobre esa coincidencia. Cuando exec() es llamada sobre una expresión regular que tiene la bandera global g o la bandera pegajosa y, consulta la propiedad lastIndex del objeto RegExp para determinar dónde empezar a buscar una coincidencia. (Y si la bandera y está activada, también restringe la coincidencia a comienza en esa posición). Para un objeto RegExp recién creado, lastIndex es 0, y la búsqueda comienza al principio de la cadena. Pero cada vez que exec() encuentra una coincidencia, actualiza la propiedad lastIndex al índice del carácter inmediatamente posterior al texto coincidente. Si exec() no encuentra ninguna coincidencia, restablece lastIndex a 0. Este comportamiento especial le permite llamar a exec() repetidamente para recorrer todas las coincidencias de expresiones regulares en una cadena. (Aunque, como hemos descrito, en ES2020 y posteriores, el método matchAll() de String es una forma más fácil de recorrer todas las coincidencias). Por ejemplo, el bucle en el siguiente código se ejecutará dos veces:</p>
    <pre>
    <code class="language-js">let pattern = /Java/g;
    let text = "JavaScript > Java";
    let match;
    while((match = pattern.exec(text)) !== null) &lbrace;
      console.log(`Matched $&lbrace;match[0]} at $&lbrace;match.index}`);
      console.log(`Next search begins at $&lbrace;pattern.lastIndex}`);
    }</code></pre>
    <article>
      <p class="title-article">La propiedad lastIndex y la reutilización de RegExp</p>
      <p>Como ya has visto, la API de expresiones regulares de JavaScript es complicada. El uso de la propiedad lastIndex con los indicadores g e y es una parte particularmente complicada de esta API. Cuando usas estas banderas, necesitas ser particularmente cuidadoso cuando llames a los métodos match(), exec(), o test() porque el comportamiento de estos métodos depende de lastIndex, y el valor de lastIndex depende de lo que hayas hecho previamente con el objeto RegExp. Esto hace facil escribir codigo con errores.</p>
      <p>Supongamos, por ejemplo, que queremos encontrar el índice de todas las etiquetas &lt;p> dentro de una cadena de texto HTML. Podríamos escribir un código como éste:</p>
    <pre>
    <code class="language-js">let match, positions = [];
    while((match = /&lt;p>/g.exec(html)) !== null) &lbrace; // POSSIBLE INFINITE LOOP
      positions.push(match.index);
    }</code></pre>
      <p>Este código no hace lo que queremos. Si la cadena html contiene al menos una etiqueta &lt;p>, el bucle será eterno. El problema es que usamos un literal RegExp en la condición del bucle while. Para cada iteración del bucle, estamos creando un nuevo objeto RegExp con lastIndex a 0, por lo que exec() siempre comienza al principio de la cadena, y si hay una coincidencia, seguirá coincidiendo una y otra vez. La solución, por supuesto, es definir el RegExp una vez, y guardarlo en una variable para que estemos usando el mismo objeto RegExp para cada iteración del bucle.</p>
      <p>Por otro lado, a veces reutilizar un objeto RegExp no es lo correcto. Supongamos, por ejemplo, que queremos recorrer todas las palabras de un diccionario para encontrar palabras que contengan pares de letras dobles:</p>
    <pre>
    <code class="language-js">let dictionary = [ "apple", "book", "coffee" ];
    let doubleLetterWords = [];
    let doubleLetter = /(\w)\1/g;
    for(let word of dictionary) &lbrace;
      if (doubleLetter.test(word)) &lbrace;
        doubleLetterWords.push(word);
      }
    }
    doubleLetterWords // => ["apple", "coffee"]: "book" is missing!</code></pre>
      <p>Como hemos puesto la bandera g en la RegExp, la propiedad lastIndex cambia después de coincidencias exitosas, y el método test() (que está basado en exec()) empieza a buscar una coincidencia en la posición especificada por lastIndex. Después de encontrar la "pp" en "apple", lastIndex es 3, por lo que empezamos a buscar la palabra "book" en la posición 3 y no vemos la "oo" que contiene.</p>
      <p>Podríamos solucionar este problema eliminando la bandera g (que en realidad no es necesaria en este ejemplo concreto), o moviendo el literal RegExp al cuerpo del bucle para que se vuelva a crear en cada iteración, o poniendo explícitamente a cero lastIndex antes de cada llamada a test().</p>
      <p>La moraleja aquí es que lastIndex hace que la API RegExp sea propensa a errores. Así que tenga mucho cuidado cuando use las banderas g o y y haga bucles. Y en ES2020 y posteriores, use el método String matchAll() en lugar de exec() para evitar este problema ya que match All() no modifica lastIndex.</p>
    </article>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>11.4 Fechas y horarios</h2>
    <p>La clase Date es la API de JavaScript para trabajar con fechas y horas. Crea un objeto Date con el constructor Date(). Sin argumentos, devuelve un objeto Date que representa la fecha y hora actuales:</p>
    <pre>
    <code class="language-js">let now = new Date(); // The current time</code></pre>
    <p>Si pasa un argumento numérico, el constructor Date() interpreta ese argumento como el número de milisegundos desde la época de 1970:</p>
    <pre>
    <code class="language-js">let epoch = new Date(0); // Midnight, January 1st, 1970, GMT</code></pre>
    <p>Si especifica dos o más argumentos enteros, se interpretan como el año, mes, día del mes, hora, minuto, segundo y milisegundo en su zona horaria local, como en lo siguiente:</p>
    <pre>
    <code class="language-js">let century = new Date(2100, // Year 2100
          0, // January
          1, // 1st
          2, 3, 4, 5); // 02:03:04.005, local time</code></pre>
    <p>Una peculiaridad de la API de fecha es que el primer mes de un año es el número 0, pero el primer día de un mes es el número 1. Si se omiten los campos de hora, el constructor de Date() los pone todos a 0 por defecto, fijando la hora en medianoche. Si se omiten los campos de hora, el constructor de Date() los pone todos a 0 por defecto, estableciendo la hora a medianoche.</p>
    <p>Tenga en cuenta que cuando se invoca con varios números, el constructor Date() los interpreta utilizando la zona horaria a la que esté configurado el ordenador local. Si desea especificar una fecha y hora en UTC (Tiempo Universal Coordinado, también conocido como GMT), puede utilizar Date.UTC(). Este método estático toma los mismos argumentos que el constructor Date(), los interpreta en UTC y devuelve una marca de tiempo en milisegundos que puedes pasar al constructor Date():</p>
    <pre>
    <code class="language-js">// Midnight in England, January 1, 2100
    let century = new Date(Date.UTC(2100, 0, 1));</code></pre>
    <p>Si imprime una fecha (con console.log(century), por ejemplo), se imprimirá, por defecto, en su zona horaria local. Si desea mostrar una fecha en UTC, debe convertirla explícitamente en una cadena con toUTCString() o toISOString().</p>
    <p>Por último, si se pasa una cadena al constructor de Date(), éste intentará parsear esa cadena como una especificación de fecha y hora. El constructor puede analizar fechas especificadas en los formatos producidos por los métodos toString(), toUTCString() y toISOString():</p>
    <pre>
    <code class="language-js">let century = new Date("2100-01-01T00:00:00Z"); // An ISO format date</code></pre>
    <p>Una vez que se tiene un objeto Date, varios métodos get y set permiten consultar y modificar los campos año, mes, día-del-mes, hora, minuto, segundo y milisegundo de la Date. Cada uno de estos métodos tiene dos formas: una que obtiene o establece utilizando la hora local y otra que obtiene o establece utilizando la hora UTC. Para obtener o establecer el año de un objeto Date, por ejemplo, se utiliza getFullYear(), getUTCFullYear(), setFullYear() o setUTCFullYear():</p>
    <pre>
    <code class="language-js">let d = new Date(); // Start with the current date
    d.setFullYear(d.getFullYear() + 1); // Increment the year</code></pre>
    <p>Para obtener o establecer los demás campos de una fecha, sustituya "FullYear" en el nombre del método por "Month", "Date", "Hours", "Minutes", "Seconds" o "Milliseconds". Algunos de los métodos de establecimiento de fecha permiten establecer más de un campo a la vez. setFullYear() y setUTC FullYear() también permiten establecer opcionalmente el mes y el día del mes. Y setHours() y setUTCHours() permiten especificar los campos minutos, segundos y milisegundos además del campo horas.</p>
    <p>Tenga en cuenta que los métodos para consultar el día del mes son getDate() y getUTC Date(). Las funciones getDay() y getUTCDay() devuelven el día de la semana (de 0 para el domingo a 6 para el sábado). El día de la semana es de sólo lectura, por lo que no existe el correspondiente método setDay().</p>
  </section>
  <section id="4-1">
    <h2>11.4.1 Marcas de tiempo</h2>
    <p>JavaScript representa las fechas internamente como enteros que especifican el número de milisegundos transcurridos desde (o antes de) la medianoche del 1 de enero de 1970, hora UTC. Se admiten números enteros de hasta 8.640.000.000.000.000, por lo que JavaScript no se quedará sin milisegundos en más de 270.000 años.</p>
    <p>Para cualquier objeto Date, el método getTime() devuelve este valor interno, y el método set Time() lo establece. Así que puedes añadir 30 segundos a un Date con código como este, por ejemplo:</p>
    <pre>
    <code class="language-js">d.setTime(d.getTime() + 30000);</code></pre>
    <p>Estos valores en milisegundos se denominan a veces timestamps, y a veces es útil trabajar con ellos directamente en lugar de con objetos Date. El método estático Date.now() devuelve la hora actual como una marca de tiempo y es útil cuando se desea medir cuánto tiempo tarda en ejecutarse el código:</p>
    <pre>
    <code class="language-js">let startTime = Date.now();
    reticulateSplines(); // Do some time-consuming operation
    let endTime = Date.now();
    console.log(`Spline reticulation took $&lbrace;endTime - startTime}ms.`);</code></pre>
    <article>
      <p class="title-article">Marcas de tiempo de alta resolución</p>
      <p>Las marcas de tiempo devueltas por Date.now() se miden en milisegundos. En realidad, un milisegundo es un tiempo relativamente largo para un ordenador, y a veces es posible que d e s e e medir el tiempo transcurrido con mayor precisión. La función performance.now() lo permite: también devuelve una marca de tiempo basada en milisegundos, pero el valor devuelto no es un entero, por lo que incluye fracciones de milisegundo. El valor devuelto por perfor mance.now() no es una marca de tiempo absoluta como lo es el valor Date.now(). En su lugar, simplemente indica cuánto tiempo ha transcurrido desde que se cargó una página web o desde que se inició el proceso Node.</p>
      <p>El objeto performance forma parte de una API de rendimiento más amplia que no está definida por el estándar ECMAScript pero que está implementada por los navegadores web y por Node. Para utilizar el objeto performance en Node, debes importarlo con:</p>
    <pre>
    <code class="language-js">const &lbrace; performance } = require("perf_hooks");</code></pre>
      <p>Permitir un cronometraje de alta precisión en la web puede permitir a sitios web sin escrúpulos averiguar la identidad de los visitantes, por lo que los navegadores (especialmente Firefox) pueden reducir la precisión de perfor mance.now() por defecto. Como desarrollador web, deberías poder volver a habilitar la temporización de alta precisión de algún modo (como estableciendo privacy.reduceTimerPrecision en false en Firefox).</p>
    </article>
  </section>
  <section id="4-2" class="py-4 xs:py-5 sm:py-6">
    <h2>11.4.2 Aritmética de fechas</h2>
    <p>Los objetos Date pueden compararse con los operadores de comparación estándar &lt;, &lt;=, > y >= de JavaScript. Y puedes restar un objeto Date de otro para determinar el número de milisegundos entre las dos fechas. (Esto funciona porque la clase Date define un método valueOf() que devuelve una marca de tiempo).</p>
    <p>Si desea añadir o restar un número determinado de segundos, minutos u horas a una fecha, lo más sencillo es modificar la marca de tiempo, como se muestra en el ejemplo anterior, en el que añadimos 30 segundos a una fecha. Esta técnica se vuelve más engorrosa si desea añadir días, y no funciona en absoluto para meses y años, ya que tienen un número variable de días. Para hacer aritmética de fechas involucrando días, meses y años, puede usar setDate(), setMonth() y setYear(). Aquí, por ejemplo, hay un código que añade tres meses y dos semanas a la fecha actual:</p>
    <pre>
    <code class="language-js">let d = new Date();
    d.setMonth(d.getMonth() + 3, d.getDate() + 14);</code></pre>
    <p>Los métodos de ajuste de fecha funcionan correctamente incluso cuando se desbordan. Cuando añadimos tres meses al mes actual, podemos acabar con un valor superior a 11 (que representa diciembre). La función setMonth() se encarga de esto incrementando el año según sea necesario. Del mismo modo, cuando establecemos el día del mes en un valor mayor que el número de días del mes, el mes se incrementa adecuadamente.</p>
  </section>
  <section id="4-3">
    <h2>11.4.3 Formateo y análisis sintáctico de cadenas de fecha</h2>
    <p>Si utilizas la clase Date para realizar un seguimiento de fechas y horas (en lugar de simplemente medir intervalos de tiempo), es probable que necesites mostrar fechas y horas a los usuarios de tu código. La clase Date define varios métodos para convertir objetos Date en cadenas. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">let d = new Date(2020, 0, 1, 17, 10, 30); // 5:10:30pm on New Year's Day 2020
    d.toString() // => "Wed Jan 01 2020 17:10:30 GMT-0800 (Pacific Standard Time)"
    d.toUTCString() // => "Thu, 02 Jan 2020 01:10:30 GMT"
    d.toLocaleDateString() // => "1/1/2020": 'en-US' locale
    d.toLocaleTimeString() // => "5:10:30 PM": 'en-US' locale
    d.toISOString() // => "2020-01-02T01:10:30.000Z"</code></pre>
    <p>Esta es una lista completa de los métodos de formato de cadena de la clase Date:</p>
    <p><codeinline>toString()</codeinline></p>
    <p>Este método utiliza la zona horaria local, pero no formatea la fecha y la hora segun la zona.</p>
    <p><codeinline>toUTCString()</codeinline></p>
    <p>Este método utiliza la zona horaria UTC, pero no da formato a la fecha teniendo en cuenta la localización.</p>
    <p><codeinline>toISOString()</codeinline></p>
    <p>Este método imprime la fecha y la hora en el formato estándar año-mes-día horas:minutos:segundos.ms de la norma ISO-8601. La letra "T" separa la parte de la fecha de la parte de la hora. La hora se expresa en UTC, y esto se indica con la letra "Z" como última letra de la salida.</p>
    <p><codeinline>toLocaleString()</codeinline></p>
    <p>Este método utiliza la zona horaria local y un formato apropiado para la configuración regional del usuario.</p>
    <p><codeinline>toDateString()</codeinline></p>
    <p>Este método formatea sólo la parte de fecha de la Fecha y omite la hora. Utiliza la zona horaria local y no realiza el formateo apropiado para la zona.</p>
    <p><codeinline>toLocaleDateString()</codeinline></p>
    <p>Este método sólo formatea la fecha. Utiliza la zona horaria local y un formato de fecha apropiado para la zona.</p>
    <p><codeinline>toTimeString()</codeinline></p>
    <p>Este método sólo da formato a la hora y omite la fecha. Utiliza la zona horaria local pero no formatea la hora de forma local.</p>
    <p><codeinline>toLocaleTimeString()</codeinline></p>
    <p>Este método formatea la hora de forma local y utiliza la zona horaria local.</p>
    <p>Ninguno de estos métodos de conversión de fecha en cadena es ideal para dar formato a las fechas y horas que se mostrarán a los usuarios finales. Véase §11.7.2 para una técnica de formateo de fecha y hora más general y adaptada a la localización.</p>
    <p>Por último, además de estos métodos que convierten un objeto Date en una cadena, también existe un método estático Date.parse() que toma una cadena como argumento, intenta analizarla como fecha y hora, y devuelve una marca de tiempo que representa esa fecha. Date.parse() puede analizar las mismas cadenas que el constructor Date() y se garantiza que puede analizar la salida de toISOString(), toUTCString() y toString().</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>11.5 Clases de error</h2>
    <p>Las sentencias throw y catch de JavaScript pueden lanzar y atrapar cualquier valor de JavaScript, incluidos los valores primitivos. No hay ningún tipo de excepción que deba utilizarse para señalar errores. JavaScript define una clase Error, sin embargo, y es tradicional usar instancias de Error o una subclase cuando se señala un error con throw. Una buena razón para utilizar un objeto Error es que, cuando se crea un Error, captura el estado de la pila de JavaScript, y si la excepción no es capturada, se mostrará la traza de la pila con el mensaje de error, que le ayudará a depurar el problema. (Tenga en cuenta que el seguimiento de pila muestra dónde se creó el objeto Error, no dónde lo lanza la sentencia throw. Si siempre crea el objeto justo antes de lanzarlo con throw new Error(), esto no causará ninguna confusión).</p>
    <p>Los objetos Error tienen dos propiedades: mensaje y nombre, y un método toString(). El valor de la propiedad message es el valor pasado al constructor Error(), convertido a cadena si es necesario. Para los objetos de error creados con Error(), la propiedad name es siempre "Error". El método toString() simplemente devuelve el valor de la propiedad name seguido de dos puntos y un espacio y el valor de la propiedad message.</p>
    <p>Aunque no forma parte del estándar ECMAScript, Node y todos los navegadores modernos también definen una propiedad stack en los objetos Error. El valor de esta propiedad es una cadena de varias líneas que contiene un seguimiento de la pila de llamadas de JavaScript en el momento en que se creó el objeto Error. Esta información puede ser útil cuando se detecta un error inesperado.</p>
    <p>Además de la clase Error, JavaScript define una serie de subclases que utiliza para señalar determinados tipos de errores definidos por ECMAScript. Estas subclases son EvalError, RangeError, ReferenceError, SyntaxError, TypeError y URIError. Puede utilizar estas clases de error en su propio código si le parecen apropiadas. Al igual que la clase Error base, cada una de estas subclases tiene un constructor que toma un único argumento de mensaje. Y las instancias de cada una de estas subclases tienen una propiedad name cuyo valor es el mismo que el nombre del constructor.</p>
    <p>Puede definir sus propias subclases de Error que mejor encapsulen las condiciones de error de su propio programa. Tenga en cuenta que no está limitado a las propiedades de nombre y mensaje. Si crea una subclase, puede definir nuevas propiedades para proporcionar detalles del error. Si está escribiendo un analizador sintáctico, por ejemplo, puede resultarle útil definir una clase ParseError con propiedades de línea y columna que especifiquen la ubicación exacta del fallo de análisis sintáctico. O si estás trabajando con peticiones HTTP, puede que quieras definir una clase HTTPError que tenga una propiedad status que contenga el código de estado HTTP (como 404 o 500) de la petición fallida.</p>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js">class HTTPError extends Error &lbrace;
      constructor(status, statusText, url) &lbrace;
        super(`$&lbrace;status} $&lbrace;statusText}: $&lbrace;url}`);
        this.status = status;
        this.statusText = statusText;
        this.url = url;
      }

      get name() &lbrace; return "HTTPError"; }
    }

    let error = new HTTPError(404, "Not Found", "http://example.com/");
    error.status // => 404
    error.message // => "404 Not Found: http://example.com/"
    error.name // => "HTTPError"</code></pre>
  </section>
  <section id="6">
    <h2>11.6 Serialización y análisis JSON</h2>
    <p>Cuando un programa necesita guardar datos o necesita transmitir datos a través de una conexión de red a otro programa, debe convertir sus estructuras de datos en memoria en una cadena de bytes o caracteres que puedan ser guardados o transmitidos y luego ser analizados para restaurar las estructuras de datos originales en memoria. Este proceso de conversión de estructuras de datos en cadenas de bytes o caracteres se conoce como serialización (o marshaling o incluso pickling).</p>
    <p>La forma más sencilla de serializar datos en JavaScript utiliza un formato de serialización conocido como JSON. Este acrónimo significa "JavaScript Object Notation" y, como su nombre indica, el formato utiliza la sintaxis literal de objetos y matrices de JavaScript para convertir estructuras de datos formadas por objetos y matrices en cadenas. JSON admite números y cadenas primitivas, así como los valores true, false y null, además de matrices y objetos construidos a partir de esos valores primitivos. JSON no admite otros tipos de JavaScript como Map, Set, RegExp, Date o matrices tipadas. No obstante, ha demostrado ser un formato de datos extraordinariamente versátil y es de uso común incluso en programas no basados en JavaScript.</p>
    <p>JavaScript soporta la serialización y deserialización de JSON con las dos funciones JSON.stringify() y JSON.parse(), que se trataron brevemente en §6.8. Dado un objeto o array (anidado a una profundidad arbitraria) que no contenga ningún valor no serializable como objetos RegExp o arrays tipados, puedes serializar el objeto simplemente pasándolo a JSON.stringify(). Como su nombre indica, el valor de retorno de esta función es una cadena. Y dada una cadena devuelta por JSON.stringify(), puede volver a crear la estructura de datos original pasando la cadena a JSON.parse():</p>
    <pre>
    <code class="language-js">let o = &lbrace;s: "", n: 0, a: [true, false, null]};
    let s = JSON.stringify(o); // s == '&lbrace;"s":"","n":0,"a":[true,false,null]}'
    let copy = JSON.parse(s); // copy == &lbrace;s: "", n: 0, a: [true, false, null]}</code></pre>
    <p>Si omitimos la parte en la que los datos serializados se guardan en un archivo o se envían a través de la red, podemos utilizar este par de funciones como una forma algo ineficiente de crear una copia en profundidad de un objeto:</p>
    <pre>
    <code class="language-js">// Make a deep copy of any serializable object or array
      function deepcopy(o) &lbrace;
        return JSON.parse(JSON.stringify(o));
      }</code></pre>
    <nota>
      <img class="self-start" src="/public/javascript/nota_gral.png" alt="Nota de la grandesa">
      <div class="">
        <p class="title-article text-left">JSON es un subconjunto de JavaScript</p>
        <p>Cuando los datos se serializan en formato JSON, el resultado es un código fuente Java Script válido para una expresión que se evalúa como una copia de la estructura de datos original. Si antepone a una cadena JSON el prefijo var datos = y pasar el resultado a eval(), obtendrás una copia de la estructura de datos original asignada a los datos variables. Nunca debes hacer esto, sin embargo, porque es un enorme agujero de seguridad-si un atacante pudiera inyectar código JavaScript arbitrario en un archivo JSON, podría hacer que tu programa ejecutara su código. Es más rápido y seguro utilizar JSON.parse() para decodificar datos con formato JSON.</p>
        <p>JSON se utiliza a veces como formato de archivo de configuración legible por humanos. Si se encuentra editando a mano un archivo JSON, tenga en cuenta que el formato JSON es un subconjunto muy estricto de JavaScript. Los comentarios no están permitidos y los nombres de propiedades deben ir entre comillas dobles, incluso cuando JavaScript no lo requiera.</p>
      </div>
    </nota>
    <p>Normalmente, sólo se pasa un único argumento a JSON.stringify() y JSON.parse(). Ambas funciones aceptan un segundo argumento opcional que nos permite extender el formato JSON, y que describiremos a continuación. JSON.stringify() también acepta un tercer argumento opcional que discutiremos primero. Si quieres que tu cadena con formato JSON sea legible por humanos (si se está utilizando como un archivo de configuración, por ejemplo), entonces debes pasar null como segundo argumento y pasar un número o cadena como tercer argumento. Este tercer argumento indica a JSON.stringify() que debe formatear los datos en varias líneas sangradas. Si el tercer argumento es un número, utilizará ese número de espacios para cada nivel de sangría. Si el tercer argumento es una cadena de espacios en blanco (como '\t'), usará esa cadena para cada nivel de sangría.</p>
    <pre>
    <code class="language-js">let o = &lbrace;s: "test", n: 0};
    JSON.stringify(o, null, 2) // => '&lbrace;\n "s": "test",\n "n": 0\n}'</code></pre>
    <p>JSON.parse() ignora los espacios en blanco, por lo que pasar un tercer argumento a JSON.stringify() no tiene ningún impacto en nuestra capacidad de volver a convertir la cadena en una estructura de datos.</p>
  </section>
  <section id="6-1" class="py-4 xs:py-5 sm:py-6">
    <h2>11.6.1 Personalizaciones JSON</h2>
    <p>Si se le pide a JSON.stringify() que serialice un valor que no está soportado de forma nativa por el formato JSON, busca si ese valor tiene un método toJSON(), y si es así, llama a ese método y luego encadena el valor devuelto en lugar del valor original. Los objetos Date implementan toJSON(): devuelve la misma cadena que el método toISOString(). Esto significa que si serializas un objeto que incluye un Date, la fecha se convertirá automáticamente en una cadena. Cuando analices la cadena serializada, la estructura de datos recreada no será exactamente la misma con la que empezaste porque tendrá una cadena donde el objeto original tenía una Fecha.</p>
    <p>Si necesita volver a crear objetos Date (o modificar el objeto analizado de cualquier otra forma), puede pasar una función "reviver" como segundo argumento a JSON.parse(). Si se especifica, esta función "reviver" se invoca una vez por cada valor primitivo (pero no los objetos o matrices que contienen esos valores primitivos) analizado a partir de la cadena de entrada. La función se invoca con dos argumentos. El primero es un nombre de propiedad, ya sea un nombre de propiedad de objeto o un índice de matriz convertido a cadena. El segundo argumento es el valor primitivo de esa propiedad de objeto o elemento de matriz. Además, la función se invoca como un método del objeto o matriz que contiene el valor primitivo, por lo que puede hacer referencia a ese objeto contenedor con la palabra clave this.</p>
    <p>El valor de retorno de la función reviver se convierte en el nuevo valor de la propiedad nombrada. Si devuelve su segundo argumento, la propiedad permanecerá sin cambios. Si devuelve undefined, entonces la propiedad nombrada será borrada del objeto o array antes de que JSON.parse() vuelva al usuario</p>
    <p>Como ejemplo, he aquí una llamada a JSON.parse() que utiliza una función reviver para filtrar algunas propiedades y volver a crear objetos Date:</p>
    <pre>
    <code class="language-js">let data = JSON.parse(text, function(key, value) &lbrace;
      // Remove any values whose property name begins with an underscore
      if (key[0] === "_") return undefined;

      // If the value is a string in ISO 8601 date format convert it to a Date.
      if (typeof value === "string" &&
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)) &lbrace;
        return new Date(value);
      }

      // Otherwise, return the value unchanged
      return value;
    });</code></pre>
    <p>Además del uso de toJSON() descrito anteriormente, JSON.stringify() también permite personalizar su salida pasando una matriz o una función como segundo argumento opcional.</p>
    <p>Si en su lugar se pasa una matriz de cadenas (o números, que se convierten en cadenas) como segundo argumento, se utilizarán como nombres de las propiedades del objeto (o elementos de la matriz). Cualquier propiedad cuyo nombre no se encuentre en la matriz se omitirá de la cadena. Además, la cadena devuelta incluirá las propiedades en el mismo orden en que aparecen en la matriz (lo que puede ser muy útil al escribir pruebas).</p>
    <p>Si se pasa una función, se trata de una función de sustitución, es decir, la inversa de la función opcional de sustitución que se puede pasar a JSON.parse(). Si se especifica, la función de sustitución se invoca para cada valor que se va a encadenar. El primer argumento de la función de sustitución es el nombre de la propiedad del objeto o el índice de la matriz del valor dentro de ese objeto, y el segundo argumento es el valor en sí. La función de sustitución se invoca como un método del objeto o matriz que contiene el valor que se va a e n c a d e n a r . El valor de retorno de la función en lugar del valor original. Si el sustituto devuelve un valor indefinido o no devuelve nada, ese valor (y su elemento de matriz o propiedad de objeto) se omite en la encadenación.</p>
    <pre>
    <code class="language-js">// Specify what fields to serialize, and what order to serialize them in
    let text = JSON.stringify(address, ["city","state","country"]);

    // Specify a replacer function that omits RegExp-value properties
    let json = JSON.stringify(o, (k, v) => v instanceof RegExp ? undefined : v);</code></pre>
    <p>Las dos llamadas a JSON.stringify() utilizan el segundo argumento de una manera benigna, produciendo una salida serializada que puede ser deserializada sin requerir una función especial. En general, sin embargo, si defines un método toJSON() para un tipo, o si usas una función replacer que realmente reemplaza valores no serializables por valores serializables, entonces típicamente necesitarás usar una función reviver personalizada con JSON.parse() para recuperar tu estructura de datos original. Si haces esto, debes entender que estás definiendo un formato de datos personalizado y sacrificando la portabilidad y compatibilidad con un gran ecosistema de herramientas y lenguajes compatibles con JSON.</p>
  </section>
  <section id="7">
    <h2>11.7 API de internacionalización</h2>
    <p>La API de internacionalización de JavaScript consta de tres clases: Intl.NumberFor mat, Intl.DateTimeFormat e Intl.Collator, que nos permiten formatear números (incluidos importes monetarios y porcentajes), fechas y horas de forma adaptada a la localización y comparar cadenas de texto de forma adaptada a la localización. Estas clases no forman parte del estándar ECMAScript, pero están definidas en el estándar ECMA402 y son compatibles con los navegadores web. La API Intl también está soportada en Node, pero en el momento de escribir esto, los binarios precompilados de Node no incluyen los datos de localización necesarios para que funcionen con otras localizaciones distintas al inglés de EE.UU.. Por lo tanto, para utilizar estas clases con Node, es posible que tenga que descargar un paquete de datos independiente o utilizar una compilación personalizada de Node.</p>
    <p>Una de las partes más importantes de la internacionalización es mostrar el texto traducido al idioma del usuario. Hay varias formas de conseguirlo, pero ninguna de ellas entra dentro del ámbito de la API Intl que se describe aquí.</p>
  </section>
  <section id="7-1" class="py-4 xs:py-5 sm:py-6">
    <h2>11.7.1 Formato de números</h2>
    <p>Los usuarios de todo el mundo esperan que los números tengan distintos formatos. Los puntos decimales pueden ser puntos o comas. Los separadores de miles pueden ser comas o puntos, y no se utilizan cada tres dígitos en todos los lugares. Algunas monedas se dividen en centésimas, otras en milésimas y otras no tienen subdivisiones. Por último, aunque en muchos idiomas se utilizan los llamados "números arábigos" del 0 al 9, esto no es universal, y los usuarios de algunos países esperarán ver los números escritos utilizando los dígitos de sus propias escrituras.</p>
    <p>La clase Intl.NumberFormat define un método format() que tiene en cuenta todas estas posibilidades de formato. El constructor recibe dos argumentos. El primer argumento especifica la configuración regional para la que debe formatearse el número y el segundo es un objeto que especifica más detalles sobre cómo debe formatearse el número. Si el primer argumento se omite o no se define, se utilizará la configuración regional del sistema (que suponemos que es la preferida por el usuario). Si el primer argumento es una cadena, especifica la configuración regional deseada, como "en-US" (inglés utilizado en Estados Unidos), "fr" (francés) o "zh-Hans-CN" (chino, utilizando el sistema de escritura Han simplificado, en China). El primer argumento también puede ser una matriz de cadenas de configuración regional y, en este caso, Intl.NumberFormat elegirá la más específica que esté bien soportada.</p>
    <p>El segundo argumento del constructor Intl.NumberFormat(), si se especifica, debe ser un objeto que defina una o más de las siguientes propiedades:</p>
    <p><codeinline>style</codeinline></p>
    <p>Especifica el tipo de formato numérico que se requiere. El valor predeterminado es "decimal". Especifique "porcentaje" para formatear un número como un porcentaje o especifique "moneda" para especificar un número como una cantidad de dinero.</p>
    <p><codeinline>currency</codeinline></p>
    <p>Si el estilo es "moneda", esta propiedad es necesaria para especificar el código de moneda ISO de tres letras (como "USD" para dólares estadounidenses o "GBP" para libras esterlinas) de la moneda deseada.</p>
    <p><codeinline>currencyDisplay</codeinline></p>
    <p>Si el estilo es "moneda", esta propiedad especifica cómo se muestra la moneda. El valor por defecto "símbolo" utiliza un símbolo de moneda si la moneda tiene uno. El valor "code" utiliza el código ISO de tres letras, y el valor "name" escribe el nombre de la moneda en forma larga.</p>
    <p><codeinline>useGrouping</codeinline></p>
    <p>Establezca esta propiedad en false si no desea que los números tengan separadores de miles (o sus equivalentes locales).</p>
    <p><codeinline>minimumIntegerDigits</codeinline></p>
    <p>El número mínimo de dígitos a utilizar para mostrar la parte entera del número. Si el número tiene menos dígitos que éste, se rellenará a la izquierda con ceros. El valor por defecto es 1, pero puede utilizar valores tan altos como 21.</p>
    <p><codeinline>minimumFractionDigits, maximumFractionDigits</codeinline></p>
    <p>Estas dos propiedades controlan el formato de la parte fraccionaria del número. Si un número tiene menos dígitos fraccionarios que el mínimo, se rellenará con ceros a la derecha. Si tiene más que el máximo, la parte fraccionaria se redondeará. Los valores legales para ambas propiedades están entre 0 y 20. El mínimo por defecto es 0 y el máximo por defecto es 3, excepto cuando se formatea moneda. cuando la longitud de la parte fraccionaria varía en función de la moneda especificada.</p>
    <p><codeinline>minimumSignificantDigits, maximumSignificantDigits</codeinline></p>
    <p>Estas propiedades controlan el número de dígitos significativos utilizados al formatear un número, por lo que son adecuadas para formatear datos científicos, por ejemplo. Si se especifican, estas propiedades anulan las propiedades de dígitos enteros y fraccionarios enumeradas anteriormente. Los valores legales están comprendidos entre 1 y 21.</p>
    <p>Una vez creado un objeto Intl.NumberFormat con la configuración regional y las opciones deseadas, se utiliza pasando un número a su método format(), que devuelve una cadena con el formato adecuado. Por ejemplo</p>
    <pre>
    <code class="language-js">let euros = Intl.NumberFormat("es", &lbrace;style: "currency", currency: "EUR"});
    euros.format(10) // => "10,00 €": ten euros, Spanish formatting

    let pounds = Intl.NumberFormat("en", &lbrace;style: "currency", currency: "GBP"});
    pounds.format(1000) // => "£1,000.00": One thousand pounds, English formatting</code></pre>
    <p>Una característica útil de Intl.NumberFormat (y también de las otras clases Intl) es que su método format() está ligado al objeto NumberFormat al que pertenece. Así, en lugar de definir una variable que haga referencia al objeto formateador y luego invocar el método format() sobre ella, puede simplemente asignar el mé todo format() a una variable y utilizarlo como si fuera una función independiente, como en este ejemplo:</p>
    <pre>
    <code class="language-js">let data = [0.05, .75, 1];
    let formatData = Intl.NumberFormat(undefined, &lbrace;
      style: "percent",
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }).format;

    data.map(formatData) // => ["5.0%", "75.0%", "100.0%"]: in en-US locale</code></pre>
    <p>Algunas lenguas, como el árabe, utilizan su propia escritura para los dígitos decimales:</p>
    <pre>
    <code class="language-js">let arabic = Intl.NumberFormat("ar", &lbrace;useGrouping: false}).format;
      arabic(1234567890) // => "١٢٣٤٥٦٧٨٩٠"</code></pre>
    <p>Otros idiomas, como el hindi, utilizan una escritura que tiene su propio conjunto de dígitos, pero tienden a utilizar los dígitos ASCII 0-9 por defecto. Si desea anular el alfabeto utilizado por defecto para los dígitos, añada -u-nu- a la configuración regional y escriba a continuación el nombre abreviado del alfabeto. Por ejemplo, puede dar formato a los números con agrupación al estilo indio y dígitos en devanagari:</p>
    <pre>
    <code class="language-js">let hindi = Intl.NumberFormat("hi-IN-u-nu-deva").format;
      hindi(1234567890) // => "१,२३,४५,६७,८९०"</code></pre>
    <p>-nu es el nombre de extensión para el sistema de numeración, y deva es la abreviatura de Devanagari. La API Intl define los nombres de otros sistemas de numeración, principalmente para las lenguas índicas del sur y el sudeste asiático.</p>
  </section>
  <section id="7-2">
    <h2>11.7.2 Formato de fechas y horas</h2>
    <p>La clase Intl.DateTimeFormat es muy parecida a la clase Intl.NumberFormat. El constructor de Intl.DateTimeFormat() toma los mismos dos argumentos que Intl.Num berFormat(): una configuración regional o matriz de configuraciones regionales y un objeto de opciones de formato. Y la forma de utilizar una instancia de Intl.DateTimeFormat es llamando a su método format() para convertir un objeto Date en una cadena.</p>
    <p>Como se mencionó en §11.4, la clase Date define métodos simples toLocaleDateString() y toLocaleTimeString() que producen una salida apropiada para la configuración regional del usuario. Pero estos métodos no permiten controlar qué campos de la fecha y la hora se muestran. Tal vez desee omitir el año pero añadir un día de la semana al formato de la fecha. ¿Quiere que el mes se represente numéricamente o por su nombre? La clase Intl.DateTimeFormat proporciona un control preciso sobre lo que se muestra basándose en las propiedades del objeto options que se pasa como segundo argumento al constructor. Tenga en cuenta, sin embargo, que Intl.DateTimeFormat no siempre puede mostrar exactamente lo que usted pide. Si especifica opciones para formatear las horas y los segundos pero omite los minutos, verá que el formateador muestra los minutos de todos modos. La idea es que utilices el objeto options para especificar qué campos de fecha y hora te gustaría presentar al usuario y cómo te gustaría formatearlos (por nombre o por número, por ejemplo), entonces el formateador buscará un formato local apropiado que se acerque más a lo que has pedido.</p>
    <p>Las opciones disponibles son las siguientes. Especifique sólo las propiedades de los campos de fecha y hora que desea que aparezcan en la salida formateada.</p>
    <p><codeinline>year</codeinline></p>
    <p>Utilice "numérico" para un año completo de cuatro dígitos o "2 dígitos" para una abreviatura de dos dígitos.</p>
    <p><codeinline>month</codeinline></p>
    <p>Utilice "numérico" para un número posiblemente corto, como "1", o "2 dígitos" para una representación numérica que siempre tenga dos dígitos, como "01". Utilice "long" para un nombre completo como "January", "short" para un nombre abreviado como "Jan", y "narrow" para un nombre muy abreviado como "J" que no se garantiza que sea único.</p>
    <p><codeinline>day</codeinline></p>
    <p>Utilice "numérico" para un número de uno o dos dígitos o "2 dígitos" para un número de dos dígitos para el día del mes.</p>
    <p><codeinline>weekday</codeinline></p>
    <p>Utilice "largo" para un nombre completo como "Monday", "corto" para un nombre abreviado como "Mon", y "estrecho" para un nombre muy abreviado como "M" que no se garantice que sea único.</p>
    <p><codeinline>era</codeinline></p>
    <p>Esta propiedad especifica si una fecha debe formatearse con una era, como CE o BCE. Esto puede ser útil si está formateando fechas de hace mucho tiempo o si está utilizando un calendario japonés. Los valores legales son "largo", "corto" y "estrecho"</p>
    <p><codeinline>hour, minute, second</codeinline></p>
    <p>Estas propiedades especifican cómo desea que se muestre la hora. Utilice "numeric" para un campo de uno o dos dígitos o "2-digit" para forzar que los números de un solo dígito se rellenen a la izquierda con un 0.</p>
    <p><codeinline>timeZone</codeinline></p>
    <p>Esta propiedad especifica la zona horaria deseada para la que se debe for- mular la fecha. Si se omite, se utiliza la zona horaria local. Las implementaciones siempre reconocen "UTC" y también pueden reconocer nombres de zonas horarias de la Autoridad de Números Asignados de Internet (IANA), como "America/Los_Angeles".</p>
    <p><codeinline>timeZoneName</codeinline></p>
    <p>Esta propiedad especifica cómo debe mostrarse la zona horaria en una fecha u hora formateada. Utilice "long" para un nombre de zona horaria completamente deletreado y "short" para una zona horaria abreviada o numérica.</p>
    <p><codeinline>hour12</codeinline></p>
    <p>Esta propiedad booleana especifica si se utiliza o no la hora de 12 horas. E l valor predeterminado depende de la configuración regional, pero puede anularlo con esta propiedad.</p>
    <p><codeinline>hourCycle</codeinline></p>
    <p>Esta propiedad permite especificar si la medianoche se escribe como 0 horas, 12 horas o 24 horas. El valor por defecto depende de la configuración regional, pero puede anularlo con esta propiedad. Tenga en cuenta que hora12 tiene prioridad sobre esta propiedad. Utilice el valor "h11" para especificar que la medianoche es 0 y la hora anterior a la medianoche es 11pm. Utilice "h12" para especificar que la medianoche son las 12. Utilice "h23" para especificar que la medianoche es 0 y la hora antes de medianoche es 23. Y utiliza "h24" para especificar que la medianoche es 24.</p>
    <p>He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">let d = new Date("2020-01-02T13:14:15Z"); // January 2nd, 2020, 13:14:15 UTC

    // With no options, we get a basic numeric date format
    Intl.DateTimeFormat("en-US").format(d) // => "1/2/2020"
    Intl.DateTimeFormat("fr-FR").format(d) // => "02/01/2020"

    // Spelled out weekday and month
    let opts = &lbrace; weekday: "long", month: "long", year: "numeric", day: "numeric" };
    Intl.DateTimeFormat("en-US", opts).format(d) // => "Thursday, January 2, 2020"
    Intl.DateTimeFormat("es-ES", opts).format(d) // => "jueves, 2 de enero de 2020"

    // The time in New York, for a French-speaking Canadian
    opts = &lbrace; hour: "numeric", minute: "2-digit", timeZone: "America/New_York" };
    Intl.DateTimeFormat("fr-CA", opts).format(d) // => "8 h 14"</code></pre>
    <p>Intl.DateTimeFormat puede mostrar fechas utilizando calendarios distintos al calendario juliano por defecto basado en la era cristiana. Aunque algunas localizaciones pueden utilizar un calendario no cristiano por defecto, siempre se puede especificar explícitamente el calendario a utilizar añadiendo -u-ca- a la localidad y a continuación el nombre del calendario. Los posibles nombres de calen- dar son "budista", "chino", "copto", "etiópico", "gregoriano", "hebreo", "indio", "islámico", "iso8601", "japonés" y "persa". Siguiendo con el ejemplo anterior, podemos determinar el año en varios calendarios no cristianos:</p>
    <pre>
    <code class="language-js">let opts = &lbarec; year: "numeric", era: "short" };
    Intl.DateTimeFormat("en", opts).format(d) // => "2020 AD"
    Intl.DateTimeFormat("en-u-ca-iso8601", opts).format(d) // => "2020 AD"
    Intl.DateTimeFormat("en-u-ca-hebrew", opts).format(d) // => "5780 AM"
    Intl.DateTimeFormat("en-u-ca-buddhist", opts).format(d) // => "2563 BE"
    Intl.DateTimeFormat("en-u-ca-islamic", opts).format(d) // => "1441 AH"
    Intl.DateTimeFormat("en-u-ca-persian", opts).format(d) // => "1398 AP"
    Intl.DateTimeFormat("en-u-ca-indian", opts).format(d) // => "1941 Saka"
    Intl.DateTimeFormat("en-u-ca-chinese", opts).format(d) // => "36 78"
    Intl.DateTimeFormat("en-u-ca-japanese", opts).format(d) // => "2 Reiwa"</code></pre>
  </section>
  <section id="7-3" class="py-4 xs:py-5 sm:py-6">
    <h2>11.7.3 Comparación de cadenas</h2>
    <p>El problema de ordenar cadenas en orden alfabético (o en un "orden de collación" más general para escrituras no alfabéticas) es más difícil de lo que los angloparlantes suelen creer. El inglés utiliza un alfabeto relativamente pequeño, sin letras acentuadas, y tenemos la ventaja de contar con una codificación de caracteres (ASCII, incorporada desde entonces a Unicode) cuyos valores numéricos se ajustan perfectamente a nuestro orden estándar de clasificación de cadenas. Las cosas no son tan sencillas en otros idiomas. El español, por ejemplo, trata la ñ como una letra distinta que va después de la n y antes de la o. El lituano alfabetiza la Y antes que la J, y el galés trata los dígrafos como CH y DD como letras únicas, con la CH después de la C y la DD después de la D.</p>
    <p>Si desea mostrar cadenas a un usuario en un orden que le resulte natural, no basta con utilizar el método sort() en una matriz de cadenas. Pero si crea un objeto Intl.Colla- tor, puede pasar el método compare() de ese objeto al método sort() para realizar una ordenación de las cadenas adecuada a la localización. Los objetos Intl.Collator pueden configurarse para que el método compare() realice comparaciones que no distingan mayúsculas de minúsculas o incluso comparaciones que sólo tengan en cuenta la letra base e ignoren los acentos y otros signos diacríticos.</p>
    <p>Al igual que Intl.NumberFormat() e Intl.DateTimeFormat(), el conector Intl.Collator() recibe dos argumentos. El primero especifica una configuración regional o una matriz de configuraciones regionales, y el segundo es un objeto opcional cuyas propiedades especifican exactamente qué tipo de comparación de cadenas se va a realizar. Las propiedades admitidas son las siguientes:</p>
    <p><codeinline>usage</codeinline></p>
    <p>Esta propiedad especifica cómo se utilizará el objeto intercalador. El valor predeterminado es "ordenar", pero también puede especificar "buscar". La idea es que, al ordenar cadenas, normalmente se desea un intercalador que diferencie tantas cadenas como sea posible para producir un orden fiable. Pero al comparar dos cadenas, algunas localizaciones pueden querer una comparación menos estricta que ignore los acentos, por ejemplo.</p>
    <p><codeinline>sensitivity</codeinline></p>
    <p>Esta propiedad especifica si el comparador es sensible a las mayúsculas y minúsculas y a los acentos al comparar cadenas. El valor "base" provoca comparaciones que ignoran mayúsculas y acentos, considerando sólo la letra base para cada carácter. (Tenga en cuenta, sin embargo, que algunos idiomas consideran ciertos caracteres acentuados como letras base distintas). "acento" tiene en cuenta los acentos en las comparaciones, pero ignora las mayúsculas y minúsculas. "case" tiene en cuenta las mayúsculas e ignora los acentos. Y "variant" realiza comparaciones estrictas que tienen en cuenta tanto las mayúsculas como los acentos. El valor por defecto de esta propiedad es "variant" cuando el uso es "sort". Si el uso es "buscar", la sensibilidad por defecto depende de la configuración regional.</p>
    <p><codeinline>ignorePunctuation</codeinline></p>
    <p>Establezca esta propiedad a true para ignorar espacios y signos de puntuación al comparar cadenas. Con esta propiedad en true, las cadenas "cualquiera" y "cualquiera", por ejemplo, se considerarán iguales.</p>
    <p><codeinline>numeric</codeinline></p>
    <p>Establezca esta propiedad a true si las cadenas que está comparando son enteras o contienen enteros y desea que se ordenen por orden numérico en lugar de por orden alfabético. Con esta opción activada, la cadena "Versión 9" se ordenará antes que "Versión 10", por ejemplo.</p>
    <p><codeinline>caseFirst</codeinline></p>
    <p>Esta propiedad especifica qué letra debe ir primero. Si especifica "upper", entonces "A" se ordenará antes que "a". Y si especifica "minúsculas", entonces "a" se ordenará antes que "A". En cualquier caso, tenga en cuenta que las variantes en mayúsculas y minúsculas de la misma letra estarán una al lado de la otra en el orden de clasificación, que es diferente del orden lexicográfico de código Uni (el comportamiento por defecto del método Array sort()) en el que todas las letras ASCII mayúsculas van antes que todas las letras ASCII minúsculas. El valor predeterminado de esta propiedad depende de la localización, y las implementaciones pueden ignorar esta propiedad y no permitirle modificar el orden de las mayúsculas y minúsculas.</p>
    <p>Una vez creado un objeto Intl.Collator para la configuración regional y las opciones deseadas, puede utilizar su método compare() para comparar dos cadenas. Este método devuelve un número. Si el valor devuelto es menor que cero, entonces la primera cadena va antes que la segunda. Si es mayor que cero, la primera cadena va después de la segunda. Y si compare() devuelve cero, entonces las dos cadenas son iguales en lo que respecta a este intercalador.</p>
    <p>Este método compare() que toma dos cadenas y devuelve un número menor, igual o mayor que cero es exactamente lo que el método Array sort() espera para su argumento opcional. Además, Intl.Collator vincula automáticamente el mé todo compare() a su instancia, por lo que puede pasarlo directamente a sort() sin tener que escribir una función envolvente e invocarla a través del objeto collator. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">// A basic comparator for sorting in the user's locale.
    // Never sort human-readable strings without passing something like this:
    const collator = new Intl.Collator().compare;
    ["a", "z", "A", "Z"].sort(collator) // => ["a", "A", "z", "Z"]

    // Filenames often include numbers, so we should sort those specially
    const filenameOrder = new Intl.Collator(undefined, &lbrace; numeric: true }).compare;
    ["page10", "page9"].sort(filenameOrder) // => ["page9", "page10"]
    
    // Find all strings that loosely match a target string
    const fuzzyMatcher = new Intl.Collator(undefined, &lbrace; sensitivity: "base", ignorePunctuation: true }).compare;
    let strings = ["food", "fool", "Føø Bar"];
    strings.findIndex(s => fuzzyMatcher(s, "foobar") === 0) // => 2</code></pre>
    <p>Algunas localidades tienen más de un orden de cotejo posible. En Alemania, por ejemplo, las guías telefónicas utilizan un orden ligeramente más fonético que los diccionarios. En España, antes de 1994, la "ch" y la "ll" se trataban como letras separadas, por lo que ese país tiene un orden de cotejo moderno y otro tradicional. Y en China, el orden de cotejo puede basarse en la codificación de los caracteres, en el radical base y los trazos de cada carácter, o en la romanización Pinyin de los caracteres. Estas variantes de intercalación no pueden seleccionarse mediante el argumento de opciones Intl.Collator, pero pueden seleccionarse añadiendo -u- co- a la cadena de configuración regional y añadiendo el nombre de la variante deseada. Utilice "de-DE-u- co-phonebk" para pedir la guía telefónica en Alemania, por ejemplo, y "zh-TW-u-co- pinyin" para pedir Pinyin en Taiwán.</p>
    <pre>
    <code class="language-js">// Before 1994, CH and LL were treated as separate letters in Spain
    const modernSpanish = Intl.Collator("es-ES").compare;
    const traditionalSpanish = Intl.Collator("es-ES-u-co-trad").compare;
    let palabras = ["luz", "llama", "como", "chico"];
    palabras.sort(modernSpanish) // => ["chico", "como", "llama", "luz"]
    palabras.sort(traditionalSpanish) // => ["como", "chico", "luz", "llama"]</code></pre>
  </section>
  <section id="8">
    <h2>11.8 La API de la consola</h2>
    <p>Usted ha visto la función console.log() utilizada a lo largo de este libro: en los navegadores web, imprime una cadena en la pestaña "Consola" del panel de herramientas de desarrollo del navegador, que puede ser muy útil cuando se depura. En Node, console.log() es una función de salida de propósito general e imprime sus argumentos al flujo stdout del proceso, donde típicamente aparece al usuario en una ventana de terminal como salida del programa.</p>
    <p>La API de consola define una serie de funciones útiles además de console.log(). La API no forma parte de ningún estándar ECMAScript, pero está soportada por navegadores y por Node y ha sido formalmente escrita y estandarizada en https:// console.spec.whatwg.org.</p>
    <p>La API de la consola define las siguientes funciones:</p>
    <p><codeinline>console.log()</codeinline></p>
    <p>Es la función de consola más conocida. Convierte sus argumentos en cadenas y las muestra en la consola. Incluye espacios entre los argumentos e inicia una nueva línea después de mostrar todos los argumentos.</p>
    <p><codeinline>console.debug(), console.info(), console.warn(), console.error()</codeinline></p>
    <p>Estas funciones son casi idénticas a c o n s o l e .log(). En Node, con sole.error() envía su salida al flujo stderr en lugar de al flujo stdout, pero las otras funciones son alias de console.log(). En los navegadores, l o s mensajes de salida generados por cada una de estas funciones pueden ir precedidos de un icono que indica su nivel o gravedad, y la consola del desarrollador también puede permitir a los desarrolladores filtrar los mensajes de la consola por nivel.</p>
    <p><codeinline>console.assert()</codeinline></p>
    <p>Si el primer argumento es verdadero (es decir, si la aserción pasa), entonces esta función no hace nada. Pero si el primer argumento es falso u otro valor falso, los argumentos restantes se imprimen como si se hubieran pasado a console.error() con el prefijo "Aserción fallida". Tenga en cuenta que, a diferencia de las funciones assert() típicas, console.assert() no lanza una excepción cuando falla una aserción.</p>
    <p><codeinline>console.clear()</codeinline></p>
    <p>Esta función borra la consola cuando eso es posible. Esto funciona en navegadores y en Node cuando Node está mostrando su salida a un terminal. Sin embargo, si la salida de Node ha sido redirigida a un archivo o a una tubería, entonces llamar a esta función no tiene ningún efecto.</p>
    <p><codeinline>console.table()</codeinline></p>
    <p>Esta función es una característica muy potente pero poco conocida para producir una salida tabular, y es particularmente útil en programas Node que necesitan producir una salida que resuma los datos. console.table() intenta mostrar su en forma tabular (aunque, si no puede hacerlo, lo muestra utilizando el formato normal de console.log()). Esto funciona mejor cuando el argumento es una matriz relativamente corta de objetos y todos los objetos de la matriz tienen el mismo conjunto (relativamente pequeño) de propiedades. En este caso, cada objeto de la matriz se formatea como una fila de la tabla, y cada propiedad es una columna de la tabla. También puede pasar una matriz de nombres de propiedades como segundo argumento opcional para especificar el conjunto de columnas deseado. Si pasa un objeto en lugar de una matriz de objetos, la salida será una tabla con una columna para los nombres de las propiedades y otra para los valores de las propiedades. O, si los valores de las propiedades son a su vez objetos, sus nombres se convertirán en columnas de la tabla.</p>
    <p><codeinline>console.trace()</codeinline></p>
    <p>Esta función registra sus argumentos como lo hace console.log() y, además, sigue su salida con un seguimiento de pila. En Node, la salida va a stderr en lugar de stdout.</p>
    <p><codeinline>console.count()</codeinline></p>
    <p>Esta función toma un argumento de cadena y registra esa cadena, seguida del número de veces que ha sido llamada con esa cadena. Esto puede ser útil cuando se depura un manejador de eventos, por ejemplo, si necesita hacer un seguimiento de cuántas veces se ha disparado el manejador de eventos.</p>
    <p><codeinline>console.countReset()</codeinline></p>
    <p>Esta función toma una cadena como argumento y reinicia el contador de esa cadena.</p>
    <p><codeinline>console.group()</codeinline></p>
    <p>Esta función imprime sus argumentos en la consola como si se hubieran pasado a console.log(), luego establece el estado interno de la consola para que todos los mensajes de consola posteriores (hasta la siguiente llamada a console.groupEnd()) tengan una sangría relativa al mensaje que acaba de imprimir. Esto permite agrupar visualmente con sangría un grupo de mensajes relacionados. En los navegadores web, la consola del desarrollador suele permitir que los mensajes agrupados se contraigan y expandan como un grupo. Los argumentos de console.group() suelen utilizarse para dar un nombre explicativo al grupo.</p>
    <p><codeinline>console.groupCollapsed()</codeinline></p>
    <p>Esta función funciona como console.group() excepto que en los navegadores web, el grupo estará "colapsado" por defecto y los mensajes que contenga estarán ocultos a menos que el usuario haga clic para expandir el grupo. En Node, esta función es un sinónimo de console.group().</p>
    <p><codeinline>console.groupEnd()</codeinline></p>
    <p>Esta función no toma argumentos. No produce ninguna salida propia, pero termina la sangría y el agrupamiento causados por la llamada más reciente a console.group() o console.groupCollapsed().</p>
    <p><codeinline>console.time()</codeinline></p>
    <p>Esta función toma un único argumento de cadena, anota la hora a la que se llamó con esa cadena y no produce ninguna salida.</p>
    <p><codeinline>console.timeLog()</codeinline></p>
    <p>Esta función toma una cadena como primer argumento. Si esa cadena s e h a pasado previamente a console.time(), entonces imprime esa cadena seguida del tiempo transcurrido desde la llamada a console.time(). Si hay argumentos adicionales a console.timeLog(), se imprimen como si se hubieran pasado a console.log().</p>
    <p><codeinline>console.timeEnd()</codeinline></p>
    <p>Esta función toma un único argumento de cadena. Si ese argumento había sido pasado previamente a console.time(), entonces imprime ese argumento y el tiempo transcurrido. Después de llamar a console.timeEnd(), ya no es legal llamar a console.time Log() sin antes volver a llamar a console.time().</p>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>11.8.1 Salida formateada con consola</h2>
    <p>Las funciones de consola que imprimen sus argumentos como console.log() tienen una característica poco conocida: si el primer argumento es una cadena que incluye %s, %i, %d, %f, %o, %O, o %c, entonces este primer argumento se trata como cadena de formato,6 y los valores de los argumentos subsiguientes se sustituyen en la cadena en lugar de las secuencias de dos caracteres %.</p>
    <p>Los significados de las secuencias son los siguientes:</p>
    <p><codeinline>%s</codeinline></p>
    <p>El argumento se convierte en una cadena.</p>
    <p><codeinline>%i and %d</codeinline></p>
    <p>El argumento se convierte en un número y luego se trunca a un entero.</p>
    <p><codeinline>%f</codeinline></p>
    <p>El argumento se convierte en un número</p>
    <p><codeinline>%o and %O</codeinline></p>
    <p>El argumento se trata como un objeto y se muestran los nombres y valores de las propiedades. (En los navegadores web, esta visualización suele ser interactiva, y los usuarios pueden expandir y contraer propiedades para explorar una estructura de datos anidada). %o y %O muestran detalles del objeto. La variante en mayúsculas utiliza un formato de salida dependiente de la implementación que se considera más útil para los desarrolladores de software.</p>
    <p><codeinline>%c</codeinline></p>
    <p>En los navegadores web, el argumento se interpreta como una cadena de estilos CSS y se utiliza para dar estilo al texto que le sigue (hasta la siguiente secuencia %c o el final de la cadena). En Node, la secuencia %c y su correspondiente argumento son simplemente ignorados.</p>
    <p>Tenga en cuenta que a menudo no es necesario utilizar una cadena de formato con las funciones de consola: normalmente es fácil obtener una salida adecuada simplemente pasando uno o más valores (incluyendo objetos) a la función y permitiendo que la implementación los muestre de forma útil. Como ejemplo, observe que, si pasa un objeto Error a console.log(), se imprime automáticamente junto con su rastro de pila.</p>
  </section>
  <section id="9">
    <h2>11.9 API de URL</h2>
    <p>Dado que JavaScript se utiliza con tanta frecuencia en navegadores y servidores web, es habitual que el código JavaScript necesite manipular URLs. La clase URL analiza las URL y también permite modificarlas (añadiendo parámetros de búsqueda o alterando las rutas, por ejemplo). También maneja adecuadamente el complicado tema de escapar y desescapar los diversos componentes de una URL.</p>
    <p>La clase URL no forma parte de ningún estándar ECMAScript, pero funciona en Node y en todos los navegadores de Internet que no sean Internet Explorer. Está estandarizada en https:// url.spec.whatwg.org.</p>
    <p>Cree un objeto URL con el constructor URL(), pasando una cadena URL absoluta como argumento. También puede pasar una URL relativa como primer argumento y la URL absoluta a la que es relativa como segundo argumento. Una vez creado el objeto URL, sus distintas propiedades le permiten consultar versiones no descifradas de las distintas partes de la URL:</p>
    <pre>
    <code class="language-js">let url = new URL("https://example.com:8000/path/name?q=term#fragment");
    url.href // => "https://example.com:8000/path/name?q=term#fragment"
    url.origin // => "https://example.com:8000"
    url.protocol // => "https:"
    url.host // => "example.com:8000"
    url.hostname // => "example.com"
    url.port // => "8000"
    url.pathname // => "/path/name"
    url.search // => "?q=term"
    url.hash // => "#fragment"</code></pre>
    <p>Aunque no se utiliza habitualmente, las URL pueden incluir un nombre de usuario o un nombre de usuario y una contraseña, y la clase URL también puede analizar estos componentes de URL:</p>
    <pre>
    <code class="language-js">let url = new URL("ftp://admin:1337!@ftp.example.com/");
    url.href // => "ftp://admin:1337!@ftp.example.com/"
    url.origin // => "ftp://ftp.example.com"
    url.username // => "admin"
    url.password // => "1337!"</code></pre>
    <p>La propiedad de origen aquí es una simple combinación del protocolo URL y el host (incluyendo el puerto si se especifica uno). Como tal, es una propiedad de sólo lectura. Pero cada una de las otras propiedades demostradas en el ejemplo anterior es de lectura/escritura: puede establecer cualquiera de estas propiedades para establecer la parte correspondiente de la URL:</p>
    <pre>
    <code class="language-js">let url = new URL("https://example.com"); // Start with our server
    url.pathname = "api/search"; // Add a path to an API endpoint
    url.search = "q=test"; // Add a query parameter
    url.toString() // => "https://example.com/api/search?q=test"</code></pre>
    <p>Una de las características importantes de la clase URL es que añade correctamente la puntuación y escapa caracteres especiales en las URL cuando es necesario:</p>
    <pre>
    <code class="language-js">let url = new URL("https://example.com");
    url.pathname = "path with spaces";
    url.search = "q=foo#bar";
    url.pathname // => "/path%20with%20spaces"
    url.search // => "?q=foo%23bar"
    url.href // => "https://example.com/path%20with%20spaces?q=foo%23bar"</code></pre>
    <p>La propiedad href en estos ejemplos es especial: leer href es equivalente a llamar a toString(): reensambla todas las partes de la URL en la forma de cadena canónica de la URL. Y establecer href a una nueva cadena vuelve a ejecutar el analizador de URL en la nueva cadena como si hubiera llamado de nuevo al constructor URL().</p>
    <p>En los ejemplos anteriores, hemos estado utilizando la propiedad de búsqueda para referirnos a toda la parte de consulta de una URL, que consiste en los caracteres desde un signo de interrogación hasta el final de la URL o hasta el primer carácter hash. A veces, es suficiente tratar esto como una única propiedad URL. A menudo, sin embargo, las peticiones HTTP codifican los valores de múltiples campos de formulario o múltiples parámetros API en la parte de consulta de una URL utilizando el formato application/x-www-form-urlencoded. En este formato, la parte de consulta de la URL es un signo de interrogación seguido de uno o más pares nombre/valor, separados entre sí por ampersands. El mismo nombre puede aparecer más de una vez, lo que da lugar a un parámetro de búsqueda con más de un valor.</p>
    <p>Si desea codificar este tipo de pares nombre/valor en la parte de consulta de una URL, entonces la propiedad searchParams será más útil que la propiedad search. La propiedad search es una cadena de lectura/escritura que permite obtener y establecer toda la parte de consulta de la U R L . La propiedad searchParams es una referencia de sólo lectura a una propiedad Objeto URLSearchParams, que dispone de una API para obtener, establecer, añadir, eliminar y ordenar los parámetros codificados en la parte de consulta de la URL:</p>
    <pre>
    <code class="language-js">let url = new URL("https://example.com/search");
    url.search // => "": no query yet
    url.searchParams.append("q", "term"); // Add a search parameter
    url.search // => "?q=term"
    url.searchParams.set("q", "x"); // Change the value of this parameter
    url.search // => "?q=x"
    url.searchParams.get("q") // => "x": query the parameter value
    url.searchParams.has("q") // => true: there is a q parameter
    url.searchParams.has("p") // => false: there is no p parameter
    url.searchParams.append("opts", "1"); // Add another search parameter
    url.search // => "?q=x&opts=1"
    url.searchParams.append("opts", "&"); // Add another value for same name
    url.search // => "?q=x&opts=1&opts=%26": note escape
    url.searchParams.get("opts") // => "1": the first value
    url.searchParams.getAll("opts") // => ["1", "&"]: all values
    url.searchParams.sort(); // Put params in alphabetical order
    url.search // => "?opts=1&opts=%26&q=x"
    url.searchParams.set("opts", "y"); // Change the opts param
    url.search // => "?opts=y&q=x"
    // searchParams is iterable
    [...url.searchParams] // => [["opts", "y"], ["q", "x"]]
    url.searchParams.delete("opts"); // Delete the opts param
    url.search // => "?q=x"
    url.href // => "https://example.com/search?q=x"</code></pre>
    <p>El valor de la propiedad searchParams es un objeto URLSearchParams. Si desea codificar parámetros de URL en una cadena de consulta, puede crear un objeto URLSearchParams, añadir parámetros, convertirlo en una cadena y establecerlo en la propiedad de búsqueda de una URL:</p>
    <pre>
    <code class="language-js">let url = new URL("http://example.com");
    let params = new URLSearchParams();
    params.append("q", "term");
    params.append("opts", "exact");
    params.toString() // => "q=term&opts=exact"
    url.search = params;
    url.href // => "http://example.com/?q=term&opts=exact"</code></pre>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h2>11.9.1 Funciones URL heredadas</h2>
    <p>Antes de la definición de la API de URL descrita anteriormente, ha habido múltiples intentos de soportar el escapado y desescapado de URLs en el núcleo del lenguaje JavaScript. El primer intento fueron las funciones definidas globalmente escape() y unescape(), que ahora están obsoletas pero todavía ampliamente implementadas. No deberían utilizarse.</p>
    <p>Cuando escape() y unescape() quedaron obsoletas, ECMAScript introdujo dos pares de funciones globales alternativas:</p>
    <p><codeinline>encodeURI() and decodeURI()</codeinline></p>
    <p>encodeURI() toma una cadena como argumento y devuelve una nueva cadena en la que se escapan los caracteres no ASCII y determinados caracteres ASCII (como el espacio). decodeURI() invierte el proceso. Los caracteres que deben escaparse se convierten primero a su codificación UTF-8 y, a continuación, cada byte de esa codificación se sustituye por una secuencia de escape %xx, donde xx son dos dígitos hexadecimales. Dado que encodeURI() está pensada para codificar URLs completas, no escapa caracteres separadores de URL como /, ? y #. Pero esto significa que encodeURI() no puede funcionar correctamente con URLs que contengan esos caracteres en sus distintos componentes.</p>
    <p><codeinline>encodeURIComponent() and decodeURIComponent()</codeinline></p>
    <p>Este par de funciones funcionan igual que encodeURI() y decodeURI(), salvo que están pensadas para escapar componentes individuales de un URI, por lo que también escapan caracteres como /, ? y # que se utilizan para separar dichos componentes. Estas son las más útiles de las funciones URL heredadas, pero tenga en cuenta que encodeURICompo nent() escapará caracteres / en un nombre de ruta que probablemente no desee escapar. Y convertirá los espacios en un parámetro de consulta a %20, aunque se supone que los espacios deben escaparse con un + en esa parte de una URL.</p>
    <p>El problema fundamental de todas estas funciones heredadas es que pretenden aplicar un único esquema de codificación a todas las partes de una URL, cuando lo cierto es que las distintas partes de una URL utilizan codificaciones diferentes. Si quieres una U R L correctamente formateada y codificada, la solución es simplemente utilizar la clase URL para todas las manipulaciones de URL que hagas.</p>
  </section>
  <section id="10">
    <h2>11.10 Temporizadores</h2>
    <p>Desde los primeros días de JavaScript, los navegadores web han definido dos funciones -setTimeout() y setInterval()- que permiten a los programas pedir al navegador que invoque una función una vez transcurrido un tiempo determinado o que invoque la función repetidamente en un intervalo especificado. Estas funciones nunca se han estandarizado como parte del núcleo del lenguaje, pero funcionan en todos los navegadores y en Node y forman parte de facto de la biblioteca estándar de JavaScript.</p>
    <p>El primer argumento de setTimeout() es una función, y el segundo es un número que especifica cuántos milisegundos deben transcurrir antes de que se invoque la función. Después de la cantidad de tiempo especificada (y quizás un poco más si el sistema está ocupado), la función será invocada sin argumentos. Aquí, por ejemplo, hay tres llamadas a setTimeout() que imprimen mensajes de consola después de un segundo, dos segundos y tres segundos:</p>
    <pre>
    <code class="language-js">setTimeout(() => &lbrace; console.log("Ready..."); }, 1000);
    setTimeout(() => &lbrace; console.log("set..."); }, 2000);
    setTimeout(() => &lbrace; console.log("go!"); }, 3000);</code></pre>
    <p>Observe que setTimeout() no espera a que transcurra el tiempo antes de volver. Las tres líneas de código de este ejemplo se ejecutan casi instantáneamente, pero luego no ocurre nada hasta que transcurren 1.000 milisegundos.</p>
    <p>Si omite el segundo argumento de setTimeout(), su valor por defecto es 0. Eso no significa, sin embargo, que la función que especifique sea invocada inmediatamente. En su lugar, la función se registra para ser llamada "tan pronto como sea posible". Si un navegador está particularmente ocupado manejando entradas del usuario u otros eventos, pueden pasar 10 milisegundos o más antes de que la función sea invocada.</p>
    <p>setTimeout() registra una función para ser invocada una vez. A veces, esa función llamará a su vez a setTimeout() para programar otra invocación en un momento futuro. Si desea invocar una función repetidamente, sin embargo, a menudo es más sencillo utilizar setInterval(). setInterval() toma los mismos dos argumentos que setTimeout() pero invoca la función repetidamente cada vez que el número especificado de milisegundos (aproximadamente) han transcurrido.</p>
    <p>Tanto setTimeout() como setInterval() devuelven un valor. Si guarda este valor en una variable, puede utilizarlo más tarde para cancelar la ejecución de la función pasándoselo a clearTimeout() o clearInterval(). El valor devuelto es típicamente un número en los navegadores web y es un objeto en Node. El tipo real no importa, y debes tratarlo como un valor opaco. Lo único que puede hacer con este valor es pasarlo a clearTimeout() para cancelar la ejecución de una función registrada con setTime out() (suponiendo que aún no haya sido invocada) o para detener la ejecución repetida de una función registrada con setInterval().</p>
    <p>A continuación se muestra un ejemplo que demuestra el uso de setTimeout(), setInterval() y clearInterval() para mostrar un simple reloj digital con la API de Consola:</p>
    <pre>
    <code class="language-js">// Once a second: clear the console and print the current time
    let clock = setInterval(() => &lbrace;
      console.clear();
      console.log(new Date().toLocaleTimeString());
    }, 1000);

    // After 10 seconds: stop the repeating code above.
    setTimeout(() => &lbrace; clearInterval(clock); }, 10000);</code></pre>
    <p>Volveremos a ver setTimeout() y setInterval() cuando tratemos la programación asíncrona en el capítulo 13.</p>
  </section>
  <section id="11" class="py-4 xs:py-5 sm:py-6">
    <h2>11.11 Resumen</h2>
    <p>Aprender un lenguaje de programación no consiste sólo en dominar la gramática. Es igualmente importante estudiar la biblioteca estándar para familiarizarse con todas las herramientas que se suministran con el lenguaje. En este capítulo se ha documentado la biblioteca estándar de JavaScript, que incluye:</p>
    <ul>
      <li class="font-normal">Estructuras de datos importantes, como Set, Map y matrices tipadas.</li>
      <li class="font-normal">Las clases Date y URL para trabajar con fechas y URLs.</li>
      <li class="font-normal">Gramática de expresiones regulares de JavaScript y su clase RegExp para la concordancia de patrones textuales.</li>
      <li class="font-normal">Biblioteca de internacionalización de JavaScript para dar formato a fechas, horas y números y para ordenar cadenas.</li>
      <li class="font-normal">El objeto JSON para serializar y deserializar estructuras de datos simples y el objeto objeto de consola para el registro de mensajes.</li>
    </ul>
  </section>
</Layoutjavascript>
