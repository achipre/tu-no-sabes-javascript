---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-12" capSiguiente="capitulo-14" />
  <section class="fadeIn">
    <h1 class="text-right">JavaScript asíncrono</h1>
    <p>Algunos programas informáticos, como las simulaciones científicas y los modelos de aprendizaje automático, están ligados al cálculo: se ejecutan continuamente, sin pausa, hasta que obtienen su resultado. Sin embargo, la mayoría de los programas informáticos del mundo real son bastante <em>asíncronos</em>. Esto significa que a menudo tienen que dejar de computar mientras esperan a que lleguen los datos de o a que ocurra algún evento. Los programas JavaScript de un navegador web suelen estar <em>orientados a eventos</em>, lo que significa que esperan a que el usuario haga clic o toque antes de hacer nada. Y los servidores basados en JavaScript suelen esperar a que las peticiones de los clientes lleguen a través de la red antes de hacer nada.</p>
    <p>Este tipo de programación asíncrona es habitual en JavaScript, y este capítulo documenta tres importantes características del lenguaje que ayudan a facilitar el trabajo con código asíncrono. Las promesas, nuevas en ES6, son objetos que representan el resultado aún no disponible - de una operación asíncrona. Las palabras clave <codeinline>async</codeinline> y <codeinline>await</codeinline> se introdujeron en ES2017 y proporcionan una nueva sintaxis que simplifica la programación asíncrona al permitir estructurar el código basado en promesas como si fuera síncrono. Por último, los iteradores asíncronos y el bucle for/await se introdujeron en ES2018 y permiten trabajar con flujos de eventos asíncronos utilizando bucles sencillos que parecen síncronos.</p>
    <p>Irónicamente, aunque JavaScript proporciona estas potentes características para trabajar con código asíncrono, no hay características del núcleo del lenguaje que sean en sí mismas asíncronas. Para demostrar Promises, <codeinline>async</codeinline>, <codeinline>await</codeinline>, y <codeinline>for/await</codeinline>, por lo tanto, primero daremos un rodeo en JavaScript del lado del cliente y del lado del servidor para explicar algunas de las características asíncronas de los navegadores web y Node. (Puedes aprender más sobre JavaScript del lado del cliente y del lado del servidor en los Capítulos <a href="capitulo-15">15</a> y <a href="capitulo-16">16</a>.)</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>13.1 Programación asíncrona con callbacks</h2>
    <p>En su nivel más fundamental, la programación asíncrona en JavaScript se realiza con <em>retrollamadas</em>. Una llamada de retorno es una función que se escribe y se pasa a otra función. Esa otra función invoca ("devuelve la llamada") a su función cuando se cumple alguna condición o se produce algún evento (asíncrono). La invocación de la función de devolución de llamada que usted proporciona le notifica la condición o el evento y, a veces, la invocación incluirá argumentos de función que proporcionan detalles adicionales. Esto es más fácil de entender con algunos ejemplos concretos, y las subsecciones siguientes demuestran varias formas de programación asíncrona basada en callbacks utilizando tanto JavaScript del lado del cliente como Node.</p>
  </section>
  <section id="1-1">
    <h2>13.1.1 Temporizadores</h2>
    <p>Uno de los tipos más simples de asincronía es cuando quieres ejecutar algún código después de que haya transcurrido una cierta cantidad de tiempo . Como vimos en <a href="capitulo-11#10">§11.10</a>, puedes hacer esto con la función <codeinline>setTimeout()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">setTimeout(checkForUpdates, 60000);</code></pre>
    <p>El primer argumento de <codeinline>setTimeout()</codeinline> es una función y el segundo es un intervalo de tiempo medido en milisegundos. En el código anterior, una hipotética función <codeinline>checkForUpdates()</codeinline> será llamada 60.000 milisegundos (1 minuto) después de la llamada a <codeinline>setTimeout()</codeinline>. <codeinline>checkForUpdates()</codeinline> es una función callback que su programa podría definir, y <codeinline>setTi meout()</codeinline> es la función que usted invoca para registrar su función callback y especificar bajo qué condiciones asíncronas debería ser invocada.</p>
    <p><codeinline>setTimeout()</codeinline> llama a la función callback especificada una vez, sin pasar argumentos, y luego se olvida de ella. Si está escribiendo una función que realmente busca actualizaciones, probablemente quiera que se ejecute repetidamente. Puede hacerlo utilizando <codeinline>setInterval()</codeinline> en lugar de <codeinline>setTimeout()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Llama a checkForUpdates en un minuto y luego nuevamente cada minuto después de eso
    let updateIntervalId = setInterval(checkForUpdates, 60000);
    // setInterval() Devuelve un valor que podemos usar para detener la repetición.
    // invocaciones por llamada clearInterval(). (Similar, setTimeout()
    // devuelve un valor que puedes pasar a clearTimeout())
    function stopCheckingForUpdates() &lbrace;
      clearInterval(updateIntervalId);
    }</code></pre>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>13.1.2 Eventos</h2>
    <p>Los programas JavaScript del lado del cliente están casi siempre orientados a eventos: en lugar de ejecutar algún tipo de cálculo predeterminado, suelen esperar a que el usuario haga algo y luego responden a sus acciones. El navegador web genera un <em>evento</em> cuando el usuario pulsa una tecla del teclado, mueve el ratón, hace clic en un botón del ratón o toca un dispositivo de pantalla táctil. Los programas JavaScript basados en eventos registran funciones de retrollamada para determinados tipos de eventos en contextos específicos, y el navegador web invoca esas funciones cada vez que se producen los eventos especificados. Estas funciones de callback se llaman <em>manejadores de eventos</em> o <em>escuchadores de eventos</em>, y se registran con <codeinline>addEventListener()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Pídale al navegador web que devuelva un objeto que represente el 
    // elemento HTML &lt;button> ue coincida con este selector CSS
    let okay = document.querySelector('#confirmUpdateDialog button.okay');

    // Ahora registre una función de devolución de llamada que se 
    // invocará cuando el usuario haga clic en ese botón.
    okay.addEventListener('click', applyUpdate);</code></pre>
    <p>En este ejemplo, <codeinline>applyUpdate()</codeinline> es una función callback hipotética que suponemos está implementada en algún otro lugar. La llamada a <codeinline>document.querySelector()</codeinline> devuelve un objeto que representa un único elemento especificado en la página web. Llamamos a <codeinline>addEventListener()</codeinline> en ese elemento para registrar nuestra llamada de retorno. El primer argumento de <codeinline>addEventListener()</codeinline> es una cadena que especifica el tipo de evento que nos interesa: un clic del ratón o un toque de la pantalla táctil, en este caso. Si el usuario hace clic o toca en ese elemento específico de la página web, entonces el navegador invocará nuestra función de devolución de llamada <codeinline>applyUpdate()</codeinline>, pasando un objeto que incluye detalles (como la hora y las coordenadas del puntero del ratón) sobre el evento.</p>
  </section>
  <section id="1-3">
    <h2>13.1.3 Eventos en red</h2>
    <p>Otra fuente común de asincronía en la programación JavaScript son las peticiones de red. JavaScript que se ejecuta en el navegador puede obtener datos de un servidor web con código como este:</p>
    <pre class="language-js">
    <code class="language-js">function getCurrentVersionNumber(versionCallback) &lbrace; // Tenga en cuenta el argumento del callback
      // Realizar una solicitud HTTP con script a una API de versión de backend
      let request = new XMLHttpRequest();
      request.open("GET", "http://www.example.com/api/version");
      request.send();

      // Registra una devolución de llamada que se invocará cuando llegue la respuesta
      request.onload = function() &lbrace;
        if (request.status === 200) &lbrace;
          // Si el estado HTTP es bueno, obtenga el número de versión y llame a la devolución de llamada.
          let currentVersion = parseFloat(request.responseText);
          versionCallback(null, currentVersion);
        } else &lbrace;
          // De lo contrario, informe un error a la devolución de llamada.
          versionCallback(response.statusText, null);
        }
      };
      // Registra otra devolución de llamada que se invocará en caso de errores de red
      request.onerror = request.ontimeout = function(e) &lbrace;
        versionCallback(e.type, null);
      };
    }</code></pre>
    <p>El código JavaScript del lado del cliente puede utilizar la clase XMLHttpRequest más funciones de devolución de llamada para realizar peticiones HTTP y gestionar de forma asíncrona la respuesta del servidor cuando llegue.<sup>1</sup> La función <codeinline>getCurrentVersionNumber()</codeinline> definida aquí (podemos imaginar que la utiliza la hipotética función <codeinline>checkForUpdates()</codeinline> que comentamos en <a href="capitulo-13#1-1">§13.1.1</a>) realiza una petición HTTP y define los manejadores de eventos que serán invocados cuando se reciba la respuesta del servidor o cuando un tiempo de espera u otro error haga que la petición falle.</p>
    <p>Observe que el código del ejemplo anterior no llama a <codeinline>addEventListener()</codeinline> como hizo nuestro ejemplo anterior. Para la mayoría de las API web (incluida ésta), los controladores de eventos pueden definirse invocando <codeinline>addEventListener()</codeinline> en el objeto que genera el evento y pasando el nombre del evento de interés junto con la función de devolución de llamada. Sin embargo, también se puede registrar un único receptor de eventos asignándolo directamente a una propiedad del objeto. Esto es lo que hacemos en este código de ejemplo, asignando funciones a las propiedades <codeinline>onload</codeinline>, <codeinline>onerror</codeinline> y <codeinline>ontimeout</codeinline>. Por convención, las propiedades listener de eventos como estas siempre tienen nombres que comienzan con <em>on</em>. <codeinline>addEventListener()</codeinline> es la técnica más flexible porque permite múltiples manejadores de eventos. Pero en los casos en los que estés seguro de que ningún otro código necesitará registrar un receptor para el mismo objeto y tipo de evento, puede ser más simple simplemente establecer la propiedad apropiada a tu callback.</p>
    <p>Otra cosa a tener en cuenta sobre la función <codeinline>getCurrentVersionNumber()</codeinline> en este código de ejemplo es que, debido a que realiza una petición asíncrona, no puede devolver de forma síncrona el valor (el número de versión actual) en el que está interesado el llamante. En su lugar, el autor de la llamada pasa una función de devolución de llamada, que se invoca cuando el resultado está listo o cuando se produce un error. En este caso, el autor de la llamada proporciona una función de devolución de llamada que espera dos argumentos. Si el XMLHttpRequest funciona correctamente, entonces <codeinline>getCurrentVersionNumber()</codeinline> invoca la llamada de retorno con un primer argumento nulo y el número de versión como segundo argumento. O, si se produce un error, entonces <codeinline>getCurrentVersionNumber()</codeinline> invoca la llamada de retorno con los detalles del error en el primer argumento y null como segundo argumento.</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>13.1.4 Callbacks y Eventos en Node</h2>
    <p>El entorno JavaScript del lado del servidor de Node.js es profundamente asíncrono y define muchas APIs que utilizan callbacks y eventos. La API predeterminada para leer el contenido de un archivo, por ejemplo, es asíncrona e invoca una función de devolución de llamada cuando se han leído los contenidos del archivo:</p>
    <pre class="language-js">
    <code class="language-js">const fs = require("fs"); // El módulo "fs" tiene API relacionadas con el sistema de archivos
      let options = &lbrace; // Un objeto para almacenar opciones para nuestro programa.
      // Las opciones predeterminadas irían aquí
      };

      // Leer un archivo de configuración y luego llamar a la función de devolución de llamada
      fs.readFile("config.json", "utf-8", (err, text) => &lbrace;
        if (err) &lbrace;
          // Si hubo un error, muestra una advertencia, pero continúa
          console.warn("Could not read config file:", err);
        } else &lbrace;
          // De lo contrario, analice el contenido del archivo y asígnelo al objeto de opciones.
          Object.assign(options, JSON.parse(text));
        }

        // En cualquier caso, ahora podemos empezar a ejecutar el programa.
        startProgram(options);
      });</code></pre>
    <p>La función <codeinline>fs.readFile()</codeinline> de Node toma una llamada de retorno de dos parámetros como último argumento. Lee el archivo especificado de forma asíncrona y luego invoca la llamada de retorno. Si el fichero se ha leído correctamente, pasa el contenido del fichero como segundo argumento de la llamada de retorno. Si hubo un error, pasa el error como primer argumento de la llamada de retorno. En este ejemplo, expresamos la llamada de retorno como una función de flecha, que es una sintaxis sucinta y natural para este tipo de operación simple.</p>
    <p>Node también define una serie de APIs basadas en eventos. La siguiente función muestra cómo hacer una petición HTTP del contenido de una URL en Node. Tiene dos capas de código asíncrono manejadas con escuchadores de eventos. Observa que Node utiliza un método <codeinline>on()</codeinline> para registrar escuchadores de eventos en lugar de <codeinline>addEventListener()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">const https = require("https");

    // Lee el contenido de texto de la URL y pásalo asincrónicamente a la devolución de llamada.
    function getText(url, callback) &lbrace;
      // Iniciar una solicitud HTTP GET para la URL
      request = https.get(url);

      // Registra una función para manejar el evento "response".
      request.on("response", response => &lbrace;
        // El evento de respuesta significa que se han recibido los encabezados de respuesta.
        let httpStatus = response.statusCode;
        // Aún no se ha recibido el cuerpo de la respuesta HTTP.
        // Así que registramos más controladores de eventos para que se llamen cuando llegue.
        response.setEncoding("utf-8"); // Nosotros estamos esperando texto Unicode
        let body = ""; // Lo que vamos a acumular aquí.

        // Este controlador de eventos se llama cuando una parte del cuerpo está lista.
        response.on("data", chunk => &lbrace; body += chunk; });

        // Este controlador de eventos se llama cuando se completa la respuesta.
        response.on("end", () => &lbrace;
          if (httpStatus === 200) &lbrace; // Si la respuesta HTTP fue buena
            callback(null, body); // Pasar el cuerpo de la respuesta a la devolución de llamada
          } else &lbrace; // De lo contrario, pasa un error
            callback(httpStatus, null);
          }
        });
      });
      
      // También registramos un controlador de eventos para errores de red de nivel inferior.
      request.on("error", (err) => &lbrace;
        callback(err, null);
      });
    }</code></pre>
  </section>
  <section id="2">
    <h2>13.2 Promesas</h2>
    <p>Ahora que hemos visto ejemplos de programación asíncrona basada en llamadas de retorno y eventos en entornos JavaScript del lado del cliente y del lado del servidor, podemos introducir <em>Promises</em>, una característica central del lenguaje diseñada para simplificar la programación asíncrona.</p>
    <p>Una promesa es un objeto que representa el resultado de un cálculo asíncrono. Ese resultado puede o no estar listo todavía, y la API Promise es intencionadamente imprecisa al respecto: no hay forma de obtener de forma sincrónica el valor de una Promise; sólo puedes pedir a la Promise que llame a una función de devolución de llamada cuando el valor esté listo. Si estás definiendo una API asíncrona como la función <codeinline>getText()</codeinline> de la sección anterior, pero quieres que esté basada en promesas, omite el argumento callback, y en su lugar devuelve un objeto Promise. La persona que llama puede entonces registrar una o más llamadas de retorno en este objeto Promise, y serán invocadas cuando el cálculo asíncrono haya terminado.</p>
    <p>Así que, en el nivel más simple, las promesas son sólo una forma diferente de trabajar con devoluciones de llamada. Sin embargo, su uso tiene ventajas prácticas. Un problema real con la programación asíncrona basada en callbacks es que es común terminar con callbacks dentro de callbacks dentro de callbacks, con líneas de código tan altamente sangradas que es dificult leer. Las promesas permiten que este tipo de devolución de llamada anidada se reexprese como una <em>cadena de promesas</em> más lineal que tiende a ser más fácil de leer y más fácil de razonar.</p>
    <p>Otro problema de las retrollamadas es que pueden dificultar la gestión de errores. Si una función asíncrona (o una llamada de retorno invocada de forma asíncrona) lanza una excepción, no hay forma de que esa excepción se propague de vuelta al iniciador de la operación asíncrona. Este es un hecho fundamental sobre la programación asíncrona: rompe el manejo de excepciones. La alternativa es rastrear y propagar meticulosamente los errores con argumentos de devolución de llamada y valores de retorno, pero esto es tedioso y difícil de hacer bien. Las promesas ayudan aquí estandarizando una forma de manejar los errores y proporcionando una forma de que los errores se propaguen correctamente a través de una cadena de promesas.</p>
    <p>Tenga en cuenta que las promesas representan los resultados futuros de cálculos asíncronos individuales. Sin embargo, no pueden utilizarse para representar cálculos asíncronos repetidos. Más adelante en este capítulo, escribiremos una alternativa basada en Promises a la función <codeinline>setTimeout()</codeinline>, por ejemplo. Pero no podemos usar Promises para reemplazar <codeinline>setInterval()</codeinline> porque esa función invoca una función callback repetidamente, que es algo para lo que las Promises no están diseñadas. De forma similar, podríamos usar una Promise en lugar del manejador de eventos "load" de un objeto XMLHttpRequest, ya que esa llamada de retorno sólo se invoca una vez. Pero normalmente no usaríamos una Promise en lugar de un manejador de eventos "click" de un objeto botón HTML, ya que normalmente queremos permitir al usuario hacer click en un botón múltiples veces.</p>
    <p>En las subsecciones siguientes:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Explicar la terminología Promise y mostrar el uso básico de Promise
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Mostrar cómo encadenar promesas
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Demuestre cómo crear sus propias API basadas en promesas
        </p>
      </li>
    </ul>
    <nota>
      <img class="self-start" src="/public/javascript/nota_warning.svg" alt="Nota de la warning">
      <div class="">
        <p>Las promesas parecen sencillas a primera vista, y el caso de uso básico de las promesas es, de hecho, sencillo y simple. Pero pueden llegar a ser sorprendentemente confusas para cualquier cosa más allá de los casos de uso más simples. Las promesas son un poderoso lenguaje para la programación asíncrona, pero es necesario entenderlas en profundidad para utilizarlas correctamente y con confianza. Sin embargo, merece la pena dedicar tiempo a desarrollar ese profundo conocimiento, y te insto a que estudies detenidamente este largo capítulo.</p>
      </div>
    </nota>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>13.2.1 Uso de promesas</h2>
    <p>Con la llegada de Promises al núcleo del lenguaje JavaScript, los navegadores web han comenzado a implementar APIs basadas en Promises. En la sección anterior, implementamos una función <codeinline>getText()</codeinline> que realizaba una petición HTTP asíncrona y pasaba el cuerpo de la respuesta HTTP a una función callback especificada como una cadena. Imagina una variante de esta función, <codeinline>getJSON()</codeinline>, que analiza el cuerpo de la respuesta HTTP como JSON y devuelve una Promise en lugar de aceptar un argumento de devolución de llamada. Implementaremos una función <codeinline>getJSON()</codeinline> más adelante en este capítulo, pero por ahora, veamos cómo utilizar esta función de utilidad que devuelve promesas:</p>
    <pre class="language-js">
    <code class="language-js">getJSON(url).then(jsonData => &lbrace;
      // Esta es una función de devolución de llamada que se invocará de 
      // forma asincrónica con el valor JSON analizado cuando esté disponible.
    });</code></pre>
    <p><codeinline>getJSON()</codeinline> inicia una petición HTTP asíncrona para la URL que especifiques y luego, mientras esa petición está pendiente, devuelve un objeto Promise. El objeto Promise define un método de instancia <codeinline>then()</codeinline>. En lugar de pasar nuestra función callback directamente a <codeinline>getJSON()</codeinline>, la pasamos al método <codeinline>then()</codeinline>. Cuando llega la respuesta HTTP, el cuerpo de esa respuesta se analiza como JSON, y el valor analizado resultante se pasa a la función que pasamos a <codeinline>then()</codeinline>.</p>
    <p>Puedes pensar en el método <codeinline>then()</codeinline> como un método de registro de callback como el método <codeinline>addEventListener()</codeinline> utilizado para registrar manejadores de eventos en Java-Script del lado del cliente. Si llamas al método <codeinline>then()</codeinline> de un objeto Promise varias veces, cada una de las funciones que especifiques será llamada cuando se complete el cálculo prometido.</p>
    <p>Sin embargo, a diferencia de muchos escuchadores de eventos, una Promise representa una sola computación, y cada función registrada con <codeinline>then()</codeinline> será invocada sólo una vez. Vale la pena señalar que la función que se pasa a <codeinline>then()</codeinline> se invoca de forma asíncrona, incluso si la computación asíncrona ya se ha completado cuando se llama a <codeinline>then()</codeinline>.</p>
    <p>A un nivel sintáctico simple, el método <codeinline>then()</codeinline> es la característica distintiva de las Promesas, y es idiomático añadir <codeinline>.then()</codeinline> directamente a la invocación de la función que devuelve la Promesa, sin el paso intermedio de asignar el objeto Promesa a una variable.</p>
    <p>También es idiomático nombrar las funciones que devuelven promesas y las funciones que utilizan los resultados de las promesas con verbos, y estos modismos conducen a un código que es particularmente fácil de leer:</p>
    <pre class="language-js">
    <code class="language-js">// Supongamos que tiene una función como ésta para mostrar un perfil de usuario.
    function displayUserProfile(profile) &lbrace; /* implementation omitted */ }

    // A continuación te mostramos cómo puedes usar esa función con una Promesa.
    // Observe cómo esta línea de código se lee casi como una oración en inglés:
    getJSON("/api/user/profile").then(displayUserProfile);</code></pre>
    <p class="title-article text-left">Gestión de errores con promesas</p>
    <p>Las operaciones asíncronas, sobre todo las que implican trabajo en red, pueden fallar de varias maneras, por lo que hay que escribir código robusto para gestionar los errores que inevitablemente se producirán.</p>
    <p>Para Promises, podemos hacer esto pasando una segunda función al método <codeinline>then()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">getJSON("/api/user/profile").then(displayUserProfile, handleProfileError);</code></pre>
    <p>Una Promise representa el resultado futuro de una computación asíncrona que ocurre después de la creación del objeto Promise. Dado que el cálculo se realiza después de que se nos devuelva el objeto Promise, no hay forma de que el cálculo devuelva tradicionalmente un valor o lance una excepción que podamos capturar. Las funciones que pasamos a <codeinline>then()</codeinline> proporcionan alternativas. Cuando una computación sincrónica se completa normalmente, simplemente devuelve el resultado a su invocador. Cuando un cálculo asíncrono basado en promesas se completa normalmente, pasa su resultado a la función que es el primer argumento de <codeinline>then()</codeinline>.</p>
    <p>Cuando algo va mal en un cálculo síncrono, se lanza una excepción que se propaga por la pila de llamadas hasta que hay una cláusula <codeinline>catch</codeinline> para manejarla. Cuando se ejecuta una computación asíncrona, su invocador ya no está en la pila, por lo que si algo va mal, simplemente no es posible lanzar una excepción de vuelta al invocador.</p>
    <p>En su lugar, los cálculos asíncronos basados en promesas pasan la excepción (normalmente como un objeto Error de algún tipo, aunque esto no es necesario) a la segunda función pasada a <codeinline>then()</codeinline>. Así, en el código anterior, si <codeinline>getJSON()</codeinline> se ejecuta normalmente, pasa su resultado a <codeinline>displayUserProfile()</codeinline>. Si hay un error (el usuario no ha iniciado sesión, el servidor está caído, la conexión a Internet del usuario se ha caído, la solicitud ha expirado, etc.), entonces <codeinline>getJSON()</codeinline> pasa un objeto Error a <codeinline>handleProfileError()</codeinline>.</p>
    <p>En la práctica, es raro ver dos funciones pasadas a <codeinline>then()</codeinline>. Hay una forma mejor y más idiomática de manejar los errores cuando se trabaja con promesas. Para entenderlo, primero considere lo que ocurre si <codeinline>getJSON()</codeinline> se completa normalmente pero se produce un error en <codeinline>displayUserProfile()</codeinline>. Esa función de llamada de retorno es invocada de forma asíncrona cuando <codeinline>getJSON()</codeinline> retorna, por lo que también es asíncrona y no puede lanzar una excepción de forma significativa (porque no hay código en la pila de llamadas para manejarla).</p>
    <p>La forma más idiomática de manejar los errores en este código es la siguiente:</p>
    <pre class="language-js">
    <code class="language-js">getJSON("/api/user/profile").then(displayUserProfile).catch(handleProfileError);</code></pre>
    <p>Con este código, un resultado normal de <codeinline>getJSON()</codeinline> todavía se pasa a <codeinline>displayUserProfile()</codeinline>, pero cualquier error en <codeinline>getJSON()</codeinline> o en <codeinline>displayUserProfile()</codeinline> (incluyendo cualquier excepción lanzada por <codeinline>displayUserProfile</codeinline>) se pasa a <codeinline>handleProfileError()</codeinline>. El método catch() es una forma abreviada de llamar a <codeinline>then()</codeinline> con un primer argumento <codeinline>null</codeinline> y la función de gestión de errores especificada como segundo argumento.</p>
    <p>Tendremos más que decir sobre <codeinline>catch()</codeinline> y este lenguaje de gestión de errores cuando hablemos de Promise chains en la siguiente sección.</p>
    <article>
      <p class="title-article">Terminología de la promesa</p>
      <p>Antes de seguir hablando de promesas, merece la pena detenerse a definir algunos términos. Cuando no estamos programando y hablamos de promesas humanas, decimos que una promesa se "cumple" o se "rompe". Cuando hablamos de promesas en JavaScript, los términos equivalentes son "cumplida" y "rechazada". Imagina que has llamado al método <codeinline>then()</codeinline> de una Promise y le has pasado dos funciones callback. Decimos que la promesa se ha <em>cumplido</em> siempre y cuando se llame a la primera llamada de retorno. Y decimos que la promesa ha sido <em>rechazada</em> cuando se llama a la segunda llamada de retorno. Si una promesa no se cumple ni se rechaza, entonces está <em>pendiente</em>. Y una vez que una promesa se cumple o se rechaza, decimos que está resuelta. Ten en cuenta que una promesa nunca puede cumplirse <em>ni</em> rechazarse a la vez. Una vez que una promesa se resuelve, nunca cambiará de cumplida a rechazada o viceversa.</p>
      <p>Recuerda cómo definimos las Promesas al principio de esta sección: "una Promise es un objeto que representa el <em>resultado</em> de una operación asíncrona". Es importante recordar que las Promesas no son sólo formas abstractas de registrar retrollamadas para que se ejecuten cuando algún código asíncrono termine: representan los resultados de ese código asíncrono. Si el código asíncrono se ejecuta normalmente (y la Promesa se cumple), entonces ese resultado es esencialmente el valor de retorno del código. Y si el código asíncrono no se completa normalmente (y la Promesa es rechazada), entonces el resultado es un objeto Error o algún otro valor que el código podría haber lanzado si no fuera asíncrono. Cualquier Promise que se haya cumplido tiene un valor asociado, y ese valor no cambiará. Si la Promise se cumple, entonces el valor es un valor de retorno que se pasa a cualquier función callback registrada como primer argumento de <codeinline>then()</codeinline>. Si la Promesa es rechazada, entonces el valor es un error de algún tipo que se pasa a cualquier función callback registrada con <codeinline>catch()</codeinline> o como segundo argumento de <codeinline>then()</codeinline>.</p>
      <p>La razón por la que quiero ser preciso sobre la terminología de las promesas es que éstas también pueden <em>resolverse</em>. Es fácil confundir este estado resuelto con el estado cumplido o con el estado resuelto, pero no es precisamente lo mismo que ninguno de los dos. Entender el estado resuelto es una de las claves para una comprensión profunda de las Promesas, y volveré a ello después de que hayamos hablado de las cadenas de Promesas más adelante.</p>
    </article>
  </section>
  <section id="2-2">
    <h2>13.2.2 Encadenar promesas</h2>
    <p>Una de las ventajas más importantes de las promesas es que proporcionan una forma natural de expresar una secuencia de operaciones asíncronas como una cadena lineal de invocaciones al método <codeinline>then()</codeinline>, sin tener que anidar cada operación dentro de la llamada de retorno de la anterior. He aquí, por ejemplo, una hipotética cadena Promise:</p>
    <pre class="language-js">
    <code class="language-js">fetch(documentURL) // Realizar una solicitud HTTP
      .then(response => response.json()) // Solicitar el cuerpo JSON de la respuesta
      .then(document => &lbrace; // Cuando obtenemos el JSON analizado
        return render(document); // mostrar el documento al usuario
      })
    .then(rendered => &lbrace; // Cuando obtenemos el documento renderizado
      cacheInDatabase(rendered); // almacenarlo en caché en la base de datos local.
    })
    .catch(error => handle(error)); // Gestionar cualquier error que se produzca</code></pre>
    <p>Este código ilustra cómo una cadena de Promises puede facilitar la expresión de una secuencia de operaciones asíncronas. Sin embargo, no vamos a discutir esta cadena Promise en particular. Sin embargo, continuaremos explorando la idea de usar cadenas Promise para hacer peticiones HTTP.</p>
    <p>Anteriormente en este capítulo, vimos el objeto XMLHttpRequest utilizado para hacer una petición HTTP en JavaScript. Este objeto de nombre extraño tiene una API antigua y complicada, y ha sido reemplazada en gran parte por la nueva API Fetch basada en promesas (<a href="capitulo-15#11-1">§15.11.1</a>). En su forma más simple, esta nueva API HTTP es sólo la función <codeinline>fetch()</codeinline>. Le pasas una URL y te devuelve una promesa. Esa promesa se cumple cuando la respuesta HTTP comienza a llegar y el estado HTTP y las cabeceras están disponibles:</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/user/profile").then(response => &lbrace;
      // Cuando se resuelve la promesa, tenemos estado y encabezados.
      if (response.ok &&
        response.headers.get("Content-Type") === "application/json") &lbrace;
        // ¿Qué podemos hacer aquí? En realidad, todavía no 
        // tenemos el cuerpo de la respuesta.
      }
    });</code></pre>
    <p>Cuando la Promesa devuelta por <codeinline>fetch()</codeinline> se cumple, pasa un objeto Response a la función que pasaste a su método <codeinline>then()</codeinline>. Este objeto response te da acceso al estado de la petición y a las cabeceras, y también define métodos como <codeinline>text()</codeinline> y <codeinline>json()</codeinline>, que te dan acceso al cuerpo de la respuesta en forma de texto y JSON, respectivamente. Pero aunque la Promesa inicial se cumpla, el cuerpo de la respuesta puede no haber llegado todavía. Así que estos métodos <codeinline>text()</codeinline> y <codeinline>json()</codeinline> para acceder al cuerpo de la respuesta devuelven Promesas. He aquí una forma ingenua de utilizar <codeinline>fetch()</codeinline> y el método <codeinline>response.json()</codeinline> para obtener el cuerpo de una respuesta HTTP:</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/user/profile").then(response => &lbrace;
      response.json().then(profile => &lbrace; // Solicitar el cuerpo analizado en JSON
        // Cuando llega el cuerpo de la respuesta, se analizará
        // automáticamente como JSON y se pasará a esta función.
        displayUserProfile(profile);
      });
    });</code></pre>
    <p>Esta es una forma ingenua de usar Promises porque las anidamos, como callbacks, lo que contradice el propósito. El lenguaje preferido es utilizar promesas en una cadena secuencial con código como este:</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/user/profile")
      .then(response => &lbrace;
        return response.json();
      })
      .then(profile => &lbrace;
        displayUserProfile(profile);
      });</code></pre>
    <p>Veamos las invocaciones a métodos en este código, ignorando los argumentos que se pasan a los métodos:</p>
    <pre class="language-js">
    <code class="language-js">fetch().then().then()</code></pre>
    <p>Cuando se invoca más de un método en una sola expresión como ésta, la llamamos <em>cadena de métodos</em>. Sabemos que la función <codeinline>fetch()</codeinline> devuelve un objeto Promise, y podemos ver que el primer <codeinline>.then()</codeinline> de esta cadena invoca un método sobre ese objeto Promise devuelto. Pero hay un segundo <codeinline>.then()</codeinline> en la cadena, lo que significa que la primera invocación del método <codeinline>then()</codeinline> debe devolver a su vez una Promise.</p>
    <p>A veces, cuando una API está diseñada para utilizar este tipo de encadenamiento de métodos, sólo hay un único objeto, y cada método de ese objeto devuelve el propio objeto para facilitar el encadenamiento. Sin embargo, no es así como funcionan las promesas. Cuando escribimos una cadena de invocaciones <codeinline>.then()</codeinline>, no estamos registrando múltiples llamadas de retorno en un único objeto Promise. En su lugar, cada invocación del método <codeinline>then()</codeinline> devuelve un nuevo objeto Promise. Ese nuevo objeto Promise no se cumple hasta que la función pasada a <codeinline>then()</codeinline> se haya completado.</p>
    <p>Volvamos a una forma simplificada de la cadena <codeinline>fetch()</codeinline> original anterior. Si definimos las funciones pasadas a las invocaciones <codeinline>then()</codeinline> en otro lugar, podríamos refactorizar el código para que se vea así:</p>
    <pre class="language-js">
    <code class="language-js">fetch(theURL) // task 1; devuelve la promesa 1
      .then(callback1) // task 2; devuelve la promesa 2
      .then(callback2); // task 3; devuelve la promesa 3</code></pre>
    <p>Veamos este código en detalle:</p>
    <ul>
      <li class="font-normal list-decimal">En la primera línea, <codeinline>fetch()</codeinline> se invoca con una URL. Inicia una petición HTTP GET para esa URL y devuelve una Promise. Llamaremos a esta petición HTTP "tarea 1" y llamaremos a la Promesa "promesa 1".</li>
      <li class="font-normal list-decimal">En la segunda línea, invocamos el método <codeinline>then()</codeinline> de la promesa 1, pasando la función <codeinline>callback1</codeinline> que queremos que se invoque cuando se cumpla la promesa 1. El método <codeinline>then()</codeinline> almacena nuestra llamada de retorno en algún lugar, y luego devuelve una nueva Promise. Llamaremos a la nueva Promise devuelta en este paso "promesa 2", y diremos que la "tarea 2" comienza cuando se invoca a <codeinline>callback1</codeinline>.</li>
      <li class="font-normal list-decimal">En la tercera línea, invocamos el método <codeinline>then()</codeinline> de la promesa 2, pasando la función <codeinline>callback2</codeinline> que queremos que se invoque cuando la promesa 2 se cumpla. Este método <codeinline>then()</codeinline> recuerda nuestra devolución de llamada y devuelve otra promesa más. Diremos que la "tarea 3" comienza cuando se invoca la llamada de <codeinline>callback2</codeinline>. Podemos llamar a esta última Promise "promesa 3", pero realmente no necesitamos un nombre para ella porque no la usaremos en absoluto.</li>
      <li class="font-normal list-decimal">Los tres pasos anteriores ocurren de forma sincrónica cuando la expresión se ejecuta por primera vez. Ahora tenemos una pausa asíncrona mientras la petición HTTP iniciada en el paso 1 se envía a través de Internet.</li>
      <li class="font-normal list-decimal">Finalmente, la respuesta HTTP comienza a llegar. La parte asíncrona de la llamada <codeinline>fetch()</codeinline> envuelve el estado HTTP y las cabeceras en un objeto Response y cumple la promesa 1 con ese objeto Response como valor.</li>
      <li class="font-normal list-decimal">Cuando se cumple la promesa 1, su valor (el objeto Response) se pasa a nuestra función <codeinline>callback1()</codeinline>, y comienza la tarea 2. El trabajo de esta tarea, dado un objeto Response como entrada, es obtener el cuerpo de la respuesta como un objeto JSON.</li>
      <li class="font-normal list-decimal">Supongamos que la tarea 2 se completa normalmente y es capaz de analizar el cuerpo de la respuesta HTTP para producir un objeto JSON. Este objeto JSON se utiliza para cumplir la promesa 2.</li>
      <li class="font-normal list-decimal">El valor que cumple la promesa 2 se convierte en la entrada de la tarea 3 cuando se pasa a la función <codeinline>callback2()</codeinline>. Esta tercera tarea muestra ahora los datos al usuario de alguna forma no especificada. Cuando la tarea 3 se complete (suponiendo que lo haga normalmente), la promesa 3 se cumplirá. Pero como nunca hemos hecho nada con la promesa 3, no pasa nada cuando esa promesa se cumple, y la cadena de computación asíncrona termina en este punto.</li>
    </ul>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>13.2.3 Resolver promesas</h2>
    <p>Mientras explicábamos la cadena de promesas de obtención de URL con la lista en la última sección, hablamos de las promesas 1, 2 y 3. Pero en realidad hay un cuarto objeto Promise involucrado también. Pero en realidad hay un cuarto objeto Promise involucrado también, y esto nos lleva a nuestra importante discusión de lo que significa que una Promise sea "resuelta".</p>
    <p>Recuerda que <codeinline>fetch()</codeinline> devuelve un objeto Promise que, cuando se cumple, pasa un objeto Response a la función callback que registramos. Este objeto Response tiene <codeinline>.text()</codeinline>, <codeinline>.json()</codeinline>, y otros métodos para solicitar el cuerpo de la respuesta HTTP en varias formas. Pero como el cuerpo puede no haber llegado todavía, estos métodos deben devolver objetos Promise. En el ejemplo que hemos estado estudiando, la "tarea 2" llama al método <codeinline>.json()</codeinline> y devuelve su valor. Este es el cuarto objeto Promise, y es el valor de retorno de la función <codeinline>callback1()</codeinline>.</p>
    <p>Volvamos a escribir el código de obtención de URL una vez más de una forma verbosa y no idiomática que haga explícitas las devoluciones de llamada y las promesas:</p>
    <pre class="language-js">
    <code class="language-js">function c1(response) &lbrace; // callback 1
      let p4 = response.json();
      return p4; // devuelve la promesa 4
    }

    function c2(profile) &lbrace; // callback 2
      displayUserProfile(profile);
    }
    let p1 = fetch("/api/user/profile"); // promise 1, task 1
    let p2 = p1.then(c1); // promise 2, task 2
    let p3 = p2.then(c2); // promise 3, task 3</code></pre>
    <p>Para que las cadenas Promise funcionen de forma útil, la salida de la tarea 2 debe convertirse en la entrada de la tarea 3. Y en el ejemplo que estamos considerando aquí, la entrada a la tarea 3 es el cuerpo de la URL que se obtuvo, analizado como un objeto JSON. Pero, como acabamos de explicar, el valor de retorno de la llamada de retorno <codeinline>c1</codeinline> no es un objeto JSON, sino la Promesa <codeinline>p4</codeinline> para ese objeto JSON. Esto parece una contradicción, pero no lo es: cuando <codeinline>p1</codeinline> se cumple, <codeinline>c1</codeinline> es invocado, y la tarea 2 comienza. Y cuando se cumple <codeinline>p2</codeinline>, se invoca a <codeinline>c2</codeinline> y comienza la tarea 3. Pero que la tarea 2 comience cuando se invoca a <codeinline>c1</codeinline> no significa que la tarea 2 deba terminar cuando <codeinline>c1</codeinline> regrese. Las promesas sirven para gestionar tareas asíncronas, después de todo, y si la tarea 2 es asíncrona (como lo es, en este caso), entonces esa tarea no se habrá completado cuando vuelva la llamada de retorno.</p>
    <p>Ahora estamos listos para discutir el detalle final que necesitas entender para dominar realmente las Promesas. Cuando pasas una llamada de retorno <codeinline>c</codeinline> al método <codeinline>then()</codeinline>, <codeinline>then()</codeinline> devuelve una Promesa <codeinline>p</codeinline> y se encarga de invocar asíncronamente a <codeinline>c</codeinline> en algún momento posterior. La llamada de retorno realiza algún cálculo y devuelve un valor <codeinline>v</codeinline>. Cuando la llamada de retorno regresa, <codeinline>p</codeinline> se <em>resuelve</em> con el valor <codeinline>v</codeinline>. Cuando una Promise se resuelve con un valor que no es a su vez una Promise, se cumple inmediatamente con ese valor. Por lo tanto, si <codeinline>c</codeinline> devuelve un valor que no es una Promise, ese valor devuelto se convierte en el valor de <codeinline>p</codeinline>, <codeinline>p</codeinline> se cumple y hemos terminado. Pero si el valor de retorno <codeinline>v</codeinline> es en sí mismo una Promise, entonces <codeinline>p</codeinline> se <em>resuelve pero aún no se cumple</em>. En esta etapa, <codeinline>p</codeinline> no puede resolverse hasta que se resuelva la Promesa <codeinline>v</codeinline>. Si <codeinline>v</codeinline> se cumple, entonces <codeinline>p</codeinline> se cumplirá con el mismo valor. Si <codeinline>v</codeinline> se rechaza, entonces <codeinline>p</codeinline> se rechazará por la misma razón. Esto es lo que significa el estado "resuelto" de una promesa: la promesa se ha asociado o "bloqueado" con otra promesa. Aún no sabemos si <codeinline>p</codeinline> se cumplirá o será rechazada, pero nuestra llamada de retorno <codeinline>c</codeinline> ya no tiene ningún control sobre eso. <codeinline>p</codeinline> está "resuelta" en el sentido de que su destino ahora depende enteramente de lo que ocurra con la promesa <codeinline>v</codeinline>.</p>
    <p>Volvamos a nuestro ejemplo de obtención de URL. Cuando <codeinline>c1</codeinline> devuelve <codeinline>p4</codeinline>, <codeinline>p2</codeinline> está resuelto. Pero estar resuelto no es lo mismo que estar realizado, por lo que la tarea 3 no comienza todavía. Cuando el cuerpo completo de la respuesta HTTP esté disponible, el método <codeinline>.json()</codeinline> podrá analizarlo y utilizar el valor analizado para completar <codeinline>p4</codeinline>. Cuando se cumple <codeinline>p4</codeinline>, <codeinline>p2</codeinline> se cumple automáticamente también, con el mismo valor JSON analizado. En este punto, el objeto JSON analizado se pasa a <codeinline>c2</codeinline> y comienza la tarea 3.</p>
    <p>Esta puede ser una de las partes de JavaScript más difíciles de entender, y puede que necesites leer esta sección más de una vez. La <a href="#figure13-1">Figura 13-1</a> presenta el proceso de forma visual y puede ayudarle a clarificarlo.</p>
    <figure id="figure13-1" class="mx-auto">
      <img src="/public/javascript/capitulo-13/figure13-1.jpg" alt="imagen de como obtener una URL">
      <figcaption>Figura 13-1. Obtención de una URL con promesas</figcaption>
    </figure>
  </section>
  <section id="2-4">
    <h2>13.2.4 Más sobre promesas y errores</h2>
    <p>Anteriormente en el capítulo, vimos que puedes pasar una segunda función callback al método <codeinline>.then()</codeinline> y que esta segunda función será invocada si la Promise es rechazada. Cuando esto ocurre, el argumento de esta segunda función de llamada de retorno es un valor -típicamente un objeto Error- que representa la razón del rechazo. También aprendimos que es poco común (e incluso poco idiomático) pasar dos callbacks a un método <codeinline>.then()</codeinline>. En su lugar, los errores relacionados con las promesas se gestionan normalmente añadiendo una invocación al método <codeinline>.catch()</codeinline> a una cadena Promise. Ahora que hemos examinado las cadenas Promise, podemos volver a la gestión de errores y discutirla con más detalle. Para empezar, me gustaría destacar que el manejo cuidadoso de errores es realmente importante cuando se hace programación asíncrona. Con código síncrono, si omites el código de gestión de errores, al menos obtendrás una excepción y un seguimiento de pila que puedes usar para averiguar qué está fallando. Con código asíncrono, las excepciones no manejadas a menudo no se reportan, y los errores pueden ocurrir silenciosamente, haciéndolos mucho más difíciles de detectar un debug. La buena noticia es que el método <codeinline>.catch()</codeinline> facilita el manejo de errores cuando se trabaja con Promises.</p>
    <p class="title-article text-left">Los métodos catch y finally</p>
    <p>El método <codeinline>.catch()</codeinline> de una Promise es simplemente una forma abreviada de llamar a <codeinline>.then()</codeinline> con <codeinline>null</codeinline> como primer argumento y una llamada de retorno como segundo argumento. Dada cualquier Promise <codeinline>p</codeinline> y una llamada de retorno <codeinline>c</codeinline>, las dos líneas siguientes son equivalentes:</p>
    <pre class="language-js">
    <code class="language-js">p.then(null, c);
    p.catch(c);</code></pre>
    <p>La abreviatura <codeinline>.catch()</codeinline> es preferible porque es más simple y porque el nombre coincide con la cláusula <codeinline>catch</codeinline> en una sentencia <codeinline>try/catch</codeinline> de manejo de excepciones. Como hemos explicado, las excepciones normales no funcionan con código asíncrono. El método <codeinline>.catch()</codeinline> de Promises es una alternativa que sí funciona para el código asíncrono. Cuando algo va mal en código síncrono, podemos hablar de una excepción "burbujeando por la pila de llamadas" hasta que encuentra un bloque <codeinline>catch</codeinline>. Con una cadena asíncrona de Promesas, la metáfora comparable podría ser la de un error "goteando por la cadena" hasta que encuentra una invocación <codeinline>.catch()</codeinline>.</p>
    <p>En ES2018, los objetos Promise también definen un método <codeinline>.finally()</codeinline> cuyo propósito es similar al de la cláusula <codeinline>finally</codeinline> de una sentencia <codeinline>try/catch/finally</codeinline>. Si añades una invocación <codeinline>.finally()</codeinline> a tu cadena Promise, la llamada de retorno que pases a <codeinline>.finally()</codeinline> se invocará cuando se cumpla la Promise sobre la que la has invocado. Tu callback será invocada si la Promise se cumple o se rechaza, y no se le pasará ningún argumento, por lo que no podrás averiguar si se cumplió o se rechazó. Pero si necesitas ejecutar algún tipo de código de limpieza (como cerrar archivos abiertos o conexiones de red) en cualquier caso, una llamada de retorno <codeinline>.finally()</codeinline> es la forma ideal de hacerlo. Al igual que <codeinline>.then()</codeinline> y <codeinline>.catch()</codeinline>, <codeinline>.finally()</codeinline> devuelve un nuevo objeto Promise. El valor de retorno de una llamada de retorno <codeinline>.finally()</codeinline> generalmente se ignora, y la Promesa devuelta por <codeinline>.finally()</codeinline> típicamente se resolverá o rechazará con el mismo valor con el que se resuelve o rechaza la Promesa sobre la que se invocó <codeinline>.finally()</codeinline>. Sin embargo, si una llamada de retorno <codeinline>.finally()</codeinline> lanza una excepción, la promesa devuelta por <codeinline>.finally()</codeinline> se rechazará con ese valor.</p>
    <p>El código de obtención de URLs que estudiamos en las secciones anteriores no hacía ningún tratamiento de errores. Vamos a corregirlo ahora con una versión más realista del código:</p>
    <pre class="language-js">
    <code class="language-js">fetch("/api/user/profile") // Iniciar la solicitud HTTP
      .then(response => &lbrace; // Llame a esto cuando el estado y los encabezados estén listos
        if (!response.ok) &lbrace; // Si recibimos un error 404 No encontrado o similar
          return null; // Es posible que el usuario haya cerrado la sesión; devuelve un perfil nulo
        }

        // Ahora revise los encabezados para asegurarse de que el servidor nos envió JSON.
        // ¡Si no es así, nuestro servidor está averiado y esto es un error grave!
        let type = response.headers.get("content-type");
        if (type !== "application/json") &lbrace;
          throw new TypeError(`Expected JSON, got $&lbrace;type}`);
        }

        // Si llegamos aquí, entonces tenemos un estado 2xx y un tipo de
        // contenido JSON, por lo que podemos devolver con confianza una
        // Promesa para el cuerpo de respuesta como un objeto JSON.
        return response.json();
    })
    .then(profile => &lbrace; // Se llama con el cuerpo de respuesta analizado o nulo
      if (profile) &lbrace;
        displayUserProfile(profile);
      }
      else &lbrace; // Si recibimos un error 404 arriba y devolvimos nulo, terminamos aquí
        displayLoggedOutProfilePage();
      }
    })
    .catch(e => &lbrace;
      if (e instanceof NetworkError) &lbrace;
        // fetch() puede fallar de esta manera si la conexión a Internet no funciona
        displayErrorMessage("Check your internet connection.");
      }
      else if (e instanceof TypeError) &lbrace;
        // Esto sucede si lanzamos TypeError arriba
        displayErrorMessage("Something is wrong with our server!");
      }
      else &lbrace;
        // Esto debe ser algún tipo de error imprevisto.
        console.error(e);
      }
    });</code></pre>
    <p>Analicemos este código viendo qué ocurre cuando las cosas van mal. Usaremos el esquema de nombres que usamos antes: <codeinline>p1</codeinline> es la Promise devuelta por la llamada <codeinline>fetch()</codeinline>. <codeinline>p2</codeinline> es la Promise devuelta por la primera llamada <codeinline>.then()</codeinline>, y <codeinline>c1</codeinline> es la llamada de retorno que pasamos a esa llamada <codeinline>.then()</codeinline>. <codeinline>p3</codeinline> es la Promise devuelta por la segunda llamada <codeinline>.then()</codeinline>, y <codeinline>c2</codeinline> es la llamada de retorno que pasamos a esa llamada. Finalmente, <codeinline>c3</codeinline> es la llamada de retorno que pasamos a la llamada <codeinline>.catch()</codeinline>. (Esa llamada devuelve una Promise, pero no necesitamos referirnos a ella por su nombre).</p>
    <p>Lo primero que podría fallar es la propia petición <codeinline>fetch()</codeinline>. Si la conexión de red está caída (o por alguna otra razón no se puede hacer una petición HTTP), entonces la promesa <codeinline>p1</codeinline> será rechazada con un objeto NetworkError. No pasamos una función de devolución de llamada de gestión de errores como segundo argumento de la llamada <codeinline>.then()</codeinline>, por lo que <codeinline>p2</codeinline> también se rechaza con el mismo objeto NetworkError. (Si hubiéramos pasado un manejador de errores a esa primera llamada <codeinline>.then()</codeinline>, el manejador de errores sería invocado, y si retornara normalmente, <codeinline>p2</codeinline> sería resuelto y/o cumplido con el valor de retorno de ese manejador). Sin un manejador, sin embargo, <codeinline>p2</codeinline> es rechazado, y luego <codeinline>p3</codeinline> es rechazado por la misma razón. En este punto, se llama al callback de gestión de errores <codeinline>c3</codeinline>, y se ejecuta el código específico de NetworkError que contiene.</p>
    <p>Otra forma en que nuestro código podría fallar es si nuestra petición HTTP devuelve un 404 Not Found u otro error HTTP. Estas son respuestas HTTP válidas, por lo que la llamada a <codeinline>fetch()</codeinline> no las considera errores. <codeinline>fetch()</codeinline> encapsula un 404 Not Found en un objeto Response y rellena <codeinline>p1</codeinline> con ese objeto, haciendo que se invoque a <codeinline>c1</codeinline>. Nuestro código en <codeinline>c1</codeinline> comprueba la propiedad ok del objeto Response para detectar que no ha recibido una respuesta HTTP normal y maneja ese caso simplemente devolviendo <codeinline>null</codeinline>. Dado que este valor de retorno no es una Promise, cumple <codeinline>p2</codeinline> inmediatamente, y <codeinline>c2</codeinline> es invocado con este valor. Nuestro código en <codeinline>c2</codeinline> comprueba y maneja explícitamente los valores falsos mostrando un resultado diferente al usuario. Este es un caso en el que tratamos una condición anormal como no error y la manejamos sin utilizar un manejador de errores.</p>
    <p>Un error más serio ocurre en <codeinline>c1</codeinline> si obtenemos un código de respuesta HTTP normal pero la cabecera Content-Type no está configurada apropiadamente. Nuestro código espera una respuesta con formato JSON, así que si el servidor nos envía HTML, XML o texto plano en su lugar, vamos a tener un problema. <codeinline>c1</codeinline> incluye código para comprobar la cabecera Content-Type. Si la cabecera es incorrecta, trata esto como un problema no recuperable y lanza un TypeError. Cuando una llamada de retorno pasada a <codeinline>.then()</codeinline> (o <codeinline>.catch()</codeinline>) lanza un valor, la promesa que era el valor de retorno de la llamada a <codeinline>.then()</codeinline> es rechazada con ese valor lanzado. En este caso, el código en <codeinline>c1</codeinline> que lanza un TypeError causa que <codeinline>p2</codeinline> sea rechazado con ese objeto TypeError. Como no especificamos un manejador de errores para <codeinline>p2</codeinline>, <codeinline>p3</codeinline> será rechazado también. <codeinline>c2</codeinline> no será llamado, y el TypeError será pasado a <codeinline>c3</codeinline>, que tiene código para comprobar explícitamente y manejar este tipo de error.</p>
    <p>Hay un par de cosas dignas de mención en este código. En primer lugar, observe que el objeto de error lanzado con una sentencia <codeinline>throw</codeinline> normal y sincrónica termina siendo manejado asincrónicamente con una invocación al método <codeinline>.catch()</codeinline> en una cadena Promise. Esto debería aclarar por qué este método abreviado es preferible a pasar un segundo argumento a <codeinline>.then()</codeinline>, y también por qué es tan idiomático terminar las cadenas Promise con una llamada a <codeinline>.catch()</codeinline>.</p>
    <p>Antes de dejar el tema del manejo de errores, quiero señalar que, aunque es idiomático terminar cada cadena Promise con un <codeinline>.catch()</codeinline> para limpiar (o al menos registrar) cualquier error que haya ocurrido en la cadena, también es perfectamente válido usar <codeinline>.catch()</codeinline> en cualquier otra parte de una cadena Promise. Si una de las etapas de tu cadena Promise puede fallar con un error, y si el error es algún tipo de error recuperable que no debería detener la ejecución del resto de la cadena, entonces puedes insertar una llamada <codeinline>.catch()</codeinline> en la cadena, resultando en un código que podría parecerse a esto:</p>
    <pre class="language-js">
    <code class="language-js">startAsyncOperation()
      .then(doStageTwo)
      .catch(recoverFromStageTwoError)
      .then(doStageThree)
      .then(doStageFour)
      .catch(logStageThreeAndFourErrors);</code></pre>
    <p>Recuerde que la llamada de retorno que pase a <codeinline>.catch()</codeinline> sólo será invocada si la llamada de retorno en una etapa anterior arroja un error. Si la llamada de retorno retorna normalmente, entonces la llamada de retorno <codeinline>.catch()</codeinline> será omitida, y el valor de retorno de la llamada de retorno previa se convertirá en la entrada de la siguiente llamada de retorno <codeinline>.then()</codeinline>. Recuerde también que las retrollamadas <codeinline>.catch()</codeinline> no son sólo para informar de errores, sino para manejarlos y recuperarse de ellos. Una vez que un error ha sido pasado a una llamada de retorno <codeinline>.catch()</codeinline>, deja de propagarse por la cadena Promise. Una llamada de retorno <codeinline>.catch()</codeinline> puede lanzar un nuevo error, pero si retorna normalmente, ese valor de retorno se utiliza para resolver y/o cumplir la Promesa asociada, y el error deja de propagarse.</p>
    <p>Seamos concretos: en el ejemplo de código anterior, si <codeinline>startAsyncOperation()</codeinline> o <codeinline>doStageTwo()</codeinline> arrojan un error, se invocará a la función <codeinline>recoverFromStageTwoError()</codeinline>. Si <codeinline>recoverFromStageTwoError()</codeinline> devuelve normalmente, su valor de retorno se pasará a <codeinline>doStageThree()</codeinline> y la operación asíncrona continuará normalmente. Por otro lado, si <codeinline>recoverFromStageTwoError()</codeinline> no pudo recuperarse, lanzará un error (o volverá a lanzar el error que se le pasó). En este caso, ni <codeinline>doStageThree()</codeinline> ni <codeinline>doStageFour()</codeinline> serán invocadas, y el error lanzado por <codeinline>recoverFromStageTwoError()</codeinline> sería pasado a <codeinline>logStageThreeAndFourErrors()</codeinline>.</p>
    <p>A veces, en entornos de red complejos, los errores pueden producirse de forma más o menos instantánea, y puede ser conveniente tratarlos simplemente reintentando la petición asíncrona. Imagina que has escrito una operación basada en Promise para consultar una base de datos:</p>
    <pre class="language-js">
    <code class="language-js">queryDatabase()
      .then(displayTable)
      .catch(displayDatabaseError);</code></pre>
    <p>Ahora supongamos que los problemas transitorios de carga de la red están causando que esto falle alrededor del 1% de las veces. Una solución sencilla podría ser reintentar la consulta con una llamada <codeinline>.catch(</codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">queryDatabase()
      .catch(e => wait(500).then(queryDatabase)) // On failure, wait and retry
      .then(displayTable)
      .catch(displayDatabaseError);</code></pre>
    <p>Si los fallos hipotéticos son realmente aleatorios, añadir esta única línea de código debería reducir su tasa de error del 1% al 0,01%.</p>
    <article>
      <p class="title-article text-left">Devolución de una promesa</p>
      <p>Volvamos una vez más al ejemplo anterior de obtención de URL, y consideremos la llamada de retorno <codeinline>c1</codeinline> que pasamos a la primera invocación <codeinline>.then()</codeinline>. Observa que hay tres formas en las que <codeinline>c1</codeinline> puede terminar. Puede volver normalmente con la Promise devuelta por la llamada <codeinline>.json()</codeinline>. Esto hace que <codeinline>p2</codeinline> se resuelva, pero si esa Promise se cumple o no, no se cumple. rechazada depende de lo que ocurra con la nueva Promise devuelta. <codeinline>c1</codeinline> también puede devolver normalmente con el valor <codeinline>null</codeinline>, lo que provoca que <codeinline>p2</codeinline> se cumpla inmediatamente. Por último, <codeinline>c1</codeinline> puede terminar lanzando un error, lo que provoca que <codeinline>p2</codeinline> sea rechazada. Estos son los tres posibles resultados de una promesa, y el código en <codeinline>c1</codeinline> demuestra cómo la llamada de retorno puede causar cada resultado.</p>
      <p>En una cadena Promise, el valor devuelto (o lanzado) en una etapa de la cadena se convierte en la entrada de la siguiente etapa de la cadena, por lo que es fundamental hacerlo bien. En la práctica, olvidarse de devolver un valor desde una función de devolución de llamada es una fuente común de errores relacionados con las promesas, y esto se ve exacerbado por la sintaxis de atajo de función de flecha de JavaScript. Considere esta línea de código que vimos antes:</p>
    <pre class="language-js">
    <code class="language-js">.catch(e => wait(500).then(queryDatabase))</code></pre>
      <p>Recordemos del <a href="capitulo-8">capítulo 8</a> que las funciones de flecha permiten muchos atajos. Como hay exactamente un argumento (el valor de error), podemos omitir los paréntesis. Como el cuerpo de la función es una única expresión, podemos omitir las llaves alrededor del cuerpo de la función, y el valor de la expresión se convierte en el valor de retorno de la función. Gracias a estos atajos, el código anterior es correcto. Pero considere este cambio aparentemente inocuo:</p>
    <pre class="language-js">
    <code class="language-js">.catch(e => &lbrace; wait(500).then(queryDatabase) })</code></pre>
      <p>Al añadir las llaves, ya no obtenemos el retorno automático. Esta función ahora devuelve <codeinline>undefined</codeinline> en lugar de devolver una Promise, lo que significa que la siguiente etapa en esta cadena Promise será invocada con <codeinline>undefined</codeinline> como entrada en lugar del resultado de la consulta reintentada. Se trata de un error sutil que puede no ser fácil de depurar.</p>
    </article>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>13.2.5 Promesas en paralelo</h2>
    <p>Hemos pasado mucho tiempo hablando de cadenas Promise para ejecutar secuencialmente los pasos asíncronos de una operación asíncrona mayor. A veces, sin embargo, queremos que ejecute una serie de operaciones asíncronas en paralelo. La función <codeinline>Promise.all()</codeinline> puede hacer esto. <codeinline>Promise.all()</codeinline> toma un array de objetos Promise como entrada y devuelve un Promise. La Promise devuelta será rechazada si alguna de las Promises de entrada es rechazada. De lo contrario, se cumplirá con una matriz de los valores de cumplimiento de cada una de las promesas de entrada. Así, por ejemplo, si quieres obtener el contenido de texto de múltiples URLs, puedes usar código como este:</p>
    <pre class="language-js">
    <code class="language-js">// Comenzamos con una matriz de URL
      const urls = [ /* zero or more URLs here */ ];
      // Y convertirlo en una matriz de objetos Promise
      promises = urls.map(url => fetch(url).then(r => r.text()));
      // Ahora obtenga una Promesa para ejecutar todas esas Promesas en paralelo
      Promise.all(promises)
        .then(bodies => &lbrace; /* hacer algo con la matriz de cadenas */ })
        .catch(e => console.error(e));</code></pre>
    <p><codeinline>Promise.all()</codeinline> es ligeramente más flexible que lo descrito anteriormente. La matriz de entrada puede contener tanto objetos Promise como valores no Promise. Si un elemento del array no es una Promise, se trata como si fuera el valor de una Promise ya cumplida y simplemente se copia sin cambios en el array de salida.</p>
    <p>La Promise devuelta por <codeinline>Promise.all()</codeinline> rechaza cuando cualquiera de las Promises de entrada es rechazada. Esto ocurre inmediatamente después del primer rechazo y puede ocurrir mientras otras Promesas de entrada siguen pendientes. En ES2020, <codeinline>Promise.allSettled()</codeinline> toma un array de promesas de entrada y devuelve una promesa, igual que <codeinline>Promise.all()</codeinline>. Pero <codeinline>Promise.allSettled()</codeinline> nunca rechaza la promesa devuelta, y no cumple esa promesa hasta que todas las promesas de entrada se hayan resuelto. La promesa se resuelve en una matriz de objetos, con un objeto por cada promesa de entrada. Cada uno de estos objetos devueltos tiene una propiedad de <codeinline>status</codeinline> establecida a "cumplido" o "rechazado". Si el estado es "cumplido", entonces el objeto también tendrá una propiedad <codeinline>value</codeinline> que da el valor de cumplimiento. Y si el estado es "rejected", entonces el objeto también tendrá una propiedad <codeinline>reason</codeinline> que da el valor de error o rechazo de la Promesa correspondiente:</p>
    <pre class="language-js">
    <code class="language-js">Promise.allSettled([Promise.resolve(1), Promise.reject(2), 3]).then(results => &lbrace;
      results[0] // => &lbrace; status: "fulfilled", value: 1 }
      results[1] // => &lbrace; status: "rejected", reason: 2 }
      results[2] // => &lbrace; status: "fulfilled", value: 3 }
    });</code></pre>
    <p>Ocasionalmente, puede que quieras ejecutar varias promesas a la vez pero que sólo te importe el valor de la primera que se cumpla. En ese caso, puedes utilizar <codeinline>Promise.race()</codeinline> en lugar de <codeinline>Promise.all()</codeinline>. Devuelve una promesa que se cumple o rechaza cuando se cumple o rechaza la primera de las promesas del array de entrada. (O, si hay algún valor que no sea Promise en el array de entrada, simplemente devuelve el primero de ellos).</p>
  </section>
  <section id="2-6">
    <h2>13.2.6 Hacer promesas</h2>
    <p>Hemos utilizado la función <codeinline>fetch()</codeinline>, que devuelve una Promise, en muchos de los ejemplos anteriores porque es una de las funciones más sencillas incorporadas en los navegadores web que devuelve una Promise. Nuestra discusión sobre las promesas también se ha basado en las hipotéticas funciones <codeinline>getJSON()</codeinline> y <codeinline>wait()</codeinline> que devuelven promesas. Las funciones escritas para devolver promesas son realmente útiles, y esta sección muestra cómo puedes crear tus propias APIs basadas en promesas. En particular, mostraremos implementaciones de <codeinline>getJSON()</codeinline> y <codeinline>wait()</codeinline>.</p>
    <p class="title-article text-left">Promesas basadas en otras promesas</p>
    <p>Es fácil escribir una función que devuelva una Promise si tienes alguna otra función que devuelva una Promise para empezar. Dada una Promise, siempre puedes crear (y devolver) una nueva llamando a <codeinline>.then()</codeinline>. Así que si usamos la función <codeinline>fetch()</codeinline> existente como punto de partida, podemos escribir <codeinline>getJSON()</codeinline> así:</p>
    <pre class="language-js">
    <code class="language-js">function getJSON(url) &lbrace;
      return fetch(url).then(response => response.json());
    }</code></pre>
    <p>El código es trivial porque el objeto Response de la API <codeinline>fetch()</codeinline> tiene un método <codeinline>json()</codeinline> predefinido. El método <codeinline>json()</codeinline> devuelve una Promise, que devolvemos desde nuestra llamada de retorno (la llamada de retorno es una función de flecha con un cuerpo de una sola expresión, por lo que la devolución está implícita), de modo que la Promise devuelta por <codeinline>getJSON()</codeinline> se resuelve a la Promise devuelta por <codeinline>response.json()</codeinline>. Cuando esa Promise se cumple, la Promise devuelta por <codeinline>getJSON()</codeinline> se cumple con el mismo valor. Nótese que no hay manejo de errores en esta implementación de <codeinline>getJSON()</codeinline>. En lugar de comprobar <codeinline>response.ok</codeinline> y la cabecera Content-Type, simplemente permitimos que el método <codeinline>json()</codeinline> rechace la Promesa devuelta con un SyntaxError si el cuerpo de la respuesta no puede ser analizado como JSON.</p>
    <p>Escribamos otra función que devuelva una Promise, esta vez usando <codeinline>getJSON()</codeinline> como fuente de la Promise inicial:</p>
    <pre class="language-js">
    <code class="language-js">function getHighScore() &lbrace;
      return getJSON("/api/user/profile").then(profile => profile.highScore);
    }</code></pre>
    <p>Suponemos que esta función forma parte de algún tipo de juego basado en web y que la URL "/api/user/profile" devuelve una estructura de datos con formato JSON que incluye una propiedad de <codeinline>highScore</codeinline>.</p>
    <p class="title-article text-left">Promesas basadas en valores síncronos</p>
    <p>A veces, puede que necesites implementar una API basada en Promise y devolver una Promise desde una función, aunque el cálculo a realizar no requiera ninguna operación asíncrona. En ese caso, los métodos estáticos <codeinline>Promise.resolve()</codeinline> y <codeinline>Promise.reject()</codeinline> harán lo que quieres. <codeinline>Promise.resolve()</codeinline> toma un valor como único argumento y devuelve una Promise que se cumplirá inmediatamente (pero de forma asíncrona) con ese valor. Del mismo modo, <codeinline>Promise.reject()</codeinline> toma un único argumento y devuelve una Promise que será rechazada con ese valor como motivo. (Para que quede claro: las promesas devueltas por estos métodos estáticos no se cumplen ni se rechazan cuando se devuelven, sino que se cumplen o se rechazan inmediatamente después de que el trozo de código síncrono actual haya terminado de ejecutarse. Normalmente, esto ocurre en unos pocos milisegundos a menos que haya muchas tareas asíncronas pendientes esperando a ejecutarse).</p>
    <p>Recuerda de <a href="#2-3">§13.2.3</a> que una Promise resuelta no es lo mismo que una Promise cumplida. Cuando llamamos a <codeinline>Promise.resolve()</codeinline>, normalmente pasamos el valor de cumplimiento para crear un objeto Promise que muy pronto se cumplirá con ese valor. Sin embargo, el método no se llama <codeinline>Promise.fulfill()</codeinline>. Si pasas una Promise <codeinline>p1</codeinline> a <codeinline>Promise.resolve()</codeinline>, devolverá una nueva Promise <codeinline>p2</codeinline>, que se resolverá inmediatamente, pero que no se cumplirá o rechazará hasta que se cumpla o rechace <codeinline>p1</codeinline>.</p>
    <p>Es posible, aunque inusual, escribir una función basada en Promise en la que el valor se compone de forma síncrona y se devuelve de forma asíncrona con <codeinline>Promise.resolve()</codeinline>. Es bastante común, sin embargo, tener casos especiales síncronos dentro de una función asíncrona, y puedes manejar estos casos especiales con <codeinline>Promise.resolve()</codeinline> y <codeinline>Promise.reject()</codeinline>. En particular, si detectas condiciones de error (como valores de argumento erróneos) antes de comenzar una operación asíncrona, puedes informar de ese error devolviendo una Promise creada con <codeinline>Promise.reject()</codeinline>. (También podrías simplemente lanzar un error de forma síncrona en ese caso, pero eso se considera mala forma porque entonces el que llama a tu función necesita escribir tanto una cláusula catch síncrona como usar un método <codeinline>.catch()</codeinline> asíncrono para manejar los errores). Finalmente, <codeinline>Promise.resolve()</codeinline> a veces es útil para crear la Promise inicial en una cadena de Promesas. Veremos un par de ejemplos que lo utilizan de esta forma.</p>
    <p class="title-article text-left">Promesas desde cero</p>
    <p>Tanto para <codeinline>getJSON()</codeinline> como para <codeinline>getHighScore()</codeinline>, empezamos llamando a una función existente para obtener una Promise inicial, y creamos y devolvimos una nueva Promise llamando al método <codeinline>.then()</codeinline> de esa Promise inicial. ¿Pero qué pasa cuando escribimos una función que devuelve una Promise y no podemos usar otra función que devuelva una Promise como punto de partida? En ese caso, utiliza el constructor <codeinline>Promise()</codeinline> para crear un nuevo objeto Promise sobre el que tengas un control total. Así es como funciona: invocas al constructor <codeinline>Promise()</codeinline> y le pasas una función como único argumento. La función que pases debe estar escrita para esperar dos parámetros, que, por convención, deben llamarse <codeinline>resolve</codeinline> y <codeinline>reject</codeinline>. El constructor llama de forma sincrónica a tu función con argumentos de función para los parámetros <codeinline>resolve</codeinline> y <codeinline>reject</codeinline>. Después de llamar a tu función, el constructor de <codeinline>Promise()</codeinline> devuelve la Promise recién creada. Esa Promise devuelta está bajo el control de la función que pasaste al constructor. Esa función debería realizar alguna operación asíncrona y luego llamar a la función <codeinline>resolve</codeinline> para resolver o cumplir la Promise devuelta o llamar a la función <codeinline>reject</codeinline> para rechazar la Promise devuelta. Tu función no tiene por qué ser asíncrona: puede llamar a <codeinline>resolve</codeinline> o <codeinline>reject</codeinline> de forma síncrona, pero la Promise se resolverá, cumplirá o rechazará de forma asíncrona si haces esto.</p>
    <p>Puede ser difícil entender las funciones pasadas a una función pasada a un constructor con sólo leer sobre ello, pero esperamos que algunos ejemplos lo aclaren. He aquí cómo escribir la función <codeinline>wait()</codeinline> basada en promesas que hemos utilizado en varios ejemplos anteriores del capítulo:</p>
    <pre class="language-js">
    <code class="language-js">function wait(duration) &lbrace;
      // Crear y devolver una nueva Promesa
      return new Promise((resolve, reject) => &lbrace; // Estos controlan la Promesa
        // Si el argumento no es válido, rechace la Promesa
        if (duration &lt; 0) &lbrace;
          reject(new Error("Time travel not yet implemented"));
        }
        // De lo contrario, espere de forma asincrónica y luego resuelva 
        // la Promesa. setTimeout invocará resolve() sin argumentos, 
        // lo que significa que la Promesa se cumplirá con el valor indefinido.
        setTimeout(resolve, duration);
      });
    }</code></pre>
    <p>Ten en cuenta que el par de funciones que usas para controlar el destino de una Promise creada con el constructor <codeinline>Promise()</codeinline> se llaman <codeinline>resolve()</codeinline> y <codeinline>reject()</codeinline>, no <codeinline>fulfill()</codeinline> y <codeinline>reject()</codeinline>. Si pasas una Promise a <codeinline>resolve()</codeinline>, la Promise devuelta se resolverá a esa nueva Promise. Sin embargo, a menudo se pasa un valor que no es una Promise, lo que llena la Promise devuelta con ese valor.</p>
    <p>El <a href="#ejemplo13-1">Ejemplo 13-1</a> es otro ejemplo de uso del constructor <codeinline>Promise()</codeinline>. Este implementa nuestra función <codeinline>getJSON()</codeinline> para su uso en Node, donde la API <codeinline>fetch()</codeinline> no está incorporada. Recuerda que comenzamos este capítulo con una discusión sobre callbacks y eventos asíncronos. Este ejemplo utiliza tanto callbacks como manejadores de eventos y es una buena demostración, por lo tanto, de cómo podemos implementar APIs basadas en Promise sobre otros estilos de programación asíncrona.</p>
    <p id="ejemplo13-1"><em>Ejemplo 13-1. Una función asíncrona getJSON()</em></p>
    <pre class="language-js">
    <code class="language-js">const http = require("http");

    function getJSON(url) &lbrace;
      // Crear y devolver una nueva Promesa
      return new Promise((resolve, reject) => &lbrace;
        // Iniciar una solicitud HTTP GET para la URL especificada
        request = http.get(url, response => &lbrace; // Se llama cuando comienza la respuesta.
          // Rechazar la Promesa si el estado HTTP es incorrecto
          if (response.statusCode !== 200) &lbrace;
            reject(new Error(`HTTP status $&lbrace;response.statusCode}`));
            response.resume(); // para que no perdamos la memoria
          }
          // Y rechazar si los encabezados de respuesta son incorrectos
          else if (response.headers["content-type"] !== "application/json") &lbrace;
            reject(new Error("Invalid content-type"));
            response.resume(); // No pierdas la memoria
          }
          else &lbrace;
            // De lo contrario, registre eventos para leer el cuerpo de la respuesta.
            let body = "";
            response.setEncoding("utf-8");
            response.on("data", chunk => &lbrace; body += chunk; });
            response.on("end", () => &lbrace;
              // Cuando el cuerpo de la respuesta esté completo, intente analizarlo
              try &lbrace;
                let parsed = JSON.parse(body);
                // Si se analiza correctamente, cumpla la promesa.
                resolve(parsed);
              } catch(e) &lbrace;
                // Si el análisis falla, rechace la promesa
                reject(e);
              }
            });
          }
        });
        // También rechazamos la Promesa si la solicitud falla antes de
        // que obtengamos una respuesta (por ejemplo, cuando la red no funciona).
        request.on("error", error => &lbrace;
          reject(error);
        });
      });
    }</code></pre>
  </section>
  <section id="2-7" class="py-4 xs:py-5 sm:py-6">
    <h2>13.2.7 Promesas en secuencia</h2>
    <p><codeinline>Promise.all()</codeinline> facilita la ejecución de un número arbitrario de promesas en paralelo. Y las cadenas de promesas facilitan la expresión de una secuencia de un número fijo de promesas. Sin embargo, ejecutar un número arbitrario de promesas en secuencia es más complicado. Supongamos, por ejemplo, que tienes un array de URLs que recuperar, pero que para evitar sobrecargar tu red, quieres recuperarlas de una en una. Si el array es de longitud arbitraria y contenido desconocido, no puedes escribir una cadena Promise por adelantado, así que necesitas construir una dinámicamente, con código como este:</p>
    <pre class="language-js">
    <code class="language-js">function fetchSequentially(urls) &lbrace;
      // Almacenaremos los cuerpos de las URL aquí a medida que los obtengamos.
      const bodies = [];

      // Aquí hay una función que devuelve una promesa y recupera un cuerpo.
      function fetchOne(url) &lbrace;
        return fetch(url)
          .then(response => response.text())
          .then(body => &lbrace;
            // Guardamos el cuerpo en el array y omitimos deliberadamente 
            // un valor de retorno aquí (devolviendo indefinido)
            bodies.push(body);
          });
      }

      // Comience con una Promesa que se cumplirá de inmediato (con valor indefinido)
      let p = Promise.resolve(undefined);

      // Ahora recorra las URL deseadas, construyendo una cadena de Promesas
      // de longitud arbitraria y obteniendo una URL en cada etapa de la cadena.
      for(url of urls) &lbrace;
        p = p.then(() => fetchOne(url));
      }

      // Cuando se cumple la última Promesa de esa cadena, la matriz de cuerpos
      // está lista. Por lo tanto, devolvamos una Promesa para esa matriz de 
      // cuerpos. Tenga en cuenta que no incluimos ningún controlador de errores: 
      // queremos permitir que los errores se propaguen al llamador.
      return p.then(() => bodies);
    }</code></pre>
    <p>Con esta función <codeinline>fetchSequentially()</codeinline> definida, podríamos obtener las URLs de una en una con un código muy parecido al código fetch-in-parallel que usamos antes para demostrar <codeinline>Promise.all()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">fetchSequentially(urls)
      .then(bodies => &lbrace; /* hacer algo con la array de strings */ })
      .catch(e => console.error(e));</code></pre>
    <p>La función <codeinline>fetchSequentially()</codeinline> comienza creando una Promise que se cumplirá inmediatamente después de que regrese. Luego construye una larga cadena lineal de Promise a partir de esa Promise inicial y devuelve la última Promise de la cadena. Es como colocar una fila de fichas de dominó y derribar la primera.</p>
    <p>Hay otro enfoque (posiblemente más elegante) que podemos adoptar. En lugar de crear las promesas por adelantado, podemos hacer que la llamada de retorno de cada promesa cree y devuelva la siguiente promesa. Es decir, en lugar de crear y encadenar un montón de promesas, creamos promesas que se resuelven en otras promesas. En lugar de crear una cadena de promesas tipo dominó, estamos creando una secuencia de promesas anidadas una dentro de otra como un conjunto de muñecas matrioskas. Con este enfoque, nuestro código puede devolver la primera promesa (la más externa), sabiendo que finalmente se cumplirá (¡o rechazará!) con el mismo valor que la última promesa (la más interna) de la secuencia. La función <codeinline>promiseSequence()</codeinline> que sigue está escrita para ser genérica y no es específica de la obtención de URLs. Está aquí al final de nuestra discusión sobre Promesas porque es complicada. Sin embargo, si has leído este capítulo con atención, espero que seas capaz de entender cómo funciona. En particular, observa que la función anidada dentro de <codeinline>promiseSequence()</codeinline> parece llamarse a sí misma recursivamente, pero debido a que la llamada "recursiva" es a través de un método <codeniline>then()</codeniline>, en realidad no está ocurriendo ninguna recursión tradicional:</p>
    <pre class="language-js">
    <code class="language-js">
    // Esta función toma un array de valores de entrada y una función "promiseMaker". 
    // Para cualquier valor de entrada x en el array, promiseMaker(x) debe devolver
    // una Promesa que se cumplirá con un valor de salida. Esta función devuelve
    // una Promesa que se cumple con una matriz de valores de salida calculados.
    //
    // Sin embargo, en lugar de crear todas las Promesas a la vez y dejar que se 
    // ejecuten en paralelo, promiseSequence() solo ejecuta una Promesa a la vez
    // y no llama a promiseMaker() para obtener un valor hasta que se haya
    // cumplido la Promesa anterior.
    function promiseSequence(inputs, promiseMaker) &lbrace;
      // Hacer una copia privada del array que podamos modificar
      inputs = [...inputs];

      // Aquí está la función que usaremos como callback de Promesa. 
      // Esta es la magia pseudorecursiva que hace que todo esto funcione.
      function handleNextInput(outputs) &lbrace;
        if (inputs.length === 0) &lbrace;
          // Si no quedan más entradas, entonces devuelve el array
          // de salidas, cumpliendo finalmente esta Promesa y 
          // todas las Promesas anteriores resueltas pero no cumplidas.
          return outputs;
        } else &lbrace;
          // Si todavía hay valores de entrada para procesar, 
          // devolveremos un objeto Promesa, resolviendo la Promesa 
          // actual con el valor futuro de una nueva Promesa.
          let nextInput = inputs.shift(); // Obtener el siguiente valor de entrada,
          return promiseMaker(nextInput)  // calcular el siguiente valor de salida,
            // Luego crea una nueva matriz de salidas con el nuevo valor de salida
            .then(output => outputs.concat(output))
            // Luego, "recurse" y pasa la nueva matriz de salidas, más larga.
            .then(handleNextInput);
        }
      }

      // Comience con una Promesa que se cumpla en una matriz vacía y
      // use la función anterior como su devolución de llamada.
      return Promise.resolve([]).then(handleNextInput);
    }</code></pre>
    <p>Esta función <codeinline>promiseSequence()</codeinline> es intencionadamente genérica. Podemos usarla para obtener URLs de con código como este:</p>
    <pre class="language-js">
    <code class="language-js">// Dada una URL, devuelve una Promesa que cumple con el texto del cuerpo de la URL
    function fetchBody(url) &lbrace; return fetch(url).then(r => r.text()); }
    // Úselo para obtener secuencialmente un montón de cuerpos de URL
    promiseSequence(urls, fetchBody)
      .then(bodies => &lbrace; /* hacer algo con el array de string */ })
      .catch(console.error);</code></pre>
  </section>
  <section id="3">
    <h2>13.3 async y await</h2>
    <p>ES2017 introduce dos nuevas palabras clave -<codeinline>async</codeinline> y <codeinline>await</codeinline>- que representan un cambio de paradigma en la programación asíncrona de JavaScript. Estas nuevas palabras clave simplifican drásticamente el uso de promesas y nos permiten escribir código asíncrono basado en promesas que parece código síncrono que se bloquea mientras espera respuestas de red u otros eventos asíncronos. Aunque sigue siendo importante entender cómo funcionan las promesas, gran parte de su complejidad (¡y a veces incluso su propia presencia!) desaparece cuando se utilizan con <codeinline>async</codeinline> y <codeinline>await</codeinline>.</p>
    <p>Como hemos visto antes en este capítulo, el código asíncrono no puede devolver un valor o lanzar una excepción del mismo modo que el código síncrono normal. Y esta es la razón por la que las Promesas están diseñadas como lo están. El valor de una Promise cumplida es como el valor de retorno de una función síncrona. Y el valor de una Promise rechazada es como el valor lanzado por una función síncrona. Esta última similitud se hace explícita por el nombre del método <codeinline>.catch()</codeinline>. <codeinline>async</codeinline> y <codeinline>await</codeinline> toman código eficiente basado en Promise y ocultar las promesas para que tu código asíncrono sea tan fácil de leer y de razonar como el código síncrono ineficiente y bloqueante.</p>
  </section>
  <section id="3-1" class="py-4 xs:py-5 sm:py-6">
    <h2>13.3.1 Expresiones de espera</h2>
    <p>La palabra clave <codeinline>await</codeinline> toma una Promise y la convierte en un valor de retorno o en una excepción lanzada. Dado un objeto Promise <codeinline>p</codeinline>, la expresión <codeinline>await p</codeinline> espera hasta que p se cumpla. Si p se cumple, entonces el valor de <codeinline>await</codeinline> <codeinline>p</codeinline> es el valor de cumplimiento de <codeinline>p</codeinline>. Por otro lado, si <codeinline>p</codeinline> es rechazado, entonces la expresión <codeinline>await p</codeinline> lanza el valor de rechazo de <codeinline>p</codeinline>. No solemos usar <codeinline>await</codeinline> con una variable que contiene una Promise; en su lugar, la usamos antes de la invocación de una función que devuelve una Promise:</p>
    <pre class="language-js">
    <code class="language-js">let response = await fetch("/api/user/profile");
    let profile = await response.json();</code></pre>
    <p>Es fundamental entender de inmediato que la palabra clave <codeinline>await</codeinline> no hace que tu programa se bloquee y literalmente no haga nada hasta que la Promise especificada se asiente. El código sigue siendo asíncrono, y <codeinline>await</codeinline> simplemente disfraza este hecho. Esto significa que <em>cualquier código que utilice</em> <codeinline>await</codeinline> <em>es en sí mismo asíncrono</em>.</p>
  </section>
  <section id="3-2">
    <h2>13.3.2 Funciones asíncronas</h2>
    <p>Dado que cualquier código que utilice <codeinline>await</codeinline> es asíncrono, hay una regla crítica: <em>sólo puedes utilizar la palabra clave <codeinline>await</codeinline> dentro de funciones que hayan sido declaradas con la palabra clave <codeinline>async</codeinline></em>. Aquí tienes una versión de la función <codeinlie>getHighScore()</codeinlie> de antes, reescrita para usar <codeinline>async</codeinline> y <codeinline>await</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">async function getHighScore() &lbrace;
      let response = await fetch("/api/user/profile");
      let profile = await response.json();
      return profile.highScore;
    }</code></pre>
    <p>Declarar una función <codeinline>async</codeinline> significa que el valor de retorno de la función será una Promise incluso si no aparece código relacionado con Promise en el cuerpo de la función. Si una función <codeinline>async</codeinline> parece devolver normalmente, entonces el objeto Promise que es el valor de retorno real de la función se resolverá a ese valor de retorno aparente. Y si una función <codeinline>async</codeinline> parece lanzar una excepción, entonces el objeto Promise que devuelve será rechazado con esa excepción.</p>
    <p>La función <codeinline>getHighScore()</codeinline> está declarada <codeinline>async</codeinline>, por lo que devuelve una Promise. Y como devuelve una Promise, podemos usar la palabra clave <codeinline>await</codeinline> con ella:</p>
    <pre class="language-js">
    <code class="language-js">displayHighScore(await getHighScore());</code></pre>
    <p>Pero recuerda, ¡esa línea de código sólo funcionará si está dentro de otra función <codeinline>async</codeinline>! Puedes anidar expresiones <codeinline>await</codeinline> dentro de funciones <codeinline>async</codeinline> tan profundamente como quieras. Pero si estás en el nivel superior<sup>2</sup> o estás dentro de una función que no es <codeinline>async</codeinline> por alguna razón, entonces no puedes usar <codeinline>await</codeinline> y tienes que tratar con una Promise devuelta de la forma habitual:</p>
    <pre class="language-js">
    <code class="language-js">getHighScore().then(displayHighScore).catch(console.error);</code></pre>
    <p>Puedes utilizar la palabra clave <codeinline>async</codeinline> con cualquier tipo de <codeinline>function</codeinline>. Funciona con la palabra clave function como sentencia o como expresión. Funciona con funciones de flecha y con la forma abreviada de método en clases y literales de objeto. (Consulta el <a href="capitulo-8">capítulo 8</a> para obtener más información sobre las distintas formas de escribir funciones).</p>
  </section>
  <section id="3-3" class="py-4 xs:py-5 sm:py-6">
    <h2>13.3.3 A la espera de múltiples promesas</h2>
    <p>Supongamos que hemos escrito nuestra función <codeinline>getJSON()</codeinline> usando <codeinline>async</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">async function getJSON(url) &lbrace;
      let response = await fetch(url);
      let body = await response.json();
      return body;
    }</code></pre>
    <p>Y ahora supongamos que queremos obtener dos valores JSON con esta función:</p>
    <pre class="language-js">
    <code class="language-js">let value1 = await getJSON(url1);
    let value2 = await getJSON(url2);</code></pre>
    <p>El problema de este código es que es innecesariamente secuencial: la obtención de la segunda URL no comenzará hasta que la primera se haya completado. Si la segunda URL no depende del valor obtenido de la primera URL, entonces probablemente deberíamos intentar obtener los dos valores al mismo tiempo. Este es un caso en el que se muestra la naturaleza basada en promesas de las funciones <codeinline>async</codeinline>. Para esperar un conjunto de funciones <codeinline>async</codeinline> que se ejecutan simultáneamente, usamos <codeinline>Promise.all()</codeinline> tal y como lo haríamos si trabajásemos con Promises directamente:</p>
    <pre class="language-js">
    <code class="language-js">let [value1, value2] = await Promise.all([getJSON(url1), getJSON(url2)]);</code></pre>
  </section>
  <section id="3-4">
    <h2>13.3.4 Detalles de la aplicación</h2>
    <p>Por último, para entender cómo funcionan las funciones <codeinline>async</codeinline>, puede ser útil pensar en lo que ocurre bajo el capó.</p>
    <p>Supongamos que escribes una función <codeinline>async</codeinline> como esta:</p>
    <pre class="language-js">
    <code class="language-js">async function f(x) &lbrace; /* body */ }</code></pre>
    <p>Puedes pensar en esto como una función que devuelve promesas envuelta alrededor del cuerpo de tu función original:</p>
    <pre class="language-js">
    <code class="language-js">function f(x) &lbrace;
      return new Promise(function(resolve, reject) &lbrace;
        try &lbrace;
          resolve((function(x) &lbrace; /* body */ })(x));
        }
        catch(e) &lbrace;
          reject(e);
        }
      });
    }</code></pre>
    <p>Es más difícil expresar la palabra clave <codeinline>await</codeinline> en términos de una transformación sintáctica como ésta. Pero piensa en la palabra clave <codeinline>await</codeinline> como un marcador que divide el cuerpo de una función en trozos separados y síncronos. Un intérprete de ES2017 puede dividir el cuerpo de la función en una secuencia de subfunciones separadas, cada una de las cuales se pasa al método <codeinline>then()</codeinline> de la Promise marcada con <codeinline>await</codeinline> que la precede.</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>13.4 Iteración asíncrona</h2>
    <p>Comenzamos este capítulo con una discusión sobre la asincronía basada en llamadas y eventos, y cuando introdujimos las Promesas, señalamos que eran útiles para cálculos asíncronos de una sola vez, pero no eran adecuadas para su uso con fuentes de eventos asíncronos repetitivos, como <codeinline>setInterval()</codeinline>, el evento "click" en un navegador web, o el evento "data" en un flujo Node. Debido a que las Promesas simples no funcionan para secuencias de eventos asíncronos, tampoco podemos usar funciones <codeinline>async</codeinline> regulares y los estados <codeinline>await</codeinline> para estas cosas.</p>
    <p>Sin embargo, ES2018 proporciona una solución. Los iteradores asíncronos son como los iteradores descritos en el <a href="capitulo-12">capítulo 12</a>, pero se basan en promesas y están pensados para utilizarse con una nueva forma del bucle <codeinline>for/of</codeinline>: <codeinline>for/await</codeinline>.</p>
  </section>
  <section id="4-1">
    <h2>13.4.1 El bucle for/await</h2>
    <p>Nodo 12 hace que sus flujos legibles sean asíncronamente iterables. Esto significa que puedes leer trozos sucesivos de datos de un flujo con un bucle <codeinline>for/await</codeinline> como este:</p>
    <pre class="language-js">
    <code class="language-js">const fs = require("fs");

    async function parseFile(filename) &lbrace;
      let stream = fs.createReadStream(filename, &lbrace; encoding: "utf-8"});
      for await (let chunk of stream) &lbrace;
        parseChunk(chunk); // Supongamos que parseChunk() está definido en otro lugar
      }
    }</code></pre>
    <p>Como una expresión <codeinline>await</codeinline> normal, el bucle <codeinline>for/await</codeinline> está basado en promesas. A grandes rasgos, el iterador asíncrono produce una promesa y el bucle <codeinline>for/await</codeinline> espera a que se cumpla la promesa, asigna el valor de cumplimiento a la variable del bucle, y ejecuta el cuerpo del bucle. Y luego vuelve a empezar, obteniendo otra Promise del iterador y esperando a que esa nueva Promise se cumpla.</p>
    <p>Suponga que tiene una matriz de URLs:</p>
    <pre class="language-js">
    <code class="language-js">const urls = [url1, url2, url3];</code></pre>
    <p>Puedes llamar a <codeinline>fetch()</codeinline> en cada URL para obtener un array de Promesas:</p>
    <pre class="language-js">
    <code class="language-js">const promises = urls.map(url => fetch(url));</code></pre>
    <p>Anteriormente vimos que podíamos utilizar <codeinline>Promise.all()</codeinline> para esperar a que se cumplieran todas las promesas del array. Pero supongamos que queremos los resultados de la primera obtención tan pronto como estén disponibles y no queremos esperar a que se obtengan todas las URLs. (Por supuesto, la primera búsqueda puede tardar más que las demás, así que esto no es necesariamente más rápido que utilizar <codeinline>Promise.all()</codeinline>). Las matrices son iterables, por lo que podemos iterar a través de la matriz de promesas con un bucle <codeinline>for/of</codeinline> normal:</p>
    <pre class="language-js">
    <code class="language-js">for(const promise of promises) &lbrace;
      response = await promise;
      handle(response);
    }</code></pre>
    <p>Este código de ejemplo utiliza un bucle <codeinline>for/of</codeinline> normal con un iterador normal. Pero como este iterador devuelve Promesas, también podemos usar el nuevo <codeinline>for/await</codeinline> para un código ligeramente más simple:</p>
    <pre class="language-js">
    <code class="language-js">for await (const response of promises) &lbrace;
      handle(response);
    }</code></pre>
    <p>En este caso, el bucle <codeinline>for/await</codeinline> sólo construye la llamada <codeinline>await</codeinline> dentro del bucle y hace nuestro código ligeramente más compacto, pero los dos ejemplos hacen exactamente lo mismo. Importantemente, ambos ejemplos sólo funcionarán si están dentro de funciones declaradas <codeinline>async</codeinline>; un bucle <codeinline>for/await</codeinline> no es diferente de una expresión <codeinline>await</codeinline> normal en ese sentido.</p>
    <p>Es importante darse cuenta, sin embargo, que estamos usando <codeinline>for/await</codeinline> con un iterador regular en este ejemplo. Las cosas son más interesantes con iteradores completamente asíncronos.</p>
  </section>
  <section id="4-2" class="py-4 xs:py-5 sm:py-6">
    <h2>13.4.2 Iteradores asíncronos</h2>
    <p>Repasemos algo de la terminología del <a href="capitulo-12">Capítulo 12</a>. Un objeto <em>iterable</em> es aquel que se puede utilizar con un bucle <codeinline>for/of</codeinline>. Define un método con el nombre simbólico <codeinline>Symbol.iterator</codeinline>. Este método devuelve un objeto <em>iterador</em>. El objeto iterador tiene un método <codeinline>next()</codeinline>, que puede ser llamado repetidamente para obtener los valores del objeto iterable. El método <codeinline>next()</codeinline> del objeto iterador devuelve objetos <em>resultado de iteración</em>. El objeto resultado de iteración tiene una propiedad <codeinline>value</codeinline> y/o una propiedad <codeinline>done</codeinline>.</p>
    <p>Los iteradores asíncronos son bastante similares a los iteradores normales, pero hay dos diferencias importantes. En primer lugar, un objeto iterable asíncrono implementa un método con el nombre simbólico <codeinline>Symbol.asyncIterator</codeinline> en lugar de <codeinline>Symbol.iterator</codeinline>. (Como vimos antes, <codeinline>for/await</codeinline> es compatible con objetos iterables normales pero prefiere objetos iterables asíncronamente, e intenta el método <codeinline>Symbol.asyncIterator</codeinline> antes de intentar el método <codeinline>Symbol.iterator</codeinline>). En segundo lugar, el método <codeinline>next()</codeinline> de un iterator asíncrono devuelve una Promise que resuelve a un objeto resultado iterador en lugar de devolver un objeto resultado iterador directamente.</p>
    <nota>
      <img class="self-start" src="/public/javascript/nota_gral.png" alt="Nota de la warning">
      <div class="">
        <p>En la sección anterior, cuando usamos <codeinline>for/await</codeinline> en un array de Promises regular, iterable sincrónicamente, estábamos trabajando con objetos resultado de iteradores sincrónicos en los que la propiedad <codeinline>value</codeinline> era un objeto Promise pero la propiedad <codeinline>done</codeinline> era síncrona. Los verdaderos iteradores asíncronos devuelven Promesas para los objetos resultado de la iteración, y tanto la propiedad <codeinline>value</codeinline> como la propiedad <codeinline>done</codeinline> son asíncronas. La diferencia es sutil: con los iteradores asíncronos, la decisión sobre cuándo termina la iteración puede hacerse de forma asíncrona.</p>
      </div>
    </nota>
  </section>
  <section id="4-3">
    <h2>13.4.3 Generadores asíncronos</h2>
    <p>Como vimos en el <a href="capitulo-12">capítulo 12</a>, la forma más sencilla de implementar un iterador suele ser utilizar un generador. Lo mismo ocurre con los iteradores asíncronos, que podemos implementar con funciones generadoras que declaramos <codeinline>async</codeinline>. Un generador asíncrono tiene las características de las funciones asíncronas y las características de los generadores: puedes usar <codeinline>await</codeinline> como lo harías en una función asíncrona normal, y puedes usar <codeinline>yield</codeinline> como lo harías en un generador normal. Pero los valores <codeinline>yield</codeinline> se envuelven automáticamente en promesas. Incluso la sintaxis de los generadores asíncronos es una combinación: <codeinline>async function</codeinline> y <codeinline>function *</codeinline> se combinan en <codeinline>async function *</codeinline>. He aquí un ejemplo que muestra cómo se puede utilizar un generador asíncrono y un bucle <codeinline>for/await</codeinline> para ejecutar código repetitivamente a intervalos fijos utilizando sintaxis de bucle en lugar de una función de devolución de llamada <codeinline>setInterval()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Un contenedor basado en Promesas alrededor de setTimeout() con el que podemos usar await.
    // Devuelve una promesa que se cumple en la cantidad especificada de milisegundos.
    function elapsedTime(ms) &lbrace;
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Una función generadora asincrónica que incrementa un contador y lo devuelve 
    // una cantidad específica (o infinita) de veces en un intervalo específico.
    async function* clock(interval, max=Infinity) &lbrace;
      for(let count = 1; count &lt;= max; count++) &lbrace; // bucle for regular
        await elapsedTime(interval); // Espera que pase el tiempo
        yield count; // ceder el paso
      }
    }
    
    // Una función de prueba que utiliza el generador asíncrono con for/await
    async function test() &lbrace; // Async para que podamos usar for/await
      for await (let tick of clock(300, 100)) &lbrace; // Repetir 100 veces cada 300 ms
        console.log(tick);
      }
    }</code></pre>
  </section>
  <section id="4-4" class="py-4 xs:py-5 sm:py-6">
    <h2>13.4.4 Implementación de iteradores asíncronos</h2>
    <p>En lugar de utilizar generadores asíncronos para implementar iteradores asíncronos, también es posible implementarlos directamente definiendo un objeto con un método <codeinline>Symbol.asyncIterator()</codeinline> que devuelva un objeto con un método <codeinline>next()</codeinline> que devuelva una Promise que resuelva a un objeto iterador resultado. En el siguiente código, reimplementamos la función <codeinline>clock()</codeinline> del ejemplo anterior para que no sea un generador y en su lugar sólo devuelva un objeto iterable asíncrono. Observa que el método <codeinline>next()</codeinline> en este ejemplo no devuelve explícitamente una Promise; en su lugar, simplemente declaramos que <codeinline>next()</codeinline> es asíncrono:</p>
    <pre class="language-js">
    <code class="language-js">function clock(interval, max=Infinity) &lbrace;
      // Una versión Promise-ificada de setTimeout con la que podemos usar await.
      // Tenga en cuenta que esto toma un tiempo absoluto en lugar de un intervalo.
      function until(time) &lbrace;
        return new Promise(resolve => setTimeout(resolve, time - Date.now()));
      }
      
      // Devuelve un objeto iterable asincrónicamente
      return &lbrace;
        startTime: Date.now(), // ¿Recuerdas cuando empezamos?
        count: 1, // Recuerde en qué iteración estamos
        async next() &lbrace; // El método next() convierte esto en un iterador
          if (this.count > max) &lbrace; // Nosotros hemos terminado
            return &lbrace; done: true }; // Resultado de la iteración que indica que se ha completado
          }
          // Averiguar cuándo debe comenzar la siguiente iteración,
          let targetTime = this.startTime + this.count * interval;
          // espera hasta ese momento,
          await until(targetTime);
          // y devolver el valor del conteo en un objeto de resultado de iteración.
          return &lbrace; value: this.count++ };
        },
        // Este método significa que este objeto iterador también es iterable.
        [Symbol.asyncIterator]() &lbrace; return this; }
      };
    }</code></pre>
    <p>Esta versión basada en iteradores de la función <codeinline>clock()</codeinline> corrige un fallo de la versión basada en generadores. Tenga en cuenta que, en este nuevo código, nos centramos en el tiempo absoluto en el que cada iteración debe comenzar y restar el tiempo actual de la misma con el fin de calcular el intervalo que pasamos a <codeinline>setTimeout()</codeinline>. Si usamos <codeinline>clock()</codeinline> con un <codeinline>for/await</codeinline> esta versión ejecutará las iteraciones del bucle con mayor precisión en el intervalo especificado porque tiene en cuenta el tiempo necesario para ejecutar realmente el cuerpo del bucle. Pero esta corrección no sólo se refiere a la precisión del tiempo. El bucle <codeinline>for/await</codeinline> siempre espera a que se cumpla la Promesa devuelta por una iteración antes de comenzar la siguiente iteración. Pero si usas un iterador asíncrono sin un bucle <codeinline>for/await</codeinline>, no hay nada que te impida llamar al método <codeinline>next()</codeinline> cuando quieras. Con la versión basada en generador de <codeinline>clock()</codeinline>, si llamas al método <codeinline>next()</codeinline> tres veces secuencialmente, obtendrás tres Promesas que se cumplirán casi exactamente al mismo tiempo, lo que probablemente no es lo que quieres. La versión basada en iteradores que hemos implementado aquí no tiene ese problema.</p>
    <p>El beneficio de los iteradores asíncronos es que nos permiten representar flujos de eventos o datos asíncronos. La función <codeinline>clock()</codeinline> discutida anteriormente era bastante simple de escribir porque la fuente de la asincronía eran las llamadas a <codeinline>setTimeout()</codeinline> que hacíamos nosotros mismos. Pero cuando intentamos trabajar con otras fuentes asíncronas, como la activación de manejadores de eventos, se hace sustancialmente más difícil implementar iteradores asíncronos: normalmente tenemos una única función manejadora de eventos que responde a los eventos, pero cada llamada al método <codeinline>next()</codeinline> del iterador debe devolver un objeto Promise distinto, y pueden producirse múltiples llamadas a <codeinline>next()</codeinline> antes de que se resuelva la primera Promise. Esto significa que cualquier método iterador asíncrono debe ser capaz de mantener una cola interna de Promesas que resuelve en orden a medida que se producen eventos asíncronos. Si encapsulamos este comportamiento de cola de promesas en una clase AsyncQueue, será mucho más fácil escribir iteradores asíncronos basados en AsyncQueue.<sup>3</sup></p>
    <p>La clase AsyncQueue que sigue tiene los métodos <codeinline>enqueue()</codeinline> y <codeinline>dequeue()</codeinline>, como es de esperar para una clase de cola. Sin embargo, el método <codeinline>dequeue()</codeinline> devuelve una Promise en lugar de un valor real, lo que significa que está bien llamar a <codeinline>dequeue()</codeinline> antes de que se haya llamado a <codeinline>enqueue()</codeinline>. La clase AsyncQueue es también un iterador asíncrono, y está pensada para ser utilizada con un bucle <codeinline>for/await</codeinline> cuyo cuerpo se ejecuta una vez cada vez que un nuevo valor es puesto en cola de forma asíncrona. (AsyncQueue tiene un método <codeinline>close()</codeinline>. Una vez invocado, no se pueden encolar más valores. Cuando una cola cerrada está vacía, el bucle <codeinline>for/await</codeinline> deja de ejecutarse).</p>
    <p>Ten en cuenta que la implementación de AsyncQueue no utiliza <codeinline>async</codeinline> ni <codeinline>await</codeinline> y en su lugar trabaja directamente con Promises. El código es algo complicado, y puedes usarlo para poner a prueba tu comprensión del material que hemos cubierto en este largo capítulo. Aunque no entiendas del todo la implementación de AsyncQueue, echa un vistazo al código. mira el ejemplo más corto que le sigue: implementa un simple pero muy interesante iterador asíncrono sobre AsyncQueue.</p>
    <pre class="language-js">
    <code class="language-js">/**
    * Una clase de cola iterable de forma asincrónica. Agrega valores con 
    * enqueue() y elimínalos con dequeue(). dequeue() devuelve una Promesa,
    * lo que significa que los valores se pueden sacar de la cola antes de
    * que se vuelvan a poner en cola. La clase implementa 
    * [Symbol.asyncIterator] y next() para que se pueda usar con el bucle 
    * for/await (que no terminará hasta que se llame al método close()).
    */
    class AsyncQueue &lbrace;
      constructor() &lbrace;
        // Los valores que se han puesto en cola pero que aún no se 
        // han sacado de ella se almacenan aquí
        this.values = [];
        // Cuando las Promesas se sacan de la cola antes de que se pongan 
        // en cola sus valores correspondientes, los métodos de resolución
        // de esas Promesas se almacenan aquí.
        this.resolvers = [];
        // Una vez cerrado, no se pueden poner en cola más valores ni se
        // pueden devolver más promesas sin cumplir.
        this.closed = false;
      }

      enqueue(value) &lbrace;
        if (this.closed) &lbrace;
          throw new Error("AsyncQueue closed");
        }
        if (this.resolvers.length > 0) &lbrace;
          // Si este valor ya ha sido prometido, resuelva esa Promesa
          const resolve = this.resolvers.shift();
          resolve(value);
        }
        else &lbrace;
          // De lo contrario, ponlo en cola.
          this.values.push(value);
        }
      }

      dequeue() &lbrace;
        if (this.values.length > 0) &lbrace;
          // Si hay un valor en cola, devuelve una Promesa resuelta para él
          const value = this.values.shift();
          return Promise.resolve(value);
        }
        else if (this.closed) &lbrace;
          // Si no hay valores en cola y estamos cerrados, devuelva 
          // una Promesa resuelta para el marcador de "fin de transmisión"
          return Promise.resolve(AsyncQueue.EOS);
        }
        else &lbrace;
          // De lo contrario, devuelve una Promesa sin resolver, 
          // poniendo en cola la función de resolución para su uso posterior.
          return new Promise((resolve) => &lbrace; this.resolvers.push(resolve); });
        }
      }

      close() &lbrace;
        // Una vez que se cierra la cola, no se agregarán más valores 
        // a la cola. Por lo tanto, resuelva las promesas pendientes 
        // con el marcador de fin de flujo.
        while(this.resolvers.length > 0) &lbrace;
          this.resolvers.shift()(AsyncQueue.EOS);
        }
        this.closed = true;
      }

      // Define el método que hace que esta clase sea iterable de forma asincrónica
      [Symbol.asyncIterator]() &lbrace; return this; }

      // Define el método que convierte este iterador en asincrónico. La 
      // promesa dequeue() se resuelve en un valor o en el centinela EOS 
      // si estamos cerrados. Aquí, necesitamos devolver una promesa que 
      // se resuelva en un objeto de resultado de iterador.
      next() &lbrace;
        return this.dequeue().then(value => (value === AsyncQueue.EOS)
          ? &lbrace; value: undefined, done: true }
          : &lbrace; value: value, done: false });
      }
    }

    // Un valor centinela devuelto por dequeue() para marcar el 
    // "final del flujo" cuando se cierra
    AsyncQueue.EOS = Symbol("end-of-stream");</code></pre>
    <p>Dado que esta clase AsyncQueue define los fundamentos de la iteración asíncrona, podemos crear nuestros propios iteradores asíncronos más interesantes simplemente poniendo valores en cola de forma asíncrona. He aquí un ejemplo que utiliza AsyncQueue para producir un flujo de eventos del navegador web que pueden ser manejados con un bucle <codeinline>for/await</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Inserta eventos del tipo especificado en el elemento de documento especificado 
    // en un objeto AsyncQueue y devuelve la cola para usarla como un flujo de eventos
    function eventStream(elt, type) &lbrace;
      const q = new AsyncQueue(); // Crear una queue
      elt.addEventListener(type, e=>q.enqueue(e)); // Poner en cola eventos
      return q;
    }

    async function handleKeys() &lbrace;
      // Obtenga una secuencia de eventos de pulsación de 
      // teclas y repítalos una vez para cada uno
      for await (const event of eventStream(document, "keypress")) &lbrace;
        console.log(event.key);
      }
    }</code></pre>
  </section>
  <section id="5">
    <h2>13.5 Resumen</h2>
    <p>En este capítulo has aprendido:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La mayor parte de la programación JavaScript del mundo real es asíncrona.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Tradicionalmente, la asincronía se ha manejado con eventos y funciones callback. Esto puede ser complicado, sin embargo, porque usted puede terminar con múltiples niveles de devoluciones de llamada anidadas dentro de otras devoluciones de llamada, y porque es difícil hacer un manejo robusto de errores.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las promesas proporcionan una nueva forma de estructurar las funciones de devolución de llamada. Si se utilizan correctamente (y, por desgracia, las promesas son fáciles de utilizar incorrectamente), pueden convertir el código asíncrono que habría sido anidado en cadenas lineales de llamadas <codeinline>then()</codeinline> donde un paso asíncrono de un cálculo sigue a otro. Además, las promesas permiten centralizar el código de gestión de errores en una única llamada <codeinline>catch()</codeinline> al final de una cadena de llamadas <codeinline>then()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las palabras clave <codeinline>async</codeinline> y <codeinline>await</codeinline> nos permiten escribir código asíncrono basado en promesas pero que parece código síncrono. Esto hace que el código sea más fácil de entender y razonar. Si una función se declara <codeinline>async</codeinline>, devolverá implícitamente una promesa. Dentro de una función <codeinline>async</codeinline>, puedes <codeinline>await</codeinline> una Promise (o una función que devuelva una Promise) como si el valor de la Promise se hubiera calculado sincrónicamente.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los objetos que son asíncronamente iterables pueden ser utilizados con un bucle <codeinline>for/await</codeinline>. Puedes crear objetos iterables asíncronamente implementando un método <codeinline>[Symbol.asyncIterator]()</codeinline> o invocando una función generadora <codeinline>async function *</codeinline>. Los iteradores asíncronos proporcionan una alternativa a los eventos de "datos" en los flujos en Node y se pueden utilizar para representar un flujo de eventos de entrada de usuario en JavaScript del lado del cliente.
        </p>
      </li>
    </ul>
  </section>
</Layoutjavascript>