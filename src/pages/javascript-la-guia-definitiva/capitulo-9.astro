---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-8" capSiguiente="capitulo-10" />
  <section class="fadeIn">
    <h1 class="text-right">Clases</h1>
    <p>Los objetos JavaScript se trataron en el <a href="capitulo-6">capítulo 6</a>. Ese capítulo trataba cada objeto como un conjunto único de propiedades, diferente de cualquier otro objeto. Sin embargo, a menudo es útil definir una <em>class</em> de objetos que comparten ciertas propiedades. Los miembros, o <em>instancias</em>, de la clase tienen sus propias propiedades para mantener o definir su estado, pero también tienen métodos que definen su comportamiento. Estos métodos son definidos por la clase y compartidos por todas las instancias. Imaginemos una clase llamada Complejo que representa y realiza operaciones aritméticas con números complejos, por ejemplo. Una instancia de Complex tendría propiedades para contener las partes real e imaginaria (el estado) del número complejo. Y la clase Complex definiría métodos para realizar la suma y la multiplicación (el comportamiento) de esos números.</p>
    <p>En JavaScript, las clases utilizan la herencia basada en prototipos: si dos objetos heredan propiedades (generalmente propiedades con valores de función o métodos) del mismo prototipo, decimos que esos objetos son instancias de la misma clase. Así es como funcionan las clases en JavaScript. Los prototipos y la herencia de JavaScript se trataron en <a href="capitulo-6#2-3">§6.2.3</a> y <a href="capitulo-6#3-2">§6.3.2</a> y necesitarás estar familiarizado con el material de esas secciones para entender este capítulo. Este capítulo cubre los prototipos en <a href="#1">§9.1</a>.</p>
    <p>Si dos objetos heredan del mismo prototipo, esto significa típicamente (pero no necesariamente) que fueron creados e inicializados por la misma función constructora o función fac- toria. Los constructores se han tratado en <a href="capitulo-4#6">§4.6</a>, <a href="capitulo-6#2-2">§6.2.2</a>, y <a href="capitulo-8#2-3">§8.2.3</a>, y este capítulo tiene más en <a href="#2">§9.2</a>.</p>
    <p>JavaScript siempre ha permitido la definición de clases. ES6 introdujo una nueva sintaxis (incluyendo una palabra clave <codeinline>class</codeinline>) que hace aún más fácil crear clases. Estas nuevas clases de JavaScript funcionan de la misma forma que las clases antiguas, y este capítulo comienza explicando la forma antigua de crear clases porque demuestra más claramente lo que sucede entre bastidores para que las clases funcionen. Una vez que hayamos explicados estos fundamentos, cambiaremos y empezaremos a utilizar la nueva sintaxis simplificada de definición de clases.</p>
    <p>Si está familiarizado con lenguajes de programación orientados a objetos fuertemente tipados como Java o C++, se dará cuenta de que las clases de JavaScript son bastante diferentes de las clases de esos lenguajes. Hay algunas similitudes sintácticas, y puede emular muchas características de las clases "clásicas" en JavaScript, pero es mejor entender de antemano que las clases de JavaScript y el mecanismo de herencia basado en prototipos son sustancialmente diferentes de las clases y el mecanismo de herencia basado en clases de Java y lenguajes similares.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>9.1 Clases y prototipos</h2>
    <p>En JavaScript, una clase es un conjunto de objetos que heredan propiedades del mismo objeto prototipo. El objeto prototipo, por lo tanto, es la característica central de una clase. El <a href="capitulo-6">Capítulo 6</a> cubrió la función <codeinline>Object.create()</codeinline> que devuelve un objeto recién creado que hereda de un objeto prototipo especificado. Si definimos un objeto prototipo y luego utilizamos <codeinline>Object.create()</codeinline> para crear objetos que hereden de él, habremos definido una clase JavaScript. Normalmente, las instancias de una clase requieren una inicialización adicional, y es común definir una función que cree e inicialice el nuevo objeto. El <a href="#ejemplo9-1">Ejemplo 9-1</a> demuestra esto: define un objeto prototipo para una clase que representa un rango de valores y también define una <em>función de fábrica</em> que crea e inicializa una nueva instancia de la clase.</p>
    <p id="ejemplo9-1"><em>Ejemplo 9-1. Una clase JavaScript sencilla</em></p>
    <pre class="language-js">
    <code class="language-js">
    // Esta es una función de fábrica que devuelve un nuevo objeto de rango.
    function range(from, to) &lbrace;
      // Utilice Object.create() para crear un objeto que herede del objeto
      // prototipo definido a continuación. El objeto prototipo se almacena 
      // como una propiedad de esta función y define los métodos compartidos
      // (comportamiento) para todos los objetos de rango.
      let r = Object.create(range.methods);
      
      // Almacene los puntos de inicio y final (estado) de este nuevo objeto de rango.
      // Estas son propiedades no heredadas que son exclusivas de este objeto.
      r.from = from;
      r.to = to;

      // Finalmente devuelve el nuevo objeto
      return r;
    }

    // Este objeto prototipo define métodos heredados por todos los objetos de rango.
      range.methods = &lbrace;
      // Devuelve verdadero si x está en el rango, falso en caso contrario
      // Este método funciona tanto para rangos textuales y de fechas como para números.
      includes(x) &lbrace; return this.from &lt;= x && x &lt;= this.to; },
      // Una función generadora que hace que las instancias de la clase sean iterables.
      // Tenga en cuenta que solo funciona para rangos numéricos.
      *[Symbol.iterator]() &lbrace;
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
      },
      
      // Devuelve una representación de cadena del rango
      toString() &lbrace; return "(" + this.from + "..." + this.to + ")"; }
    };

    // A continuación se muestran ejemplos de uso de un objeto de rango.
    let r = range(1,3); // Create a range object
    r.includes(2) // => true: 2 is in the range
    r.toString() // => "(1...3)"
    [...r] // => [1, 2, 3]; convertir a una matriz mediante iterador</code></pre>
    <p>Hay algunas cosas dignas de mención en el código del <a href="#ejemplo9-1">Ejemplo 9-1</a>:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Este código define una función de fábrica <codeinline>range()</codeinline> para crear nuevos objetos Range.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Utiliza la propiedad <codeinline>methods</codeinline> de esta función <codeinline>range()</codeinline> como un lugar conveniente para almacenar el objeto prototipo que define la clase. No hay nada especial o idiomático en poner el objeto prototipo aquí.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La función <codeinline>range()</codeinline> define las propiedades <codeinline>from</codeinline> y <codeinline>to</codeinline> en cada objeto Range. Estas son las propiedades no compartidas y no heredadas que definen el estado único de cada objeto Range individual.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El objeto <codeinline>range.methods</codeinline> utiliza la sintaxis abreviada de ES6 para definir métodos, razón por la cual no se ve la palabra clave <codeinline>function</codeinline> en ninguna parte. (Véase <a href="capitulo-6#10-5">§6.10.5</a> para revisar la sintaxis abreviada de métodos del literal de objeto).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Uno de los métodos del prototipo tiene el nombre computado (<a href="capitulo-6#10-2">§6.10.2</a>) <codeinline>Symbol.iterator</codeinline>, lo que significa que está definiendo un iterador para objetos Range. El nombre de este método está prefijado con <codeinline>*</codeinline>, lo que indica que es una función generadora en lugar de una función normal. Los iteradores y generadores se tratan en detalle en el <a href="capitulo-12">Capítulo 12</a>. Por ahora, el resultado es que las instancias de esta clase Range pueden utilizarse con el bucle <codeinline>for/of</codeinline> y con el operador de extensión <codeinline>...</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Todos los métodos compartidos y heredados definidos en <codeinline>range.methods</codeinline> utilizan las propiedades <codeinline>from</codeinline> y <codeinline>to</codeinline> que se inicializaron en la función de fábrica <codeinline>range()</codeinline>. Para referirse a ellos, utilizan la palabra clave <codeinline>this</codeinline> para referirse al objeto a través del cual fueron invocados. Este uso de <codeinline>this</codeinline> es una característica fundamental de los métodos de cualquier clase.
        </p>
      </li>
    </ul>
  </section>
  <section id="2">
    <h2>9.2 Clases y constructores</h2>
    <p>El <a href="#ejemplo9-1">Ejemplo 9-1</a> demuestra una forma simple de definir una clase JavaScript. Sin embargo, no es la forma idiomática de hacerlo, porque no define un <em>constructor</em>. Un constructor es una función diseñada para la inicialización de objetos recién creados. Los constructores se invocan mediante la palabra clave <codeinline>new</codeinline>, tal y como se describe en <a href="capitulo-8#2-3">§8.2.3</a>. Las invocaciones a constructores utilizando <codeinline>new</codeinline> crean automáticamente el nuevo objeto, por lo que el propio constructor sólo necesita inicializar el estado de ese nuevo objeto. La característica crítica de las invocaciones a constructores es que la propiedad <codeinline>prototype</codeinline> del constructor se utiliza como prototipo del nuevo objeto. En <a href="capitulo-6#2-3">§6.2.3</a> se introdujeron los prototipos y se hizo hincapié en que, si bien casi todos los objetos tienen un prototipo, sólo unos pocos objetos tienen una propiedad <codeinline>prototype</codeinline>. Finalmente, podemos aclararlo: son los objetos función los que tienen una propiedad prototipo. Esto significa que todos los objetos creados con la misma función constructora heredan del mismo objeto y, por tanto, son miembros de la misma clase. El <a href="#ejemplo9-2">Ejemplo 9-2</a> muestra cómo podríamos modificar la clase Range del <a href="#ejemplo9-1">Ejemplo 9-1</a> para utilizar una función constructora en lugar de una función de fábrica. El <a href="#ejemplo9-2">Ejemplo 9-2</a> demuestra la forma idiomática de crear una clase en versiones de Java-Script que no soportan la palabra clave <codeinline>class</codeinline> de ES6. Aunque class está bien soportado ahora, todavía hay mucho código JavaScript antiguo que define clases como esta, y deberías estar familiarizado con el modismo para que puedas leer código antiguo y para que entiendas lo que está pasando "bajo el capó" cuando usas la palabra clave <codeinline>class</codeinline>.</p>
    <p><em>Ejemplo 9-2. Una clase Range que utiliza un constructor</em></p>
    <pre class="language-js">
    <code class="language-js">// Esta es una función constructora que inicializa nuevos objetos Range.
    // Tenga en cuenta que no crea ni devuelve el objeto. Solo lo inicializa.
    function Range(from, to) &lbrace;
      // Almacene los puntos de inicio y final (estado) de este nuevo objeto de rango.
      // Estas son propiedades no heredadas que son exclusivas de este objeto.
      this.from = from;
      this.to = to;
    }

    // Todos los objetos Range heredan de este objeto.
    // Tenga en cuenta que el nombre de la propiedad debe ser "prototipo" para que esto funcione.
    Range.prototype = &lbrace;
      // Devuelve verdadero si x está en el rango, falso en caso contrario
      // Este método funciona tanto para rangos textuales y de fechas como para números.
      includes: function(x) &lbrace; return this.from &lt;= x && x &lt;= this.to; },

      // Una función generadora que hace que las instancias de la clase sean iterables.
      // Tenga en cuenta que solo funciona para rangos numéricos.
      [Symbol.iterator]: function*() &lbrace;
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
      },

      // Devuelve una representación de cadena del rango
      toString: function() &lbrace; return "(" + this.from + "..." + this.to + ")"; }
    };

    // A continuación se muestran ejemplos de uso de esta nueva clase Range
    let r = new Range(1,3); // Cree un objeto Range; observe el uso de new
    r.includes(2) // => true: 2 está en el rango
    r.toString() // => "(1...3)"
    [...r] // => [1, 2, 3]; convertir a una matriz mediante iterador</code></pre>
    <p>Merece la pena comparar los Ejemplos <a href="#ejemplo9-1">9-1</a> y <a href="#ejemplo9-2">9-2</a> con bastante cuidado y observar las diferencias entre estas dos técnicas para definir clases. Primero, observe que renombramos la función de fábrica <codeinline>range()</codeinline> a <codeinline>Range()</codeinline> cuando la convertimos en un constructor. Esta es una convención de codificación muy común: las funciones constructoras definen, en cierto sentido, clases, y las clases tienen nombres que (por convención) comienzan con mayúsculas. Las funciones y métodos normales tienen nombres que empiezan con minúsculas.</p>
    <p>A continuación, observe que el constructor <codeinline>Range()</codeinline> es invocado (al final del ejemplo) con la palabra clave new mientras que la función de fábrica <codeinline>range()</codeinline> fue invocada sin ella. El <a href="#ejemplo9-1">Ejemplo 9-1</a> utiliza la invocación regular de la función (<a href="capitulo-8#2-1">§8.2.1</a>) para crear el nuevo objeto, y el <a href="#ejemplo9-2">Ejemplo 9-2</a> utiliza la invocación del constructor (<a href="capitulo-8#2-3">§8.2.3</a>). Como el constructor <codeinline>Range()</codeinline> se invoca con <codeinline>new</codeinline>, no tiene que llamar a <codeinline>Object.create()</codeinline> ni realizar ninguna acción para crear un nuevo objeto. El nuevo objeto se crea automáticamente antes de llamar al constructor, y es accesible como el valor <codeinline>this</codeinline>. El constructor <codeinline>Range()</codeinline> simplemente tiene que inicializar <codeinline>this</codeinline>. Los constructores ni siquiera tienen que devolver el objeto recién creado. La invocación del constructor crea automáticamente un nuevo objeto, invoca al constructor como un método de ese objeto y devuelve el nuevo objeto. El hecho de que la invocación de constructores sea tan diferente de la invocación de funciones normales es otra de las razones por las que damos a los constructores nombres que empiezan con mayúsculas. Los constructores están escritos para ser invocados como constructores, con la palabra clave <codeinline>new</codeinline>, y normalmente no funcionarán correctamente si se invocan como funciones normales. Una convención de nomenclatura que mantenga las funciones constructoras diferenciadas de las funciones normales ayuda a los programadores a saber cuándo usar <codeinline>new</codeinline>.</p>
    <article>
      <p class="title-article">Constructores y new.target</p>
      <p>Dentro del cuerpo de una función, puede saber si la función ha sido invocada como constructor con la expresión especial <codeinline>new.target</codeinline>. Si el valor de esa expresión está definido, entonces sabe que la función fue invocada como un constructor, con la palabra clave <codeinline>new</codeinline>. Cuando hablemos de subclases en <a href="#5">§9.5</a>, veremos que <codeinline>new.target</codeinline> no siempre es una referencia al constructor en el que se usa: también puede referirse a la función constructora de una subclase.</p>
      <p>Si <codeinline>new.target</codeinline> es <codeinline>undefined</codeinline>, entonces la función contenedora fue invocada como una función, sin la palabra clave <codeinline>new</codeinline>. Los diversos constructores de error de JavaScript pueden ser invocados sin <codeinline>new</codeinline>, y si quieres emular esta característica en tus propios constructores, debes puede escribirlas así:</p>
    <pre class="language-js">
    <code class="language-js">function C() &lbrace;
      if (!new.target) return new C();
      // El código de inicialización va aquí
    }</code></pre>
      <p>Esta técnica sólo funciona para constructores definidos de esta forma anticuada. Las clases creadas con la palabra clave <codeinline>class</codeinline> no permiten invocar sus constructores sin <codeinline>new</codeinline>.</p>
    </article>
    <p>Otra diferencia crítica entre los Ejemplos <a href="#ejemplo9-1">9-1</a> y <a href="#ejemplo9-2">9-2</a> es la forma en que se nombra el objeto prototipo. En el primer ejemplo, el prototipo era <codeinline>range.methods</codeinline>. Era un nombre conveniente y descriptivo, pero arbitrario. En el segundo ejemplo, el prototipo es <codeinline>Range.prototype</codeinline>, y este nombre es obligatorio. Una invocación del constructor <codeinline>Range()</codeinline> utiliza automáticamente <codeinline>Range.prototype</codeinline> como prototipo del nuevo objeto Range.</p>
    <p>Finalmente, observe también las cosas que no cambian entre los Ejemplos <a href="#ejemplo9-1">9-1</a> y <a href="#ejemplo9-2">9-2</a> : los métodos range se definen e invocan de la misma manera para ambas clases. Debido a que el <a href="#ejemplo9-2">Ejemplo 9-2</a> demuestra la forma idiomática de crear clases en versiones de Java-Script anteriores a ES6, no utiliza la sintaxis abreviada de métodos de ES6 en el objeto prototipo y deletrea explícitamente los métodos con la palabra clave <codeinline>function</codeinline>. Pero puede ver que la implementación de los métodos es la misma en ambos ejemplos.</p>
    <p>Es importante notar que ninguno de los dos ejemplos de rangos utiliza funciones flecha al definir constructores o métodos. Recuerde de <a href="capitulo-8#1-3">§8.1.3</a> que las funciones definidas de esta manera no tienen una propiedad <codeinline>prototype</codeinline> y por lo tanto no pueden ser utilizadas como constructores. Además, las funciones flecha heredan la palabra clave <codeinline>this</codeinline> del contexto en el que se definen en lugar de establecerla en función del objeto a través del cual se invocan, y esto las hace inútiles para los métodos porque la característica definitoria de los métodos es que utilizan <codeinline>this</codeinline> para referirse a la instancia sobre la que se invocaron.</p>
    <p>Afortunadamente, la nueva sintaxis de <codeinline>class</codeinline> ES6 no permite la opción de definir métodos con funciones de flecha, así que este no es un error que puedas cometer accidentalmente al usar esa sintaxis. Cubriremos la palabra clave de la clase ES6 pronto, pero primero, hay más detalles que cubrir sobre los constructores.</p>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>9.2.1 Constructores, identidad de clase e instanceof</h2>
    <p>Como hemos visto, el objeto prototipo es fundamental para la identidad de una clase: dos objetos son instancias de la misma clase si y sólo si heredan del mismo objeto prototipo. La función constructora que inicializa el estado de un nuevo objeto no es fundamental: dos funciones constructoras pueden tener propiedades <codeinline>prototype</codeinline> que el mismo objeto prototipo. Entonces, ambos constructores se pueden utilizar para crear instancias de la misma clase.</p>
    <p>Aunque los constructores no son tan fundamentales como los prototipos, el constructor sirve como la cara pública de una clase. Lo más obvio es que el nombre de la función del constructor suele adoptarse como nombre de la clase. Decimos, por ejemplo, que el constructor <codeinline>Range()</codeinline> crea objetos Range. Pero, fundamentalmente, los constructores se utilizan como operando derecho del operador <codeinline>instanceof</codeinline> cuando se comprueba la pertenencia de los objetos a una clase. Si tenemos un objeto <codeinline>r</codeinline> y queremos saber si es un objeto Range, podemos escribir:</p>
    <pre class="language-js">
    <code class="language-js">r instanceof Range // => true: r hereda de Range.prototype</code></pre>
    <p>El operador <codeinline>instanceof</codeinline> se describió en <a href="capitulo-4#9-4">§4.9.4</a>. El operando izquierdo debe ser el objeto que se está probando, y el operando derecho debe ser una función constructora que nombre una clase. La expresión <codeinline>o instanceof C</codeinline> es <codeinline>true</codeinline> si <codeinline>o</codeinline> hereda de <codeinline>C.prototype</codeinline>. No es necesario que la herencia sea directa: si <codeinline>o</codeinline> hereda de un objeto que a su vez hereda de un objeto que hereda de <codeinline>C.prototype</codeinline>, la expresión seguirá siendo <codeinline>true</codeinline>.</p>
    <p>Técnicamente hablando, en el ejemplo de código anterior, el operador <codeinline>instanceof</codeinline> no está comprobando si <codeinline>r</codeinline> fue realmente inicializado por el constructor <codeinline>Range</codeinline>. En su lugar, está comprobando si <codeinline>r</codeinline> hereda de <codeinline>Range.prototype</codeinline>. Si definimos una función <codeinline>Strange()</codeinline> y establecemos que su prototipo sea el mismo que <codeinline>Range.prototype</codeinline>, entonces los objetos creados con <codeinline>new Strange()</codeinline> contarán como objetos Range en lo que respecta a <codeinline>instanceof</codeinline> (no funcionarán realmente como objetos Range, sin embargo, porque sus propiedades <codeinline>from</codeinline> y <codeinline>to</codeinline> no han sido inicializadas):</p>
    <pre class="language-js">
    <code class="language-js">function Strange() &lbrace;}
    Strange.prototype = Range.prototype;
    new Strange() instanceof Range // => true</code></pre>
    <p>Aunque <codeinline>instanceof</codeinline> no puede verificar realmente el uso de un constructor, sigue utilizando una función constructora como su lado derecho porque los constructores son la identidad pública de una clase.</p>
    <p>Si desea probar la cadena de prototipos de un objeto para un prototipo específico y no desea utilizar la función constructora como intermediaria, puede utilizar el método <codeinline>isPrototypeOf()</codeinline>. En el <a href="#ejemplo9-1">Ejemplo 9-1</a>, por ejemplo, definimos una clase sin función constructora, por lo que no hay forma de utilizar <codeinline>instanceof</codeinline> con esa clase. En su lugar, sin embargo, podríamos comprobar si un objeto <codeinline>r</codeinline> es miembro de esa clase sin constructor con este código:</p>
    <pre class="language-js">
    <code class="language-js">range.methods.isPrototypeOf(r); // range.methods es el objeto prototipo.</code></pre>
  </section>
  <section id="2-2">
    <h2>9.2.2 El constructor Propiedad</h2>
    <p>En el <a href="#ejemplo9-2">Ejemplo 9-2</a>, establecimos <codeinline>Range.prototype</codeinline> en un nuevo objeto que contenía los métodos de nuestra clase. Aunque era conveniente expresar esos métodos como propiedades de un único objeto literal, en realidad no era necesario crear un nuevo objeto. Cualquier función JavaScript normal (excluidas las funciones de flecha, las funciones generadoras y las funciones asíncronas) puede utilizarse como constructor, y las invocaciones de constructores necesitan una propiedad <codeinline>prototype</codeinline>. Por lo tanto, todas las funciones normales de JavaScript<sup>1</sup> tienen automáticamente una propiedad <codeinline>prototype</codeinline>. El valor de esta propiedad es un objeto que tiene una única propiedad <codeinline>constructor</codeinline> no enumerable. El valor de la propiedad <codeinline>constructor</codeinline> es el objeto función:</p>
    <pre class="language-js">
    <code class="language-js">let F = function() &lbrace;}; // Este es un objeto de función.
    let p = F.prototype;    // Este es el objeto prototipo asociado con F.
    let c = p.constructor;  // Esta es la función asociada al prototipo.
    c === F                 // => true: F.prototype.constructor === F para cualquier F</code></pre>
    <p>La existencia de este objeto prototipo predefinido con su propiedad <codeinline>constructor</codeinline> significa que los objetos suelen heredar una propiedad <codeinline>constructor</codeinline> que hace referencia a su con- structor. Dado que los constructores sirven como identidad pública de una clase, esta propiedad constructor da la clase de un objeto:</p>
    <pre class="language-js">
    <code class="language-js">let o = new F(); // Crear un objeto o de clase F
    o.constructor === F // => true: La propiedad del constructor especifica la clase.</code></pre>
    <p>La <a href="#figure9-1">Figura 9-1</a> ilustra esta relación entre la función constructora, su objeto prototipo, la referencia del prototipo al constructor y las instancias creadas con el constructor.</p>
    <figure id="figure9-1" class="flex flex-col items-center">
      <img src="/public/javascript/capitulo-9/figure9-1.png" alt="función constructora">
      <figcaption>Figura 9-1. Una función constructora, su prototipo e instancia</figcaption>
    </figure>
    <p>Observe que la <a href="#figure9-1">Figura 9-1</a> utiliza nuestro constructor <codeinline>Range()</codeinline> como ejemplo. De hecho, sin embargo, la clase Range definida en el <a href="#ejemplo9-2">Ejemplo 9-2</a> sobrescribe el objeto predefinido <codeinline>Range.prototype</codeinline> con un objeto propio. Y el nuevo objeto prototipo que define no tiene una propiedad <codeinline>constructor</codeinline>. Así que las instancias de la clase Range, tal y como están definidas, no tienen una propiedad <codeinline>constructor</codeinline>. Podemos remediar este problema añadiendo explícitamente un constructor al prototipo:</p>
    <pre class="language-js">
    <code class="language-js">Range.prototype = &lbrace;
      constructor: Range, // Establezca explícitamente la referencia anterior del constructor
      
      /* Las definiciones de métodos van aquí */
    };</code></pre>
    <p>Otra técnica común que es probable que veas en código JavaScript antiguo es utilizar el objeto prototipo predefinido con su propiedad <codeinline>constructor</codeinline> y añadirle métodos de uno en uno con código como este:</p>
    <pre class="language-js">
    <code class="language-js">// Amplíe el objeto Range.prototype predefinido para que no lo sobrescribamos
    // la propiedad Range.prototype.constructor creada automáticamente.
    Range.prototype.includes = function(x) &lbrace;
      return this.from &lt;= x && x &lt;= this.to;
    };
    Range.prototype.toString = function() &lbrace;
      return "(" + this.from + "..." + this.to + ")";
    };</code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>9.3 Clases con la clase Palabra clave</h2>
    <p>Las clases han sido parte de JavaScript desde la primera versión del lenguaje, pero en ES6, finalmente obtuvieron su propia sintaxis con la introducción de la palabra clave <codeinline>class</codeinline>. El <a href="#ejemplo9-3">Ejemplo 9-3</a> muestra el aspecto de nuestra clase Range cuando se escribe con esta nueva sintaxis.</p>
    <p><em>Ejemplo 9-3. La clase Range reescrita utilizando la clase</em></p>
    <pre class="language-js">
    <code class="language-js">class Range &lbrace;
      constructor(from, to) &lbrace;
        // Almacene los puntos de inicio y final (estado) de este nuevo objeto de rango.
        // Estas son propiedades no heredadas que son exclusivas de este objeto.
        this.from = from;
        this.to = to;
      }

      // Devuelve verdadero si x está en el rango, falso en caso contrario
      // Este método funciona tanto para rangos textuales y de fechas como para números.
      includes(x) &lbrace; return this.from &lt;= x && x &lt;= this.to; }

      // Una función generadora que hace que las instancias de la clase sean iterables.
      // Tenga en cuenta que solo funciona para rangos numéricos.
      *[Symbol.iterator]() &lbrace;
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
      }

      // Devuelve una representación de cadena del rango
      toString() &lbrace; return `($&lbrace;this.from}...$&lbrace;this.to})`; }
    }
    // A continuación se muestran ejemplos de uso de esta nueva clase Range
    let r = new Range(1,3); // Crear un objeto Range
    r.includes(2)           // => true: 2 está en el rango
    r.toString()            // => "(1...3)"
    [...r]                  // => [1, 2, 3]; convertir a una matriz mediante iterador</code></pre>
    <p>Es importante entender que las clases definidas en los Ejemplos <a href="#ejemplo9-2">9-2</a> y <a href="#ejemplo9-3">9-3</a> funcionan exactamente de la misma manera. La introducción de la palabra clave <codeinline>class</codeinline> en el lenguaje no altera la naturaleza fundamental de las clases basadas en prototipos de JavaScript. Y aunque el <a href="#ejemplo9-3">Ejemplo 9-3</a> utiliza la palabra clave <codeinline>class</codeinline>, el objeto Range resultante es una función constructor, igual que la versión definida en el <a href="#ejemplo9-2">Ejemplo 9-2</a>. La nueva sintaxis de <codeinline>class</codeinline> es limpia y conveniente, pero es mejor considerarla como "azúcar sintáctico" para el mecanismo de definición de clases más fundamental mostrado en el <a href="#ejemplo9-2">Ejemplo 9-2</a>.</p>
    <p>Observe lo siguiente sobre la sintaxis de la clase en el <a href="#ejemplo9-3">Ejemplo 9-3</a>:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La clase se declara con la palabra clave <codeinline>class</codeinline>, que va seguida del nombre de la clase y de un cuerpo de clase entre llaves.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El cuerpo de la clase incluye definiciones de métodos que utilizan la abreviatura de método literal de objeto (que también utilizamos en el <a href="#ejemplo9-1">Ejemplo 9-1</a>), donde se omite la palabra clave <codeinline>function</codeinline>. Sin embargo, a diferencia de los literales de objeto, no se utilizan comas para separar los métodos entre sí. (Aunque los cuerpos de clase son superficialmente similares a los literales de objeto, no son lo mismo. En particular, no admiten la definición de propiedades con pares nombre/valor).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La palabra clave <codeinline>constructor</codeinline> se utiliza para definir la función constructora de la clase. Sin embargo, la función definida no se llama realmente "constructor". La declaración de la <codeinline>class</codeinline> define una nueva variable <codeinline>Range</codeinline> y le asigna el valor de esta función <codeinline>constructor</codeinline> especial.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si su clase no necesita hacer ninguna inicialización, puede omitir la palabra clave constructor y su cuerpo, y una función constructora vacía será implícitamente creada para usted.
        </p>
      </li>
    </ul>
    <p>Si desea definir una clase que subclase -o <em>herede</em>- de otra clase, puede utilizar la palabra clave <codeinline>extends</codeinline> junto con la palabra clave <codeinline>class</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// Un Span es como un Range, pero en lugar de inicializarlo con un inicio y 
    // un final, lo inicializamos con un inicio y una longitud.
    class Span extends Range &lbrace;
      constructor(start, length) &lbrace;
        if (length >= 0) &lbrace;
          super(start, start + length);
        } else &lbrace;
          super(start + length, start);
        }
      }
    }</code></pre>
    <p>La creación de subclases es un tema aparte. Volveremos a tratarlo y explicaremos las palabras clave <codeinline>extends</codeinline> y <codeinline>super</codeinline> que se muestran aquí en <a href="#5">§9.5</a>.</p>
    <p>Al igual que las declaraciones de funciones, las declaraciones de clases tienen forma de declaración y de expresión. Del mismo modo que podemos escribir</p>
    <pre class="language-js">
    <code class="language-js">let square = function(x) &lbrace; return x * x; };
    square(3) // => 9</code></pre>
    <p>también podemos escribir:</p>
    <pre class="language-js">
    <code class="language-js">let Square = class &lbrace; constructor(x) &lbrace; this.area = x * x; } };
    new Square(3).area // => 9</code></pre>
    <p>Al igual que ocurre con las expresiones de definición de funciones, las expresiones de definición de clases pueden incluir un nombre de clase opcional. Si se proporciona dicho nombre, éste sólo se define dentro del propio cuerpo de la clase.</p>
    <p>Aunque las expresiones de función son bastante comunes (sobre todo con la abreviatura arrow func- tion), en la programación JavaScript, las expresiones de definición de clase no son algo que vaya a utilizar mucho, a menos que se encuentre escribiendo una función que tome una clase como argumento y devuelva una subclase.</p>
    <p>Concluiremos esta introducción a la palabra clave <codeinline>class</codeinline> mencionando un par de cosas importantes que deberías saber y que no son evidentes en la sintaxis de <codeinline>class</codeinline>.</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Todo el código dentro del cuerpo de una declaración de <codeinline>class</codeinline> está implícitamente en modo estricto (<a href="capitulo-5#6-3">§5.6.3</a>), incluso si no aparece ninguna directiva <codeinline>"use strict"</codeinline>. Esto significa, por ejemplo, que no puede utilizar literales enteros octales o la sentencia <codeinline>with</codeinline> dentro de los cuerpos de las clases y que es más probable que obtenga errores de sintaxis si olvida declarar una variable antes de utilizarla.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          A diferencia de las declaraciones de funciones, las declaraciones de clases no se “hoisted.” Recordemos que <a href="capitulo-8#1-1">§8.1.1</a> que las definiciones de función se comportan como si se hubieran movido a la parte superior del fichero o función que las encierra, lo que significa que puede invocar una función en el código que viene antes de la definición real de la función. Aunque las declaraciones de clases se parecen a las declaraciones de funciones en algunos aspectos, no comparten este comportamiento de elevación: <em>no se puede</em> instanciar una clase antes de declararla.
        </p>
      </li>
    </ul>
  </section>
  <section id="3-1">
    <h2>9.3.1 Métodos estáticos</h2>
    <p>Puede definir un método estático dentro del cuerpo de una <codeinline>class</codeinline> anteponiendo a la declaración del método la palabra clave static. Los métodos <codeinline>static</codeinline> se definen como propiedades de la función constructora y no como propiedades del objeto prototipo.</p>
    <p>Por ejemplo, supongamos que añadimos el siguiente código al <a href="#ejemplo9-3">Ejemplo 9-3</a>:</p>
    <pre class="language-js">
    <code class="language-js"></code>static parse(s) &lbrace;
      let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);
      if (!matches) &lbrace;
        throw new TypeError(`Cannot parse Range from "$&lbrace;s}".`)
      }
      return new Range(parseInt(matches[1]), parseInt(matches[2]));
    }</pre>
    <p>El método definido por este código es <codeinline>Range.parse()</codeinline>, no <codeinline>Range.prototype.parse()</codeinline>, y debes invocarlo a través del constructor, no a través de una instancia:</p>
    <pre class="language-js">
    <code class="language-js">let r = Range.parse('(1...10)'); // Devuelve un nuevo objeto Range
    r.parse('(1...10)'); // TypeError: r.parse no es una función</code></pre>
    <p>A veces verás métodos estáticos llamados <em>métodos</em> de clase porque son invocados usando el nombre de la clase/constructor. Cuando se utiliza este término, es para contrastar los métodos de clase con los <em>métodos de instancia</em> regulares que se invocan sobre instancias de la clase. Debido a que los métodos estáticos son invocados en el constructor en lugar de en cualquier instancia en particular, casi nunca tiene sentido utilizar la palabra clave this en un método estático.</p>
    <p>Veremos ejemplos de métodos estáticos en el <a href="#ejemplo9-4">Ejemplo 9-4</a>.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>9.3.2 Getters, Setters y otras formas de métodos</h2>
    <p>Dentro del cuerpo de una <codeinline>class</codeinline> se pueden definir métodos getter y setter (<a href="capitulo-6#10-6">§6.10.6</a>) igual que en los literales de objeto. La única diferencia es que en los cuerpos de clase, no se pone una coma después del getter o setter. El <a href="ejemplo9-4">Ejemplo 9-4</a> incluye un ejemplo práctico de un método getter en una clase.</p>
    <p>En general, todas las sintaxis abreviadas de definición de métodos permitidas en los literales de objetos también están permitidas en los cuerpos de las clases. Esto incluye métodos generadores (marcados con <codeinline>*</codeinline>) y métodos cuyos nombres son el valor de una expresión entre corchetes. De hecho, ya has visto (en el <a href="#ejemplo9-3">Ejemplo 9-3</a>) un método generador con un nombre calculado que hace iterable la clase Range:</p>
    <pre class="language-js">
    <code class="language-js">*[Symbol.iterator]() &lbrace;
      for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    }</code></pre>
  </section>
  <section id="3-3">
    <h2>9.3.3 Campos públicos, privados y estáticos</h2>
    <p>En la discusión aquí de clases definidas con la palabra clave <codeinline>class</codeinline>, sólo hemos descrito la definición de métodos dentro del cuerpo de la clase. El estándar ES6 sólo permite la creación de métodos (incluyendo getters, setters y generadores) y métodos estáticos; no incluye sintaxis para definir campos. Si desea definir un campo (que no es más que un sinónimo orientado a objetos de "propiedad") en una instancia de clase, debe hacerlo en la función constructora o en uno de los métodos. Y si desea definir un campo estático para una clase, debe hacerlo fuera del cuerpo de la clase, después de que la clase haya sido definida. El <a href="#ejemplo9-4">Ejemplo 9-4</a> incluye ejemplos de ambos tipos de campos.</p>
    <p>Sin embargo, se está normalizando una sintaxis de clase ampliada que permite definir campos de instancia y estáticos, tanto públicos como privados. El código que se muestra en el resto de esta sección aún no es JavaScript estándar a principios de 2020, pero ya es compatible con Chrome y parcialmente compatible (solo campos de instancia públicos) con Firefox. La sintaxis de los campos de instancia públicos es de uso común entre los programadores de JavaScript que utilizan el framework React y el transpilador Babel.</p>
    <p>Supongamos que estás escribiendo una clase como ésta, con un constructor que inicializa tres campos:</p>
    <pre class="language-js">
    <code class="language-js">class Buffer &lbrace;
      constructor() &lbrace;
        this.size = 0;
        this.capacity = 4096;
        this.buffer = new Uint8Array(this.capacity);
      }
    }</code></pre>
    <p>Con la nueva sintaxis de campo de instancia que probablemente se estandarizará, podría escribir en su lugar:</p>
    <pre class="language-js">
    <code class="language-js">class Buffer &lbrace;
      size = 0;
      capacity = 4096;
      buffer = new Uint8Array(this.capacity);
    }</code></pre>
    <p>Con la nueva sintaxis de campo de instancia que probablemente se estandarizará, podría escribir en su lugar:</p>
    <pre class="language-js">
    <code class="language-js">class Buffer &lbrace;
    #size = 0;
    get size() &lbrace; return this.#size; }
    }</code></pre>
    <p>El código de inicialización del campo se ha movido fuera del constructor y ahora aparece directamente en el cuerpo de la clase. (Por supuesto, ese código se sigue ejecutando como parte del constructor. Si no defines un constructor, los campos se inicializan como parte del constructor implícitamente creado). Los prefijos <codeinline>this.</codeinline> que aparecían en la parte izquierda de las asignaciones han desaparecido, pero tenga en cuenta que todavía debe utilizar <codeinline>this.</codeinline> para referirse a estos campos, incluso en la parte derecha de las asignaciones inicializadoras. La ventaja de inicializar los campos de instancia de esta forma es que esta sintaxis permite (pero no obliga) a poner los inicializadores en la parte superior de la definición de la clase, dejando claro a los lectores exactamente qué campos contendrán el estado de cada instancia. Puede declarar los campos sin un inicializador escribiendo simplemente el nombre del campo seguido de un punto y coma. Si lo haces así, el valor inicial del campo será <codeinline>undefined</codeinline>. Es mejor hacer siempre explícito el valor inicial de todos los campos de la clase.</p>
    <p>Antes de añadir esta sintaxis de campo, los cuerpos de clase se parecían mucho a los literales de objeto que utilizaban la sintaxis abreviada de método, salvo que se habían eliminado las comas. Esta sintaxis de campo -con signos de igual y punto y coma en lugar de dos puntos y comas- deja claro que los cuerpos de clase no son en absoluto lo mismo que los literales de objeto.</p>
    <p>La misma propuesta que pretende estandarizar estos campos de instancia también define los campos de instancia privados. Si utiliza la sintaxis de inicialización de campos de instancia mostrada en el ejemplo anterior para definir un campo cuyo nombre comience por <codeinline>#</codeinline> (que normalmente no es un carácter legal en los identificadores de JavaScript), ese campo se podrá utilizar (con el prefijo <codeinline>#</codeinline>) dentro del cuerpo de la clase, pero será invisible e inaccesible (y, por tanto, inmutable) para cualquier código fuera del cuerpo de la clase. Si, para la clase Buffer hipotética anterior, desea asegurarse de que los usuarios de la clase no puedan modificar inadvertidamente el campo de <codeinline>size</codeinline> de una instancia, podría utilizar un campo <codeinline>#size</codeinline> privado en su lugar y, a continuación, definir una función getter para proporcionar acceso de sólo lectura al valor:</p>
    <pre class="language-js">
    <code class="language-js">class Buffer &lbrace;
      #size = 0;
      get size() &lbrace; return this.#size; }
    }</code></pre>
    <p>Tenga en cuenta que los campos privados deben ser declarados utilizando esta nueva sintaxis de campo antes de que puedan ser utilizados. No se puede escribir <codeinline>this.#size = 0;</codeinline> en el constructor de una clase a menos que se incluya una "declaración" del campo directamente en el cuerpo de la clase.</p>
    <p>Por último, una propuesta relacionada pretende normalizar el uso de la palabra clave <codeinline>static</codeinline> para los campos. Si añades <codeinline>static</codeinline> antes de una declaración de campo público o privado, esos campos se crearán como propiedades de la función constructora en lugar de propiedades de instancias. Considere el método estático <codeinline>Range.parse()</codeinline> que hemos definido. Incluye una expresión regular bastante compleja que podría ser bueno factorizar en su propio campo estático. Con la nueva sintaxis de campo estático propuesta, podríamos hacerlo así:</p>
    <pre class="language-js">
    <code class="language-js">static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;
    static parse(s) &lbrace;
      let matches = s.match(Range.integerRangePattern);
      if (!matches) &lbrace;
        throw new TypeError(`Cannot parse Range from "$&lbrace;s}".`)
      }
      return new Range(parseInt(matches[1]), matches[2]);
    }</code></pre>
    <p>Si quisiéramos que este campo estático fuera accesible sólo dentro de la clase, podríamos hacerlo privado usando un nombre como <codeinline>#pattern</codeinline>.</p>
  </section>
  <section id="3-4" class="py-4 xs:py-5 sm:py-6">
    <h2>9.3.4 Ejemplo: Una clase de números complejos</h2>
    <p>El <a href="#ejemplo9-4">Ejemplo 9-4</a> define una clase para representar números complejos. La clase es relativamente simple, pero incluye métodos de instancia (incluyendo getters), métodos estáticos, campos de instancia y campos estáticos. Incluye algo de código comentado que demuestra cómo podríamos utilizar la sintaxis aún no estándar para definir campos de instancia y campos estáticos dentro del cuerpo de la clase.</p>
    <p><em>Ejemplo 9-4. Complex.js: una clase de números complejos</em></p>
    <pre class="language-js">
    <code class="language-js">
    /**
    * Instances of this Complex class represent complex numbers.
    * Recall that a complex number is the sum of a real number and an
    * imaginary number and that the imaginary number i is the square root of -1.
    */
    class Complex &lbrace;
      // Once class field declarations are standardized, we could declare
      // private fields to hold the real and imaginary parts of a complex number
      // here, with code like this:
      //
      // #r = 0;
      // #i = 0;

      // This constructor function defines the instance fields r and i on every
      // instance it creates. These fields hold the real and imaginary parts of
      // the complex number: they are the state of the object.
      constructor(real, imaginary) &lbrace;
        this.r = real; // This field holds the real part of the number.
        this.i = imaginary; // This field holds the imaginary part.
      }

      // Here are two instance methods for addition and multiplication
      // of complex numbers. If c and d are instances of this class, we
      // might write c.plus(d) or d.times(c)
      plus(that) &lbrace;
        return new Complex(this.r + that.r, this.i + that.i);
      }
      times(that) &lbrace;
        return new Complex(this.r * that.r - this.i * that.i, this.r * that.i + this.i * that.r);
      }

      // And here are static variants of the complex arithmetic methods.
      // We could write Complex.sum(c,d) and Complex.product(c,d)
      static sum(c, d) &lbrace; return c.plus(d); }
      static product(c, d) &lbrace; return c.times(d); }

      // These are some instance methods that are defined as getters
      // so they're used like fields. The real and imaginary getters would
      // be useful if we were using private fields this.#r and this.#i
      get real() &lbrace; return this.r; }
      get imaginary() &lbrace; return this.i; }
      get magnitude() &lbrace; return Math.hypot(this.r, this.i); }

      // Classes should almost always have a toString() method
      toString() &lbrace; return `&lbrace;$&lbrace;this.r},$&lbrace;this.i}}`; }

      // It is often useful to define a method for testing whether
      // two instances of your class represent the same value
      equals(that) &lbrace;
        return that instanceof Complex && this.r === that.r && this.i === that.i;
      }
      // Once static fields are supported inside class bodies, we could
      // define a useful Complex.ZERO constant like this:
      // static ZERO = new Complex(0,0);
    }
    // Here are some class fields that hold useful predefined complex numbers.
    Complex.ZERO = new Complex(0,0);
    Complex.ONE = new Complex(1,0);
    Complex.I = new Complex(0,1);</code></pre>
    <p>Con la clase Complex del <a href="#ejemplo9-4">Ejemplo 9-4</a> definida, podemos utilizar el constructor, los campos de instancia, los métodos de instancia, los campos de clase y los métodos de clase con código como éste:</p>
    <pre class="language-js">
    <code class="language-js">let c = new Complex(2, 3);     // Crear un nuevo objeto con el constructor
    let d = new Complex(c.i, c.r); // Usar campos de instancia de c
    c.plus(d).toString()           // => "&lbrace;5,5}"; usa métodos de instancia
    c.magnitude                    // => Math.hypot(2,3); usa una función getter
    Complex.product(c, d)          // => new Complex(0, 13); un método estático
    Complex.ZERO.toString()        // => "&lbrace;0,0}"; una propiedad estática</code></pre>
  </section>
  <section id="4">
    <h2>9.4 Añadir métodos a clases existentes</h2>
    <p>El mecanismo de herencia basado en prototipos de JavaScript es dinámico: un objeto hereda propiedades de su prototipo, incluso si las propiedades del prototipo cambian después de la creación del objeto. Esto significa que podemos aumentar las clases de JavaScript simplemente añadiendo nuevos métodos a sus objetos prototipo.</p>
    <p>Aquí, por ejemplo, hay código que añade un método para calcular el conjugado complejo a la clase Complex del <a href="#ejemplo9-4">Ejemplo 9-4</a>:</p>
    <pre class="language-js">
    <code class="language-js">// Devuelve un número complejo que es el conjugado complejo de éste.
    Complex.prototype.conj = function() &lbrace; return new Complex(this.r, -this.i); };</code></pre>
    <p>El objeto prototipo de las clases incorporadas de JavaScript también está abierto de esta forma, lo que significa que podemos añadir métodos a números, cadenas, matrices, funciones, etc. Esto es útil para implementar nuevas características del lenguaje en versiones antiguas del mismo:</p>
    <pre class="language-js">
    <code class="language-js">// Si el nuevo método String startsWith() no está ya definido...
    if (!String.prototype.startsWith) &lbrace;
      // ...entonces defínelo así usando el antiguo método indexOf().
      String.prototype.startsWith = function(s) &lbrace;
        return this.indexOf(s) === 0;
      };
    }</code></pre>
    <p>He aquí otro ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// Invoca la función f este número de veces, pasando el número de iteración
    // Por ejemplo, para imprimir "hola" 3 veces:
    // let n = 3;
    // n.times(i => &lbrace; console.log(`hello $&lbrace;i}`); });
    Number.prototype.times = function(f, context) &lbrace;
    let n = this.valueOf();
    for(let i = 0; i &lt; n; i++) f.call(context, i);
    };</code></pre>
    <p>Añadir métodos a los prototipos de los tipos incorporados se considera generalmente una mala idea porque causará confusión y problemas de compatibilidad en el futuro si una nueva versión de JavaScript define un método con el mismo nombre. Incluso es posible añadir métodos a <codeinline>Object.prototype</codeinline>, haciéndolos disponibles para todos los objetos. Pero esto nunca es bueno porque las propiedades añadidas a <codeinline>Object.prototype</codeinline> son visibles para los bucles <codeinline>for/in</codeinline> (aunque puede evitarlo utilizando <codeinline>Object.defineProperty()</codeinline> [<a href="capitulo-14#1">§14.1</a>] para hacer que la nueva propiedad no sea enumerable).</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>9.5 Subclases</h2>
    <p>En programación orientada a objetos, una clase B puede <em>extender</em> o <em>subclasificar</em> a otra clase A. Decimos que A es la <em>superclase</em> y B es la <em>subclase</em>. Las instancias de B heredan los métodos de A. La clase B puede definir sus propios métodos, algunos de los cuales pueden <em>sobreescribir</em> métodos del mismo nombre definidos por la clase A. Si un método de B anula un método de A, el método de anulación en B a menudo tiene que invocar el método anulado en A. Del mismo modo, el constructor de la subclase <codeinline>B()</codeinline> normalmente debe invocar el constructor de la superclase <codeinline>A()</codeinline> con el fin de garantizar que las instancias estén completamente inicializadas.</p>
    <p>Esta sección comienza mostrando cómo definir subclases a la antigua, pre-ES6 manera, y luego pasa rápidamente a demostrar subclasificación utilizando la <codeinline>class</codeinline> y se <codeinline>extends</codeinline> palabras clave y constructor superclase método de invocación con la palabra clave <codeinline>super</codeinline>. A continuación hay una subsección sobre cómo evitar las subclases y confiar en la composición de objetos en lugar de la herencia. La sección termina con un ejemplo extendido que define una jerarquía de clases Set y demuestra cómo se pueden utilizar las clases abstractas para separar la interfaz de la implementación.</p>
  </section>
  <section id="5-1">
    <h2>9.5.1 Subclases y prototipos</h2>
    <p>Supongamos que queremos definir una subclase Span de la clase Range del <a href="#ejemplo9-2">Ejemplo 9-2</a>. Esta subclase funcionará igual que un Range, pero en lugar de inicializarla con un inicio y un final, especificaremos un inicio y una distancia, o span. Una instancia de esta clase Span es también una instancia de la superclase Range. Una instancia de Span hereda un método personalizado <codeinline>toString()</codeinline> de <codeinline>Span.prototype</codeinline>, pero para ser una subclase de Range, también debe heredar métodos (como <codeinline>includes()</codeinline>) de <codeinline>Range.prototype</codeinline>.</p>
    <p><em>Ejemplo 9-5. Span.js: una subclase simple de Range</em></p>
    <pre class="language-js">
    <code class="language-js">// Esta es la función constructora para nuestra subclase
    function Span(start, span) &lbrace;
      if (span >= 0) &lbrace;
        this.from = start;
        this.to = start + span;
      } else &lbrace;
        this.to = start;
        this.from = start + span;
      }
    }

    // Asegúrese de que el prototipo Span hereda del prototipo Range
    Span.prototype = Object.create(Range.prototype);
    
    // No queremos heredar Range.prototype.constructor, así que
    // definir nuestra propia propiedad constructora.
    Span.prototype.constructor = Span;
    
    // Al definir su propio método toString(), Span anula el método
    // toString() que de otro modo heredaría de Range.
    Span.prototype.toString = function() &lbrace;
      return `($&lbrace;this.from}... +$&lbrace;this.to - this.from})`;
    };</code></pre>
    <p>Para que Span sea una subclase de Range, tenemos que hacer que <codeinline>Span.prototype</codeinline> herede de <codeinline>Range.prototype</codeinline>. La línea de código clave en el ejemplo anterior es ésta, y si tiene sentido para ti, entiendes cómo funcionan las subclases en JavaScript:</p>
    <pre class="language-js">
    <code class="language-js">Span.prototype = Object.create(Range.prototype);</code></pre>
    <p>Los objetos creados con el constructor <codeinline>Span()</codeinline> heredarán del objeto <codeinline>Span.prototype</codeinline>. Pero hemos creado ese objeto para que herede de <codeinline>Range.prototype</codeinline>, por lo que los objetos Span heredarán tanto de <codeinline>Span.prototype</codeinline> como de <codeinline>Range.prototype</codeinline>.</p>
    <p>Puede observar que nuestro constructor <codeinline>Span()</codeinline> establece las mismas propiedades <codeinline>from</codeinline> y <codeinline>to</codeinline> que el constructor <codeinline>Range()</codeinline>, por lo que no necesita invocar al constructor <codeinline>Range()</codeinline> para inicializar el nuevo objeto. Del mismo modo, el método <codeinline>toString()</codeinline> de Span reimplementa completamente la conversión de cadenas sin necesidad de llamar a la versión de Range de <codeinline>toString()</codeinline>. Esto convierte a Span en un caso especial, y sólo podemos salirnos con la nuestra con este tipo de subclase porque conocemos los detalles de implementación de la superclase. Un mecanismo de subclasificación robusto necesita permitir a las clases invocar los métodos y el constructor de su superclase, pero antes de ES6, JavaScript no tenía una forma sencilla de hacer estas cosas.</p>
    <p>Afortunadamente, ES6 resuelve estos problemas con la palabra clave <codeinline>super</codeinline> como parte de la <codeinline>class</codeinline> sintaxis. La siguiente sección muestra cómo funciona.</p>
  </section>
  <section id="5-2" class="py-4 xs:py-5 sm:py-6">
    <h2>9.5.2 Subclases con extends y super</h2>
    <p>En ES6 y posteriores, puede crear una superclase simplemente añadiendo una cláusula extends a la declaración de una clase, y puede hacerlo incluso para clases incorporadas:</p>
    <pre class="language-js">
    <code class="language-js">// Una subclase de matriz trivial que agrega captadores para el primer y el último elemento.
    class EZArray extends Array &lbrace;
      get first() &lbrace; return this[0]; }
      get last() &lbrace; return this[this.length-1]; }
    }
    let a = new EZArray();
    a instanceof EZArray  // => true: a es una instancia de subclase
    a instanceof Array    // => true: a también es una instancia de superclase.
    a.push(1,2,3,4);      // a.length == 4; podemos usar métodos heredados
    a.pop()               // => 4: Otro método heredado
    a.first               // => 1: primer captador definido por la subclase
    a.last                // => 3: último captador definido por la subclase
    a[1]                  // => 2: la sintaxis de acceso al array regular todavía funciona.
    Array.isArray(a)      // => true: la instancia de subclase en realidad es un array
    EZArray.isArray(a)    // => true: la subclase también hereda métodos estáticos</code></pre>
    <p>Esta subclase de EZArray define dos métodos getter simples. Las instancias de EZArray se comportan como matrices ordinarias, y podemos utilizar métodos y propiedades heredadas como <codeinline>push()</codeinline>, <codeinline>pop()</codeinline>, y <codeinline>length</codeinline>. Pero también podemos utilizar el <codeinline>first</codeinline> y el <codeinline>last</codeinline> getter definidos en la subclase. No sólo se heredan métodos de instancia como <codeinline>pop()</codeinline>, sino también métodos estáticos como <codeinline>Array.isArray</codeinline>. Esta es una nueva característica habilitada por la sintaxis de clases ES6: <codeinline>EZArray()</codeinline> es una función, pero hereda de <codeinline>Array()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">// EZArray hereda los métodos de instancia porque 
    // EZArray.prototype hereda de Array.prototype
    Array.prototype.isPrototypeOf(EZArray.prototype) // => true
    // Además, EZArray hereda los métodos y propiedades estáticos
    // porque EZArray hereda de Array. Esta es una característica especial
    // de la palabra clave extends y no era posible antes de ES6.
    Array.isPrototypeOf(EZArray)                     // => true</code></pre>
    <p>Nuestra subclase EZArray es demasiado simple para ser muy instructiva. El <a href="#ejemplo9-6">Ejemplo 9-6</a> es un ejemplo más completo. Define una subclase TypedMap de la clase Map incorporada que añade comprobación de tipos para asegurar que las claves y valores del mapa son de los tipos especificados (según <codeinline>typeof</codeinline>). Es importante destacar que este ejemplo demuestra el uso de la palabra clave super para invocar el constructor y los métodos de la superclase.</p>
    <p><em>Ejemplo 9-6. TypedMap.js: una subclase de Map que comprueba los tipos de clave y valor</em></p>
    <pre class="language-js">
    <code class="language-js">class TypedMap extends Map &lbrace;
      constructor(keyType, valueType, entries) &lbrace;
        // Si se especifican entradas, verifique sus tipos
        if (entries) &lbrace;
          for(let [k, v] of entries) &lbrace;
            if (typeof k !== keyType || typeof v !== valueType) &lbrace;
              throw new TypeError(`Wrong type for entry [$&lbrace;k}, $&lbrace;v}]`);
            }
          }
        }

        // Inicializar la superclase con las entradas iniciales (con verificación de tipo)
        super(entries);

        // Y luego inicialice esta subclase almacenando los tipos
        this.keyType = keyType;
        this.valueType = valueType;
      }

      // Ahora redefina el método set() para agregar verificación de 
      // tipo para cualquier entrada nueva agregada al mapa.
      set(key, value) &lbrace;
        // Generar un error si la clave o el valor son del tipo incorrecto
        if (this.keyType && typeof key !== this.keyType) &lbrace;
          throw new TypeError(`$&lbrace;key} is not of type $&lbrace;this.keyType}`);
        }
        if (this.valueType && typeof value !== this.valueType) &lbrace;
          throw new TypeError(`$&lbrace;value} is not of type $&lbrace;this.valueType}`);
        }
        // Si los tipos son correctos, invocamos la versión de la superclase 
        // del método set() para agregar la entrada al mapa y devolvemos 
        // lo que devuelva el método de la superclase.
        return super.set(key, value);
      }
    }</code></pre>
    <p>Los dos primeros argumentos del constructor <codeinline>TypedMap()</codeinline> son los tipos de clave y valor deseados. Deben ser cadenas, como "number" y "boolean", que devuelve el operador <codeinline>typeof</codeinline>. También puede especificar un tercer argumento: una matriz (o cualquier objeto iterable) de matrices <codeinline>[key,value]</codeinline> que especifiquen las entradas iniciales en el mapa. Si especifica alguna entrada inicial, lo primero que hace el constructor es verificar que sus tipos son correctos. A continuación, el constructor invoca al constructor de la superclase, utilizando la palabra clave super como si fuera el nombre de una función. El constructor <codeinline>Map()</codeinline> toma un argumento opcional: un objeto iterable de matrices <codeinline>[key,value]</codeinline>. Así que el tercer argumento opcional del constructor <codeinline>TypedMap()</codeinline> es el primer argumento opcional del constructor <codeinline>Map()</codeinline>, y se lo pasamos al constructor de la superclase con <codeinline>super(entries)</codeinline>.</p>
    <p>Después de invocar al constructor de la superclase para inicializar el estado de la superclase, el constructor de <codeinline>TypedMap()</codeinline> inicializa su propio estado de subclase estableciendo <codeinline>this.keyType</codeinline> y <codeinline>this.valueType</codeinline> a los tipos especificados. Necesita establecer estas propiedades para poder utilizarlas de nuevo en el método <codeinline>set()</codeinline>.</p>
    <p>Hay algunas reglas importantes que necesitas saber sobre el uso de <codeinline>super()</codeinline> en los constructores:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si defines una clase con la palabra clave <codeinline>extends</codeinline>, entonces el constructor de tu clase debe usar <codeinline>super()</codeinline> para invocar al constructor de la superclase.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si no defines un constructor en tu subclase, se definirá uno automáticamente. Este constructor definido implícitamente simplemente toma los valores que se le pasen y los pasa a <codeinline>super()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          No puede utilizar la palabra clave <codeinline>this</codeinline> en su constructor hasta después de haber invocado al constructor de la superclase con <codeinline>super()</codeinline>. Esto impone la regla de que las superclases se inicializan a sí mismas antes que las subclases.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La expresión especial <codeinline>new.target</codeinline> es indefinida en funciones que se invocan sin la palabra clave <codeinline>new</codeinline>. En funciones constructoras, sin embargo, <codeinline>new.target</codeinline> es una referencia al constructor que fue invocado. Cuando un constructor de una subclase es invocado y usa <codeinline>super()</codeinline> para invocar al constructor de la superclase, ese constructor de la superclase verá al constructor de la subclase como el valor de <codeinline>new.target</codeinline>. Una superclase bien diseñada no debería necesitar saber si ha sido subclasificada, pero podría ser útil poder utilizar <codeinline>new.target.name</codeinline> en mensajes de registro, por ejemplo.
        </p>
      </li>
    </ul>
    <p>Después del constructor, la siguiente parte del <a href="#ejemplo9-6">Ejemplo 9-6</a> es un método llamado <codeinline>set()</codeinline>. La superclase Map define un método llamado <codeinline>set()</codeinline> para añadir una nueva entrada al mapa. Decimos que este método <codeinline>set()</codeinline> en TypedMap <em>sobrescribe</em> al método <codeinline>set()</codeinline> de su superclase. Esta simple subclase de TypedMap no sabe nada sobre añadir nuevas entradas al mapa, pero sí sabe cómo comprobar tipos, así que eso es lo que hace primero, verificando que la clave y el valor a añadir al mapa tienen los tipos correctos y lanzando un error si no es así. Este método <codeinline>set()</codeinline> no tiene ninguna forma de añadir la clave y el valor al propio mapa, pero para eso está el método <codeinline>set()</codeinline> de la superclase. Así que usamos la palabra clave <codeinline>super</codeinline> de nuevo para invocar la versión del método de la superclase. En este contexto, super funciona de forma muy parecida a la palabra clave this: se refiere al objeto actual pero permite el acceso a métodos sobrescritos definidos en la superclase.</p>
    <p>En los constructores, es necesario invocar al constructor de la superclase antes de poder acceder a <codeinline>this</codeinline> e inicializar el nuevo objeto uno mismo. No existen estas reglas cuando se sobrescribe un método. Un método que sobrescribe un método de la superclase no está obligado a invocar el método de la superclase. Si utiliza <codeinline>super</codeinline> para invocar el método invocado (o cualquier método) en la superclase, puede hacerlo al principio, en medio o al final del método invocado.</p>
    <p>Por último, antes de dejar atrás el ejemplo de TypedMap, vale la pena señalar que esta clase es una candidata ideal para el uso de campos privados. Tal y como está escrita la clase ahora, un usuario podría cambiar las propiedades <codeinline>keyType</codeinline> o <codeinline>valueType</codeinline> para subvertir la comprobación de tipos.</p>
    <p>Una vez que se admitan los campos privados, podríamos cambiar estas propiedades a <codeinline>#keyType</codeinline> y <codeinline>#valueType</codeinline> para que no puedan ser alterados desde el exterior.</p>
  </section>
  <section id="5-3">
    <h2>9.5.3 Delegación en lugar de herencia</h2>
    <p>La palabra clave <codeinline>extends</codeinline> facilita la creación de subclases. Pero eso no significa que <em>deba</em> crear muchas subclases. Si quiere escribir una clase que comparta el comportamiento de otra clase, puede intentar heredar ese comportamiento creando una subclase. Pero a menudo es más fácil y más flexible obtener ese comportamiento deseado en su clase haciendo que su clase cree una instancia de la otra clase y simplemente delegando en esa instancia según sea necesario. No se crea una nueva clase subclasificando, sino envolviendo o "componiendo" otras clases. Este enfoque de la delegación se denomina a menudo "composición", y es una máxima muy citada de la programación orientada a objetos que uno debe "favorecer la composición sobre la herencia".<sup>2</sup></p>
    <p>Supongamos, por ejemplo, que queremos una clase Histograma que se comporte como la clase Set de JavaScript, excepto que en lugar de llevar la cuenta de si un valor ha sido añadido a set o no, mantiene un recuento del número de veces que el valor ha sido añadido. Dado que la API de esta clase Histograma es similar a Set, podríamos considerar subclasificar Set y añadir un método <codeinline>count()</codeinline>. Por otro lado, una vez que empezamos a pensar en cómo podríamos implementar este método <codeinline>count()</codeinline>, podríamos darnos cuenta de que la clase Histograma es más parecida a Map que a Set porque necesita mantener un mapeo entre valores y el número de veces que han sido añadidos. Así que en lugar de subclasificar Set, podemos crear una clase que defina una API similar a Set pero que implemente esos métodos delegando en un objeto Map interno. El <a href="#ejemplo9-7">Ejemplo 9-7</a> muestra cómo podemos hacer esto.</p>
    <p><em>Ejemplo 9-7. Histogram.js: una clase tipo Set implementada con delegación</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * Una clase similar a un conjunto que lleva un registro de cuántas veces
    * se ha agregado un valor. Llame a add() y remove() como lo haría
    * para un conjunto, y llame a count() para averiguar cuántas veces
    * se ha agregado un valor determinado.
    * El iterador predeterminado genera los valores que se han agregado al
    * menos una vez. Use entries() si desea iterar pares [valor, conteo].
    */
    class Histogram &lbrace;
      // Para inicializar, simplemente creamos un objeto Mapa para delegar.
      constructor() &lbrace; this.map = new Map(); }

      // Para cualquier clave dada, el recuento es el valor en el Mapa, 
      // o cero si la clave no aparece en el Mapa.
      count(key) &lbrace; return this.map.get(key) || 0; }

      // El método similar a Set has() devuelve verdadero si el recuento no es cero
      has(key) &lbrace; return this.count(key) > 0; }

      // El tamaño del histograma es solo el número de entradas en el mapa.
      get size() &lbrace; return this.map.size; }

      // Para agregar una clave, simplemente incremente su conteo en el Mapa.
      add(key) &lbrace; this.map.set(key, this.count(key) + 1); }

      // Eliminar una clave es un poco más complicado porque tenemos 
      // que eliminar la clave del Mapa si el recuento vuelve a cero.
      delete(key) &lbrace;
        let count = this.count(key);
        if (count === 1) &lbrace;
          this.map.delete(key);
        } else if (count > 1) &lbrace;
          this.map.set(key, count - 1);
        }
      }

      // Iterar un histograma solo devuelve las claves almacenadas en él
      [Symbol.iterator]() &lbrace; return this.map.keys(); }

      // Estos otros métodos iteradores simplemente delegan al objeto Mapa
      keys() &lbrace; return this.map.keys(); }
      values() &lbrace; return this.map.values(); }
      entries() &lbrace; return this.map.entries(); }
    }</code></pre>
    <p>Todo lo que hace el constructor <codeinline>Histogram()</codeinline> en el <a href="#ejemplo9-7">Ejemplo 9-7</a> es crear un objeto Map. Y la mayoría de los métodos son de una sola línea que simplemente delegan a un método del mapa, haciendo la implementación bastante simple. Debido a que usamos delegación en lugar de herencia, un objeto Histograma no es una instancia de Set o Map. Pero Histogram implementa una serie de métodos Set de uso común, y en un lenguaje no tipado como JavaScript, que a menudo es lo suficientemente bueno: una relación de herencia formal es a veces agradable, pero a menudo opcional.</p>
  </section>
  <section id="5-4" class="py-4 xs:py-5 sm:py-6">
    <h2>9.5.4 Jerarquías de clases y clases abstractas</h2>
    <p>El <a href="#ejemplo9-6">Ejemplo 9-6</a> muestra cómo podemos subclasificar Map. El <a href="#ejemplo9-7">Ejemplo 9-7</a> demuestra cómo podemos delegar en un objeto Map sin subclasificar nada. Usar clases JavaScript para encapsular datos y modularizar tu código es a menudo una gran técnica, y puedes encontrarte usando la palabra clave <codeinline>class</codeinline> frecuentemente. Pero puedes encontrar que prefieres la composición a la herencia y que raramente necesitas usar <codeinline>extends</codeinline> (excepto cuando estás usando una librería o framework que requiere que extiendas sus clases base).</p>
    <p>Hay algunas circunstancias en las que múltiples niveles de subclase son apropiados, sin embargo, y terminaremos este capítulo con un ejemplo extendido que demuestra una jerarquía de clases que representan diferentes tipos de conjuntos. (Las clases de conjuntos definidas en el <a href="#ejemplo9-8">Ejemplo 9-8</a> son similares, pero no completamente compatibles, con la clase incorporada Set de JavaScript).</p>
    <p>El <a href="#ejemplo9-8">Ejemplo 9-8</a> define muchas subclases, pero también demuestra cómo se pueden definir <em>clases abstractas</em> - clases que no incluyen una implementación completa - para servir como superclase común para un grupo de subclases relacionadas. Una superclase abstracta puede definir una implementación parcial que todas las subclases heredan y comparten. Así, las subclases sólo tienen que definir su propio comportamiento implementando los métodos abstractos definidos (pero no implementados) por la superclase. Tenga en cuenta que JavaScript no tiene ninguna definición formal de métodos abstractos o clases abstractas; simplemente estoy usando ese nombre aquí para los métodos no implementados y las clases incompletamente implementadas.</p>
    <p>El <a href="#ejemplo9-8">Ejemplo 9-8</a> está bien comentado y se sostiene por sí mismo. Le animo a que lo lea como ejemplo final de este capítulo sobre clases. La clase final en el <a href="#ejemplo9-8">Ejemplo 9-8</a> hace mucha manipulación de bits con los operadores <codeinline>&</codeinline>, <codeinline>|</codeinline>, y <codeinline>~</codeinline>, que puedes revisar en <a href="capitulo-4#8-3">§4.8.3</a>.</p>
    <p id="ejemplo9-8"><em>Ejemplo 9-8. Sets.js: una jerarquía de clases de conjuntos abstractos y concretos</em></p>
    <pre class="language-js">
    <code class="language-js">/**
    * La clase AbstractSet define un único método abstracto, has().
    */
    class AbstractSet &lbrace;
      // Lanza un error aquí para que las subclases se vean obligadas
      // a definir su propia versión funcional de este método.
      has(x) &lbrace; throw new Error("Abstract method"); }
    }

    /**
    * NotSet es una subclase concreta de AbstractSet.
    * Los miembros de este conjunto son todos los valores que no son 
    * miembros de otro conjunto. Como está definido en términos de 
    * otro conjunto, no se puede escribir y, como tiene infinitos 
    * miembros, no se puede enumerar.
    * Todo lo que podemos hacer con él es comprobar su pertenencia y 
    * convertirlo en una cadena mediante notación matemática.
    */
    class NotSet extends AbstractSet &lbrace;
      constructor(set) &lbrace;
        super();
        this.set = set;
      }

      // Nuestra implementación del método abstracto que heredamos
      has(x) &lbrace; return !this.set.has(x); }
      // Y también anulamos este método de objeto.
      toString() &lbrace; return `&lbrace; x| x ∉ $&lbrace;this.set.toString()} }`; }
    }

    /**
    * El conjunto de rangos es una subclase concreta de AbstractSet. 
    * Sus miembros son todos los valores que se encuentran entre los 
    * límites de origen y destino, ambos incluidos. Dado que sus 
    * miembros pueden ser números de punto flotante, no es 
    * enumerable y no tiene un tamaño significativo.
    */
    class RangeSet extends AbstractSet &lbrace;
      constructor(from, to) &lbrace;
        super();
        this.from = from;
        this.to = to;
      }

      has(x) &lbrace; return x >= this.from && x &lt;= this.to; }
      toString() &lbrace; return `&lbrace; x| $&lbrace;this.from} ≤ x ≤ $&lbrace;this.to} }`; }
    }

    /*
    * AbstractEnumerableSet es una subclase abstracta de AbstractSet. 
    * Define un captador abstracto que devuelve el tamaño del conjunto 
    * y también define un iterador abstracto. Y luego implementa los 
    * métodos isEmpty(), toString() y equals() concretos sobre estos. 
    * Las subclases que implementan el iterador, el captador de tamaño y 
    * el método has() obtienen estos métodos concretos de forma gratuita.
    */
    class AbstractEnumerableSet extends AbstractSet &lbrace;
      get size() &lbrace; throw new Error("Abstract method"); }
      [Symbol.iterator]() &lbrace; throw new Error("Abstract method"); }

      isEmpty() &lbrace; return this.size === 0; }
      toString() &lbrace; return `&lbrace;$&lbrace;Array.from(this).join(", ")}}`; }
      equals(set) &lbrace;
        // Si el otro conjunto tampoco es Enumerable, no es igual a éste
        if (!(set instanceof AbstractEnumerableSet)) return false;

        // Si no tienen el mismo tamaño, no son iguales.
        if (this.size !== set.size) return false;

        // Recorrer los elementos de este conjunto
        for(let element of this) &lbrace;
          // Si un elemento no está en el otro conjunto, no son iguales
          if (!set.has(element)) return false;
        }

        // Los elementos coinciden, por lo que los conjuntos son iguales.
        return true;
      }
    }
    /*
    * SingletonSet es una subclase concreta de AbstractEnumerableSet.
    * Un conjunto singleton es un conjunto de solo lectura con un solo miembro.
    */
    class SingletonSet extends AbstractEnumerableSet &lbrace;
      constructor(member) &lbrace;
        super();
        this.member = member;
      }

      // Implementamos estos tres métodos y heredamos las implementaciones 
      // de isEmpty, equals() y toString() basadas en estos métodos.
      has(x) &lbrace; return x === this.member; }
      get size() &lbrace; return 1; }
      *[Symbol.iterator]() &lbrace; yield this.member; }
    }

    /*
    * AbstractWritableSet es una subclase abstracta de AbstractEnumerableSet.
    * Define los métodos abstractos insert() y remove() que insertan y eliminan
    * elementos individuales del conjunto y, luego, implementa los métodos add(),
    * subtract() e intersect() concretos sobre ellos. Tenga en cuenta
    * que nuestra API difiere aquí de la clase Set estándar de JavaScript.
    */
    class AbstractWritableSet extends AbstractEnumerableSet &lbrace;
      insert(x) &lbrace; throw new Error("Abstract method"); }
      remove(x) &lbrace; throw new Error("Abstract method"); }

      add(set) &lbrace;
        for(let element of set) &lbrace;
          this.insert(element);
        }
      }

      subtract(set) &lbrace;
        for(let element of set) &lbrace;
          this.remove(element);
        }
      }

      intersect(set) &lbrace;
        for(let element of this) &lbrace;
          if (!set.has(element)) &lbrace;
            this.remove(element);
          }
        }
      }
    }

    /**
    * Un BitSet es una subclase concreta de AbstractWritableSet con
    * una implementación de conjunto de tamaño fijo muy eficiente 
    * para conjuntos cuyos elementos son números enteros no 
    * negativos menores que un tamaño máximo.
    */
    class BitSet extends AbstractWritableSet &lbrace;
      constructor(max) &lbrace;
        super();
        this.max = max; // El entero máximo que podemos almacenar.
        this.n = 0;     // ¿Cuántos números enteros hay en el conjunto?
        this.numBytes = Math.floor(max / 8) + 1;   // ¿Cuántos bytes necesitamos?
        this.data = new Uint8Array(this.numBytes); // Los bytes
      }

      // Método interno para comprobar si un valor es un miembro legal de este conjunto
      _valid(x) &lbrace; return Number.isInteger(x) && x >= 0 && x &lt;= this.max; }

      // Comprueba si el bit especificado del byte especificado de nuestra 
      // matriz de datos está configurado o no. Devuelve verdadero o falso.
      _has(byte, bit) &lbrace; return (this.data[byte] & BitSet.bits[bit]) !== 0; }

      // ¿El valor x está en este BitSet?
      has(x) &lbrace;
        if (this._valid(x)) &lbrace;
          let byte = Math.floor(x / 8);
          let bit = x % 8;
          return this._has(byte, bit);
        } else &lbrace;
          return false;
        }
      }

      // Inserte el valor x en el BitSet
      insert(x) &lbrace;
        if (this._valid(x)) &lbrace;            // Si el valor es válido
          let byte = Math.floor(x / 8);  // convertir a byte y bit
          let bit = x % 8;
          if (!this._has(byte, bit)) &lbrace;           // Si ese bit aún no está configurado
            this.data[byte] |= BitSet.bits[bit]; // Luego configúrelo
            this.n++;                            // y aumentar el tamaño del conjunto
          }
        } else &lbrace;
          throw new TypeError("Invalid set element: " + x );
        }
      }

      remove(x) &lbrace;
        if (this._valid(x)) &lbrace;           // Si el valor es válido
          let byte = Math.floor(x / 8); // Calcular el byte y el bit
          let bit = x % 8;
          if (this._has(byte, bit)) &lbrace;   // Si ese bit ya está configurado
            this.data[byte] &= BitSet.masks[bit]; // then unset it
            this.n--;                             // y disminuir el tamaño
          }
        } else &lbrace;
          throw new TypeError("Invalid set element: " + x );
        }
      }

      // Un captador para devolver el tamaño del conjunto
      get size() &lbrace; return this.n; }

      // Itere el conjunto simplemente comprobando cada bit por turno.
      // (Podríamos ser mucho más inteligentes y optimizar esto sustancialmente)
      *[Symbol.iterator]() &lbrace;
        for(let i = 0; i &lt;= this.max; i++) &lbrace;
          if (this.has(i)) &lbrace;
            yield i;
          }
        }
      }
    }

    // Algunos valores precalculados utilizados por los 
    // métodos has(), insert() y remove()
    BitSet.bits = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
    BitSet.masks = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);</code></pre>
  </section>
  <section id="6" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>9.6 Resumen</h2>
    <p>En este capítulo se han explicado las principales características de las clases de JavaScript:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los objetos que son miembros de la misma clase heredan propiedades del mismo objeto prototipo. El objeto prototipo es la característica clave de las clases de JavaScript, y es posible definir clases con nada más que el método <codeinline>Object.create()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Antes de ES6, las clases se definían más típicamente definiendo primero una función constructora. Las funciones creadas con la palabra clave <codeinline>function</codeinline> tienen una propiedad <codeinline>prototype</codeinline>, y el valor de esta propiedad es un objeto que se utiliza como prototipo de todos los objetos creados cuando la función se invoca con <codeinline>new</codeinline> como constructor. Al inicializar este objeto prototipo, puede definir los métodos compartidos de su clase. Aunque el objeto prototipo es la característica clave de la clase, la función constructora es la identidad pública de la clase.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          ES6 introduce una palabra clave <codeinline>class</codeinline> que facilita la definición de clases, pero bajo el capó, el mecanismo de constructores y prototipos sigue siendo el mismo.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las subclases se definen mediante la palabra clave <codeinline>extends</codeinline> en la declaración de una clase.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las subclases pueden invocar el constructor de su superclase o métodos sobrescritos de su superclase con la palabra clave <codeinline>super</codeinline>.
        </p>
      </li>
    </ul>
  </section>
</Layoutjavascript>