---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";

---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-3" capSiguiente="capitulo-5" />
  <section class="fadeIn">
    <h1>Expresiones y operadores</h1>
    <p>Este capítulo documenta las expresiones de JavaScript y los operadores con los que se construyen muchas de esas expresiones. Una <em>expresión</em> es una frase de JavaScript que puede ser <em>evaluada</em> para producir un valor. Una constante incrustada literalmente en tu programa es un tipo de expresión muy simple. Un nombre de variable es también una expresión simple que se evalúa a cualquier valor que se haya asignado a esa variable. Las expresiones complejas se construyen a partir de expresiones más simples. Una expresión de acceso a array, por ejemplo, consiste en una expresión que evalúa a un array seguida de un corchete cuadrado abierto, una expresión que evalúa a un entero y un corchete cuadrado cerrado. Esta nueva expresión, más compleja, se evalúa al valor almacenado en el índice especificado de la matriz especificada. Del mismo modo, una expresión de invocación de función consiste en una expresión que se evalúa como un objeto de función y cero o más expresiones adicionales que se utilizan como argumentos de la función.</p>
    <p>La forma más habitual de construir una expresión compleja a partir de expresiones más sencillas es mediante un <em>operador</em>. Un operador combina los valores de sus operandos (normalmente dos) de alguna forma y los evalúa a un nuevo valor. El operador de multiplicación <codeinline>*</codeinline> es un ejemplo sencillo. La expresión <codeinline>x * y</codeinline> se evalúa como el producto de los valores de las expresiones <codeinline>x</codeinline> e <codeinline>y</codeinline>. Para simplificar, a veces decimos que un operador <em>devuelve</em> un valor en lugar de "se evalúa como" un valor.</p>
    <p>Este capítulo documenta todos los operadores de JavaScript, y también explica expresiones (como la indexación de matrices y la invocación de funciones) que no utilizan operadores. Si ya conoces otro lenguaje de programación que utilice sintaxis de tipo C, verás que la sintaxis de la mayoría de las expresiones y operadores de JavaScript ya te resulta familiar.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>4.1 Expresiones primarias</h2>
    <p>Las expresiones más sencillas, conocidas como <em>expresiones primarias</em>, son aquellas que son independientes, es decir, que no incluyen expresiones más sencillas. Las expresiones primarias en JavaScript son valores constantes o <em>literales</em>, ciertas palabras clave del lenguaje y referencias a variables.</p>
    <p>Los literales son valores constantes que se incrustan directamente en el programa. Tienen el siguiente aspecto:</p>
    <pre>
    <code class="language-javascript">1.23      // Un literal numérico
    "hello"   // Un literal de string
    /pattern/ // Una expresión regular literal</code></pre>
    <p>La sintaxis de JavaScript para los literales numéricos se trató en <a href="capitulo-3#2">§3.2</a> Los literales de string se documentaron en <a href="capitulo-3#3">§3.3</a>. La sintaxis de literal es de expresiones regulares se introdujo en <a href="capitulo-3#3-5">§3.3.5</a> y se documentará en detalle en <a href="capitulo-11#3">§11.3</a>.</p>
    <p>Algunas de las palabras reservadas de JavaScript son expresiones primarias:</p>
    <pre>
    <code class="language-javascript">true  // Se evalua un valor booleano verdadero
    false // Se evalua un valor booleano falso
    null  // Se evalua a un valor nulo
    this  // Se evalúa el objeto "actual"</code></pre>
    <p>Aprendimos sobre <codeinline>true</codeinline>, <codeinline>false</codeinline> y <codeinline>null</codeinline> en <a href="capitulo-3#4">§3.4</a> y <a href="capitulo-3#5">§3.5</a>. A diferencia de las otras palabras clave, <codeinline>this</codeinline> no es una constante - se evalúa a diferentes valores en diferentes lugares del programa. La palabra clave <codeinline>this</codeinline> se utiliza en programación orientada a objetos. Dentro del cuerpo de un método, <codeinline>this</codeinline> se evalúa como el objeto sobre el que se invoca el método. Véase <a href="#5">§4.5</a>, <a href="capitulo-8">Capítulo 8</a> (especialmente <a href="capitulo-8#2-2">§8.2.2</a>) y <a href="capitulo-9">Capítulo 9</a> para más información sobre <codeinline>this</codeinline>.</p>
    <p>Por último, el tercer tipo de expresión primaria es una referencia a una variable, constante o propiedad del objeto global:</p>
    <pre>
    <code class="language-javascript">i         // Evalua el valor de la variable i.
    sum       // Evalua el valor de la variable sum.
    undefined // El valor de la propiedad "undefined" del objeto global.</code></pre> 
    <p>Cuando un identificador aparece solo en un programa, JavaScript asume que es una variable, constante o propiedad del objeto global y busca su valor. Si no existe ninguna variable con ese nombre, al intentar evaluar una variable inexistente se produce un error ReferenceError.</p>
  </section>
  <section id="2">
    <h2>4.2 Inicializadores de objetos y arrays</h2>
    <p>Los <em>inicializadores de objetos</em> y <em>array</em> son expresiones cuyo valor es un objeto o una matriz recién creados. Estas expresiones inicializadoras se denominan a veces <em>literales de objeto</em> y <em>literales de arrays</em>. Sin embargo, a diferencia de los literales verdaderos, no son expresiones primarias, porque incluyen un número de subexpresiones que especifican valores de propiedades y elementos. Los inicializadores de matrices tienen una sintaxis ligeramente más simple, y comenzaremos con ellos.</p>
    <p>Un inicializador de matriz es una lista de expresiones separadas por comas y contenidas entre corchetes. El valor de un inicializador de matriz es una matriz recién creada. Los elementos de esta nueva matriz se inicializan con los valores de las expresiones separadas por comas:</p>
    <pre>
    <code class="language-javascript">[]        // Un array vacio: Ninguan expresion en los corchetes significa sin elementos.
    [1+2,3+4] // Un array de dos elementos. Primer elemento es 3 y el segundo es 7</code></pre>
    <p>Las expresiones de elemento en un inicializador de matriz pueden ser a su vez inicializadores de matriz, lo que significa que estas expresiones pueden crear matrices anidadas:</p>
    <pre>
    <code class="language-javascript">let matrix = [[1,2,3], [4,5,6], [7,8,9]];</code></pre>
    <p>Las expresiones de elemento en un inicializador de matriz se evalúan cada vez que se evalúa el inicializador de matriz. Esto significa que el valor de la expresión de un inicializador de matriz puede ser diferente cada vez que se evalúa.</p>
    <p>Los elementos no definidos pueden incluirse en un literal de matriz simplemente omitiendo un valor entre comas. Por ejemplo, el siguiente array contiene cinco elementos, entre ellos tres indefinidos:</p>
    <pre>
    <code class="language-javascript">let sparseArray = [1,,,,5];</code></pre>
    <p>Se permite una sola coma después de la última expresión en un inicializador de matriz y no crea un elemento indefinido. Sin embargo, cualquier expresión de acceso al array para un índice posterior al de la última expresión se evaluará necesariamente como indefinido.</p>
    <p>Las expresiones de inicialización de objetos son como las expresiones de inicialización de matrices, pero los corchetes se sustituyen por llaves y cada subexpresión va precedida de un nombre de propiedad y dos puntos:</p>
    <pre>
    <code class="language-javascript">let p = &lbrace; x: 2.3, y: -1.2 }; // Un objeto con dos propiedades
    let q = &lbrace;};                  // Un objeto vacio sin propiedades
    q.x = 2.3; q.y = -1.2;       // Ahora q tiene la misma propiedad que p</code></pre>
    <p>En ES6, los literales de objeto tienen una sintaxis mucho más rica en funciones (encontrará más detalles en (<a href="capitulo-6#10"></a>). Los literales de objeto pueden anidarse. Por ejemplo:</p>
    <pre>
    <code class="language-javascript">let rectangle = &lbrace;
      upperLeft: &lbrace; x: 2, y: 2 },
      lowerRight: &lbrace; x: 4, y: 5 }
    };</code></pre>
    <p>Volveremos a ver inicializadores de objetos y matrices en los capítulos 6 y 7.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>4.3 Definir expresiones de funciones</h2>
    <p>Una <em>definicion de expresion de funciones</em> define una función JavaScript, y el valor dedicha expresión es la función recién definida. En cierto sentido, una expresión de definición de función es un "literal de función" del mismo modo que un inicializador de objeto es un "literal de objeto". Una expresión de definición de función suele estar formada por la palabra clave function seguida de una lista separada por comas de cero o más identificadores (los nombres de los parámetros) en formato paréntesis y un bloque de código JavaScript (el cuerpo de la función) entre llaves. Por ejemplo:</p>
    <pre>
    <code class="language-js">// Esta función retorna el cuadrado del valor pasado.
    let square = function(x) &lbrace; return x * x; };</code></pre>
    <p>Una expresión de definición de función también puede incluir un nombre para la función. Las funciones también pueden definirse utilizando una declaración de función en lugar de una expresión de función. Y en ES6 y posteriores, las expresiones de función pueden utilizar una nueva sintaxis compacta "función de flecha". Los detalles completos sobre la definición de funciones se encuentran en el <a href="capitulo-8">Capítulo 8</a>.</p>
  </section>
  <section id="4">
    <h2>4.4 Expresiones de acceso a la propiedad</h2>
    <p>Una <em>expresión de acceso a propiedades</em> evalúa el valor de una propiedad de objeto o de un elemento de matriz. JavaScript define dos sintaxis para el acceso a propiedades:</p>
    <pre class="language-javascript">
    expression . identifier
    expression [ expression ]</pre>
    <p>El primer estilo de acceso a una propiedad es una expresión seguida de un punto y un identificador. La expresión especifica el objeto, y el identificador especifica el nombre de la propiedad deseada. El segundo estilo de acceso a propiedades sigue a la primera expresión (el objeto o matriz) con otra expresión entre corchetes. Esta segunda expresión especifica el nombre de la propiedad deseada o el índice del elemento de la matriz deseado. He aquí algunos ejemplos concretos:</p>
    <pre>
    <code class="language-javascript">let o = &lbrace;x: 1, y: &lbrace;z: 3}}; // Un ejemplo de objeto
    let a = [o, 4, [5, 6]];    // Un ejemplo de array que contiene el objeto o.
    o.x       // => 1: La propiedad x de la expresión o
    o.y.z     // => 3: La propiedad z de la expresión o.y
    o["x"]    // => 1: La propiedad x del objeto o
    a[1]      // => 4: El elemento en el índice 1 de la expresión a
    a[2]["1"] // => 6: El elemento en el índice 2 de la expresión a[2]
    a[0].x    // => 1: La propiedad x de la expresion a[0]</code></pre>
    <p>Con cualquiera de los dos tipos de expresión de acceso a propiedades, primero se evalúa la expresión anterior a <codeinline>.</codeinline> o <codeinline>[</codeinline>. Si el valor es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, la expresión lanza un TypeError, ya que estos son los dos valores de JavaScript que no pueden tener propiedades. Si la expresión de objeto va seguida de un punto y un identificador, se busca el valor de la propiedad nombrada por ese identificador y se convierte en el valor global de la expresión. Si la expresión del objeto va seguida de otra expresión entre corchetes, esta segunda expresión se evalúa y se convierte en una cadena. El valor global de la expresión es entonces el valor de la propiedad nombrada por esa cadena. En cualquier caso, si la propiedad nombrada no existe, el valor de la expresión de acceso a la propiedad es <em>undefined</em>.</p>
    <p>La sintaxis <em>.identifier</em> es la más sencilla de las dos opciones de acceso a propiedades, pero tenga en cuenta que sólo puede utilizarse cuando la propiedad a la que desea acceder tiene un nombre que es un identificador legal, y cuando conoce el nombre al escribir el programa. Si la propiedad incluye espacios o caracteres de puntuación, o cuando es un número (para matrices), debe utilizar la notación de corchetes. Los corchetes también se utilizan cuando el nombre de la propiedad no es estático, sino que es el resultado de un cálculo (véase un ejemplo en <a href="capitulo-6#3-1">§6.3.1</a>).</p>
    <p>Los objetos y sus propiedades se tratan en detalle en el <a href="capitulo-6">Capitulo 6</a>, y las matrices y sus elementos en el <a href="capitulo-7">Capítulo 7</a>.</p>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.4.1 Acceso condicional a la propiedad</h2>
    <p>ES2020 añade dos nuevos tipos de expresiones de acceso a propiedades:</p>
    <pre class="language-js">
    expression ?. identifier
    expression ?.[ expression ]</pre>
    <p>En JavaScript, los valores <codeinline>null</codeinline> e <codeinline>undefined</codeinline> son los dos únicos valores que no tienen propiedades. En una expresión regular de acceso a propiedades que utilice <codeinline>.</codeinline> o <codeinline>[]</codeinline>, se produce un error de tipo TypeError si la expresión de la izquierda se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Puede utilizar la sintaxis <codeinline>?.</codeinline> y <codeinline>?.[]</codeinline> para evitar errores de este tipo.</p>
    <p>Considere la expresión <codeinline>a?.b</codeinline>. Si a es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces la expresión se evalúa como <codeinline>undefined</codeinline> sin ningún intento de acceder a la propiedad <codeinline>b</codeinline>. Si <codeinline>a</codeinline> es algún otro valor, entonces <codeinline>a?.b</codeinline> se evalúa como <codeinline>a.b</codeinline> (y si <codeinline>a</codeinline> no tiene una propiedad llamada <codeinline>b</codeinline>, entonces el valor volverá a ser <codeinline>undefined</codeinline>).</p>
    <p>Esta forma de expresión de acceso a propiedades a veces se denomina “optional chaining” porque también funciona para expresiones de acceso a propiedades “chained” más largas como ésta:</p>
    <pre>
    <code class="language-js">let a = &lbrace; b: null };
    a.b?.c.d // => undefined</code></pre>
    <p><codeinline>a</codeinline> es un objeto, por lo que <codeinline>a.b</codeinline> es una expresión de acceso a propiedades válida. Pero el valor de <codeinline>a.b</codeinline> es <codeinline>null</codeinline>, por lo que <codeinline>a.b.c</codeinline> lanzaría un TypeError. Usando <codeinline>?.</codeinline> en lugar de <codeinline>.</codeinline> evitamos el error de tipo, y <codeinline>a.b?.c</codeinline> se evalúa como <codeinline>undefined</codeinline>. Esto significa que </codeinline>(a.b?.c).d</codeinline> lanzará un TypeError, porque esa expresión intenta acceder a una propiedad del valor <codeinline>undefined</codeinline>. Pero -y esta es una parte muy importante del "encadenamiento opcional"-<codeinline>a.b?.c.d</codeinline> (sin los paréntesis) simplemente evalúa a <codeinline>undefined</codeinline> y no lanza un error. Esto se debe a que el acceso a propiedades con <codeinline>?.</codeinline> es un "cortocircuito": si la subexpresión a la izquierda de <codeinline>?.</codeinline> se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces toda la expresión se evalúa inmediatamente como <codeinline>undefined</codeinline> sin ningún otro intento de acceso a propiedades.</p>
    <p>Por supuesto, si <codeinline>a.b</codeinline> es un objeto, y si ese objeto no tiene una propiedad llamada <codeinline>c</codeinline>, entonces <codeinline>a.b?.c.d</codeinline> lanzará de nuevo un TypeError, y querremos usar otro acceso condicional a propiedades</p>
    <pre>
    <code class="language-js">let a = &lbrace; b: &lbrace;} };
    a.b?.c?.d // => undefined</code></pre>
    <p>El acceso condicional a propiedades también es posible utilizando <codeinline>?.[]</codeinline> en lugar de <codeinline>[]</codeinline>. En la expresión <codeinline>a?.[b][c]</codeinline>, si el valor de a es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, toda la expresión se evalúa inmediatamente como <codeinline>undefined</codeinline>, y las subexpresiones <codeinline>b</codeinline> y <codeinline>c</codeinline> ni siquiera se evalúan. Si alguna de estas expresiones tiene efectos secundarios, éstos no se producirán si <codeinline>a</codeinline> no está definida:</p>
    <pre>
    <code class="language-js">let a;        // Uy, olvidamos inicializar esta variable
    let index = 0;
    try &lbrace;
      a[index++]; // Lanza TypeError
    } catch(e) &lbrace;
      index       // => 1: el incremento se produce antes de que se lance el error
    }
    a?.[index++]  // => undefined: por que a es undefined
    index // => 1: no se incrementa por que ?.[] corto-circuita
    a[index++]    // !TypeError: no se puede indexar undefined.</code></pre>
    <p>El acceso condicional a propiedades con <codeinline>?.</codeinline> y <codeinline>?.[]</codeinline> es una de las características más recientes de Java- Script. Desde principios de 2020, esta nueva sintaxis es compatible con las versiones actuales o beta de la mayoría de los principales navegadores.</p>
  </section>
  <section id="5">
    <h2>4.5 Expresiones de invocación</h2>
    <p>Una <em>expresión de invocación</em> es la sintaxis de JavaScript para llamar (o ejecutar) una función o método. Comienza con una expresión de función que identifica la función a llamar. La expresión de función va seguida de un paréntesis de apertura, una lista separada por comas de cero o más expresiones de argumento y un paréntesis de cierre. Algunos ejemplos:</p>
    <pre>
    <code class="language-js">f(0)             // f es la función; 0 es el argumento.
    Math.max(x,y,z)  // Math.max es la funcion: x, y y z son los argumentos.
    a.sort()         // a.sort es la función y no toma argumentos.</code></pre>
    <p>Cuando se evalúa una expresión de invocación, primero se evalúa la expresión de la función y, a continuación, se evalúan las expresiones de los argumentos para obtener una lista de valores de los argumentos. Si el valor de la expresión de función no es una función, se lanza un TypeError. A continuación, los valores de los argumentos se asignan, en orden, a los nombres de los parámetros especificados al definir la función y, por último, se ejecuta el cuerpo de la función. Si la función utiliza una sentencia <codeinline>return</codeinline> para devolver un valor, entonces ese valor se convierte en el valor de la expresión de invocación. En caso contrario, el valor de la expresión de invocación es <codeinline>undefined</codeinline>. Los detalles completos sobre la invocación de funciones, incluida una explicación de lo que ocurre cuando el número de expresiones de argumento no coincide con el número de parámetros en la definición de la función, se encuentran en el <a href="capitulo-8">Capítulo 8</a>.</p>
    <p>Cada expresión de invocación incluye un par de paréntesis y una expresión antes del paréntesis abierto. Si esa expresión es una expresión de acceso a una propiedad, entonces la invocación se conoce como <em>invocación a un método</em>. En las invocaciones a métodos, el objeto o array objeto del acceso a la propiedad se convierte en el valor de la palabra clave <codeinline>this</codeinline> mientrasque se ejecuta el cuerpo de la función. Esto permite un paradigma de programación orientada a objetos en el que las funciones (que llamamos "métodos" cuando se utilizan de esta manera) operan sobre el objeto del que forman parte. Para más detalles, véase el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="5-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.5.1 Invocación condicional</h2>
    <p>En ES2020, también puede invocar una función utilizando <codeinline>?.()</codeinline> en lugar de <codeinline>()</codeinline>. Normalmente, cuando se invoca una función, si la expresión a la izquierda de los paréntesis es <codeinline>null</codeinline> o no <codeinline>undefined</codeinline> o cualquier otra no-función, se lanza un TypeError. Con la nueva sintaxis de invocación <codeinline>?.()</codeinline>, si la expresión a la izquierda del <codeinline>?.</codeinline> se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, toda la expresión de invocación se evalúa como <codeinline>undefined</codeinline> y no se lanza ninguna excepción.</p>
    <p>Los objetos array tienen un método <codeinline>sort()</codeinline> al que opcionalmente se le puede pasar un argumento de función que defina el orden de clasificación deseado para los elementos del array. Antes de ES2020, si querías escribir un método como <codeinline>sort()</codeinline> que toma un argumento de función opcional, normalmente usabas una sentencia <codeinline>if</codeinline> para comprobar que el argumento de función estaba definido antes de invocarlo en el cuerpo del <codeinline>if</codeinline>:</p>
    <pre>
    <code class="language-js">function square(x, log) &lbrace; // El segundo argumento es opcional
      if (log) &lbrace;              // Si pasa la función opcional
        log(x);               // Invoca la función
      }
      return x * x;           // Devuelve el cuadrado del argumento
    }</code></pre>
    <p>Con esta sintaxis de invocación condicional de ES2020, sin embargo, puedes simplemente escribir la invocación de la función usando <codeinline>?.()</codeinline>, sabiendo que la invocación sólo ocurrirá si realmente hay un valor que invocar:</p>
    <pre>
    <code class="language-js">function square(x, log) &lbrace; // El segundo argumento es opcional
      log?.(x);               // Llama a la función si log es definido
      return x * x;           // Retorna el cuadrado del argumento
    }</code></pre>
    <p>Tenga en cuenta, sin embargo, que <codeinline>?.()</codeinline> sólo comprueba si el lado izquierdo es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. No comprueba que el valor sea realmente una función. Por tanto, la función <codeinline>square()</codeinline> de este ejemplo lanzaría una excepción si se le pasaran dos números, por ejemplo.</p>
    <p>Al igual que las expresiones de acceso condicional a propiedades (<a href="#4-1">§4.4.1</a>) la invocación de funciones con <codeinline>?.()</codeinline> es un cortocircuito: si el valor a la izquierda de <codeinline>?.</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, no se evalúa ninguna de las expresiones de argumento dentro de los paréntesis:</p>
    <pre>
    <code class="language-js">let f = null, x = 0;
    try &lbrace;
    f(x++);       // Lanza TypeError porque f es null
    } catch(e) &lbrace;
    x             // => 0: el incremento se produce antes de que se lance el error
    }
    f?.(x++)      // => undefined: f es null, pero no se lanza ninguna excepción
    x             // => 1: se salta el incremento porque corto-circuita</code></pre>
    <p>Las expresiones de invocación condicional con <codeinline>?.()</codeinline> funcionan tanto para métodos como para funciones. Pero como la invocación de métodos también implica el acceso a propiedades, merece la pena dedicar un momento a entender las diferencias entre las siguientes expresiones:</p>
    <pre>
    <code class="language-js">o.m()   // Acceso regular a la propiedad, invocación regular
    o?.m()  // Acceso condicional a la propiedad, invocación regular
    o.m?.() // Acceso regular a la propiedad, invocación condicional</code></pre>
    <p>En la primera expresión, o debe ser un objeto con una propiedad <codeinline>m</codeinline> y el valor de esa propiedad debe ser una función. En la segunda expresión, si <codeinline>o</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces la expresión se evalúa como <codeinline>undefined</codeinline>. Pero si <codeinline>o</codeinline> tiene cualquier otro valor, entonces debe tener una propiedad <codeinline>m</codeinline> cuyo valor sea una función. Y en la tercera expresión, <codeinline>o</codeinline> no debe ser <codeinline>null</codeinline> ni <codeinline>undefined</codeinline>. Si no tiene una propiedad <codeinline>m</codeinline>, o si el valor de esa propiedad es <codeinline>null</codeinline>, entonces toda la expresión se evalúa como <codeinline>undefined</codeinline>.</p>
    <p>La invocación condicional con <codeinline>?.()</codeinline> es una de las características más recientes de JavaScript. Desde los primeros meses de 2020, esta nueva sintaxis es compatible con las versiones actuales o beta de la mayoría de los principales navegadores.</p>
  </section>
  <section id="6">
    <h2>4.6 Expresiones de creación de objetos</h2>
    <p>Una <em>expresión de creación de objeto</em> crea un nuevo objeto e invoca una función (denominada constructor) para inicializar las propiedades de dicho objeto. Las expresiones de creación de objetos son como las expresiones de invocación, salvo que van precedidas de la palabra clave <codeinline>new</codeinline>:</p>
    <pre>
    <code class="language-js">new Object()
    new Point(2,3)</code></pre>
    <p>Si no se pasan argumentos a la función constructora en una expresión de creación de objeto, se puede omitir el par de paréntesis vacío:</p>
    <pre>
    <code class="language-js">new Object
    new Date</code></pre>
    <p>El valor de una expresión de creación de objeto es el objeto recién creado. Los constructores se explican con más detalle en el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7 Visión general del operador</h2>
    <p>Los operadores se utilizan para las expresiones aritméticas, las expresiones de comparación, las expresiones lógicas y las expresiones de asignación de JavaScript, entre otras. La <a href="#tabla4-1">Tabla 4-1</a> resume los operadores y sirve como referencia práctica.</p>
    <p>Tenga en cuenta que la mayoría de los operadores se representan mediante caracteres de puntuación, como <codeinline>+</codeinline> y <codeinline>=</codeinline>. Algunos, sin embargo, se representan mediante palabras clave, como <codeinline>delete</codeinline> e <codeinline>instanceof</codeinline>. Los operadores de palabras clave son operadores regulares, al igual que los expresados con signos de puntuación; simplemente tienen una sintaxis menos sucinta.</p>
    <p>La <a href="#tabla4-1">Tabla 4-1</a> está organizada por precedencia de operadores. Los operadores listados en primer lugar tienen mayor precedencia que los listados en último lugar. Los operadores separados por una línea horizontal tienen niveles de precedencia diferentes. La columna A indica la asociatividad del operador, que puede ser L (de izquierda a derecha) o R (de derecha a izquierda), y la columna N especifica el número de operandos. La columna Tipos indica los tipos esperados de los operandos y (después del símbolo →) el tipo de resultado del operador. Las subsecciones que siguen a la tabla explican los conceptos de precedencia, asociatividad y tipo de operando. Los propios operandos se documentan individualmente a continuación.</p>
    <div id="tabla4-1" class="flex flex-col items-center">
      <p><em>Tabla 4-1. Operadores de JavaScript</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg text-center">Operador</td>
            <td class="max-w-72 pl-4">Operanción</td>
            <td class="max-w-lg pl-4">A</td>
            <td class="max-w-lg pl-4">N</td>
            <td class="max-w-lg px-4">Tipos</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">++</codeinline></td>
              <td class="max-w-72 pl-4">Aumento previo o posterior</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">--</codeinline></td>
              <td class="max-w-72 pl-4">Decrecimiento previo o posterior</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → num</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">-</codeinline></td>
              <td class="max-w-72 pl-4">Negar número</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">num → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">+</codeinline></td>
              <td class="max-w-72 pl-4">Convertir a número</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → num</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">~</codeinline></td>
              <td class="max-w-72 pl-4">Invertir bits</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!</codeinline></td>
              <td class="max-w-72 pl-4">Invertir valores booleanos</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">bool → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">delete</codeinline></td>
              <td class="max-w-72 pl-4">Eliminar una propiedad</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">typeof</codeinline></td>
              <td class="max-w-72 pl-4">Determinar el tipo de un valor</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → str</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">void</codeinline></td>
              <td class="max-w-72 pl-4">Devolver una valor indefinido</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → undef</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">**</codeinline></td>
              <td class="max-w-72 pl-4">Potencia</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">*</codeinline>, <codeinline class="md:text-base bg-transparent">/</codeinline>, <codeinline class="md:text-base bg-transparent">%</codeinline></td>
              <td class="max-w-72 pl-4">Multiplicaión, división y resto</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">**</codeinline>, <codeinline class="md:text-base bg-transparent">**</codeinline></td>
              <td class="max-w-72 pl-4">Suma, resta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">+</codeinline></td>
              <td class="max-w-72 pl-4">Concatenar strings</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">str, str → str</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;&lt;</codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la izquierda</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">>></codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la derecha con signo extendido</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">>>></codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la derecha con extensión cero</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;</codeinline>, <codeinline class="md:text-base bg-transparent">&lt;=</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;=</codeinline></td>
              <td class="max-w-72 pl-4">Comparar por orden numérico</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;</codeinline>, <codeinline class="md:text-base bg-transparent">&lt;=</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;=</codeinline></td>
              <td class="max-w-72 pl-4">Comparar por orden alfabético</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">str, str → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">instanceof</codeinline></td>
              <td class="max-w-72 pl-4">Clase de objeto de prueba</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">obj, func → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">in</codeinline></td>
              <td class="max-w-72 pl-4">Comprobar si la propiedad existe</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, obj → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">==</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de igualdad no estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!=</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de desigualdad no estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">===</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de igualdad estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!==</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de desigualdad estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits &</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">^</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits XOR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">|</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits OR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&&</codeinline></td>
              <td class="max-w-72 pl-4">Computa valores logicos AND</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">||</codeinline></td>
              <td class="max-w-72 pl-4">Computa valores logicos OR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">??</codeinline></td>
              <td class="max-w-72 pl-4">Escoge el primer operando definido</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">?:</codeinline></td>
              <td class="max-w-72 pl-4">Escoge el segundo o el tercero operando</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">3</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">=</codeinline></td>
              <td class="max-w-72 pl-4">Asigna el valor a una variable o propiedad</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-40 pl-4">
                <codeinline class="md:text-base bg-transparent">**=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">*=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">/=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">%=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">-=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">&=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">^=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">|=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">&lt;&lt;=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">>>=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">>>>=</codeinline>, 
              </td>
              <td class="max-w-72 pl-4">Operar y asignar</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4">
                <codeinline class="md:text-base bg-transparent">,</codeinline>
              </td>
              <td class="max-w-72 pl-4">Descarta el primer operando, devuelve el segundo</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
        </tbody>
      </table>
    </div>
  </section>
  <section id="7-1">
    <h2>4.7.1 Número de operandos</h2>
    <p>Los operadores pueden clasificarse en función del número de operandos que esperan (su <em>aridad</em>). La mayoría de los operadores de JavaScript, como el operador de multiplicación <codeinline>*</codeinline>, son <em>operadores binarios</em> que combinan dos expresiones en una única expresión más compleja. Es decir, esperan dos operandos. JavaScript también admite una serie de <em>operadores unarios</em>, que convierten una expresión simple en una única expresión más compleja. El operador <codeinline>-</codeinline> en la expresión <codeinline>-x</codeinline> es un operador unario que realiza la operación de negación en el operando <codeinline>x</codeinline>. Por último, JavaScript admite un <em>operador ternario</em>, el operador condicional <codeinline>?:</codeinline>, que combina tres expresiones en una sola.</p>
  </section>
  <section id="7-2" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.2 Tipo de operando y resultado</h2>
    <p>Algunos operadores funcionan con valores de cualquier tipo, pero la mayoría esperan que sus operandos sean de un tipo específico, y la mayoría de los operadores devuelven (o evalúan a) un valor de un tipo específico. La columna Tipos de la <a href="#tabla4-1">Tabla 4-1</a> especifica los tipos de operando (antes de la flecha) y el tipo de resultado (después de la flecha) para los operadores.</p>
    <p>Los operadores de JavaScript suelen convertir el tipo (véase <a href="capitulo-3#9">§3.9</a>) de sus operandos según sea necesario. El operador de multiplicación <codeinline>*</codeinline> espera operandos numéricos, pero la expresión <codeinline>"3" * "5"</codeinline> es legal porque JavaScript puede convertir los operandos a números. El valor de esta expresión es el número 15, no la cadena "15", por supuesto. Recuerde también que todos los valores de JavaScript son "verdaderos" o "falsos", por lo que los operadores que esperan operandos booleanos funcionarán con un operando de cualquier tipo.</p>
    <p>Algunos operadores se comportan de forma diferente en función del tipo de los operandos utilizados con ellos. En particular, el operador <codeinline>+</codeinline> suma operandos numéricos pero concatena operandos de cadena. Del mismo modo, los operadores de comparación como <codeinline>&lt;</codeinline> realizan la comparación en orden numérico o alfabético en función del tipo de los operandos. Las descripciones de los operadores individuales explican sus dependencias de tipo y especifican qué conversiones de tipo realizan.
    </p>
    <p>Observa que los operadores de asignación y algunos de los otros operadores listados en la <a href="#tabla4-1">Tabla 4-1</a> esperan un operando de tipo <codeinline>lvalue</codeinline>. <em>lvalue</em> es un término histórico que significa "una expresión que puede aparecer legalmente en el lado izquierdo de una expresión de asignación". En JavaScript, las variables, las propiedades de los objetos y los elementos de las matrices son lvalues.</p>
  </section>
  <section id="7-3">
    <h2>4.7.3 Efectos secundarios del operador</h2>
    <p>Evaluar una expresión simple como <codeinline>2 * 3</codeinline> nunca afecta al estado de tu programa, y cualquier cálculo futuro que realice tu programa no se verá afectado por esa evaluación. Sin embargo, algunas expresiones tienen <em>efectos secundarios</em> y su evaluación puede afectar al resultado de futuras evaluaciones. Los operadores de asignación son el ejemplo más obvio: si asigna un valor a una variable o propiedad, cambia el valor de cualquier expresión que utilice esa variable o propiedad. Los operadores de incremento y decremento <codeinline>++</codeinline> y <codeinline>--</codeinline> son similares, ya que realizan una asignación implícita. El operador <codeinline>delete</codeinline> también tiene efectos secundarios: borrar una propiedad es como (pero no lo mismo que) asignar <codeinline>undefined</codeinline> a la propiedad.</p>
    <p>Ningún otro operador de JavaScript tiene efectos secundarios, pero las expresiones de invocación de funciones y creación de objetos tendrán efectos secundarios si alguno de los operadores utilizados en el cuerpo de la función o del constructor tiene efectos secundarios.</p>
  </section>
  <section id="7-4" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.4  Precedencia del operador</h2>
    <p>Los operadores listados en la <a href="#tabla4-1">Tabla 4-1</a> están ordenados de mayor a menor precedencia, con líneas horizontales separando grupos de operadores en el mismo nivel de precedencia. La precedencia de los operadores controla el orden en que se realizan las operaciones. Los operadores con mayor precedencia (más cerca de la parte superior de la tabla) se ejecutan antes que los de menor precedencia (más cerca de la parte inferior).</p>
    <p>Considera la siguiente expresión:</p>
    <pre>
    <code class="language-js">w = x + y*z;</code></pre>
    <p>El operador de multiplicación <codeinline>*</codeinline> tiene mayor precedencia que el operador de suma <codeinline>+</codeinline>, por lo que la multiplicación se realiza antes que la suma. Por otra parte, el operador de asignación <codeinline>=</codeinline> tiene la precedencia más baja, por lo que la asignación se realiza una vez completadas todas las operaciones del lado derecho.</p>
    <p>La precedencia de los operadores puede anularse mediante el uso explícito de paréntesis. Para forzar que la suma del ejemplo anterior se realice primero, escriba:</p>
    <pre>
    <code class="language-js">w = (x + y)*z;</code></pre>
    <p>Tenga en cuenta que las expresiones de acceso e invocación de propiedades tienen mayor precedencia que cualquiera de los operadores listados en la <a href="#tabla4-1">Tabla 4-1</a>. Considere esta expresión:</p>
    <pre>
    <code class="language-js">// my es un objeto con una propiedad llamada funciones cuyo valor es 
    // una matriz de funciones. Invocamos la función número x, le pasamos el argumento y 
    // y luego pedimos el tipo del valor devuelto.
    typeof my.functions[x](y)</code></pre>
    <p>Aunque <codeinline>typeof</codeinline> es uno de los operadores de mayor prioridad, la operación <codeinline>typeof</codeinline> se forma sobre el resultado del acceso a la propiedad, el índice del array y la invocación a la función, todos los cuales tienen mayor prioridad que los operadores.</p>
    <p>En la práctica, si no está seguro de la precedencia de los operadores, lo más sencillo es utilizar paréntesis para explicitar el orden de evaluación. Las reglas que es importante conocer son las siguientes: la multiplicación y la división se realizan antes que la suma y la resta, y la asignación tiene una precedencia muy baja y casi siempre se realiza en último lugar.</p>
    <p>Cuando se añaden nuevos operadores a JavaScript, no siempre encajan de forma natural en este esquema de precedencia. El operador <codeinline>??</codeinline> ( <a href="#13-2">§4.13.2</a>) se muestra en la tabla como de menor precedencia que <codeinline>||</codeinline> y <codeinline>&&</codeinline>, pero, de hecho, su precedencia relativa a esos operadores no está definida, y ES2020 requiere que use explícitamente paréntesis si mezcla <codeinline>&&</codeinline> con <codeinline>||</codeinline> o <codeinline>&&</codeinline>. De manera similar, el nuevo operador de exponenciación <codeinline>**</codeinline> no tiene una precedencia bien definida con respecto al operador de negación unario, y debe usar paréntesis cuando combine negación con exponenciación.</p>
  </section>
  <section id="7-5">
    <h2>4.7.5 Asociatividad de operadores</h2>
    <p>En la <a href="tabla4-1">Tabla 4-1</a> la columna A especifica la <em>asociatividad</em> del operador. Un valor de L especifica la asociatividad de izquierda a derecha, y un valor de R especifica la asociatividad de derecha a izquierda. La asociatividad de un operador especifica el orden en que se realizan las operaciones de la misma precedencia. La asociatividad de izquierda a derecha significa que las operaciones se realizan de izquierda a derecha. Por ejemplo, el operador de resta tiene asociatividad de izquierda a derecha, así:</p>
    <pre>
    <code class="language-js">w = x - y - z;</code></pre>
    <p>es lo mismo que:</p>
    <pre>
    <code class="language-js">w = ((x - y) - z);</code></pre>
    <p>Por otra parte, las siguientes expresiones:</p>
    <pre>
    <code class="language-js">y = a ** b ** c;
    x = ~-y;
    w = x = y = z;
    q = a?b:c?d:e?f:g;</code></pre>
    <p>son equivalentes:</p>
    <pre>
    <code class="language-js">y = (a ** (b ** c));
    x = ~(-y);
    w = (x = (y = z));
    q = a?b:(c?d:(e?f:g));</code></pre>
    <p>porque los operadores de exponenciación, unario, asignación y condicional ternario tienen asociatividad de derecha a izquierda.</p>
  </section>
  <section id="7-6" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.6 Orden de evaluación</h2>
    <p>La precedencia de operadores y la asociatividad especifican el orden en que se realizan las operaciones en una expresión compleja, pero no especifican el orden en que se evalúan las subexpresiones. JavaScript siempre evalúa las expresiones en un orden estrictamente de izquierda a derecha. En la expresión <codeinline>w = x + y * z</codeinline>, por ejemplo, la subexpresión <codeinline>w</codeinline> se evalúa en primer lugar, seguida de <codeinline>x</codeinline>, <codeinline>y</codeinline> y <codeinline>z</codeinline>. A continuación, los valores de <codeinline>y</codeinline> y <codeinline>z</codeinline> se multiplican, se suman al valor de <codeinline>x</codeinline> y se asignan a la variable o propiedad especificada por la expresión <codeinline>w</codeinline>. La adición de paréntesis a las expresiones puede cambiar el orden relativo de la multiplicación, la suma y la asignación, pero no el orden de evaluación de izquierda a derecha.</p>
    <p>El orden de evaluación sólo tiene importancia si alguna de las expresiones evaluadas tiene efectos secundarios que afectan al valor de otra expresión. Si la expresión <codeinline>x</codeinline> incrementa una variable que es utilizada por la expresión <codeinline>z</codeinline>, entonces el hecho de que <codeinline>x</codeinline> se evalúe antes que <codeinline>z</codeinline> es importante.</p>
  </section>
  <section id="8">
    <h2>4.8 Expresiones aritméticas</h2>
    <p>Esta sección trata de los operadores que realizan operaciones aritméticas u otras manipulaciones numéricas en sus operandos. Los operadores de exponenciación, multiplicación, división y sustracción son sencillos y se tratan en primer lugar. El operador de suma recibe una subsección propia porque también puede realizar la concatenación de cadenas y tiene algunas reglas de conversión de tipos inusuales. Los operadores unarios y los operadores bit a bit también se tratan en subsecciones propias.</p>
    <p>La mayoría de estos operadores aritméticos (excepto los que se indican a continuación) pueden utilizarse con operandos BigInt (véase <a href="capitulo-3#2-5">§3.2.5</a> ) o con números normales, siempre que no se mezclen los dos tipos.</p>
    <p>Los operadores aritméticos básicos son <codeinline>**</codeinline> (exponenciación), <codeinline>*</codeinline> (multiplicación), <codeinline>/</codeinline> (división), <codeinline>%</codeinline> (módulo: resto después de la división), <codeinline>+</codeinline> (suma) y <codeinline>-</codeinline> (resta). Como se ha indicado, hablaremos del operador <codeinline>+</codeinline> en una sección aparte. Los otros cinco operadores básicos simplemente evalúan sus operandos, convierten los valores en números si es necesario y, a continuación, calculan la potencia, el producto, el cociente, el resto o la diferencia. No numérico los operandos que no pueden convertirse en números se convierten en el valor <codeinline>NaN</codeinline>. Si cualquiera de los operandos es (o se convierte en) <codeinline>NaN</codeinline>, el resultado de la operación es (casi siempre) <codeinline>NaN</codeinline>.</p>
    <p>El operador <codeinline>**</codeinline> tiene mayor precedencia que <codeinline>*</codeinline>, <codeinline>/</codeinline> y <codeinline>%</codeinline> (que a su vez tienen mayor precedencia que <codeinline>+</codeinline> y <codeinline>-</codeinline>). A diferencia de los otros operadores, <codeinline>**</codeinline> funciona de derecha a izquierda, por lo que <codeinline>2**2**3</codeinline> es lo mismo que <codeinline>2**8</codeinline>, no que <codeinline>4**3</codeinline>. Existe una ambigüedad natural en expresiones como <codeinline>-3**2</codeinline>. Dependiendo de la precedencia relativa del signo menos unario y de la exponenciación, esa expresión podría significar <codeinline>(-3)**2</codeinline> o <codeinline>--(3**2)</codeinline>. Los distintos lenguajes manejan esto de forma diferente, y en lugar de tomar partido, JavaScript simplemente convierte en un error sintáctico omitir los paréntesis en este caso, obligándole a escribir una expresión inequívoca. <codeinline>**</codeinline> es el operador aritmético más reciente de JavaScript: se añadió al lenguaje con ES2016. Sin embargo, la función <codeinline>Math.pow()</codeinline> ha estado disponible desde las primeras versiones de JavaScript y realiza exactamente la misma operación que el operador <codeinline>**</codeinline>.</p>
    <p>El operador <codeinline>/</codeinline> divide el primer operando por el segundo. Si está acostumbrado a lenguajes de programación que distinguen entre números enteros y de coma flotante, es posible que espere obtener un resultado entero al dividir un número entero por otro. En JavaScript, sin embargo, todos los números son de coma flotante, por lo que todas las operaciones de división tienen resultados de coma flotante: <codeinline>5/2</codeinline> equivale a <codeinline>2.5</codeinline>, no a <codeinline>2</codeinline>. La división por cero produce infinitos positivos o negativos, mientras que <codeinline>0/0</codeinline> se evalúacomo <codeinline>NaN</codeinline>: en ninguno de estos casos se produce un error.</p>
    <p>El operador <codeinline>%</codeinline> calcula el primer operando módulo el segundo operando. En otras palabras, devuelve el resto de la división entera del primer operando por el segundo operando. El signo del resultado es el mismo que el del primer operando. Por ejemplo, <codeinline>5 % 2</codeinline> se evalúacomo <codeinline>1</codeinline>, y <codeinline>-5 % 2</codeinline> se evalúa como <codeinline>-1</codeinline>.</p>
    <p>Aunque el operador módulo se utiliza normalmente con operandos enteros, también funciona con valores de coma flotante. Por ejemplo, <codeinline>6.5 % 2.1</codeinline> equivale a <codeinline>0.2</codeinline>.</p>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.8.1 Operador de +</h2>
    <p>El operador binario <codeinline>+</codeinline> suma operandos numéricos o concatena operandos de cadena:</p>
    <pre>
    <code class="language-js">1 + 2                   // => 3
    "hello" + " " + "there" // => "hello there"
    "1" + "2"               // => "12"</code></pre>
    <p>Cuando los valores de ambos operandos son números, o ambos son cadenas, entonces es obvio lo que hace el operador <codeinline>+</codeinline>. En cualquier otro caso, sin embargo, es necesaria la conversión de tipos, y la operación a realizar depende de la conversión efectuada. Las reglas de conversión de <codeinline>+</codeinline> dan prioridad a la concatenación de cadenas: si uno de los operandos es una cadena o un objeto que se convierte en cadena, el otro operando se convierte en cadena y se realiza la concatenación. La suma sólo se realiza si ninguno de los dos operandos es una cadena.</p>
    <p>Técnicamente, el operador <codeinline>+</codeinline> se comporta así:</p>
    <ul>
      <li class="font-normal">Si alguno de los valores de su operando es un objeto, lo convierte en una primitiva mediante el algoritmo de conversión de objetos a primitivas descrito en <a href="capitulo-3#9-3">§3.9.3</a> Los objetos Date se convierten mediante su método <codeinline>toString()</codeinline>, y todos los demás objetos se convierten mediante <codeinline>valueOf()</codeinline>, si dicho método devuelve un valor primitivo. Sin embargo, la mayoría de los objetos no tienen un método <codeinline>valueOf()</codeinline> utilizable, por lo que también se convierten mediante <codeinline>toString()</codeinline>.</li>
      <li class="font-normal">Tras la conversión de objeto a primitivo, si alguno de los operandos es una cadena, el otro se convierte en cadena y se realiza la concatenación.</li>
      <li class="font-normal">En caso contrario, ambos operandos se convierten en números (o en <codeinline>NaN</codeinline> y se realiza la suma.</li>
    </ul>
    <p>He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">1 + 2         // => 3: suma
    "1" + "2"     // => "12": concatenación
    "1" + 2       // => "12": concatenación después numérico-a-string
    1 + &lbrace;} // => "1[object Object]": concatenación después objeto-a-string
    true + true   // => 2: suma después booleano-a-numérico
    2 + null      // => 2: suma después null a cero
    2 + undefined // => NaN: suma despues undefined se convierte a NaN</code></pre>
    <p>Por último, es importante tener en cuenta que cuando el operador <codeinline>+</codeinline> se utiliza con cadenas y números, puede no ser asociativo. Es decir, el resultado puede depender del orden en que se realicen las operaciones.</p>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js">1 + 2 + " blind mice"   // => "3 blind mice"
    1 + (2 + " blind mice") // => "12 blind mice"</code></pre>
    <p>La primera línea no tiene paréntesis, y el operador <codeinline>+</codeinline> tiene asociatividad de izquierda a derecha, por lo que los dos números se suman primero, y su suma se concatena con la cadena. En la segunda línea, los paréntesis alteran este orden de operaciones: el número 2 se concatena con la cadena para producir una nueva cadena. A continuación, el número 1 se concatena con la nueva cadena para obtener el resultado final.</p>
  </section>
</Layoutjavascript>