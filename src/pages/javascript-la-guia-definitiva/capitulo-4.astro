---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";

---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-3" capSiguiente="capitulo-5" />
  <section class="fadeIn">
    <h1>Expresiones y operadores</h1>
    <p>Este capítulo documenta las expresiones de JavaScript y los operadores con los que se construyen muchas de esas expresiones. Una <em>expresión</em> es una frase de JavaScript que puede ser <em>evaluada</em> para producir un valor. Una constante incrustada literalmente en tu programa es un tipo de expresión muy simple. Un nombre de variable es también una expresión simple que se evalúa a cualquier valor que se haya asignado a esa variable. Las expresiones complejas se construyen a partir de expresiones más simples. Una expresión de acceso a array, por ejemplo, consiste en una expresión que evalúa a un array seguida de un corchete cuadrado abierto, una expresión que evalúa a un entero y un corchete cuadrado cerrado. Esta nueva expresión, más compleja, se evalúa al valor almacenado en el índice especificado de la matriz especificada. Del mismo modo, una expresión de invocación de función consiste en una expresión que se evalúa como un objeto de función y cero o más expresiones adicionales que se utilizan como argumentos de la función.</p>
    <p>La forma más habitual de construir una expresión compleja a partir de expresiones más sencillas es mediante un <em>operador</em>. Un operador combina los valores de sus operandos (normalmente dos) de alguna forma y los evalúa a un nuevo valor. El operador de multiplicación <codeinline>*</codeinline> es un ejemplo sencillo. La expresión <codeinline>x * y</codeinline> se evalúa como el producto de los valores de las expresiones <codeinline>x</codeinline> e <codeinline>y</codeinline>. Para simplificar, a veces decimos que un operador <em>devuelve</em> un valor en lugar de "se evalúa como" un valor.</p>
    <p>Este capítulo documenta todos los operadores de JavaScript, y también explica expresiones (como la indexación de matrices y la invocación de funciones) que no utilizan operadores. Si ya conoces otro lenguaje de programación que utilice sintaxis de tipo C, verás que la sintaxis de la mayoría de las expresiones y operadores de JavaScript ya te resulta familiar.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>4.1 Expresiones primarias</h2>
    <p>Las expresiones más sencillas, conocidas como <em>expresiones primarias</em>, son aquellas que son independientes, es decir, que no incluyen expresiones más sencillas. Las expresiones primarias en JavaScript son valores constantes o <em>literales</em>, ciertas palabras clave del lenguaje y referencias a variables.</p>
    <p>Los literales son valores constantes que se incrustan directamente en el programa. Tienen el siguiente aspecto:</p>
    <pre>
    <code class="language-javascript">1.23      // Un literal numérico
    "hello"   // Un literal de string
    /pattern/ // Una expresión regular literal</code></pre>
    <p>La sintaxis de JavaScript para los literales numéricos se trató en <a href="capitulo-3#2">§3.2</a> Los literales de string se documentaron en <a href="capitulo-3#3">§3.3</a>. La sintaxis de literal es de expresiones regulares se introdujo en <a href="capitulo-3#3-5">§3.3.5</a> y se documentará en detalle en <a href="capitulo-11#3">§11.3</a>.</p>
    <p>Algunas de las palabras reservadas de JavaScript son expresiones primarias:</p>
    <pre>
    <code class="language-javascript">true  // Se evalua un valor booleano verdadero
    false // Se evalua un valor booleano falso
    null  // Se evalua a un valor nulo
    this  // Se evalúa el objeto "actual"</code></pre>
    <p>Aprendimos sobre <codeinline>true</codeinline>, <codeinline>false</codeinline> y <codeinline>null</codeinline> en <a href="capitulo-3#4">§3.4</a> y <a href="capitulo-3#5">§3.5</a>. A diferencia de las otras palabras clave, <codeinline>this</codeinline> no es una constante - se evalúa a diferentes valores en diferentes lugares del programa. La palabra clave <codeinline>this</codeinline> se utiliza en programación orientada a objetos. Dentro del cuerpo de un método, <codeinline>this</codeinline> se evalúa como el objeto sobre el que se invoca el método. Véase <a href="#5">§4.5</a>, <a href="capitulo-8">Capítulo 8</a> (especialmente <a href="capitulo-8#2-2">§8.2.2</a>) y <a href="capitulo-9">Capítulo 9</a> para más información sobre <codeinline>this</codeinline>.</p>
    <p>Por último, el tercer tipo de expresión primaria es una referencia a una variable, constante o propiedad del objeto global:</p>
    <pre>
    <code class="language-javascript">i         // Evalua el valor de la variable i.
    sum       // Evalua el valor de la variable sum.
    undefined // El valor de la propiedad "undefined" del objeto global.</code></pre> 
    <p>Cuando un identificador aparece solo en un programa, JavaScript asume que es una variable, constante o propiedad del objeto global y busca su valor. Si no existe ninguna variable con ese nombre, al intentar evaluar una variable inexistente se produce un error ReferenceError.</p>
  </section>
  <section id="2">
    <h2>4.2 Inicializadores de objetos y arrays</h2>
    <p>Los <em>inicializadores de objetos</em> y <em>array</em> son expresiones cuyo valor es un objeto o una matriz recién creados. Estas expresiones inicializadoras se denominan a veces <em>literales de objeto</em> y <em>literales de arrays</em>. Sin embargo, a diferencia de los literales verdaderos, no son expresiones primarias, porque incluyen un número de subexpresiones que especifican valores de propiedades y elementos. Los inicializadores de matrices tienen una sintaxis ligeramente más simple, y comenzaremos con ellos.</p>
    <p>Un inicializador de matriz es una lista de expresiones separadas por comas y contenidas entre corchetes. El valor de un inicializador de matriz es una matriz recién creada. Los elementos de esta nueva matriz se inicializan con los valores de las expresiones separadas por comas:</p>
    <pre>
    <code class="language-javascript">[]        // Un array vacio: Ninguan expresion en los corchetes significa sin elementos.
    [1+2,3+4] // Un array de dos elementos. Primer elemento es 3 y el segundo es 7</code></pre>
    <p>Las expresiones de elemento en un inicializador de matriz pueden ser a su vez inicializadores de matriz, lo que significa que estas expresiones pueden crear matrices anidadas:</p>
    <pre>
    <code class="language-javascript">let matrix = [[1,2,3], [4,5,6], [7,8,9]];</code></pre>
    <p>Las expresiones de elemento en un inicializador de matriz se evalúan cada vez que se evalúa el inicializador de matriz. Esto significa que el valor de la expresión de un inicializador de matriz puede ser diferente cada vez que se evalúa.</p>
    <p>Los elementos no definidos pueden incluirse en un literal de matriz simplemente omitiendo un valor entre comas. Por ejemplo, el siguiente array contiene cinco elementos, entre ellos tres indefinidos:</p>
    <pre>
    <code class="language-javascript">let sparseArray = [1,,,,5];</code></pre>
    <p>Se permite una sola coma después de la última expresión en un inicializador de matriz y no crea un elemento indefinido. Sin embargo, cualquier expresión de acceso al array para un índice posterior al de la última expresión se evaluará necesariamente como indefinido.</p>
    <p>Las expresiones de inicialización de objetos son como las expresiones de inicialización de matrices, pero los corchetes se sustituyen por llaves y cada subexpresión va precedida de un nombre de propiedad y dos puntos:</p>
    <pre>
    <code class="language-javascript">let p = &lbrace; x: 2.3, y: -1.2 }; // Un objeto con dos propiedades
    let q = &lbrace;};                  // Un objeto vacio sin propiedades
    q.x = 2.3; q.y = -1.2;       // Ahora q tiene la misma propiedad que p</code></pre>
    <p>En ES6, los literales de objeto tienen una sintaxis mucho más rica en funciones (encontrará más detalles en (<a href="capitulo-6#10"></a>). Los literales de objeto pueden anidarse. Por ejemplo:</p>
    <pre>
    <code class="language-javascript">let rectangle = &lbrace;
      upperLeft: &lbrace; x: 2, y: 2 },
      lowerRight: &lbrace; x: 4, y: 5 }
    };</code></pre>
    <p>Volveremos a ver inicializadores de objetos y matrices en los capítulos 6 y 7.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>4.3 Definir expresiones de funciones</h2>
    <p>Una <em>definicion de expresion de funciones</em> define una función JavaScript, y el valor dedicha expresión es la función recién definida. En cierto sentido, una expresión de definición de función es un "literal de función" del mismo modo que un inicializador de objeto es un "literal de objeto". Una expresión de definición de función suele estar formada por la palabra clave function seguida de una lista separada por comas de cero o más identificadores (los nombres de los parámetros) en formato paréntesis y un bloque de código JavaScript (el cuerpo de la función) entre llaves. Por ejemplo:</p>
    <pre>
    <code class="language-js">// Esta función retorna el cuadrado del valor pasado.
    let square = function(x) &lbrace; return x * x; };</code></pre>
    <p>Una expresión de definición de función también puede incluir un nombre para la función. Las funciones también pueden definirse utilizando una declaración de función en lugar de una expresión de función. Y en ES6 y posteriores, las expresiones de función pueden utilizar una nueva sintaxis compacta "función de flecha". Los detalles completos sobre la definición de funciones se encuentran en el <a href="capitulo-8">Capítulo 8</a>.</p>
  </section>
  <section id="4">
    <h2>4.4 Expresiones de acceso a la propiedad</h2>
    <p>Una <em>expresión de acceso a propiedades</em> evalúa el valor de una propiedad de objeto o de un elemento de matriz. JavaScript define dos sintaxis para el acceso a propiedades:</p>
    <pre class="language-javascript">
    expression . identifier
    expression [ expression ]</pre>
    <p>El primer estilo de acceso a una propiedad es una expresión seguida de un punto y un identificador. La expresión especifica el objeto, y el identificador especifica el nombre de la propiedad deseada. El segundo estilo de acceso a propiedades sigue a la primera expresión (el objeto o matriz) con otra expresión entre corchetes. Esta segunda expresión especifica el nombre de la propiedad deseada o el índice del elemento de la matriz deseado. He aquí algunos ejemplos concretos:</p>
    <pre>
    <code class="language-javascript">let o = &lbrace;x: 1, y: &lbrace;z: 3}}; // Un ejemplo de objeto
    let a = [o, 4, [5, 6]];    // Un ejemplo de array que contiene el objeto o.
    o.x       // => 1: La propiedad x de la expresión o
    o.y.z     // => 3: La propiedad z de la expresión o.y
    o["x"]    // => 1: La propiedad x del objeto o
    a[1]      // => 4: El elemento en el índice 1 de la expresión a
    a[2]["1"] // => 6: El elemento en el índice 2 de la expresión a[2]
    a[0].x    // => 1: La propiedad x de la expresion a[0]</code></pre>
    <p>Con cualquiera de los dos tipos de expresión de acceso a propiedades, primero se evalúa la expresión anterior a <codeinline>.</codeinline> o <codeinline>[</codeinline>. Si el valor es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, la expresión lanza un TypeError, ya que estos son los dos valores de JavaScript que no pueden tener propiedades. Si la expresión de objeto va seguida de un punto y un identificador, se busca el valor de la propiedad nombrada por ese identificador y se convierte en el valor global de la expresión. Si la expresión del objeto va seguida de otra expresión entre corchetes, esta segunda expresión se evalúa y se convierte en una cadena. El valor global de la expresión es entonces el valor de la propiedad nombrada por esa cadena. En cualquier caso, si la propiedad nombrada no existe, el valor de la expresión de acceso a la propiedad es <em>undefined</em>.</p>
    <p>La sintaxis <em>.identifier</em> es la más sencilla de las dos opciones de acceso a propiedades, pero tenga en cuenta que sólo puede utilizarse cuando la propiedad a la que desea acceder tiene un nombre que es un identificador legal, y cuando conoce el nombre al escribir el programa. Si la propiedad incluye espacios o caracteres de puntuación, o cuando es un número (para matrices), debe utilizar la notación de corchetes. Los corchetes también se utilizan cuando el nombre de la propiedad no es estático, sino que es el resultado de un cálculo (véase un ejemplo en <a href="capitulo-6#3-1">§6.3.1</a>).</p>
    <p>Los objetos y sus propiedades se tratan en detalle en el <a href="capitulo-6">Capitulo 6</a>, y las matrices y sus elementos en el <a href="capitulo-7">Capítulo 7</a>.</p>
  </section>
  <section id="4-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.4.1 Acceso condicional a la propiedad</h2>
    <p>ES2020 añade dos nuevos tipos de expresiones de acceso a propiedades:</p>
    <pre class="language-js">
    expression ?. identifier
    expression ?.[ expression ]</pre>
    <p>En JavaScript, los valores <codeinline>null</codeinline> e <codeinline>undefined</codeinline> son los dos únicos valores que no tienen propiedades. En una expresión regular de acceso a propiedades que utilice <codeinline>.</codeinline> o <codeinline>[]</codeinline>, se produce un error de tipo TypeError si la expresión de la izquierda se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Puede utilizar la sintaxis <codeinline>?.</codeinline> y <codeinline>?.[]</codeinline> para evitar errores de este tipo.</p>
    <p>Considere la expresión <codeinline>a?.b</codeinline>. Si a es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces la expresión se evalúa como <codeinline>undefined</codeinline> sin ningún intento de acceder a la propiedad <codeinline>b</codeinline>. Si <codeinline>a</codeinline> es algún otro valor, entonces <codeinline>a?.b</codeinline> se evalúa como <codeinline>a.b</codeinline> (y si <codeinline>a</codeinline> no tiene una propiedad llamada <codeinline>b</codeinline>, entonces el valor volverá a ser <codeinline>undefined</codeinline>).</p>
    <p>Esta forma de expresión de acceso a propiedades a veces se denomina “optional chaining” porque también funciona para expresiones de acceso a propiedades “chained” más largas como ésta:</p>
    <pre>
    <code class="language-js">let a = &lbrace; b: null };
    a.b?.c.d      // => undefined</code></pre>
    <p><codeinline>a</codeinline> es un objeto, por lo que <codeinline>a.b</codeinline> es una expresión de acceso a propiedades válida. Pero el valor de <codeinline>a.b</codeinline> es <codeinline>null</codeinline>, por lo que <codeinline>a.b.c</codeinline> lanzaría un TypeError. Usando <codeinline>?.</codeinline> en lugar de <codeinline>.</codeinline> evitamos el error de tipo, y <codeinline>a.b?.c</codeinline> se evalúa como <codeinline>undefined</codeinline>. Esto significa que </codeinline>(a.b?.c).d</codeinline> lanzará un TypeError, porque esa expresión intenta acceder a una propiedad del valor <codeinline>undefined</codeinline>. Pero -y esta es una parte muy importante del "encadenamiento opcional"-<codeinline>a.b?.c.d</codeinline> (sin los paréntesis) simplemente evalúa a <codeinline>undefined</codeinline> y no lanza un error. Esto se debe a que el acceso a propiedades con <codeinline>?.</codeinline> es un "cortocircuito": si la subexpresión a la izquierda de <codeinline>?.</codeinline> se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces toda la expresión se evalúa inmediatamente como <codeinline>undefined</codeinline> sin ningún otro intento de acceso a propiedades.</p>
    <p>Por supuesto, si <codeinline>a.b</codeinline> es un objeto, y si ese objeto no tiene una propiedad llamada <codeinline>c</codeinline>, entonces <codeinline>a.b?.c.d</codeinline> lanzará de nuevo un TypeError, y querremos usar otro acceso condicional a propiedades</p>
    <pre>
    <code class="language-js">let a = &lbrace; b: &lbrace;} };
    a.b?.c?.d     // => undefined</code></pre>
    <p>El acceso condicional a propiedades también es posible utilizando <codeinline>?.[]</codeinline> en lugar de <codeinline>[]</codeinline>. En la expresión <codeinline>a?.[b][c]</codeinline>, si el valor de a es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, toda la expresión se evalúa inmediatamente como <codeinline>undefined</codeinline>, y las subexpresiones <codeinline>b</codeinline> y <codeinline>c</codeinline> ni siquiera se evalúan. Si alguna de estas expresiones tiene efectos secundarios, éstos no se producirán si <codeinline>a</codeinline> no está definida:</p>
    <pre>
    <code class="language-js">let a;        // Uy, olvidamos inicializar esta variable
    let index = 0;
    try &lbrace;
      a[index++]; // Lanza TypeError
    } catch(e) &lbrace;
      index       // => 1: el incremento se produce antes de que se lance el error
    }
    a?.[index++]  // => undefined: por que a es undefined
    index         // => 1: no se incrementa por que ?.[] corto-circuita
    a[index++]    // !TypeError: no se puede indexar undefined.</code></pre>
    <p>El acceso condicional a propiedades con <codeinline>?.</codeinline> y <codeinline>?.[]</codeinline> es una de las características más recientes de Java- Script. Desde principios de 2020, esta nueva sintaxis es compatible con las versiones actuales o beta de la mayoría de los principales navegadores.</p>
  </section>
  <section id="5">
    <h2>4.5 Expresiones de invocación</h2>
    <p>Una <em>expresión de invocación</em> es la sintaxis de JavaScript para llamar (o ejecutar) una función o método. Comienza con una expresión de función que identifica la función a llamar. La expresión de función va seguida de un paréntesis de apertura, una lista separada por comas de cero o más expresiones de argumento y un paréntesis de cierre. Algunos ejemplos:</p>
    <pre>
    <code class="language-js">f(0)             // f es la función; 0 es el argumento.
    Math.max(x,y,z)  // Math.max es la funcion: x, y y z son los argumentos.
    a.sort()         // a.sort es la función y no toma argumentos.</code></pre>
    <p>Cuando se evalúa una expresión de invocación, primero se evalúa la expresión de la función y, a continuación, se evalúan las expresiones de los argumentos para obtener una lista de valores de los argumentos. Si el valor de la expresión de función no es una función, se lanza un TypeError. A continuación, los valores de los argumentos se asignan, en orden, a los nombres de los parámetros especificados al definir la función y, por último, se ejecuta el cuerpo de la función. Si la función utiliza una sentencia <codeinline>return</codeinline> para devolver un valor, entonces ese valor se convierte en el valor de la expresión de invocación. En caso contrario, el valor de la expresión de invocación es <codeinline>undefined</codeinline>. Los detalles completos sobre la invocación de funciones, incluida una explicación de lo que ocurre cuando el número de expresiones de argumento no coincide con el número de parámetros en la definición de la función, se encuentran en el <a href="capitulo-8">Capítulo 8</a>.</p>
    <p>Cada expresión de invocación incluye un par de paréntesis y una expresión antes del paréntesis abierto. Si esa expresión es una expresión de acceso a una propiedad, entonces la invocación se conoce como <em>invocación a un método</em>. En las invocaciones a métodos, el objeto o array objeto del acceso a la propiedad se convierte en el valor de la palabra clave <codeinline>this</codeinline> mientrasque se ejecuta el cuerpo de la función. Esto permite un paradigma de programación orientada a objetos en el que las funciones (que llamamos "métodos" cuando se utilizan de esta manera) operan sobre el objeto del que forman parte. Para más detalles, véase el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="5-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.5.1 Invocación condicional</h2>
    <p>En ES2020, también puede invocar una función utilizando <codeinline>?.()</codeinline> en lugar de <codeinline>()</codeinline>. Normalmente, cuando se invoca una función, si la expresión a la izquierda de los paréntesis es <codeinline>null</codeinline> o no <codeinline>undefined</codeinline> o cualquier otra no-función, se lanza un TypeError. Con la nueva sintaxis de invocación <codeinline>?.()</codeinline>, si la expresión a la izquierda del <codeinline>?.</codeinline> se evalúa como <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, toda la expresión de invocación se evalúa como <codeinline>undefined</codeinline> y no se lanza ninguna excepción.</p>
    <p>Los objetos array tienen un método <codeinline>sort()</codeinline> al que opcionalmente se le puede pasar un argumento de función que defina el orden de clasificación deseado para los elementos del array. Antes de ES2020, si querías escribir un método como <codeinline>sort()</codeinline> que toma un argumento de función opcional, normalmente usabas una sentencia <codeinline>if</codeinline> para comprobar que el argumento de función estaba definido antes de invocarlo en el cuerpo del <codeinline>if</codeinline>:</p>
    <pre>
    <code class="language-js">function square(x, log) &lbrace; // El segundo argumento es opcional
      if (log) &lbrace;              // Si pasa la función opcional
        log(x);               // Invoca la función
      }
      return x * x;           // Devuelve el cuadrado del argumento
    }</code></pre>
    <p>Con esta sintaxis de invocación condicional de ES2020, sin embargo, puedes simplemente escribir la invocación de la función usando <codeinline>?.()</codeinline>, sabiendo que la invocación sólo ocurrirá si realmente hay un valor que invocar:</p>
    <pre>
    <code class="language-js">function square(x, log) &lbrace; // El segundo argumento es opcional
      log?.(x);               // Llama a la función si log es definido
      return x * x;           // Retorna el cuadrado del argumento
    }</code></pre>
    <p>Tenga en cuenta, sin embargo, que <codeinline>?.()</codeinline> sólo comprueba si el lado izquierdo es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. No comprueba que el valor sea realmente una función. Por tanto, la función <codeinline>square()</codeinline> de este ejemplo lanzaría una excepción si se le pasaran dos números, por ejemplo.</p>
    <p>Al igual que las expresiones de acceso condicional a propiedades (<a href="#4-1">§4.4.1</a>) la invocación de funciones con <codeinline>?.()</codeinline> es un cortocircuito: si el valor a la izquierda de <codeinline>?.</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, no se evalúa ninguna de las expresiones de argumento dentro de los paréntesis:</p>
    <pre>
    <code class="language-js">let f = null, x = 0;
    try &lbrace;
    f(x++);       // Lanza TypeError porque f es null
    } catch(e) &lbrace;
    x             // => 0: el incremento se produce antes de que se lance el error
    }
    f?.(x++)      // => undefined: f es null, pero no se lanza ninguna excepción
    x             // => 1: se salta el incremento porque corto-circuita</code></pre>
    <p>Las expresiones de invocación condicional con <codeinline>?.()</codeinline> funcionan tanto para métodos como para funciones. Pero como la invocación de métodos también implica el acceso a propiedades, merece la pena dedicar un momento a entender las diferencias entre las siguientes expresiones:</p>
    <pre>
    <code class="language-js">o.m()   // Acceso regular a la propiedad, invocación regular
    o?.m()  // Acceso condicional a la propiedad, invocación regular
    o.m?.() // Acceso regular a la propiedad, invocación condicional</code></pre>
    <p>En la primera expresión, o debe ser un objeto con una propiedad <codeinline>m</codeinline> y el valor de esa propiedad debe ser una función. En la segunda expresión, si <codeinline>o</codeinline> es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, entonces la expresión se evalúa como <codeinline>undefined</codeinline>. Pero si <codeinline>o</codeinline> tiene cualquier otro valor, entonces debe tener una propiedad <codeinline>m</codeinline> cuyo valor sea una función. Y en la tercera expresión, <codeinline>o</codeinline> no debe ser <codeinline>null</codeinline> ni <codeinline>undefined</codeinline>. Si no tiene una propiedad <codeinline>m</codeinline>, o si el valor de esa propiedad es <codeinline>null</codeinline>, entonces toda la expresión se evalúa como <codeinline>undefined</codeinline>.</p>
    <p>La invocación condicional con <codeinline>?.()</codeinline> es una de las características más recientes de JavaScript. Desde los primeros meses de 2020, esta nueva sintaxis es compatible con las versiones actuales o beta de la mayoría de los principales navegadores.</p>
  </section>
  <section id="6">
    <h2>4.6 Expresiones de creación de objetos</h2>
    <p>Una <em>expresión de creación de objeto</em> crea un nuevo objeto e invoca una función (denominada constructor) para inicializar las propiedades de dicho objeto. Las expresiones de creación de objetos son como las expresiones de invocación, salvo que van precedidas de la palabra clave <codeinline>new</codeinline>:</p>
    <pre>
    <code class="language-js">new Object()
    new Point(2,3)</code></pre>
    <p>Si no se pasan argumentos a la función constructora en una expresión de creación de objeto, se puede omitir el par de paréntesis vacío:</p>
    <pre>
    <code class="language-js">new Object
    new Date</code></pre>
    <p>El valor de una expresión de creación de objeto es el objeto recién creado. Los constructores se explican con más detalle en el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7 Visión general del operador</h2>
    <p>Los operadores se utilizan para las expresiones aritméticas, las expresiones de comparación, las expresiones lógicas y las expresiones de asignación de JavaScript, entre otras. La <a href="#tabla4-1">Tabla 4-1</a> resume los operadores y sirve como referencia práctica.</p>
    <p>Tenga en cuenta que la mayoría de los operadores se representan mediante caracteres de puntuación, como <codeinline>+</codeinline> y <codeinline>=</codeinline>. Algunos, sin embargo, se representan mediante palabras clave, como <codeinline>delete</codeinline> e <codeinline>instanceof</codeinline>. Los operadores de palabras clave son operadores regulares, al igual que los expresados con signos de puntuación; simplemente tienen una sintaxis menos sucinta.</p>
    <p>La <a href="#tabla4-1">Tabla 4-1</a> está organizada por precedencia de operadores. Los operadores listados en primer lugar tienen mayor precedencia que los listados en último lugar. Los operadores separados por una línea horizontal tienen niveles de precedencia diferentes. La columna A indica la asociatividad del operador, que puede ser L (de izquierda a derecha) o R (de derecha a izquierda), y la columna N especifica el número de operandos. La columna Tipos indica los tipos esperados de los operandos y (después del símbolo →) el tipo de resultado del operador. Las subsecciones que siguen a la tabla explican los conceptos de precedencia, asociatividad y tipo de operando. Los propios operandos se documentan individualmente a continuación.</p>
    <div id="tabla4-1" class="flex flex-col items-center">
      <p><em>Tabla 4-1. Operadores de JavaScript</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="max-w-lg text-center">Operador</td>
            <td class="max-w-72 pl-4">Operanción</td>
            <td class="max-w-lg pl-4">A</td>
            <td class="max-w-lg pl-4">N</td>
            <td class="max-w-lg px-4">Tipos</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">++</codeinline></td>
              <td class="max-w-72 pl-4">Aumento previo o posterior</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">--</codeinline></td>
              <td class="max-w-72 pl-4">Decrecimiento previo o posterior</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → num</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">-</codeinline></td>
              <td class="max-w-72 pl-4">Negar número</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">num → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">+</codeinline></td>
              <td class="max-w-72 pl-4">Convertir a número</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → num</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">~</codeinline></td>
              <td class="max-w-72 pl-4">Invertir bits</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!</codeinline></td>
              <td class="max-w-72 pl-4">Invertir valores booleanos</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">bool → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">delete</codeinline></td>
              <td class="max-w-72 pl-4">Eliminar una propiedad</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">lval → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">typeof</codeinline></td>
              <td class="max-w-72 pl-4">Determinar el tipo de un valor</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → str</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">void</codeinline></td>
              <td class="max-w-72 pl-4">Devolver una valor indefinido</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">1</td>
              <td class="max-w-lg px-4">any → undef</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">**</codeinline></td>
              <td class="max-w-72 pl-4">Potencia</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">*</codeinline>, <codeinline class="md:text-base bg-transparent">/</codeinline>, <codeinline class="md:text-base bg-transparent">%</codeinline></td>
              <td class="max-w-72 pl-4">Multiplicaión, división y resto</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">**</codeinline>, <codeinline class="md:text-base bg-transparent">**</codeinline></td>
              <td class="max-w-72 pl-4">Suma, resta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → num</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">+</codeinline></td>
              <td class="max-w-72 pl-4">Concatenar strings</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">str, str → str</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;&lt;</codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la izquierda</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">>></codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la derecha con signo extendido</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">>>></codeinline></td>
              <td class="max-w-72 pl-4">Desplazamiento a la derecha con extensión cero</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;</codeinline>, <codeinline class="md:text-base bg-transparent">&lt;=</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;=</codeinline></td>
              <td class="max-w-72 pl-4">Comparar por orden numérico</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">num, num → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&lt;</codeinline>, <codeinline class="md:text-base bg-transparent">&lt;=</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;</codeinline>, <codeinline class="md:text-base bg-transparent">&gt;=</codeinline></td>
              <td class="max-w-72 pl-4">Comparar por orden alfabético</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">str, str → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">instanceof</codeinline></td>
              <td class="max-w-72 pl-4">Clase de objeto de prueba</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">obj, func → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">in</codeinline></td>
              <td class="max-w-72 pl-4">Comprobar si la propiedad existe</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, obj → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">==</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de igualdad no estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!=</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de desigualdad no estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr>
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">===</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de igualdad estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">!==</codeinline></td>
              <td class="max-w-72 pl-4">Prueba de desigualdad estricta</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → bool</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits &</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">^</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits XOR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">|</codeinline></td>
              <td class="max-w-72 pl-4">Computa a nivel de bits OR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">int, int → int</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">&&</codeinline></td>
              <td class="max-w-72 pl-4">Computa valores logicos AND</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → any</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">||</codeinline></td>
              <td class="max-w-72 pl-4">Computa valores logicos OR</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → any</td>
            </tr>
            <tr class="bg-[#f6e4c5] border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">??</codeinline></td>
              <td class="max-w-72 pl-4">Escoge el primer operando definido</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → any</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">?:</codeinline></td>
              <td class="max-w-72 pl-4">Escoge el segundo o el tercero operando</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">3</td>
              <td class="max-w-lg px-4">bool, any, any → any</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4"><codeinline class="md:text-base bg-transparent">=</codeinline></td>
              <td class="max-w-72 pl-4">Asigna el valor a una variable o propiedad</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">lval, any → any</td>
            </tr>
            <tr class="border-b-2 border-amber-900">
              <td class="max-w-40 pl-4">
                <codeinline class="md:text-base bg-transparent">**=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">*=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">/=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">%=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">-=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">&=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">^=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">|=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">&lt;&lt;=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">>>=</codeinline>, 
                <codeinline class="md:text-base bg-transparent">>>>=</codeinline>, 
              </td>
              <td class="max-w-72 pl-4">Operar y asignar</td>
              <td class="max-w-lg pl-4">R</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">lval, any → any</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="max-w-lg pl-4">
                <codeinline class="md:text-base bg-transparent">,</codeinline>
              </td>
              <td class="max-w-72 pl-4">Descarta el primer operando, devuelve el segundo</td>
              <td class="max-w-lg pl-4">L</td>
              <td class="max-w-lg pl-4">2</td>
              <td class="max-w-lg px-4">any, any → any</td>
            </tr>
        </tbody>
      </table>
    </div>
  </section>
  <section id="7-1">
    <h2>4.7.1 Número de operandos</h2>
    <p>Los operadores pueden clasificarse en función del número de operandos que esperan (su <em>aridad</em>). La mayoría de los operadores de JavaScript, como el operador de multiplicación <codeinline>*</codeinline>, son <em>operadores binarios</em> que combinan dos expresiones en una única expresión más compleja. Es decir, esperan dos operandos. JavaScript también admite una serie de <em>operadores unarios</em>, que convierten una expresión simple en una única expresión más compleja. El operador <codeinline>-</codeinline> en la expresión <codeinline>-x</codeinline> es un operador unario que realiza la operación de negación en el operando <codeinline>x</codeinline>. Por último, JavaScript admite un <em>operador ternario</em>, el operador condicional <codeinline>?:</codeinline>, que combina tres expresiones en una sola.</p>
  </section>
  <section id="7-2" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.2 Tipo de operando y resultado</h2>
    <p>Algunos operadores funcionan con valores de cualquier tipo, pero la mayoría esperan que sus operandos sean de un tipo específico, y la mayoría de los operadores devuelven (o evalúan a) un valor de un tipo específico. La columna Tipos de la <a href="#tabla4-1">Tabla 4-1</a> especifica los tipos de operando (antes de la flecha) y el tipo de resultado (después de la flecha) para los operadores.</p>
    <p>Los operadores de JavaScript suelen convertir el tipo (véase <a href="capitulo-3#9">§3.9</a>) de sus operandos según sea necesario. El operador de multiplicación <codeinline>*</codeinline> espera operandos numéricos, pero la expresión <codeinline>"3" * "5"</codeinline> es legal porque JavaScript puede convertir los operandos a números. El valor de esta expresión es el número 15, no la cadena "15", por supuesto. Recuerde también que todos los valores de JavaScript son "verdaderos" o "falsos", por lo que los operadores que esperan operandos booleanos funcionarán con un operando de cualquier tipo.</p>
    <p>Algunos operadores se comportan de forma diferente en función del tipo de los operandos utilizados con ellos. En particular, el operador <codeinline>+</codeinline> suma operandos numéricos pero concatena operandos de cadena. Del mismo modo, los operadores de comparación como <codeinline>&lt;</codeinline> realizan la comparación en orden numérico o alfabético en función del tipo de los operandos. Las descripciones de los operadores individuales explican sus dependencias de tipo y especifican qué conversiones de tipo realizan.
    </p>
    <p>Observa que los operadores de asignación y algunos de los otros operadores listados en la <a href="#tabla4-1">Tabla 4-1</a> esperan un operando de tipo <codeinline>lvalue</codeinline>. <em>lvalue</em> es un término histórico que significa "una expresión que puede aparecer legalmente en el lado izquierdo de una expresión de asignación". En JavaScript, las variables, las propiedades de los objetos y los elementos de las matrices son lvalues.</p>
  </section>
  <section id="7-3">
    <h2>4.7.3 Efectos secundarios del operador</h2>
    <p>Evaluar una expresión simple como <codeinline>2 * 3</codeinline> nunca afecta al estado de tu programa, y cualquier cálculo futuro que realice tu programa no se verá afectado por esa evaluación. Sin embargo, algunas expresiones tienen <em>efectos secundarios</em> y su evaluación puede afectar al resultado de futuras evaluaciones. Los operadores de asignación son el ejemplo más obvio: si asigna un valor a una variable o propiedad, cambia el valor de cualquier expresión que utilice esa variable o propiedad. Los operadores de incremento y decremento <codeinline>++</codeinline> y <codeinline>--</codeinline> son similares, ya que realizan una asignación implícita. El operador <codeinline>delete</codeinline> también tiene efectos secundarios: borrar una propiedad es como (pero no lo mismo que) asignar <codeinline>undefined</codeinline> a la propiedad.</p>
    <p>Ningún otro operador de JavaScript tiene efectos secundarios, pero las expresiones de invocación de funciones y creación de objetos tendrán efectos secundarios si alguno de los operadores utilizados en el cuerpo de la función o del constructor tiene efectos secundarios.</p>
  </section>
  <section id="7-4" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.4  Precedencia del operador</h2>
    <p>Los operadores listados en la <a href="#tabla4-1">Tabla 4-1</a> están ordenados de mayor a menor precedencia, con líneas horizontales separando grupos de operadores en el mismo nivel de precedencia. La precedencia de los operadores controla el orden en que se realizan las operaciones. Los operadores con mayor precedencia (más cerca de la parte superior de la tabla) se ejecutan antes que los de menor precedencia (más cerca de la parte inferior).</p>
    <p>Considera la siguiente expresión:</p>
    <pre>
    <code class="language-js">w = x + y*z;</code></pre>
    <p>El operador de multiplicación <codeinline>*</codeinline> tiene mayor precedencia que el operador de suma <codeinline>+</codeinline>, por lo que la multiplicación se realiza antes que la suma. Por otra parte, el operador de asignación <codeinline>=</codeinline> tiene la precedencia más baja, por lo que la asignación se realiza una vez completadas todas las operaciones del lado derecho.</p>
    <p>La precedencia de los operadores puede anularse mediante el uso explícito de paréntesis. Para forzar que la suma del ejemplo anterior se realice primero, escriba:</p>
    <pre>
    <code class="language-js">w = (x + y)*z;</code></pre>
    <p>Tenga en cuenta que las expresiones de acceso e invocación de propiedades tienen mayor precedencia que cualquiera de los operadores listados en la <a href="#tabla4-1">Tabla 4-1</a>. Considere esta expresión:</p>
    <pre>
    <code class="language-js">// my es un objeto con una propiedad llamada funciones cuyo valor es 
    // una matriz de funciones. Invocamos la función número x, le pasamos el argumento y 
    // y luego pedimos el tipo del valor devuelto.
    typeof my.functions[x](y)</code></pre>
    <p>Aunque <codeinline>typeof</codeinline> es uno de los operadores de mayor prioridad, la operación <codeinline>typeof</codeinline> se forma sobre el resultado del acceso a la propiedad, el índice del array y la invocación a la función, todos los cuales tienen mayor prioridad que los operadores.</p>
    <p>En la práctica, si no está seguro de la precedencia de los operadores, lo más sencillo es utilizar paréntesis para explicitar el orden de evaluación. Las reglas que es importante conocer son las siguientes: la multiplicación y la división se realizan antes que la suma y la resta, y la asignación tiene una precedencia muy baja y casi siempre se realiza en último lugar.</p>
    <p>Cuando se añaden nuevos operadores a JavaScript, no siempre encajan de forma natural en este esquema de precedencia. El operador <codeinline>??</codeinline> ( <a href="#13-2">§4.13.2</a>) se muestra en la tabla como de menor precedencia que <codeinline>||</codeinline> y <codeinline>&&</codeinline>, pero, de hecho, su precedencia relativa a esos operadores no está definida, y ES2020 requiere que use explícitamente paréntesis si mezcla <codeinline>??</codeinline> con <codeinline>||</codeinline> o <codeinline>&&</codeinline>. De manera similar, el nuevo operador de exponenciación <codeinline>**</codeinline> no tiene una precedencia bien definida con respecto al operador de negación unario, y debe usar paréntesis cuando combine negación con exponenciación.</p>
  </section>
  <section id="7-5">
    <h2>4.7.5 Asociatividad de operadores</h2>
    <p>En la <a href="tabla4-1">Tabla 4-1</a> la columna A especifica la <em>asociatividad</em> del operador. Un valor de L especifica la asociatividad de izquierda a derecha, y un valor de R especifica la asociatividad de derecha a izquierda. La asociatividad de un operador especifica el orden en que se realizan las operaciones de la misma precedencia. La asociatividad de izquierda a derecha significa que las operaciones se realizan de izquierda a derecha. Por ejemplo, el operador de resta tiene asociatividad de izquierda a derecha, así:</p>
    <pre>
    <code class="language-js">w = x - y - z;</code></pre>
    <p>es lo mismo que:</p>
    <pre>
    <code class="language-js">w = ((x - y) - z);</code></pre>
    <p>Por otra parte, las siguientes expresiones:</p>
    <pre>
    <code class="language-js">y = a ** b ** c;
    x = ~-y;
    w = x = y = z;
    q = a?b:c?d:e?f:g;</code></pre>
    <p>son equivalentes:</p>
    <pre>
    <code class="language-js">y = (a ** (b ** c));
    x = ~(-y);
    w = (x = (y = z));
    q = a?b:(c?d:(e?f:g));</code></pre>
    <p>porque los operadores de exponenciación, unario, asignación y condicional ternario tienen asociatividad de derecha a izquierda.</p>
  </section>
  <section id="7-6" class="py-4 xs:py-5 sm:py-6">
    <h2>4.7.6 Orden de evaluación</h2>
    <p>La precedencia de operadores y la asociatividad especifican el orden en que se realizan las operaciones en una expresión compleja, pero no especifican el orden en que se evalúan las subexpresiones. JavaScript siempre evalúa las expresiones en un orden estrictamente de izquierda a derecha. En la expresión <codeinline>w = x + y * z</codeinline>, por ejemplo, la subexpresión <codeinline>w</codeinline> se evalúa en primer lugar, seguida de <codeinline>x</codeinline>, <codeinline>y</codeinline> y <codeinline>z</codeinline>. A continuación, los valores de <codeinline>y</codeinline> y <codeinline>z</codeinline> se multiplican, se suman al valor de <codeinline>x</codeinline> y se asignan a la variable o propiedad especificada por la expresión <codeinline>w</codeinline>. La adición de paréntesis a las expresiones puede cambiar el orden relativo de la multiplicación, la suma y la asignación, pero no el orden de evaluación de izquierda a derecha.</p>
    <p>El orden de evaluación sólo tiene importancia si alguna de las expresiones evaluadas tiene efectos secundarios que afectan al valor de otra expresión. Si la expresión <codeinline>x</codeinline> incrementa una variable que es utilizada por la expresión <codeinline>z</codeinline>, entonces el hecho de que <codeinline>x</codeinline> se evalúe antes que <codeinline>z</codeinline> es importante.</p>
  </section>
  <section id="8">
    <h2>4.8 Expresiones aritméticas</h2>
    <p>Esta sección trata de los operadores que realizan operaciones aritméticas u otras manipulaciones numéricas en sus operandos. Los operadores de exponenciación, multiplicación, división y sustracción son sencillos y se tratan en primer lugar. El operador de suma recibe una subsección propia porque también puede realizar la concatenación de cadenas y tiene algunas reglas de conversión de tipos inusuales. Los operadores unarios y los operadores bit a bit también se tratan en subsecciones propias.</p>
    <p>La mayoría de estos operadores aritméticos (excepto los que se indican a continuación) pueden utilizarse con operandos BigInt (véase <a href="capitulo-3#2-5">§3.2.5</a> ) o con números normales, siempre que no se mezclen los dos tipos.</p>
    <p>Los operadores aritméticos básicos son <codeinline>**</codeinline> (exponenciación), <codeinline>*</codeinline> (multiplicación), <codeinline>/</codeinline> (división), <codeinline>%</codeinline> (módulo: resto después de la división), <codeinline>+</codeinline> (suma) y <codeinline>-</codeinline> (resta). Como se ha indicado, hablaremos del operador <codeinline>+</codeinline> en una sección aparte. Los otros cinco operadores básicos simplemente evalúan sus operandos, convierten los valores en números si es necesario y, a continuación, calculan la potencia, el producto, el cociente, el resto o la diferencia. No numérico los operandos que no pueden convertirse en números se convierten en el valor <codeinline>NaN</codeinline>. Si cualquiera de los operandos es (o se convierte en) <codeinline>NaN</codeinline>, el resultado de la operación es (casi siempre) <codeinline>NaN</codeinline>.</p>
    <p>El operador <codeinline>**</codeinline> tiene mayor precedencia que <codeinline>*</codeinline>, <codeinline>/</codeinline> y <codeinline>%</codeinline> (que a su vez tienen mayor precedencia que <codeinline>+</codeinline> y <codeinline>-</codeinline>). A diferencia de los otros operadores, <codeinline>**</codeinline> funciona de derecha a izquierda, por lo que <codeinline>2**2**3</codeinline> es lo mismo que <codeinline>2**8</codeinline>, no que <codeinline>4**3</codeinline>. Existe una ambigüedad natural en expresiones como <codeinline>-3**2</codeinline>. Dependiendo de la precedencia relativa del signo menos unario y de la exponenciación, esa expresión podría significar <codeinline>(-3)**2</codeinline> o <codeinline>--(3**2)</codeinline>. Los distintos lenguajes manejan esto de forma diferente, y en lugar de tomar partido, JavaScript simplemente convierte en un error sintáctico omitir los paréntesis en este caso, obligándole a escribir una expresión inequívoca. <codeinline>**</codeinline> es el operador aritmético más reciente de JavaScript: se añadió al lenguaje con ES2016. Sin embargo, la función <codeinline>Math.pow()</codeinline> ha estado disponible desde las primeras versiones de JavaScript y realiza exactamente la misma operación que el operador <codeinline>**</codeinline>.</p>
    <p>El operador <codeinline>/</codeinline> divide el primer operando por el segundo. Si está acostumbrado a lenguajes de programación que distinguen entre números enteros y de coma flotante, es posible que espere obtener un resultado entero al dividir un número entero por otro. En JavaScript, sin embargo, todos los números son de coma flotante, por lo que todas las operaciones de división tienen resultados de coma flotante: <codeinline>5/2</codeinline> equivale a <codeinline>2.5</codeinline>, no a <codeinline>2</codeinline>. La división por cero produce infinitos positivos o negativos, mientras que <codeinline>0/0</codeinline> se evalúacomo <codeinline>NaN</codeinline>: en ninguno de estos casos se produce un error.</p>
    <p>El operador <codeinline>%</codeinline> calcula el primer operando módulo el segundo operando. En otras palabras, devuelve el resto de la división entera del primer operando por el segundo operando. El signo del resultado es el mismo que el del primer operando. Por ejnpmemplo, <codeinline>5 % 2</codeinline> se evalúacomo <codeinline>1</codeinline>, y <codeinline>-5 % 2</codeinline> se evalúa como <codeinline>-1</codeinline>.</p>
    <p>Aunque el operador módulo se utiliza normalmente con operandos enteros, también funciona con valores de coma flotante. Por ejemplo, <codeinline>6.5 % 2.1</codeinline> equivale a <codeinline>0.2</codeinline>.</p>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.8.1 Operador de +</h2>
    <p>El operador binario <codeinline>+</codeinline> suma operandos numéricos o concatena operandos de cadena:</p>
    <pre>
    <code class="language-js">1 + 2                   // => 3
    "hello" + " " + "there" // => "hello there"
    "1" + "2"               // => "12"</code></pre>
    <p>Cuando los valores de ambos operandos son números, o ambos son cadenas, entonces es obvio lo que hace el operador <codeinline>+</codeinline>. En cualquier otro caso, sin embargo, es necesaria la conversión de tipos, y la operación a realizar depende de la conversión efectuada. Las reglas de conversión de <codeinline>+</codeinline> dan prioridad a la concatenación de cadenas: si uno de los operandos es una cadena o un objeto que se convierte en cadena, el otro operando se convierte en cadena y se realiza la concatenación. La suma sólo se realiza si ninguno de los dos operandos es una cadena.</p>
    <p>Técnicamente, el operador <codeinline>+</codeinline> se comporta así:</p>
    <ul>
      <li class="font-normal">Si alguno de los valores de su operando es un objeto, lo convierte en una primitiva mediante el algoritmo de conversión de objetos a primitivas descrito en <a href="capitulo-3#9-3">§3.9.3</a> Los objetos Date se convierten mediante su método <codeinline>toString()</codeinline>, y todos los demás objetos se convierten mediante <codeinline>valueOf()</codeinline>, si dicho método devuelve un valor primitivo. Sin embargo, la mayoría de los objetos no tienen un método <codeinline>valueOf()</codeinline> utilizable, por lo que también se convierten mediante <codeinline>toString()</codeinline>.</li>
      <li class="font-normal">Tras la conversión de objeto a primitivo, si alguno de los operandos es una cadena, el otro se convierte en cadena y se realiza la concatenación.</li>
      <li class="font-normal">En caso contrario, ambos operandos se convierten en números (o en <codeinline>NaN</codeinline> y se realiza la suma.</li>
    </ul>
    <p>He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">1 + 2         // => 3: suma
    "1" + "2"     // => "12": concatenación
    "1" + 2       // => "12": concatenación después numérico-a-string
    1 + &lbrace;}        // => "1[object Object]": concatenación después objeto-a-string
    true + true   // => 2: suma después booleano-a-numérico
    2 + null      // => 2: suma después null a cero
    2 + undefined // => NaN: suma despues undefined se convierte a NaN</code></pre>
    <p>Por último, es importante tener en cuenta que cuando el operador <codeinline>+</codeinline> se utiliza con cadenas y números, puede no ser asociativo. Es decir, el resultado puede depender del orden en que se realicen las operaciones.</p>
    <p>Por ejemplo:</p>
    <pre>
    <code class="language-js">1 + 2 + " blind mice"   // => "3 blind mice"
    1 + (2 + " blind mice") // => "12 blind mice"</code></pre>
    <p>La primera línea no tiene paréntesis, y el operador <codeinline>+</codeinline> tiene asociatividad de izquierda a derecha, por lo que los dos números se suman primero, y su suma se concatena con la cadena. En la segunda línea, los paréntesis alteran este orden de operaciones: el número 2 se concatena con la cadena para producir una nueva cadena. A continuación, el número 1 se concatena con la nueva cadena para obtener el resultado final.</p>
  </section>
  <section id="8-2">
    <h2>4.8.2 Operadores aritméticos unarios</h2>
    <p>Los operadores unarios modifican el valor de un único operando para producir un nuevo valor. En JavaScript, todos los operadores unarios tienen precedencia alta y son asociativos a la derecha. Los operadores aritméticos unarios descritos en esta sección (<codeinline>+</codeinline>, <codeinline>-</codeinline>, <codeinline>++</codeinline> y <codeinline>--</codeinline>) convierten su único operando en un número, si es necesario. Tenga en cuenta que los caracteres de puntuación <codeinline>+</codeinline> y <codeinline>-</codeinline> se utilizan como operadores unarios y binarios.</p>
    <p>Los operadores aritméticos unarios son los siguientes:</p>
    <div>
      <p><em>Más unario (<codeinline>+</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador unario más convierte su operando en un número (o en <codeinline>NaN</codeinline>) y devuelve el valor convertido. Cuando se utiliza con un operando que ya es un número, no hace nada. Este operador no puede utilizarse con valores BigInt, ya que no pueden convertirse en números normales.</p>
    </div>
    <div>
      <p><em>Menos unario (<codeinline>-</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">Cuando <codeinline>-</codeinline> se utiliza como operador unario, convierte su operando en un número, si es necesario, y luego cambia el signo del resultado.</p>
    </div>
    <div>
      <p><em>Incremento (<codeinline>++</codeinline>)</em></p>
      <div class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
        <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>++</codeinline> incrementa (es decir, suma 1) su único operando, que debe ser un lvalue (una variable, un elemento de una matriz o una propiedad de un objeto). El operador convierte su operando en un número, suma 1 a ese número y asigna el valor incrementado de nuevo a la variable, elemento o propiedad.</p>
        <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El valor de retorno del operador <codeinline>++</codeinline> depende de su posición respecto al operando. Cuando se utiliza antes del operando, se conoce como operador de preincremento, incrementa el operando y se evalúa al valor incrementado de ese operando. Cuando se utiliza después del operando, donde se conoce como operador de post-incremento, incrementa su operando pero se evalúa al valor <em>no incrementado</em> de ese operando. Considere la diferencia entre estas dos líneas de código:</p>
        <pre>
        <code class="language-js">let i = 1, j = ++i;   // i and j are both 2
        let n = 1, m = n++;   // n is 2, m is 1</code></pre>
        <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">Tenga en cuenta que la expresión <codeinline>x++</codeinline> no siempre es lo mismo que <codeinline>x=x+1</codeinline>. El operador <codeinline>++</codeinline> nunca realiza una concatenación de cadenas: siempre convierte su operando en un número y lo incrementa. Si <codeinline>x</codeinline> es la cadena "1", <codeinline>++x</codeinline> es el número 2, pero <codeinline>x+1</codeinline> es la cadena "11".</p>
        <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">Tenga en cuenta también que, debido a la inserción automática de punto y coma de JavaScript, no puede insertar un salto de línea entre el operador de postincremento y el operando que lo precede. Si lo hace, JavaScript tratará el operando como una sentencia completa por sí misma e insertará un punto y coma antes.</p>
        <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">Este operador, tanto en su forma de preincremento como de postincremento, se utiliza normalmente para incrementar un contador que controla un bucle for (<a href="capitulo-5#4-3">§5.4.3</a>).</p>
      </div>
    </div>
    <div>
      <p><em>Disminución (<codeinline>--</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>--</codeinline> espera un operando lvalue. Convierte el valor del operando en un número, resta 1 y asigna el valor decrementado de nuevo al operando. Al igual que el operador <codeinline>++</codeinline>, el valor de retorno de <codeinline>--</codeinline> depende de su posición con respecto al operando. Cuando se utiliza antes del operando, decrementa y devuelve el valor <em>decrementado</em>. Cuando se utiliza después del operando, decrementa el operando pero devuelve el valor sin decuentar. Cuando se utiliza después de su operando, no se permite ningún salto de línea entre el operando y el operador.</p>
    </div>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>4.8.3 Operadores bit a bit</h2>
    <p>Los operadores bit a bit (bitwise) realizan una manipulación de bajo nivel de los bits en la representación binaria de los números. Aunque no realizan operaciones aritméticas tradicionales, aquí se clasifican como operadores aritméticos porque operan con operandos numéricos y devuelven un valor numérico. Cuatro de estos operadores realizan álgebra booleana en los bits individuales de los operandos, comportándose como si cada bit de cada operando fuera un valor booleano (1=verdadero, 0=falso). Los otros tres operadores bit a bit se utilizan para desplazar bits a izquierda y derecha. Estos operadores no son de uso común en la programación de JavaScript, y si usted no está familiarizado con la representación binaria de los enteros, incluyendo la representación del complemento a dos de los enteros negativos, probablemente puede saltarse esta sección.</p>
    <p>Los operadores bit a bit esperan operandos enteros y se comportan como si esos valores se representaran como enteros de 32 bits en lugar de valores de coma flotante de 64 bits. Estos operadores convierten sus operandos en números, si es necesario, y luego coaccionan los valores numéricos a enteros de 32 bits eliminando cualquier parte fraccionaria y cualquier bit más allá del 32. Los operadores de desplazamiento requieren un operando a la derecha entre 0 y 31. Después de convertir este operando en un entero de 32 bits sin signo, eliminan cualquier bit más allá del 5o, lo que produce un número en el rango apropiado. Sorprendentemente, <codeinline>NaN</codeinline>, <codeinline>Infinity</codeinline> y <codeinline>-Infinity</codeinline> se convierten en 0 cuando se utilizan como operandos de estos operadores bit a bit.</p>
    <p>Todos estos operadores bit a bit, excepto <codeinline>>>></codeinline>, pueden utilizarse con operandos numéricos normales o con operandos BigInt (véase <a href="capitulo-3#2-5">§3.2.5</a>).</p>
    <div>
      <p><em>Bitwise AND (<codeinline>&</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&</codeinline> realiza una operación booleana AND en cada bit de sus argumentos enteros. Un bit se activa en el resultado sólo si el bit correspondiente está activado en ambos operandos. Por ejemplo, <codeinline>0x1234 & 0x00FF</codeinline> equivale a <codeinline>0x0034</codeinline>.</p>
    </div>
    <div>
      <p><em>Bitwise OR (<codeinline>|</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>|</codeinline> realiza una operación booleana OR en cada bit de sus argumentos enteros. Un bit se activa en el resultado si el bit correspondiente está activado en uno o ambos operandos. Por ejemplo, <codeinline>0x1234 | 0x00FF</codeinline> equivale a <codeinline>0x12FF</codeinline>.</p>
    </div>
    <div>
      <p><em>Bitwise XOR (<codeinline>^</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>^</codeinline> realiza una operación booleana OR exclusiva en cada bit de sus argumentos enteros. OR exclusivo significa que o bien el operando uno es <codeinline>true</codeinline> o bien el operando dos es <codeinline>true</codeinline>, pero no ambos. Se activa un bit en el resultado de esta operación si se activa el bit correspondiente en uno (pero no en ambos) de los dos operandos. Por ejemplo, <codeinline>0xFF00 ^ 0xF0F0</codeinline> equivale a <codeinline>0x0F0F</codeinline>.</p>
    </div>
    <div>
      <p><em>Bitwise NOT (<codeinline>~</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>~</codeinline> es un operador unario que aparece antes de su único operando entero. Funciona invirtiendo todos los bits del operando. Debido a la forma en que se representan los enteros con signo en JavaScript, aplicar el operador <codeinline>~</codeinline> a un valor equivale a cambiar su signo y restar 1. Por ejemplo, <codeinline>~0x0F</codeinline> equivale a <codeinline>0xFFFFFFF0</codeinline>, es decir, -16.</p>
    </div>
    <div>
      <p><em>Desplazamiento a la izquierda (<codeinline>&lt;&lt;</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&lt;&lt;</codeinline> desplaza todos los bits de su primer operando hacia la izquierda el número de posiciones especificado en el segundo operando, que debe ser un número entero comprendido entre 0 y 31. Por ejemplo, en la operación a <codeinline>&lt;&lt; 1</codeinline>, el primer bit (el bit de unos) de <codeinline>a</codeinline> se convierte en el segundo bit (el bit de dos), el segundo bit de <codeinline>a</codeinline> se convierte en el tercero, etc. Se utiliza un cero para el nuevo primer bit, y se pierde el valor del bit 32. Desplazar un valor una posición a la izquierda equivale a multiplicar por 2, desplazar dos posiciones equivale a multiplicar por 4, y así sucesivamente. Por ejemplo, <codeinline>7 &lt;&lt; 2</codeinline> equivale a 28.</p>
    </div>
    <div>
      <p><em>Desplazamiento a la derecha con signo (<codeinline>&gt;&gt;</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&gt;&gt;</codeinline> desplaza todos los bits de su primer operando hacia la derecha el número de posiciones especificado en el segundo operando (un entero entre 0 y 31).Losbitsdesplazados a la derecha sepierden.Losbitsrellenados a la izquierda dependen del bit de signo del operando original, para preservar el signo del resultado. Si el primer operando es positivo, el resultado tiene ceros en los bits altos; si el primer operando es negativo, el resultado tiene unos en los bits altos. Desplazar un valor positivo un lugar a la derecha equivale a dividir por 2 (descartando el resto), desplazar dos lugares a la derecha equivale a una división entera por 4, y así sucesivamente. Por ejemplo, <codeinline>7 &gt;&gt; 1</codeinline> equivale a 3, pero tenga en cuenta que <codeinline>-7 &gt;&gt; 1</codeinline> equivale a -4.</p>
    </div>
    <div>
      <p><em>Desplazamiento a la derecha con relleno cero (<codeinline>&gt;&gt;&gt;</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&gt;&gt;&gt;</codeinline> es igual que el operador <codeinline>&gt;&gt;</codeinline>, excepto en que los bits desplazados a la izquierda son siempre cero, independientemente del signo del primer operando. Esto resulta útil cuando se desea tratar valores de 32 bits con signo como si fueran enteros sin signo. <codeinline>-1 &gt;&gt; 4</codeinline> equivale a -1, pero <codeinline>-1 &gt;&gt;&gt; 4</codeinline> equivale a <codeinline>0x0FFFFFFF</codeinline>, por ejemplo. Este es el único de los operadores bitwise de JavaScript que no se puede utilizar con valores BigInt. BigInt no representa números negativos poniendo el bit alto como lo hacen los enteros de 32 bits, y este operador sólo tiene sentido para esa representación particular de complemento a dos.</p>
    </div>
  </section>
  <section id="9">
    <h2>4.9 Expresiones relacionales</h2>
    <p>Esta sección describe los operadores relacionales de JavaScript. Estos operadores comprueban si existe una relación (como "igual a", "menor que" o "propiedad de") entre dos valores y devuelven <codeinline>true</codeinline> o <codeinline>false</codeinline> en función de si existe dicha relación. Las expresiones relacionales siempre se evalúan con un valor booleano, y ese valor se utiliza a menudo para controlar el flujo de ejecución del programa en las sentencias <codeinline>if</codeinline>, <codeinline>while</codeinline> y <codeinline>for</codeinline> (véase el <a href="capitulo-5">Capítulo 5</a> Las subsecciones siguientes documentan los operadores de igualdad y desigualdad, los operadores de comparación y los otros dos operadores relacionales de JavaScript, <codeinline>in</codeinline> e <codeinline>instanceof</codeinline>.</p>
  </section>
  <section id="9-1" class="py-4 xs:py-5 sm:py-6">
    <h2>4.9.1 Operadores de igualdad y desigualdad</h2>
    <p>Los operadores <codeinline>==</codeinline> y <codeinline>===</codeinline> comprueban si dos valores son iguales, utilizando dos definiciones diferentes de igualdad. Ambos operadores aceptan operandos de cualquier tipo, y ambos devuelven <codeinline>true</codeinline> si sus operandos son iguales y <codeinline>false</codeinline> si son diferentes. El operador <codeinline>===</codeinline> se conoce como operador de igualdad estricta (o a veces operador de identidad) y comprueba si sus dos operandos son "idénticos" utilizando una definición estricta de igualdad. El operador <codeinline>==</codeinline> se conoce como operador de igualdad; comprueba si sus dos operandos son "iguales" utilizando una definición más relajada de igualdad que permite conversiones de tipo.</p>
    <p>Los operadores <codeinline>!=</codeinline> y <codeinline>!==</codeinline> comprueban exactamente lo contrario que los operadores <codeinline>==</codeinline> y <codeinline>===</codeinline>. El operador de desigualdad <codeinline>!=</codeinline> devuelve <codeinline>false</codeinline> si dos valores son iguales según <codeinline>==</codeinline> y <codeinline>true</codeinline> en caso contrario. El operador <codeinline>!==</codeinline> devuelve <codeinline>false</codeinline> si dos valores son estrictamente iguales y <codeinline>true</codeinline> en caso contrario. Como se verá en <a href="#10">§4.10</a>, el operador <codeinline>!</codeinline> calcula la operación booleana NOT. Esto facilita recordar que <codeinline>!=</codeinline> y <codeinline>!==</codeinline> significan"no igual a" y "no estrictamente igual a".</p>
    <article>
      <p class="title-article">Los operadores =, == y ===</p>
      <p>JavaScript admite los operadores <codeinline>=</codeinline>, <codeinline>==</codeinline> y <codeinline>===</codeinline>. Asegúrese de comprender las diferencias entre estos operadores de asignación, igualdad e igualdad estricta, y tenga cuidado de utilizar el correcto al codificar. Aunque es tentador leer los tres operadores como "iguales", puede ayudar a reducir la confusión si lees "obtiene" o "se asigna" para <codeinline>=</codeinline>, "es igual a" para <codeinline>==</codeinline>, y "es estrictamente igual a" para <codeinline>===</codeinline>.</p>
      <p>El operador <codeinline>==</codeinline> es una característica heredada de JavaScript y se considera una fuente de errores. Casi siempre se debe utilizar <codeinline>===</codeinline> en lugar de <codeinline>==</codeinline>, y <codeinline>!==</codeinline> en lugar de <codeinline>!=</codeinline>.</p>
    </article>
    <p>Como se menciona en <a href="capitulo-3#8">§3.8</a>, los objetos JavaScript se comparan por referencia, no por valor. Un objeto es igual a sí mismo, pero no a cualquier otro objeto. Si dos objetos distintos tienen el mismo número de propiedades, con los mismos nombres y valores, siguen sin ser iguales. Del mismo modo, dos matrices que tienen los mismos elementos en el mismo orden no son iguales entre sí.</p>
    <p class="title-article text-left">Igualdad estricta</p>
    <p>El operador de igualdad estricta <codeinline>===</codeinline> evalúa sus operandos y luego compara los dos valores de la siguiente manera, sin realizar ninguna conversión de tipo:</p>
    <ul class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
      <li class="font-normal">Si los dos valores tienen tipos diferentes, no son iguales.</li>
      <li class="font-normal">Si ambos valores son <codeinline>null</codeinline> o ambos valores son <codeinline>undefined</codeinline>, son iguales.</li>
      <li class="font-normal">Si ambos valores son el valor booleano <codeinline>true</codeinline> o ambos son el valor booleano <codeinline>false</codeinline>, son iguales.</li>
      <li class="font-normal">Si uno o ambos valores son <codeinline>NAN</codeinline>, no son iguales. (Esto es sorprendente, pero el valor <codeinline>NaN</codeinline> nunca es igual a ningún otro valor, ¡incluido él mismo! Para comprobar si un valor <codeinline>x</codeinline> es <codeinline>NaN</codeinline>, utilice <codeinline>x !== x</codeinline>, o la función global <codeinline>isNaN()</codeinline>).</li>
      <li class="font-normal">Si ambos valores son números y tienen el mismo valor, son iguales. Si un valor es <codeinline>0</codeinline> y el otro es <codeinline>-0</codeinline>, también son iguales.</li>
      <li class="font-normal">Si ambos valores son cadenas y contienen exactamente los mismos valores de 16 bits (véase la barra lateral en <a href="capitulo-3#3-3">§3.3</a>) en las mismas posiciones, son iguales. Si las cadenas difieren en longitud o contenido, no son iguales. Dos cadenas pueden tener el mismo significado y la misma apariencia visual, pero aún así estar codificadas utilizando diferentes secuencias de valores de 16 bits. JavaScript no realiza ninguna normalización Unicode, y un par de cadenas como éstas no se considera igual con los operadores <codeinline>===</codeinline> o <codeinline>==</codeinline>.</li>
      <li class="font-normal">Si ambos valores se refieren al mismo objeto, matriz o función, son iguales. Si se refieren a objetos diferentes, no son iguales, aunque ambos objetos tengan propiedades idénticas.</li>
    </ul>
    <p class="title-article text-left">Igualdad con conversión de tipos</p>
    <p>El operador de igualdad <codeinline>==</codeinline> es como el operador de igualdad estricta, pero menos estricto. Si los valores de los dos operandos no son del mismo tipo, intenta algunas conversiones de tipo y vuelve a intentar la comparación:</p>
    <ul class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
      <li class="font-normal">Si los dos valores tienen el mismo tipo, compruebe si son estrictamente iguales como se ha descrito anteriormente. Si son estrictamente iguales, son iguales. Si no son estrictamente iguales, no son iguales.</li>
      <li class="font-normal">Si los dos valores no tienen el mismo tipo, el operador <codeinline>==</codeinline> puede considerarlos iguales. Utiliza las siguientes reglas y conversiones de tipo para comprobar la igualdad:
        <li class="font-normal">Si un valor es <codeinline>null</codeinline> y el otro <codeinline>undefined</codeinline>, son iguales.</li>
        <li class="font-normal">Si un valor es un número y el otro es una cadena, convierta la cadena en un
          número e intente de nuevo la comparación utilizando el valor convertido.</li>
        <li class="font-normal">Si alguno de los valores es <codeinline>true</codeinline>, conviértalo en 1 y vuelva a realizar la comparación. Si alguno de los valores es <codeinline>false</codeinline>, conviértalo en 0 y vuelva a intentar la comparación.</li>
        <li class="font-normal">Si un valor es un objeto y el otro es un número o una cadena, convierta el objeto en una primitiva utilizando el algoritmo descrito en <a href="capitulo-3#9-3">§3.9.3</a> y vuelva a intentar la comparación. Un objeto se convierte en un valor primitivo mediantesufunción <codeinline>toString()</codeinline> o su método <codeinline>valueOf()</codeinline>. Las clases incorporadas del núcleo de JavaScript intentan la conversión <codeinline>valueOf()</codeinline> antes que la conversión <codeinline>toString()</codeinline>, excepto la clase <codeinline>Date</codeinline>, que realiza la conversión <codeinline>toString()</codeinline>.</li>
        <li class="font-normal">Cualquier otra combinación de valores no es igual.</li>
      </li>
    </ul>
    <p>Como ejemplo de comprobación de la igualdad, considere la comparación:</p>
    <pre>
    <code class="language-js">"1" == true // => true</code></pre>
    <p>Esta expresión se evalúa como <codeinline>true</codeinline>, lo que indica que estos valores de aspecto tan diferente son iguales. El valor booleano <codeinline>true</codeinline> se convierte primero en el número 1, y la comparación se realiza de nuevo. A continuación, la cadena <codeinline>"1"</codeinline> se convierte en el número 1. Como ahora ambos valores son iguales, la comparación devuelve verdadero.</p>
  </section>
  <section id="9-2">
    <h2>9.2 Operadores de comparación</h2>
    <p>Los operadores de comparación comprueban el orden relativo (numérico o alfabético) de sus dos operandos:</p>
    <div>
      <p><em>Menor que (<codeinline>&lt;</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&lt;</codeinline> se evalúa como <codeinline>true</codeinline> si su primer operando es menor que su segundo operando; en caso contrario, se evalúa como <codeinline>false</codeinline>.</p>
    </div>
    <div>
      <p><em>Mayor que (<codeinline>&gt;</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&gt;</codeinline> se evalúa como <codeinline>true</codeinline> si su primer operando es mayor que su segundo operando; en caso contrario, se evalúa como <codeinline>false</codeinline>.</p>
    </div>
    <div>
      <p><em>Menor o igual que (<codeinline>&lt;=</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&lt;=</codeinline> se evalúa como <codeinline>true</codeinline> si su primer operando es menor o igual que su segundo operando; en caso contrario, se evalúa como <codeinline>false</codeinline>.</p>
    </div>
    <div>
      <p><em>Mayor o igual (<codeinline>&gt;=</codeinline>)</em></p>
      <p class="ml-5 xs:ml-6 sm:ml-7 md:ml-8">El operador <codeinline>&gt;=</codeinline> se evalúa como <codeinline>true</codeinline> si su primer operando es mayor o igual que su segundo operando; en caso contrario, se evalúa como <codeinline>false</codeinline>.</p>
    </div>
    <p>Los operandos de estos operadores de comparación pueden ser de cualquier tipo. Sin embargo, la comparación sólo puede realizarse con números y cadenas, por lo que los operandos que no son números o cadenas se convierten.</p>
    <p>La comparación y la conversión se producen del siguiente modo:</p>
    <ul class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
      <li class="font-normal">Si cualquiera de los operandos se evalúa como un objeto, dicho objeto se convierte en un valor primitivo, tal y como se describe al final de <a href="capitulo-3#9-3">§3.9.3</a>; si su método <codeinline>valueOf()</codeinline> devuelve un valor primitivo, se utiliza dicho valor. En caso contrario, se utiliza el valor devuelto por su método <codeinline>toString()</codeinline>.</li>
      <li class="font-normal">Si, tras cualquier conversión objeto-primitivo necesaria, ambos operandos son cadenas, las dos cadenas se comparan, utilizando el orden alfabético, donde "orden alfabético" se define por el orden numérico de los valores Unicode de 16 bits que componen las cadenas.</li>
      <li class="font-normal">Si, tras la conversión de objeto a primitivo, al menos un operando no es una cadena, ambos operandos se convierten en números y se comparan numéricamente. <codeinline>0</codeinline> y <codeinline>-0</codeinline> se consideran iguales. <codeinline>Infinity</codeinline> es mayor que cualquier número que no sea él mismo, y <codeinline>-Infinity</codeinline> es menor que cualquier número que no sea él mismo. Si cualquiera de los operandos es (o se convierte en) <codeinline>NaN</codeinline>, el operador de comparación siempre devuelve <codeinline>false</codeinline>. Aunque los operadores aritméticos no permiten mezclar valores BigInt con números normales, los operadores de comparación sí permiten realizar comparaciones entre números y BigInts.</li>
    </ul>
    <p>Recuerde que las cadenas JavaScript son secuencias de valores enteros de 16 bits, y que la comparación de cadenas es sólo una comparación numérica de los valores de las dos cadenas. El orden de codificación numérica definido por Unicode puede no coincidir con el orden de colla- ción tradicional utilizado en un idioma o configuración regional concretos. Tenga en cuenta, en particular, que la comparación de cadenas distingue entre mayúsculas y minúsculas, y que todas las letras ASCII mayúsculas son "menos que" todas las letras ASCII minúsculas. Esta regla puede dar lugar a resultados confusos si no se tiene en cuenta. Por ejemplo, según el operador <codeinline>&lt;</codeinline>, la cadena "Zoo" está antes que la cadena "aardvark".</p>
    <p>Para un algoritmo de comparación de cadenas más robusto, pruebe el método <codeinline>String.localeCompare()</codeinline>, que también tiene en c u e n t a las definiciones de orden alfabético específicas de cada localización. Para realizar comparaciones sin distinguir mayúsculas de minúsculas, puede convertir las cadenas a minúsculas o mayúsculas utilizando <codeinline>String.toLowerCase()</codeinline> o <codeinline>String.toUpperCase()</codeinline>. Y, para una herramienta de comparación de cadenas más general y mejor localizada, utilice la clase <codeinline>Intl.Collator</codeinline> descrita en <a href="capitulo-11#7-3">§11.7.3</a>.</p>
    <p>Tanto el operador <codeinline>+</codeinline> como los operadores de comparación se comportan de forma diferente para los operandos numéricos y los de cadena. <codeinline>+</codeinline> favorece a las cadenas: realiza la concatenación si cualquiera de los operandos es una cadena. Los operadores de comparación favorecen a los números y sólo comparan cadenas si ambos operandos son cadenas:</p>
    <pre>
    <code class="language-javascript">1 + 2      // => 3: suma.
    "1" + "2"  // => "12": concatenación.
    "1" + 2    // => "12": 2 se convierte en "2".
    11 &lt; 3     // => false: comparación numérica.
    "11" &lt; "3" // => true: comparación de string.
    "11" &lt; 3   // => false: comparación numérica, "11" se convierte en 11.
    "uno" &lt; 3  // => false: comparación numérica, "uno" se convierte en NaN.</code></pre>
    <p>Por último, tenga en cuenta que los operadores <codeinline>&lt;=</codeinline> (menor que o igual) y <codeinline>&gt;=</codeinline> (mayor que o igual) no se basan en los operadores de igualdad o igualdad estricta para determinar si dos valores son "iguales". En su lugar, el operador menor que o igual se define simplemente como "no mayor que", y el operador mayor que o igual se define como "no menor que". La dirección se produce una excepción cuando cualquiera de los operandos es (o se convierte en) <codeinline>NaN</codeinline>, en cuyo caso, los cuatro operadores de comparación devuelven <codeinline>false</codeinline>.</p>
  </section>
  <section id="9-3" class="py-4 xs:py-5 sm:py-6">
    <h2>4.9.3 El operador in</h2>
    <p>El operador <codeinline>in</codeinline> espera un operando izquierdo que sea una cadena, un símbolo o un valor que pueda convertirse en cadena. Espera un operando del lado derecho que es un objeto. Se evalúa como <codeinline>true</codeinline> si el valor del lado izquierdo es el nombre de una propiedad del objeto del lado derecho. Por ejemplo:</p>
    <pre>
    <code class="language-js">let point = &lbrace;x: 1, y: 1}; // Definir un objeto
    "x" in point              // => true: el objecto tiene una propiedad llamada "x"
    "z" in point              // => false: el objeto no tiene una propiedad llamada "z".
    "toString" in point       // => true: el objeto hereda el método toString

    let data = [7,8,9];       // Un array con elementos (indices) 0, 1, y 2
    "0" in data               // => true: array tiene un elemento "0"
    1 in data                 // => true: los numeros se convierten en cadenas
    3 in data                 // => false: no hay elemento 3</code></pre>
  </section>
  <section id="9-4">
    <h2>4.9.4 El operador instanceof</h2>
    <p>El operador <codeinline>instanceof</codeinline> espera un operando del lado izquierdo que es un objeto y un operando del lado derecho que identifica una clase de objetos. El operador evalúa a <codeinline>true</codeinline> si el objeto del lado izquierdo es una instancia de la clase del lado derecho y evalúa a <codeinline>false</codeinline> en caso contrario. En el <a href="capitulo-9">capítulo 9</a> se explica que, en JavaScript, las clases de objetos se definen mediante la función constructora que los inicializa. Por lo tanto, el operando derecho de <codeinline>instanceof</codeinline> debe ser una función. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">let d = new Date(); // Crea un nuevo objeto con el constructor Date()
    d instanceof Date   // => true: d fue creado con Date()
    d instanceof Object // => true: todos los objetos son instancias de Object
    d instanceof Number // => false: d no es un objeto Number
    let a = [1, 2, 3];  // Creaun array con la sintaxis literal de array
    a instanceof Array  // => true: a es un array
    a instanceof Object // => true: todos los arrays son objectos
    a instanceof RegExp // => false: los arrays no son expresiones regulares</code></pre>
    <p>Tenga en cuenta que todos los objetos son <codeinline>Object.instanceof</codeinline>. instanceof considera las "superclases" cuando decide si un objeto es una instancia de una clase. Si el operando del lado izquierdo de <codeinline>instanceof</codeinline> no es un objeto, <codeinline>instanceof</codeinline> devuelve <codeinline>false</codeinline>. Si el operando del lado derecho no es una clase de objetos, lanza un <codeinline>TypeError</codeinline>.</p>
    <p>Para entender cómo funciona el operador <codeinline>instanceof</codeinline>, debes entender la "cadena de prototipos". Éste es el mecanismo de herencia de JavaScript, y se describe en <a href="capitulo-6#3-2">§6.3.2</a>. Para evaluar la expresión <codeinline>o instanceof f</codeinline>, JavaScript evalúa <codeinline>f.prototype</codeinline>, y luego busca ese valor en la cadena de prototipos de <codeinline>o</codeinline>. Si lo encuentra, entonces <codeinline>o</codeinline> es una instancia de <codeinline>f</codeinline> (o de una subclase de <codeinline>f</codeinline>) y el operador devuelve verdadero. Si <codeinline>f.prototype</codeinline> no es uno de los valores de la cadena prototipo de <codeinline>o</codeinline>, entonces <codeinline>o</codeinline> no es una instancia de <codeinline>f</codeinline> y <codeinline>instanceof</codeinline> devuelve <codeinline>false</codeinline>.</p>
  </section>
  <section id="10"class="py-4 xs:py-5 sm:py-6">
    <h2>4.10 Expresiones lógicas</h2>
    <p>Los operadores lógicos <codeinline>&&</codeinline>, <codeinline>||</codeinline> y <codeinline>!</codeinline> realizan álgebra booleana y se utilizan a menudo junto con los operadores relacionales para combinar dos expresiones relacionales en una expresión más compleja. Estos operadores se describen en las subsecciones siguientes. Para comprenderlos en su totalidad, puede que desee repasar el concepto de valores verdaderos (“truthy”) y falsos (“falsy”) introducido en <a href="capitulo-3#4">§3.4</a>.</p>
  </section>
</Layoutjavascript>