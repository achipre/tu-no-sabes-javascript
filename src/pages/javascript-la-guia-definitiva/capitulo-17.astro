---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-16" capSiguiente="#" />
  <section class="fadeIn">
    <h1>Herramientas y extensiones de JavaScript</h1>
    <p>Enhorabuena por haber llegado al último capítulo de este libro. Si has leído todo lo que viene antes, ahora tienes una comprensión detallada del lenguaje JavaScript y sabes cómo usarlo en Node y en los navegadores web. Este capítulo es una especie de regalo de graduación: introduce un puñado de herramientas de programación importantes que muchos programadores de JavaScript encuentran útiles, y también describe dos extensiones ampliamente utilizadas para el núcleo del lenguaje JavaScript. Tanto si decides utilizar estas herramientas y extensiones para tus propios proyectos como si no, es casi seguro que las verás utilizadas en otros proyectos, por lo que es importante que al menos sepas lo que son.</p>
    <p>Las herramientas y extensiones del lenguaje que se tratan en este capítulo son:</p>
    <ul> <li class="font-normal">ESLint para encontrar posibles errores y problemas de estilo en tu código.</li>
      <li class="font-normal">Prettier para dar formato a su código JavaScript de forma estandarizada.</li>
      <li class="font-normal">Jest como una solución todo-en-uno para escribir pruebas unitarias de JavaScript.</li>
      <li class="font-normal">npm para gestionar e instalar las bibliotecas de software de las que depende su programa.</li>
      <li class="font-normal">Herramientas de agrupación de código, como webpack, Rollup y Parcel, que convierten tus módulos de código JavaScript en un único paquete para su uso en la web.</li>
      <li class="font-normal">Babel para traducir código JavaScript que utiliza nuevas características del lenguaje (o que utiliza extensiones del lenguaje) en código JavaScript que puede ejecutarse en los navegadores web actuales.</li>
      <li class="font-normal">La extensión de lenguaje JSX (utilizada por el framework React) que permite describir interfaces de usuario mediante expresiones JavaScript que parecen marcas HTML.</li>
      <li class="font-normal">La extensión de lenguaje Flow (o la extensión similar TypeScript) que le permite anotar su código JavaScript con tipos y comprobar su código para la seguridad de tipos.</li>
    </ul>
    <p>Este capítulo no documenta estas herramientas y extensiones de forma exhaustiva. El objetivo es simplemente explicarlas con la suficiente profundidad como para que puedas entender por qué son útiles y cuándo podrías querer utilizarlas. Todo lo cubierto en este capítulo es ampliamente utilizado en el mundo de la programación JavaScript, y si decides adoptar una herramienta o extensión, encontrarás mucha documentación y tutoriales en línea.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>17.1 Linting con ESLint</h2>
    <p>En programación, el término lint se refiere a código que, aunque técnicamente correcto, es antiestético, o un posible bug, o subóptimo de alguna manera. Un linter es una herramienta para detectar pelusas en tu código, y linting es el proceso de ejecutar un linter en tu código (y luego arreglar tu código para eliminar las pelusas de modo que el linter ya no se queje).</p>
    <p>El linter más utilizado para JavaScript hoy en día es ESLint. Si lo ejecutas y luego te tomas el tiempo de arreglar los problemas que señala, hará que tu código sea más limpio y menos propenso a tener errores. Considere el siguiente código:</p>
    <p>Si ejecutas ESLint en este código, puede que obtengas una salida como esta:</p>
    <p>A veces, las cadenas pueden parecer puntillosas. ¿Realmente importa si usamos comillas dobles o simples para nuestras cadenas? Por otra parte, la sangría correcta es importante para la legibilidad, y el uso de === y let en lugar de == y var te protege. de errores sutiles. Y las variables no utilizadas son peso muerto en su código, no hay razón para mantenerlos alrededor.</p>
    <p>ESLint define muchas reglas de linting y tiene un ecosistema de plug-ins que añaden muchas más. Pero ESLint es totalmente configurable, y puedes definir un archivo de configuración que ajuste ESLint para que aplique exactamente las reglas que quieras y sólo esas reglas.</p>
  </section>
  <section id="2">
    <h2>17.2 Formateo JavaScript con Prettier </h2>
    <p>Una de las razones por las que algunos proyectos utilizan linters es para imponer un estilo de codificación coherente, de modo que cuando un equipo de programadores trabaje en una base de código compartida, utilice convenciones de código compatibles. Esto incluye reglas de sangrado de código, pero también puede incluir cosas como qué tipo de comillas son preferibles y si debe haber un espacio entre la palabra clave for y el paréntesis abierto que le sigue.</p>
    <p>Una alternativa moderna a la aplicación de reglas de formato de código mediante un linter es adoptar una herramienta como Prettier para analizar y reformatear automáticamente todo el código.</p>
    <p>Supongamos que ha escrito la siguiente función, que funciona, pero tiene un formato poco convencional:</p>
    <p>Al ejecutar Prettier en este código se corrige la sangría, se añaden los puntos y comas que faltan, se añaden espacios alrededor de los operadores binarios y se insertan saltos de línea después de &lbrace; y antes de }, lo que da como resultado un código de aspecto mucho más convencional:</p>
    <p>Si invoca Prettier con la opció n --write, simplemente reformateará el archivo especificado en su lugar en lugar de imprimir una versión reformateada. Si utiliza git para gestionar su código fuente, puede invocar Prettier con la opció n --write en un hook de confirmación para que el código se formatee automáticamente antes de ser registrado.</p>
    <p>Prettier es especialmente potente si configuras tu editor de código para que lo ejecute automáticamente cada vez que guardes un archivo. A mí me resulta liberador escribir código descuidado y ver cómo se corrige automáticamente.</p>
    <p>Prettier es configurable, pero sólo tiene unas pocas opciones. Puede seleccionar la longitud máxima de línea, la cantidad de sangría, si se debe usar punto y coma, si las cadenas deben estar entre comillas simples o dobles, y algunas otras cosas. En general, las opciones por defecto de Pretti- er son bastante razonables. La idea es que adopte Prettier para su proyecto y no tenga que pensar nunca más en el formato del código.</p>
    <p>Personalmente, me gusta mucho usar Prettier en proyectos JavaScript. Sin embargo, no lo he usado para el código de este libro, porque en gran parte de mi código dependo de un cuidadoso for- mado a mano para alinear mis comentarios verticalmente, y Prettier los desordena.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>17.3 Pruebas unitarias con Jest </h2>
    <p>Escribir pruebas es una parte importante de cualquier proyecto de programación no trivial. Los lenguajes dinámicos como JavaScript soportan marcos de pruebas que reducen drásticamente el esfuerzo necesario para escribir pruebas, ¡y casi hacen que escribir pruebas sea divertido! Hay muchas herramientas y librerías de pruebas para JavaScript, y muchas están escritas de forma modular, de modo que es posible elegir una librería como ejecutor de pruebas, otra librería para aserciones y una tercera para mocking. En esta sección, sin embargo, describiremos Jest, que es un framework popular que incluye todo lo que necesitas en un solo paquete.</p>
    <p>Suponga que ha escrito la siguiente función:</p>
    <p>Un buen conjunto de pruebas para esta función podría verificar que getTemperature() está obteniendo la URL correcta, y que está convirtiendo las escalas de temperatura correctamente. Podemos hacer esto con una prueba basada en Jest como la siguiente. Este código define una implementación simulada de getJSON() para que la prueba no haga realmente una petición de red. Y como getTemperature() es una función asíncrona, las pruebas también son asíncronas; puede ser complicado probar funciones asíncronas, pero Jest lo hace relativamente fácil:</p>
    <p>Con la prueba escrita, podemos utilizar el comando jest para ejecutarla, y descubrimos que una de nuestras pruebas falla:</p>
    <p>Nuestra implementación de getTemperature() está utilizando una fórmula incorrecta para convertir C a F. Multiplica por 5 y divide por 9 en lugar de multiplicar por 9 y dividir por 5. Si corregimos el código y ejecutamos Jest de nuevo, podemos ver que las pruebas pasan. Y, como extra, si añadimos el argumento --coverage cuando invoquemos a jest, calculará y mostrará la cobertura del código para nuestras pruebas:</p>
    <p>La ejecución de nuestra prueba nos dio una cobertura de código del 100% para el módulo que estábamos probando, que es exactamente lo que queríamos. Sólo nos dio una cobertura parcial de getJSON(), pero nos burlamos de ese módulo y no estábamos tratando de probarlo, así que es de esperar.</p>
  </section>
  <section id="4">
    <h2>17.4 Gestión de paquetes con npm </h2>
    <p>En el desarrollo de software moderno, es habitual que cualquier programa no trivial que escribas dependa de librerías de software de terceros. Si estás escribiendo un servidor web en Node, por ejemplo, puede que estés usando el framework Express. Y si estás creando una interfaz de usuario para ser mostrada en un navegador web, podrías usar un marco de trabajo front-end como React o LitElement o Angular. Un gestor de paquetes facilita la búsqueda e instalación de paquetes de terceros como estos. Igualmente importante, un gestor de paquetes realiza un seguimiento de los paquetes de los que depende tu código y guarda esta información en un archivo para que cuando alguien más quiera probar tu programa, pueda descargar tu código y tu lista de dependencias, y luego usar su propio gestor de paquetes para instalar todos los paquetes de terceros que tu código necesita.</p>
    <p>npm es el gestor de paquetes que se incluye con Node, y se introdujo en §16.1.5. Sin embargo, es tan útil para la programación JavaScript del lado del cliente como para la programación del lado del servidor con Node.</p>
    <p>Si estás probando el proyecto JavaScript de otra persona, una de las primeras cosas que harás después de descargar su código es escribir npm install. Esto lee las dependencias listadas en el archivo package.json y descarga los paquetes de terceros que el proyecto necesita y los guarda en un directorio node_modules/.</p>
    <p>También puedes escribir npm install &lt;nombre-paquete> para instalar un paquete concreto en el directorio node_modules/ de tu proyecto:</p>
    <p>Además de instalar el paquete nombrado, npm también hace un registro de la dependencia en el archivo package.json para el proyecto. Registrar las dependencias de esta manera es lo que permite a otros instalar esas dependencias simplemente escribiendo npm install.</p>
    <p>El otro tipo de dependencia son las herramientas de desarrollo que necesitan los desarrolladores que quieren trabajar en su proyecto, pero que en realidad no son necesarias para ejecutar el código. Si un proyecto utiliza Prettier, por ejemplo, para asegurar que todo su código tiene un formato consistente, entonces Prettier es una "dependencia dev", y puede instalar y grabar una de ellas con --save-dev:</p>
    <p>A veces es posible que desee instalar herramientas de desarrollo a nivel mundial para que sean accesibles en cualquier lugar, incluso para el código que no forma parte de un proyecto formal con un archivo package.json y un directorio node_modules/. Para ello puedes utilizar la opción -g (for global):</p>
    <p>Además del comando "install", npm soporta los comandos "uninstall" y "update", que hacen lo que su nombre indica. npm también tiene un interesante comando "audit" que puedes usar para encontrar y corregir vulnerabilidades de seguridad en tus dependencias:</p>
    <p>Cuando se instala una herramienta como ESLint localmente para un proyecto, el script eslint termina en ./ node_modules/.bin/eslint, lo que hace que el comando sea incómodo de ejecutar. Afortunadamente, npm viene con un comando conocido como "npx", que puede utilizar para ejecutar herramientas instaladas localmente con comandos como npx eslint o npx jest. (Y si usas npx para invocar una herramienta que aún no ha sido instalada, la instalará por ti).</p>
    <p>La empresa detrás de npm también mantiene el repositorio de paquetes https://npmjs.com, que contiene cientos de miles de paquetes de código abierto. Pero no es necesario utilizar el gestor de paquetes npm para acceder a este repositorio de paquetes. Otras alternativas son yarn y pnpm.</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>17.5 Agrupación de códigos</h2>
    <p>Si estás escribiendo un gran programa JavaScript para ejecutarlo en navegadores web, probablemente querrás usar una herramienta de agrupación de código, especialmente si usas librerías externas que se entregan como módulos. Los desarrolladores web han estado utilizando módulos ES6 (§10.3) durante años, desde mucho antes de que las palabras clave import y export fueran soportadas en la web. Para ello, los programadores utilizan una herramienta de agrupación de código que comienza en el punto de entrada principal (o puntos de entrada) del programa y sigue el árbol de directivas de importación para encontrar todos los módulos de los que depende el programa. A continuación, combina todos esos archivos de módulos individuales en un único paquete de código JavaScript y reescribe las directivas de importación y exportación para que el código funcione en esta nueva forma. El resultado es un único archivo de código que puede cargarse en un navegador web que no admita módulos.</p>
    <p>En la actualidad, los navegadores web soportan casi universalmente los módulos ES6, pero los desarrolladores web aún tienden a utilizar paquetes de código, al menos cuando publican código de producción. Los desarrolladores consideran que la experiencia del usuario es mejor cuando se carga un único paquete de código de tamaño medio la primera vez que visita un sitio web que cuando se cargan muchos módulos pequeños.</p>
    <p>Existen varias herramientas de empaquetado de JavaScript. Entre los más utilizados se encuentran webpack, Rollup y Parcel. Las características básicas de los bundlers son más o menos las mismas, y se diferencian en función de lo configurables que son o de lo fáciles que son de usar. Webpack existe desde hace mucho tiempo, tiene un gran ecosistema de plug-ins, es altamente configurable y puede soportar librerías antiguas que no son módulos. Pero también puede ser complejo y difícil de configurar. En el otro extremo del espectro está Parcel, que pretende ser una alternativa de configuración cero que simplemente hace lo correcto.</p>
    <p>Además de realizar la agrupación básica, las herramientas de agrupación también pueden proporcionar algunas funciones adicionales:</p>
    <ul>
      <li class="font-normal">Algunos programas tienen más de un punto de entrada. Una aplicación web con múltiples páginas, por ejemplo, podría escribirse con un punto de entrada diferente para cada página. Por lo general, los agrupadores permiten crear un paquete por punto de entrada o crear un único paquete que admita varios puntos de entrada.</li>
      <li class="font-normal">Los programas pueden usar import() en su forma funcional (§10.3.6) en lugar de su forma estática para cargar dinámicamente los módulos cuando son realmente necesarios en lugar de cargarlos estáticamente al iniciar el programa. Hacer esto es a menudo una buena manera de mejorar el tiempo de arranque de su programa. Las herramientas Bundler que soportan import() pueden ser capaces de producir múltiples paquetes de salida: uno para cargar en el momento de inicio, y uno o más que se cargan dinámicamente cuando sea necesario. Esto puede funcionar bien si sólo hay unas pocas llamadas a import() en su programa y cargan módulos con conjuntos relativamente disjuntos de dependencias. Si los módulos cargados dinámicamente comparten dependencias, entonces se vuelve complicado averiguar cuántos bundles producir, y es probable que tenga que configurar manualmente su bundler para resolver esto.</li>
      <li class="font-normal">Por lo general, los empaquetadores pueden generar un archivo de mapa de código fuente que define una correspondencia entre las líneas de código del paquete y las líneas correspondientes de los archivos fuente originales. Esto permite que las herramientas de desarrollo de navegadores muestren automáticamente los errores de JavaScript en sus ubicaciones originales.</li>
      <li class="font-normal">A veces, cuando importas un módulo a tu programa, sólo utilizas algunas de sus funciones. Una buena herramienta de bundler puede analizar el código para determinar qué partes no se utilizan y pueden omitirse de los bundles. Esta función recibe el caprichoso nombre de "tree-shaking".</li>
      <li class="font-normal">Los agrupadores suelen tener una arquitectura basada en plug-ins y admiten plug-ins que permiten importar y agrupar "módulos" que en realidad no son archivos de código JavaScript. Supongamos que su programa incluye una gran estructura de datos compatible con JSON. Los agrupadores de código pueden configurarse para permitirle mover esa estructura de datos a un archivo JSON independiente y luego importarlo a su programa con una declaración como import widgets from "./big-widget-list.json". Del mismo modo, los desarrolladores web que incrustan CSS en sus programas JavaScript pueden utilizar plug-ins de bundler que les permiten importar archivos CSS con una directiva de importación. Tenga en cuenta, sin embargo, que si importa cualquier cosa que no sea un archivo JavaScript, está utilizando una extensión JavaScript no estándar y haciendo que su código dependa de la herramienta bundler.</li>
      <li class="font-normal">En un lenguaje como JavaScript, que no requiere compilación, ejecutar una herramienta de bun- dler parece un paso de compilación, y es frustrante tener que ejecutar un bun- dler después de cada edición de código antes de poder ejecutar el código en el navegador. Los bundlers normalmente soportan vigilantes del sistema de archivos que detectan ediciones en cualquier archivo de un directorio de proyecto y regeneran automáticamente los bundles necesarios. C o n esta función, puedes guardar el código y volver a cargar inmediatamente la ventana del navegador para probarlo.</li>
      <li class="font-normal">Algunos bundlers también admiten un modo de "sustitución de módulos en caliente" para desarrolladores en el que cada vez que se regenera un bundle, éste se carga automáticamente en el navegador. Cuando esto funciona, es una experiencia mágica para los desarrolladores, pero hay algunos trucos bajo el capó para que funcione, y no es adecuado para todos los proyectos.</li>
    </ul>
  </section>
  <section id="6">
    <h2>17.6 Transpilación con Babel</h2>
    <p>Babel es una herramienta que compila JavaScript escrito con características del lenguaje moderno en JavaScript que no utiliza esas características del lenguaje moderno. Dado que compila JavaScript a JavaScript, Babel recibe a veces el nombre de "transpilador". Babel se creó para que los desarrolladores web pudieran utilizar las nuevas características del lenguaje ES6 y posteriores sin dejar de utilizar los navegadores web que sólo admitían ES5.</p>
    <p>Características del lenguaje como el operador de exponenciación ** y las funciones de flecha pueden transformarse con relativa facilidad en Math.pow() y expresiones de función. Otras características del lenguaje, como la palabra clave class, requieren transformaciones mucho más complejas y, en general, la salida de código de Babel no está pensada para ser legible por humanos. Sin embargo, al igual que las herramientas de empaquetado, Babel puede producir mapas de código fuente que asignan las ubicaciones del código transformado a sus ubicaciones de código fuente originales, lo que ayuda enormemente a la hora de trabajar con código transformado.</p>
    <p>Los proveedores de navegadores están haciendo un mejor trabajo para mantenerse al día con la evolución del lenguaje Java Script, y hoy en día hay mucha menos necesidad de compilar funciones de flecha y declaraciones de clase. Babel todavía puede ayudar cuando se desea utilizar las últimas características como separadores de guión bajo en literales numéricos.</p>
    <p>Como la mayoría de las otras herramientas descritas en este capítulo, puedes instalar Babel con npm y ejecutarlo con npx. Babel lee un archivo de configuración .babelrc</p>
    <p>que le indica cómo desea que se transforme su código JavaScript. Babel define "presets" entre los que puedes elegir dependiendo de las extensiones del lenguaje que quieras usar y de la agresividad con la que quieras transformar las características estándar del lenguaje. Uno de los presets interesantes es para la compresión de código mediante minificación (eliminación de comentarios y espacios en blanco, renombramiento de variables, etc.).</p>
    <p>Si utiliza Babel y una herramienta de agrupación de código, puede configurar el agrupador de código para que ejecute automáticamente Babel en sus archivos JavaScript a medida que construye el paquete para usted. Si es así, puede ser una opción conveniente porque simplifica el proceso de producción de código ejecutable. Webpack, por ejemplo, admite un módulo "babel-loader" que puede instalar y configurar para ejecutar Babel en cada módulo JavaScript a medida que se agrupa.</p>
    <p>Aunque hoy en día hay menos necesidad de transformar el núcleo del lenguaje JavaScript, Babel se sigue utilizando habitualmente para soportar extensiones no estándar del lenguaje, y describiremos dos de estas extensiones del lenguaje en las secciones siguientes.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>17.7 JSX: Expresiones de marcado en JavaScript</h2>
    <p>JSX es una extensión del núcleo de JavaScript que utiliza sintaxis de estilo HTML para definir un árbol de elementos. JSX se asocia más estrechamente con el marco React para interfaces de usuario en la web. En React, los árboles de elementos definidos con JSX se renderizan en última instancia en un navegador web como HTML. Incluso si no tienes planes de utilizar React, su popularidad significa que es probable que veas código que utiliza JSX. Esta sección explica lo que necesitas saber para darle sentido. (Esta sección es sobre la extensión de lenguaje JSX, no sobre React, y explica sólo lo suficiente de React para proporcionar contexto para la sintaxis JSX).</p>
    <p>Los elementos JSX son un nuevo tipo de sintaxis de expresión de JavaScript. Los literales de cadena de Java Script se delimitan con comillas, y los literales de expresión regular se delimitan con barras oblicuas. Del mismo modo, los literales de expresiones JSX se delimitan con corchetes angulares. He aquí una muy sencilla:</p>
    <p>Si utiliza JSX, tendrá que utilizar Babel (o una herramienta similar) para compilar las expresiones JSX en JavaScript normal. La transformación es tan sencilla que algunos desarrolladores optan por utilizar React sin usar JSX. Babel transforma la expresión JSX de esta sentencia de asignación en una simple llamada a una función:</p>
    <p>La sintaxis JSX es similar a HTML, y al igual que los elementos HTML, los elementos React pueden tener atributos como estos:</p>
    <p>Cuando un elemento tiene uno o más atributos, éstos se convierten en propiedades de un objeto pasado como segundo argumento a createElement():</p>
    <p>Al igual que los elementos HTML, los elementos JSX pueden tener cadenas y otros elementos como hijos. Al igual que los operadores aritméticos de JavaScript pueden utilizarse para escribir expresiones aritméticas de complejidad arbitraria, los elementos JSX también pueden anidarse a una profundidad arbitraria para crear árboles de elementos:</p>
    <p>Las expresiones regulares de llamadas a funciones JavaScript también pueden anidarse a una profundidad arbitraria, y estas expresiones JSX anidadas se traducen en un conjunto de llamadas createElement() anidadas. Cuando un elemento JSX tiene hijos, esos hijos (que suelen ser cadenas y otros elementos JSX) se pasan como argumentos tercero y siguientes:</p>
    <p>El valor devuelto por React.createElement() es un objeto JavaScript ordinario que es utilizado por React para renderizar la salida en una ventana del navegador. Dado que esta sección trata sobre la sintaxis JSX y no sobre React, no vamos a entrar en detalles sobre los objetos Element devueltos o el proceso de renderizado. Vale la pena señalar que puedes configurar Babel para compilar elementos JSX a invocaciones de una función diferente, por lo que si crees que la sintaxis JSX sería una forma útil de expresar otros tipos de estructuras de datos anidadas, puedes adoptarla para tus propios usos no relacionados con React.</p>
    <p>Una característica importante de la sintaxis JSX es que puede incrustar expresiones JavaScript regulares dentro de expresiones JSX. Dentro de una expresión JSX, el texto entre llaves se interpreta como JavaScript plano. Estas expresiones anidadas están permitidas como valores de atributo y como elementos hijos. Por ejemplo:</p>
    <p>La función sidebar() devuelve un elemento JSX. Toma cuatro argumentos que utiliza dentro del elemento JSX. La sintaxis de llaves puede recordarle los literales de plantilla que utilizan $&lbrace;} para incluir expresiones JavaScript dentro de cadenas. Como sabemos que las expresiones JSX se compilan en invocaciones de funciones, no debería sorprendernos que se puedan incluir expresiones JavaScript arbitrarias, ya que las invocaciones de funciones también se pueden escribir con expresiones arbitrarias. Este código de ejemplo es traducido por Babel a lo siguiente:</p>
    <p>Este código es fácil de leer y entender: las llaves han desaparecido y el código resultante pasa los parámetros de la función entrante a React.createElement() de forma natural. Fíjate en el truco que hemos hecho aquí con el parámetro drawLine y el operador && de cortocircuito. Si llamas a sidebar() con sólo tres argumentos, entonces drawLine por defecto es true, y el cuarto argumento de la llamada externa a createElement() es el elemento &lt;hr/>. Pero si pasa false como cuarto argumento a sidebar(), entonces el cuarto argumento de la llamada externa a createElement() se evalúa como false, y no se crea ningún elemento &lt;hr/>. Este uso del operador && es un lenguaje común en JSX para incluir o excluir condicionalmente un elemento hijo dependiendo del valor de alguna otra expresión. (Este modismo funciona con React porque React simplemente ignora los hijos que son falsos o nulos y no produce ninguna salida para ellos).</p>
    <p>Cuando utiliza expresiones JavaScript dentro de expresiones JSX, no está limitado a valores simples como los valores de cadena y booleano del ejemplo anterior. Cualquier valor Java Script está permitido. De hecho, es bastante común en la programación React utilizar objetos, matrices y funciones. Considera la siguiente función, por ejemplo:</p>
    <p>Esta función utiliza un objeto literal como valor del atributo style del elemento &lt;ul>. (El elemento &lt;ul> tiene un único hijo, pero el valor de ese hijo es una matriz. La matriz hija es la matriz creada mediante la función map() en la matriz de entrada para crear una matriz de elementos &lt;li>.</p>
    <p>(Esto funciona con React porque la librería React aplana los hijos de un elemento cuando los renderiza. Un elemento con un array hijo es lo mismo que ese elemento con cada uno de esos elementos del array como hijos). Por último, ten en cuenta que cada una de las matrices anidadas &lt;li> tiene un atributo manejador de eventos onClick cuyo valor es una función de flecha. El código JSX compila al siguiente código JavaScript puro (que he formatulado con Prettier):</p>
    <p>Otro uso de las expresiones de objeto en JSX es con el operador de extensión de objeto (§6.10.4) para especificar múltiples atributos a la vez. Supón que te encuentras escribiendo muchas expresiones JSX que repiten un conjunto común de atributos. Puedes simplificar tus expresiones definiendo los atributos como propiedades de un objeto y "esparciéndolos" en tus elementos JSX:</p>
    <p>Babel compila esto para utilizar una función _extends() (omitida aquí) que combina que atributo className con los atributos contenidos en el objeto hebreo:</p>
    <p>Por último, hay otra característica importante de JSX que aún no hemos cubierto. Como has visto, todos los elementos JSX comienzan con un identificador inmediatamente después del paréntesis angular de apertura. Si la primera letra de este identificador es minúscula (como ha sido en todos los ejemplos aquí), entonces el identificador se pasa a createElement() como una cadena. Pero si la primera letra del identificador es mayúscula, entonces se trata como un identificador real, y es el valor JavaScript de ese identificador el que se pasa como primer argumento a createElement(). Esto significa que la expresión JSX &lt;Math/> compila código JavaScript que pasa el objeto Math global a React.createElement().</p>
    <p>Para React, esta capacidad de pasar valores no string como primer argumento a createEle ment() permite la creación de componentes. Un componente es una forma de escribir un simple</p>
    <p>Expresión JSX (con un nombre de componente en mayúsculas) que representa una expresión más compleja (utilizando nombres de etiqueta HTML en minúsculas).</p>
    <p>La forma más sencilla de definir un nuevo componente en React es escribir una función que tome un "objeto props" como argumento y devuelva una expresión JSX. Un objeto props es simplemente un objeto JavaScript que representa valores de atributos, como los objetos que se pasan como segundo argumento a createElement(). He aquí, por ejemplo, otra versión de nuestra función sidebar():</p>
    <p>Esta nueva función Sidebar() es muy parecida a la función anterior sidebar(). Pero ésta tiene un nombre que empieza por mayúscula y toma un único argumento objeto en lugar de argumentos separados. Esto la convierte en un componente React y significa que puede utilizarse en lugar de un nombre de etiqueta HTML en expresiones JSX:</p>
    <p>Este elemento &lt;Sidebar/> se compila así:</p>
    <p>Es una simple expresión JSX, pero cuando React la renderice, pasará el segundo argumento (el objeto Props) al primer argumento (la función Sidebar()) y utilizará la expresión JSX devuelta por esa función en lugar de la expresión &lt;Sidebar>.</p>
  </section>
  <section id="8">
    <h2>17.8 Comprobación de tipos con Flow</h2>
    <p>Flow es una extensión de lenguaje que te permite anotar tu código JavaScript con información de tipo, y una herramienta para comprobar tu código JavaScript (tanto anotado como no anotado) en busca de errores de tipo. Para utilizar Flow, empieza a escribir código utilizando la extensión de lenguaje Flow para añadir anotaciones de tipo. A continuación, ejecuta la herramienta Flow para analizar el código e informar de los errores tipográficos. Una vez que haya corregido los errores y esté listo para ejecutar el código, utilice Babel (quizás automáticamente como parte del proceso de agrupación de código) para eliminar las anotaciones de tipo de Flow de su código. (Una de las cosas buenas de la extensión del lenguaje Flow es que no hay ninguna sintaxis nueva que Flow tenga que compilar o transformar. Utilizas la extensión del lenguaje Flow para añadir anotaciones al código, y todo lo que Babel tiene que hacer es quitar esas anotaciones para devolver tu código a JavaScript estándar).</p>
    <article>
      <p class="title-article">TypeScript frente a Flow</p>
      <p>TypeScript es una alternativa muy popular a Flow. TypeScript es una extensión de Java-Script que añade tipos así como otras características del lenguaje. El compilador de TypeScript "tsc" compila programas TypeScript en programas JavaScript y en el proceso los analiza e informa de errores de tipo de la misma manera que lo hace Flow. tsc no es un plugin de Babel: es su propio compilador independiente.</p>
      <p>Las anotaciones de tipo simples en TypeScript se escriben normalmente de forma idéntica a las mismas anotaciones en Flow. Para tipado más avanzado, la sintaxis de las dos extensiones diverge, pero la intención y el valor de las dos extensiones es el mismo. Mi objetivo en esta sección es explicar los beneficios de las anotaciones de tipo y el análisis estático de código. Lo haré con ejemplos basados en Flow, pero todo lo demostrado aquí también se puede lograr con TypeScript con cambios de sintaxis relativamente simples.</p>
      <p>TypeScript fue lanzado en 2012, antes de ES6, cuando JavaScript no tenía una palabra clave class o un bucle for/of o módulos o Promises. Flow es una extensión limitada del lenguaje que añade anotaciones de tipo a JavaScript y nada más. TypeScript, por el contrario, fue diseñado como un nuevo lenguaje. Como su nombre indica, añadir tipos a JavaScript es el propósito principal de TypeScript, y es la razón por la que la gente lo usa hoy en día. Pero los tipos no son la única característica que TypeScript añade a JavaScript: el lenguaje TypeScript tiene palabras clave enum y namespace que simplemente no existen en JavaScript. En 2020, TypeScript tiene una mejor integración con IDEs y editores de código (particularmente VSCode, que, como TypeScript, es de Microsoft) que Flow.</p>
      <p>En última instancia, este es un libro sobre JavaScript, y estoy cubriendo Flow aquí en lugar de TypeScript porque no quiero quitarle protagonismo a JavaScript. Pero todo lo que aprendas aquí sobre añadir tipos a JavaScript te será útil si decides adoptar TypeScript para tus proyectos.</p>
    </article>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.1 Instalación y funcionamiento de Flow</h2>
  </section>
  <section id="8-2">
    <h2>17.8.2 Uso de anotaciones de tipo</h2>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.3 Tipos de clases</h2>
  </section>
  <section id="8-4">
    <h2>17.8.4 Tipos de objetos</h2>
  </section>
  <section id="8-5" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.5 Alias de tipo</h2>
  </section>
  <section id="8-6">
    <h2>17.8.6 Tipos de matrices</h2>
  </section>
  <section id="8-7" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.7 Otros tipos parametrizados</h2>
  </section>
  <section id="8-8">
    <h2>17.8.8 Tipos de sólo lectura</h2>
  </section>
  <section id="8-9" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.9 Tipos de funciones</h2>
  </section>
  <section id="8-10">
    <h2>17.8.10 Tipos de sindicatos</h2>
  </section>
  <section id="8-11" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.11 Tipos enumerados y uniones discriminadas</h2>
  </section>
  <section id="9" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>17.9 Resumen</h2>
  </section>
  </Layoutjavascript>