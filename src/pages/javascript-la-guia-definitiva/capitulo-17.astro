---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-16" capSiguiente="#" />
  <section class="fadeIn">
    <h1 class="text-right">Herramientas y extensiones de JavaScript</h1>
    <p>Enhorabuena por haber llegado al último capítulo de este libro. Si has leído todo lo que viene antes, ahora tienes una comprensión detallada del lenguaje JavaScript y sabes cómo usarlo en Node y en los navegadores web. Este capítulo es una especie de regalo de graduación: introduce un puñado de herramientas de programación importantes que muchos programadores de JavaScript encuentran útiles, y también describe dos extensiones ampliamente utilizadas para el núcleo del lenguaje JavaScript. Tanto si decides utilizar estas herramientas y extensiones para tus propios proyectos como si no, es casi seguro que las verás utilizadas en otros proyectos, por lo que es importante que al menos sepas lo que son.</p>
    <p>Las herramientas y extensiones del lenguaje que se tratan en este capítulo son:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>ESLint para encontrar posibles errores y problemas de estilo en tu código.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>Prettier para dar formato a su código JavaScript de forma estandarizada.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>Jest como una solución todo-en-uno para escribir pruebas unitarias de JavaScript.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>npm para gestionar e instalar las bibliotecas de software de las que depende su programa.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>Herramientas de agrupación de código, como webpack, Rollup y Parcel, que convierten tus módulos de código JavaScript en un único paquete para su uso en la web.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>Babel para traducir código JavaScript que utiliza nuevas características del lenguaje (o que utiliza extensiones del lenguaje) en código JavaScript que puede ejecutarse en los navegadores web actuales.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>La extensión de lenguaje JSX (utilizada por el framework React) que permite describir interfaces de usuario mediante expresiones JavaScript que parecen marcas HTML.</p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>La extensión de lenguaje Flow (o la extensión similar TypeScript) que le permite anotar su código JavaScript con tipos y comprobar su código para la seguridad de tipos.</p>
      </li>
    </ul>
    <p>Este capítulo no documenta estas herramientas y extensiones de forma exhaustiva. El objetivo es simplemente explicarlas con la suficiente profundidad como para que puedas entender por qué son útiles y cuándo podrías querer utilizarlas. Todo lo cubierto en este capítulo es ampliamente utilizado en el mundo de la programación JavaScript, y si decides adoptar una herramienta o extensión, encontrarás mucha documentación y tutoriales en línea.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>17.1 Linting con ESLint</h2>
    <p>En programación, el término <em>lint</em> se refiere a código que, aunque técnicamente correcto, es antiestético, o un posible bug, o subóptimo de alguna manera. Un <em>linter</em> es una herramienta para detectar pelusas en tu código, y <em>linting</em> es el proceso de ejecutar un linter en tu código (y luego arreglar tu código para eliminar las pelusas de modo que el linter ya no se queje).</p>
    <p>El linter más utilizado para JavaScript hoy en día es <a href="https://eslint.org/">ESLint</a>. Si lo ejecutas y luego te tomas el tiempo de arreglar los problemas que señala, hará que tu código sea más limpio y menos propenso a tener errores. Considere el siguiente código:</p>
    <pre class="language-js">
    <code>var x = 'unused';

    export function factorial(x) &lbrace;
      if (x == 1) &lbrace;
        return 1;
      } else &lbrace;
        return x * factorial(x-1)
      }
    }</code></pre>
    <p>Si ejecutas ESLint en este código, puede que obtengas una salida como esta:</p>
    <pre class="language-js">
    $ eslint code/ch17/linty.js

    code/ch17/linty.js
      1:1   error   Unexpected var, use let or const instead      no-var
      1:5   error   'x' is assigned a value but never used        no-unused-vars
      1:9   warning Strings must use doublequote                  quotes
      4:11  error   Expected '===' and instead saw '=='           eqeqeq
      5:1   error   Expected indentation of 8 spaces but found 6  indent
      7:28  error   Missing semicolon                             semi

    ✖ 6 problems (5 errors, 1 warning)
      3 errors and 1 warning potentially fixable with the `--fix` option.</pre>
    <p>A veces, las cadenas pueden parecer puntillosas. ¿Realmente importa si usamos comillas dobles o simples para nuestras cadenas? Por otra parte, la sangría correcta es importante para la legibilidad, y el uso de <codeinline>===</codeinline> y let en lugar de <codeinline>==</codeinline> y var te protege. de errores sutiles. Y las variables no utilizadas son peso muerto en su código, no hay razón para mantenerlos alrededor.</p>
    <p>ESLint define muchas reglas de linting y tiene un ecosistema de plug-ins que añaden muchas más. Pero ESLint es totalmente configurable, y puedes definir un archivo de configuración que ajuste ESLint para que aplique exactamente las reglas que quieras y sólo esas reglas.</p>
  </section>
  <section id="2">
    <h2>17.2 Formateo JavaScript con Prettier </h2>
    <p>Una de las razones por las que algunos proyectos utilizan linters es para imponer un estilo de codificación coherente, de modo que cuando un equipo de programadores trabaje en una base de código compartida, utilice convenciones de código compatibles. Esto incluye reglas de sangrado de código, pero también puede incluir cosas como qué tipo de comillas son preferibles y si debe haber un espacio entre la palabra clave <codeinline>for</codeinline> y el paréntesis abierto que le sigue.</p>
    <p>Una alternativa moderna a la aplicación de reglas de formato de código mediante un linter es adoptar una herramienta como <a href="https://prettier.io/">Prettier</a> para analizar y reformatear automáticamente todo el código.</p>
    <p>Supongamos que ha escrito la siguiente función, que funciona, pero tiene un formato poco convencional:</p>
    <pre class="language-js">
    <code>function factorial(x)
    &lbrace;
      if(x===1)&lbrace;return 1}
      else&lbrace;return x*factorial(x-1)}
    }</code></pre>
    <p>Al ejecutar Prettier en este código se corrige la sangría, se añaden los puntos y comas que faltan, se añaden espacios alrededor de los operadores binarios y se insertan saltos de línea después de <codeinline>&lbrace;</codeinline> y antes de <codeinline>}</codeinline>, lo que da como resultado un código de aspecto mucho más convencional:</p>
    <pre class="language-js">
    <code>$ prettier factorial.js
    function factorial(x) &lbrace;
      if (x === 1) &lbrace;
        return 1;
      } else &lbrace;
        return x * factorial(x - 1);
      }
    }</code></pre>
    <p>Si invoca Prettier con la opció n <codeinline>--write</codeinline>, simplemente reformateará el archivo especificado en su lugar en lugar de imprimir una versión reformateada. Si utiliza <codeinline>git</codeinline> para gestionar su código fuente, puede invocar Prettier con la opció n <codeinline>--write</codeinline> en un hook de confirmación para que el código se formatee automáticamente antes de ser registrado.</p>
    <p>Prettier es especialmente potente si configuras tu editor de código para que lo ejecute automáticamente cada vez que guardes un archivo. A mí me resulta liberador escribir código descuidado y ver cómo se corrige automáticamente.</p>
    <p>Prettier es configurable, pero sólo tiene unas pocas opciones. Puede seleccionar la longitud máxima de línea, la cantidad de sangría, si se debe usar punto y coma, si las cadenas deben estar entre comillas simples o dobles, y algunas otras cosas. En general, las opciones por defecto de Prettier son bastante razonables. La idea es que adopte Prettier para su proyecto y no tenga que pensar nunca más en el formato del código.</p>
    <p>Personalmente, me gusta mucho usar Prettier en proyectos JavaScript. Sin embargo, no lo he usado para el código de este libro, porque en gran parte de mi código dependo de un cuidadoso for- mado a mano para alinear mis comentarios verticalmente, y Prettier los desordena.</p>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>17.3 Pruebas unitarias con Jest </h2>
    <p>Escribir pruebas es una parte importante de cualquier proyecto de programación no trivial. Los lenguajes dinámicos como JavaScript soportan marcos de pruebas que reducen drásticamente el esfuerzo necesario para escribir pruebas, ¡y casi hacen que escribir pruebas sea divertido! Hay muchas herramientas y librerías de pruebas para JavaScript, y muchas están escritas de forma modular, de modo que es posible elegir una librería como ejecutor de pruebas, otra librería para aserciones y una tercera para mocking. En esta sección, sin embargo, describiremos <a href="https://jestjs.io/">Jest</a>, que es un framework popular que incluye todo lo que necesitas en un solo paquete.</p>
    <p>Suponga que ha escrito la siguiente función:</p>
    <pre class="language-js">
    <code>const getJSON = require("./getJSON.js");

    /**
    * getTemperature() toma el nombre de una ciudad como entrada y devuelve 
    * una Promesa que se resolverá en la temperatura actual de esa ciudad, 
    * en grados Fahrenheit. Se basa en un servicio web (falso) que devuelve 
    * las temperaturas mundiales en grados Celsius.  
    */
    module.exports = async function getTemperature(city) &lbrace;
      // Obtén la temperatura en Celsius del servicio web
      let c = await getJSON(
        `https://globaltemps.example.com/api/city/$&lbrace;city.toLowerCase()}`
      );
      // Convierte a Fahrenheit y devuelve ese valor.
      return (c * 5 / 9) + 32; // TODO: vuelve a comprobar esta fórmula
    };</code></pre>
    <p>Un buen conjunto de pruebas para esta función podría verificar que <codeinline>getTemperature()</codeinline> está obteniendo la URL correcta, y que está convirtiendo las escalas de temperatura correctamente. Podemos hacer esto con una prueba basada en Jest como la siguiente. Este código define una implementación simulada de <codeinline>getJSON()</codeinline> para que la prueba no haga realmente una petición de red. Y como <codeinline>getTemperature()</codeinline> es una función asíncrona, las pruebas también son asíncronas; puede ser complicado probar funciones asíncronas, pero Jest lo hace relativamente fácil:</p>
    <pre class="language-js">
    <code>// Importa la función que vamos a probar
    const getTemperature = require("./getTemperature.js");

    // Y simula el módulo getJSON() del que depende getTemperature()
    jest.mock("./getJSON");
    const getJSON = require("./getJSON.js");

    // Dile a la función simulada getJSON() que devuelva una Promesa 
    // ya resuelta con el valor de cumplimiento 0.
    getJSON.mockResolvedValue(0);

    // Nuestro conjunto de pruebas para getTemperature() comienza aquí
    describe("getTemperature()", () => &lbrace;
      // Esta es la primera prueba. Nos aseguramos de que getTemperature() 
      // llame a getJSON() con la URL que esperamos
      test("Invokes the correct API", async () => &lbrace;
        let expectedURL = "https://globaltemps.example.com/api/city/vancouver";
        let t = await(getTemperature("Vancouver"));
        // Las simulaciones de Jest recuerdan cómo se las llamó y podemos comprobarlo.
        expect(getJSON).toHaveBeenCalledWith(expectedURL);
      });

      // Esta segunda prueba verifica que getTemperature() convierte 
      // Celsius a Fahrenheit correctamente
      test("Converts C to F correctly", async () => &lbrace;
        getJSON.mockResolvedValue(0); // Si getJSON devuelve 0C
        expect(await getTemperature("x")).toBe(32); // Esperamos 32F

        // 100C debería convertirse a 212F
        getJSON.mockResolvedValue(100); // Si getJSON devuelve 100C
        expect(await getTemperature("x")).toBe(212); // Esperamos 212F
      });
    });</code></pre>
    <p>Con la prueba escrita, podemos utilizar el comando <codeinline>jest</codeinline> para ejecutarla, y descubrimos que una de nuestras pruebas falla:</p>
    <pre class="language-js">
    $ jest getTemperature
      FAIL ch17/getTemperature.test.js
        getTemperature()
          ✓ Invokes the correct API (4ms)
          ✕ Converts C to F correctly (3ms)

        ● getTemperature() › Converts C to F correctly

        expect(received).toBe(expected) // Object.is equality

        Expected: 212
        Received: 87.55555555555556

        29 |    // 100C should convert to 212F
        30 |    getJSON.mockResolvedValue(100); // If getJSON returns 100C
      > 31 |    expect(await getTemperature("x")).toBe(212); // Expect 212F
           |                                         ^
        32 | });
        33 | });
        34 |

        at Object.&lt;anonymous> (ch17/getTemperature.test.js:31:43)

    Test Suites:  1 failed, 1 total
    Tests:        1 failed, 1 passed, 2 total
    Snapshots:    0 total
    Time:         1.403s
    Ran all test suites matching /getTemperature/i.</pre>
    <p>Nuestra implementación de <codeinline>getTemperature()</codeinline> está utilizando una fórmula incorrecta para convertir C a F. Multiplica por 5 y divide por 9 en lugar de multiplicar por 9 y dividir por 5. Si corregimos el código y ejecutamos Jest de nuevo, podemos ver que las pruebas pasan. Y, como extra, si añadimos el argumento <codeinline>--coverage</codeinline> cuando invoquemos a <codeinline>jest</codeinline>, calculará y mostrará la cobertura del código para nuestras pruebas:</p>
    <pre class="language-js">
    $ jest --coverage getTemperature
      PASS ch17/getTemperature.test.js
        getTemperature()
          ✓ Invokes the correct API (3ms)
          ✓ Converts C to F correctly (1ms)
    ------------------|--------|---------|---------|---------|------------------|
    File              | % Stmts| % Branch| % Funcs | % Lines | Uncovered Line #s|
    ------------------|--------|---------|---------|---------|------------------|
    All files         |   71.43|      100|    33.33|    83.33|                  |
    getJSON.js        |   33.33|      100|        0|       50|                 2|
    getTemperature.js |     100|      100|      100|      100|                  |
    ------------------|--------|---------|---------|---------|------------------|
    Test Suites:  1 passed, 1 total
    Tests:        2 passed, 2 total
    Snapshots:    0 total
    Time:         1.508s
    Ran all test suites matching /getTemperature/i.</pre>
    <p>La ejecución de nuestra prueba nos dio una cobertura de código del 100% para el módulo que estábamos probando, que es exactamente lo que queríamos. Sólo nos dio una cobertura parcial de <codeinline>getJSON()</codeinline>, pero nos burlamos de ese módulo y no estábamos tratando de probarlo, así que es de esperar.</p>
  </section>
  <section id="4">
    <h2>17.4 Gestión de paquetes con npm </h2>
    <p>En el desarrollo de software moderno, es habitual que cualquier programa no trivial que escribas dependa de librerías de software de terceros. Si estás escribiendo un servidor web en Node, por ejemplo, puede que estés usando el framework Express. Y si estás creando una interfaz de usuario para ser mostrada en un navegador web, podrías usar un marco de trabajo front-end como React o LitElement o Angular. Un gestor de paquetes facilita la búsqueda e instalación de paquetes de terceros como estos. Igualmente importante, un gestor de paquetes realiza un seguimiento de los paquetes de los que depende tu código y guarda esta información en un archivo para que cuando alguien más quiera probar tu programa, pueda descargar tu código y tu lista de dependencias, y luego usar su propio gestor de paquetes para instalar todos los paquetes de terceros que tu código necesita.</p>
    <p>npm es el gestor de paquetes que se incluye con Node, y se introdujo en <a href="capitulo-16#1-5">§16.1.5</a>. Sin embargo, es tan útil para la programación JavaScript del lado del cliente como para la programación del lado del servidor con Node.</p>
    <p>Si estás probando el proyecto JavaScript de otra persona, una de las primeras cosas que harás después de descargar su código es escribir <codeinline>npm install</codeinline>. Esto lee las dependencias listadas en el archivo <em>package.json</em> y descarga los paquetes de terceros que el proyecto necesita y los guarda en un directorio <em>node_modules/</em>.</p>
    <p>También puedes escribir <codeinline>npm install &lt;nombre-paquete></codeinline> para instalar un paquete concreto en el directorio <em>node_modules/</em> de tu proyecto:</p>
    <pre>
    <code class="language-js">$ npm install express</code></pre>
    <p>Además de instalar el paquete nombrado, npm también hace un registro de la dependencia en el archivo <em>package.json</em> para el proyecto. Registrar las dependencias de esta manera es lo que permite a otros instalar esas dependencias simplemente escribiendo <codeinline>npm install</codeinline>.</p>
    <p>El otro tipo de dependencia son las herramientas de desarrollo que necesitan los desarrolladores que quieren trabajar en su proyecto, pero que en realidad no son necesarias para ejecutar el código. Si un proyecto utiliza Prettier, por ejemplo, para asegurar que todo su código tiene un formato consistente, entonces Prettier es una "dependencia dev", y puede instalar y grabar una de ellas con <codeinline>--save-dev</codeinline>:</p>
    <pre>
    <code class="language-js">$ npm install --save-dev prettier</code></pre>
    <p>A veces es posible que desee instalar herramientas de desarrollo a nivel mundial para que sean accesibles en cualquier lugar, incluso para el código que no forma parte de un proyecto formal con un archivo <em>package.json</em> y un directorio <em>node_modules/</em>. Para ello puedes utilizar la opción <codeinline>-g</codeinline> (for global):</p>
    <pre class="language-js">
    $ npm install -g eslint jest
    /usr/local/bin/eslint -> /usr/local/lib/node_modules/eslint/bin/eslint.js
    /usr/local/bin/jest -> /usr/local/lib/node_modules/jest/bin/jest.js
    + jest@24.9.0
    + eslint@6.7.2
    added 653 packages from 414 contributors in 25.596s

    $ which eslint
    /usr/local/bin/eslint
    $ which jest
    /usr/local/bin/jest</pre>
    <p>Además del comando "install", npm soporta los comandos "uninstall" y "update", que hacen lo que su nombre indica. npm también tiene un interesante comando "audit" que puedes usar para encontrar y corregir vulnerabilidades de seguridad en tus dependencias:</p>
    <pre class="language-js">
    $ npm audit --fix
                    === npm audit security report ===
    found 0 vulnerabilities
      in 876354 scanned packages</pre>
    <p>Cuando se instala una herramienta como ESLint localmente para un proyecto, el script eslint termina en <em>./ node_modules/.bin/eslint</em>, lo que hace que el comando sea incómodo de ejecutar. Afortunadamente, npm viene con un comando conocido como "npx", que puede utilizar para ejecutar herramientas instaladas localmente con comandos como <codeinline>npx eslint</codeinline> o <codeinline>npx jest</codeinline>. (Y si usas npx para invocar una herramienta que aún no ha sido instalada, la instalará por ti).</p>
    <p>La empresa detrás de npm también mantiene el repositorio de paquetes <a href="https://npmjs.com">https://npmjs.com</a>, que contiene cientos de miles de paquetes de código abierto. Pero no es necesario utilizar el gestor de paquetes npm para acceder a este repositorio de paquetes. Otras alternativas son <a href="https://yarnpkg.com/">yarn</a> y <a href="https://pnpm.io/">pnpm</a>.</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>17.5 Agrupación de códigos</h2>
    <p>Si estás escribiendo un gran programa JavaScript para ejecutarlo en navegadores web, probablemente querrás usar una herramienta de agrupación de código, especialmente si usas librerías externas que se entregan como módulos. Los desarrolladores web han estado utilizando módulos ES6 (<a href="capitulo-10#3">§10.3</a>) durante años, desde mucho antes de que las palabras clave <codeinline>import</codeinline> y <codeinline>export</codeinline> fueran soportadas en la web. Para ello, los programadores utilizan una herramienta de agrupación de código que comienza en el punto de entrada principal (o puntos de entrada) del programa y sigue el árbol de directivas de <codeinline>import</codeinline> para encontrar todos los módulos de los que depende el prog  rama. A continuación, combina todos esos archivos de módulos individuales en un único paquete de código JavaScript y reescribe las directivas de <codeinline>import</codeinline> y <codeinline>export</codeinline> para que el código funcione en esta nueva forma. El resultado es un único archivo de código que puede cargarse en un navegador web que no admita módulos.</p>
    <p>En la actualidad, los navegadores web soportan casi universalmente los módulos ES6, pero los desarrolladores web aún tienden a utilizar paquetes de código, al menos cuando publican código de producción. Los desarrolladores consideran que la experiencia del usuario es mejor cuando se carga un único paquete de código de tamaño medio la primera vez que visita un sitio web que cuando se cargan muchos módulos pequeños.</p>
    <p>Existen varias herramientas de empaquetado de JavaScript. Entre los más utilizados se encuentran <a href="https://webpack.js.org/">webpack</a>, <a href="https://rollupjs.org/">Rollup</a> y <a href="https://parceljs.org/">Parcel</a>. Las características básicas de los bundlers son más o menos las mismas, y se diferencian en función de lo configurables que son o de lo fáciles que son de usar. Webpack existe desde hace mucho tiempo, tiene un gran ecosistema de plug-ins, es altamente configurable y puede soportar librerías antiguas que no son módulos. Pero también puede ser complejo y difícil de configurar. En el otro extremo del espectro está Parcel, que pretende ser una alternativa de configuración cero que simplemente hace lo correcto.</p>
    <p>Además de realizar la agrupación básica, las herramientas de agrupación también pueden proporcionar algunas funciones adicionales:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Algunos programas tienen más de un punto de entrada. Una aplicación web con múltiples páginas, por ejemplo, podría escribirse con un punto de entrada diferente para cada página. Por lo general, los agrupadores permiten crear un paquete por punto de entrada o crear un único paquete que admita varios puntos de entrada.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>Los programas pueden usar <codeinline>import()</codeinline> en su forma funcional (<a href="capitulo-10#3-6">§10.3.6</a>) en lugar de su forma estática para cargar dinámicamente los módulos cuando son realmente necesarios en lugar de cargarlos estáticamente al iniciar el programa. Hacer esto es a menudo una buena manera de mejorar el tiempo de arranque de su programa. Las herramientas Bundler que soportan <codeinline class="inline-block">import()</codeinline> pueden ser capaces de producir múltiples paquetes de salida: uno para cargar en el momento de inicio, y uno o más que se cargan dinámicamente cuando sea necesario. Esto puede funcionar bien si sólo hay unas pocas llamadas a <codeinline class="inline-block">import()</codeinline> en su programa y cargan módulos con conjuntos relativamente disjuntos de dependencias. Si los módulos cargados dinámicamente comparten dependencias, entonces se vuelve complicado averiguar cuántos bundles producir, y es probable que tenga que configurar manualmente su bundler para resolver esto.</p>
        
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Por lo general, los empaquetadores pueden generar un archivo de <em>mapa de código</em> fuente que define una correspondencia entre las líneas de código del paquete y las líneas correspondientes de los archivos fuente originales. Esto permite que las herramientas de desarrollo de navegadores muestren automáticamente los errores de JavaScript en sus ubicaciones originales.</li>
        </p>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          A veces, cuando importas un módulo a tu programa, sólo utilizas algunas de sus funciones. Una buena herramienta de bundler puede analizar el código para determinar qué partes no se utilizan y pueden omitirse de los bundles. Esta función recibe el caprichoso nombre de "tree-shaking".</li>
        </p>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los agrupadores suelen tener una arquitectura basada en plug-ins y admiten plug-ins que permiten importar y agrupar "módulos" que en realidad no son archivos de código JavaScript. Supongamos que su programa incluye una gran estructura de datos compatible con JSON. Los agrupadores de código pueden configurarse para permitirle mover esa estructura de datos a un archivo JSON independiente y luego importarlo a su programa con una declaración como <codeinline>import widgets from "./big-widget-list.json"</codeinline>. Del mismo modo, los desarrolladores web que incrustan CSS en sus programas JavaScript pueden utilizar plug-ins de bundler que les permiten <codeinline>import</codeinline> archivos CSS con una directiva de importación. Tenga en cuenta, sin embargo, que si importa cualquier cosa que no sea un archivo JavaScript, está utilizando una extensión JavaScript no estándar y haciendo que su código dependa de la herramienta bundler.</li>
        </p>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En un lenguaje como JavaScript, que no requiere compilación, ejecutar una herramienta de bun- dler parece un paso de compilación, y es frustrante tener que ejecutar un bun- dler después de cada edición de código antes de poder ejecutar el código en el navegador. Los bundlers normalmente soportan vigilantes del sistema de archivos que detectan ediciones en cualquier archivo de un directorio de proyecto y regeneran automáticamente los bundles necesarios. C o n esta función, puedes guardar el código y volver a cargar inmediatamente la ventana del navegador para probarlo.</li>
        </p>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Algunos bundlers también admiten un modo de "sustitución de módulos en caliente" para desarrolladores en el que cada vez que se regenera un bundle, éste se carga automáticamente en el navegador. Cuando esto funciona, es una experiencia mágica para los desarrolladores, pero hay algunos trucos bajo el capó para que funcione, y no es adecuado para todos los proyectos.</li>
        </p>
    </ul>
  </section>
  <section id="6">
    <h2>17.6 Transpilación con Babel</h2>
    <p><a href="https://babeljs.io/">Babel</a> es una herramienta que compila JavaScript escrito con características del lenguaje moderno en JavaScript que no utiliza esas características del lenguaje moderno. Dado que compila JavaScript a JavaScript, Babel recibe a veces el nombre de "transpilador". Babel se creó para que los desarrolladores web pudieran utilizar las nuevas características del lenguaje ES6 y posteriores sin dejar de utilizar los navegadores web que sólo admitían ES5.</p>
    <p>Características del lenguaje como el operador de exponenciación <codeinline>**</codeinline> y las funciones de flecha pueden transformarse con relativa facilidad en <codeinline>Math.pow()</codeinline> y expresiones de <codeinline>function</codeinline>. Otras características del lenguaje, como la palabra clave <codeinline>class</codeinline>, requieren transformaciones mucho más complejas y, en general, la salida de código de Babel no está pensada para ser legible por humanos. Sin embargo, al igual que las herramientas de empaquetado, Babel puede producir mapas de código fuente que asignan las ubicaciones del código transformado a sus ubicaciones de código fuente originales, lo que ayuda enormemente a la hora de trabajar con código transformado.</p>
    <p>Los proveedores de navegadores están haciendo un mejor trabajo para mantenerse al día con la evolución del lenguaje Java Script, y hoy en día hay mucha menos necesidad de compilar funciones de flecha y declaraciones de clase. Babel todavía puede ayudar cuando se desea utilizar las últimas características como separadores de guión bajo en literales numéricos.</p>
    <p>Como la mayoría de las otras herramientas descritas en este capítulo, puedes instalar Babel con npm y ejecutarlo con npx. Babel lee un archivo de configuración <em>.babelrc</em> que le indica cómo desea que se transforme su código JavaScript. Babel define "presets" entre los que puedes elegir dependiendo de las extensiones del lenguaje que quieras usar y de la agresividad con la que quieras transformar las características estándar del lenguaje. Uno de los presets interesantes es para la compresión de código mediante minificación (eliminación de comentarios y espacios en blanco, renombramiento de variables, etc.).</p>
    <p>Si utiliza Babel y una herramienta de agrupación de código, puede configurar el agrupador de código para que ejecute automáticamente Babel en sus archivos JavaScript a medida que construye el paquete para usted. Si es así, puede ser una opción conveniente porque simplifica el proceso de producción de código ejecutable. Webpack, por ejemplo, admite un módulo "babel-loader" que puede instalar y configurar para ejecutar Babel en cada módulo JavaScript a medida que se agrupa.</p>
    <p>Aunque hoy en día hay menos necesidad de transformar el núcleo del lenguaje JavaScript, Babel se sigue utilizando habitualmente para soportar extensiones no estándar del lenguaje, y describiremos dos de estas extensiones del lenguaje en las secciones siguientes.</p>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>17.7 JSX: Expresiones de marcado en JavaScript</h2>
    <p>JSX es una extensión del núcleo de JavaScript que utiliza sintaxis de estilo HTML para definir un árbol de elementos. JSX se asocia más estrechamente con el marco React para interfaces de usuario en la web. En React, los árboles de elementos definidos con JSX se renderizan en última instancia en un navegador web como HTML. Incluso si no tienes planes de utilizar React, su popularidad significa que es probable que veas código que utiliza JSX. Esta sección explica lo que necesitas saber para darle sentido. (Esta sección es sobre la extensión de lenguaje JSX, no sobre React, y explica sólo lo suficiente de React para proporcionar contexto para la sintaxis JSX).</p>
    <p>Los elementos JSX son un nuevo tipo de sintaxis de expresión de JavaScript. Los literales de cadena de Java Script se delimitan con comillas, y los literales de expresión regular se delimitan con barras oblicuas. Del mismo modo, los literales de expresiones JSX se delimitan con corchetes angulares. He aquí una muy sencilla:</p>
    <pre class="language-js">
    <code>let line = &lt;hr/>;</code></pre>
    <p>Si utiliza JSX, tendrá que utilizar Babel (o una herramienta similar) para compilar las expresiones JSX en JavaScript normal. La transformación es tan sencilla que algunos desarrolladores optan por utilizar React sin usar JSX. Babel transforma la expresión JSX de esta sentencia de asignación en una simple llamada a una función:</p>
    <pre class="language-js">
    <code>let line = React.createElement("hr", null);</code></pre>
    <p>La sintaxis JSX es similar a HTML, y al igual que los elementos HTML, los elementos React pueden tener atributos como estos:</p>
    <pre class="language-js">
    <code>let image = &lt;img src="logo.png" alt="The JSX logo" hidden/>;</code></pre>
    <p>Cuando un elemento tiene uno o más atributos, éstos se convierten en propiedades de un objeto pasado como segundo argumento a <codeinline>createElement()</codeinline>:</p>
    <pre class="language-js">
    <code>let image = React.createElement("img", &lbrace;
      src: "logo.png",
      alt: "The JSX logo",
      hidden: true
    });</code></pre>
    <p>Al igual que los elementos HTML, los elementos JSX pueden tener cadenas y otros elementos como hijos. Al igual que los operadores aritméticos de JavaScript pueden utilizarse para escribir expresiones aritméticas de complejidad arbitraria, los elementos JSX también pueden anidarse a una profundidad arbitraria para crear árboles de elementos:</p>
    <pre class="language-js">
    <code>let sidebar = (
      &lt;div className="sidebar">
        &lt;h1>Title&lt;/h1>
        &lt;hr/>
        &lt;p>This is the sidebar content&lt;/p>
      &lt;/div>
    );</code></pre>
    <p>Las expresiones regulares de llamadas a funciones JavaScript también pueden anidarse a una profundidad arbitraria, y estas expresiones JSX anidadas se traducen en un conjunto de llamadas <codeinline>createElement()</codeinline> anidadas. Cuando un elemento JSX tiene hijos, esos hijos (que suelen ser cadenas y otros elementos JSX) se pasan como argumentos tercero y siguientes:</p>
    <pre class="language-js">
    <code>let sidebar = React.createElement(
      "div", &lbrace; className: "sidebar"},  // Esta llamada externa crea un &lt;div>
      React.createElement("h1", null,  // Este es el primer elemento secundario del &lt;div/>
                             "Title"), // y su propio primer elemento secundario.
      React.createElement("hr", null), // El segundo elemento secundario del &lt;div/>.
      React.createElement("p", null,   // Y el tercer elemento secundario.
                        "This is the sidebar content"));</code></pre>
    <p>El valor devuelto por <codeinline>React.createElement()</codeinline> es un objeto JavaScript ordinario que es utilizado por React para renderizar la salida en una ventana del navegador. Dado que esta sección trata sobre la sintaxis JSX y no sobre React, no vamos a entrar en detalles sobre los objetos Element devueltos o el proceso de renderizado. Vale la pena señalar que puedes configurar Babel para compilar elementos JSX a invocaciones de una función diferente, por lo que si crees que la sintaxis JSX sería una forma útil de expresar otros tipos de estructuras de datos anidadas, puedes adoptarla para tus propios usos no relacionados con React.</p>
    <p>Una característica importante de la sintaxis JSX es que puede incrustar expresiones JavaScript regulares dentro de expresiones JSX. Dentro de una expresión JSX, el texto entre llaves se interpreta como JavaScript plano. Estas expresiones anidadas están permitidas como valores de atributo y como elementos hijos. Por ejemplo:</p>
    <pre class="language-js">
    <code>function sidebar(className, title, content, drawLine=true) &lbrace;
      return (
        &lt;div className=&lbrace;className}>
          &lt;h1>&lbrace;title}&lt;/h1>
          &lbrace; drawLine && &lt;hr/> }
          &lt;p>&lbrace;content}&lt;/p>
        &lt;/div>
      );
    }</code></pre>
    <p>La función <codeinline>sidebar()</codeinline> devuelve un elemento JSX. Toma cuatro argumentos que utiliza dentro del elemento JSX. La sintaxis de llaves puede recordarle los literales de plantilla que utilizan <codeinline>$&lbrace;}</codeinline> para incluir expresiones JavaScript dentro de cadenas. Como sabemos que las expresiones JSX se compilan en invocaciones de funciones, no debería sorprendernos que se puedan incluir expresiones JavaScript arbitrarias, ya que las invocaciones de funciones también se pueden escribir con expresiones arbitrarias. Este código de ejemplo es traducido por Babel a lo siguiente:</p>
    <pre class="language-js">
    <code>function sidebar(className, title, content, drawLine=true) &lbrace;
      return React.createElement("div", &lbrace; className: className },
                    React.createElement("h1", null, title),
                    drawLine && React.createElement("hr", null),
                    React.createElement("p", null, content));
    }</code></pre>
    <p>Este código es fácil de leer y entender: las llaves han desaparecido y el código resultante pasa los parámetros de la función entrante a <codeinline>React.createElement()</codeinline> de forma natural. Fíjate en el truco que hemos hecho aquí con el parámetro <codeinline>drawLine</codeinline> y el operador <codeinline>&&</codeinline> de cortocircuito. Si llamas a <codeinline>sidebar()</codeinline> con sólo tres argumentos, entonces <codeinline>drawLine</codeinline> por defecto es <codeinline>true</codeinline>, y el cuarto argumento de la llamada externa a <codeinline>createElement()</codeinline> es el elemento <codeinline>&lt;hr/></codeinline>. Pero si pasa <codeinline>false</codeinline> como cuarto argumento a <codeinline>sidebar()</codeinline>, entonces el cuarto argumento de la llamada externa a <codeinline>createElement()</codeinline> se evalúa como <codeinline>false</codeinline>, y no se crea ningún elemento <codeinline>&lt;hr/></codeinline>. Este uso del operador <codeinline>&&</codeinline> es un lenguaje común en JSX para incluir o excluir condicionalmente un elemento hijo dependiendo del valor de alguna otra expresión. (Este modismo funciona con React porque React simplemente ignora los hijos que son <codeinline>false</codeinline> o <codeinline>null</codeinline> y no produce ninguna salida para ellos).</p>
    <p>Cuando utiliza expresiones JavaScript dentro de expresiones JSX, no está limitado a valores simples como los valores de cadena y booleano del ejemplo anterior. Cualquier valor Java Script está permitido. De hecho, es bastante común en la programación React utilizar objetos, matrices y funciones. Considera la siguiente función, por ejemplo:</p>
    <pre class="language-js">
    <code>// Dada un array de string y una función de devolución de llamada, devuelve un 
    // elemento JSX que representa una lista HTML &lt;ul> con un array de 
    // elementos &lt;li> como elementos hijos.
    function list(items, callback) &lbrace;
      return (
        &lt;ul style=&lbrace; &lbrace;padding:10, border:"solid red 4px"} }>
          &lbrace;items.map((item,index) => &lbrace;
            &lt;li onClick=&lbrace;() => callback(index)} key=&lbrace;index}>&lbrace;item}&lt;/li>
          })}
        &lt;/ul>
      );
    }</code></pre>
    <p>Esta función utiliza un objeto literal como valor del atributo <codeinline>style</codeinline> del elemento <codeinline>&lt;ul></codeinline>. (El elemento <codeinline>&lt;ul></codeinline> tiene un único hijo, pero el valor de ese hijo es una matriz. La matriz hija es la matriz creada mediante la función <codeinline>map()</codeinline> en la matriz de entrada para crear una matriz de elementos <codeinline>&lt;li></codeinline>.</p>
    <p>(Esto funciona con React porque la librería React aplana los hijos de un elemento cuando los renderiza. Un elemento con un array hijo es lo mismo que ese elemento con cada uno de esos elementos del array como hijos). Por último, ten en cuenta que cada una de las matrices anidadas <codeinline>&lt;li></codeinline> tiene un atributo manejador de eventos <codeinline>onClick</codeinline> cuyo valor es una función de flecha. El código JSX compila al siguiente código JavaScript puro (que he formatulado con Prettier):</p>
    <pre class="language-js">
    <code>function list(items, callback) &lbrace;
      return React.createElement(
        "ul",
        &lbrace; style: &lbrace; padding: 10, border: "solid red 4px" } },
        items.map((item, index) =>
          React.createElement(
            "li",
            &lbrace; onClick: () => callback(index), key: index },
            item
          )
        )
      );
    }</code></pre>
    <p>Otro uso de las expresiones de objeto en JSX es con el operador de extensión de objeto (<a href="capitulo-6#10-4">§6.10.4</a>) para especificar múltiples atributos a la vez. Supón que te encuentras escribiendo muchas expresiones JSX que repiten un conjunto común de atributos. Puedes simplificar tus expresiones definiendo los atributos como propiedades de un objeto y "esparciéndolos" en tus elementos JSX:</p>
    <pre class="language-js">
    <code>let hebrew = &lbrace; lang: "he", dir: "rtl" }; // Especifica el idioma y la dirección
    let shalom = &lt;span className="emphasis" &lbrace;...hebrew}>ם҇לқ&lt;/span>;</code></pre> 
    <p>Babel compila esto para utilizar una función <codeinline>_extends()</codeinline> (omitida aquí) que combina que atributo <codeinline>className</codeinline> con los atributos contenidos en el objeto <codeinline>hebrew</codeinline>:</p>
    <pre class="language-js">
    <code>let shalom = React.createElement("span",
                  _extends(&lbrace;className: "emphasis"}, hebrew),
                  "\u05E9\u05DC\u05D5\u05DD");</code></pre>
    <p>Por último, hay otra característica importante de JSX que aún no hemos cubierto. Como has visto, todos los elementos JSX comienzan con un identificador inmediatamente después del paréntesis angular de apertura. Si la primera letra de este identificador es minúscula (como ha sido en todos los ejemplos aquí), entonces el identificador se pasa a <codeinline>createElement()</codeinline> como una cadena. Pero si la primera letra del identificador es mayúscula, entonces se trata como un identificador real, y es el valor JavaScript de ese identificador el que se pasa como primer argumento a <codeinline>createElement()</codeinline>. Esto significa que la expresión JSX <codeinline>&lt;Math/></codeinline> compila código JavaScript que pasa el objeto Math global a <codeinline>React.createElement()</codeinline>.</p>
    <p>Para React, esta capacidad de pasar valores no string como primer argumento a <codeinline>createElement()</codeinline> permite la creación de <em>componentes</em>. Un componente es una forma de escribir un simple</p>
    <p>Expresión JSX (con un nombre de componente en mayúsculas) que representa una expresión más compleja (utilizando nombres de etiqueta HTML en minúsculas).</p>
    <p>La forma más sencilla de definir un nuevo componente en React es escribir una función que tome un "objeto props" como argumento y devuelva una expresión JSX. Un <em>objeto props</em> es simplemente un objeto JavaScript que representa valores de atributos, como los objetos que se pasan como segundo argumento a <codeinline>createElement()</codeinline>. He aquí, por ejemplo, otra versión de nuestra función <codeinline>sidebar()</codeinline>:</p>
    <pre class="language-js">
    <code>function Sidebar(props) &lbrace;
      return (
        &lt;div>
          &lt;h1>&lbrace;props.title}&lt;/h1>
          &lbrace; props.drawLine && &lt;hr/> }
          &lt;p>&lbrace;props.content}&lt;/p>
        &lt;/div>
      );
    }</code></pre>
    <p>Esta nueva función <codeinline>Sidebar()</codeinline> es muy parecida a la función anterior <codeinline>sidebar()</codeinline>. Pero ésta tiene un nombre que empieza por mayúscula y toma un único argumento objeto en lugar de argumentos separados. Esto la convierte en un componente React y significa que puede utilizarse en lugar de un nombre de etiqueta HTML en expresiones JSX:</p>
    <pre class="language-js">
    <code>let sidebar = &lt;Sidebar title="Something snappy" content="Something wise"/>;</code></pre>
    <p>Este elemento <codeinline>&lt;Sidebar/></codeinline> se compila así:</p>
    <pre class="language-js">
    <code>let sidebar = React.createElement(Sidebar, &lbrace;
      title: "Something snappy",
      content: "Something wise"
    });</code></pre>
    <p>Es una simple expresión JSX, pero cuando React la renderice, pasará el segundo argumento (el objeto Props) al primer argumento (la función <codeinline>Sidebar()</codeinline>) y utilizará la expresión JSX devuelta por esa función en lugar de la expresión <codeinline>&lt;Sidebar></codeinline>.</p>
  </section>
  <section id="8">
    <h2>17.8 Comprobación de tipos con Flow</h2>
    <p><a href="https://flow.org/">Flow</a> es una extensión de lenguaje que te permite anotar tu código JavaScript con información de tipo, y una herramienta para comprobar tu código JavaScript (tanto anotado como no anotado) en busca de errores de tipo. Para utilizar Flow, empieza a escribir código utilizando la extensión de lenguaje Flow para añadir anotaciones de tipo. A continuación, ejecuta la herramienta Flow para analizar el código e informar de los errores tipográficos. Una vez que haya corregido los errores y esté listo para ejecutar el código, utilice Babel (quizás automáticamente como parte del proceso de agrupación de código) para eliminar las anotaciones de tipo de Flow de su código. (Una de las cosas buenas de la extensión del lenguaje Flow es que no hay ninguna sintaxis nueva que Flow tenga que compilar o transformar. Utilizas la extensión del lenguaje Flow para añadir anotaciones al código, y todo lo que Babel tiene que hacer es quitar esas anotaciones para devolver tu código a JavaScript estándar).</p>
    <article>
      <p class="title-article">TypeScript frente a Flow</p>
      <p>TypeScript es una alternativa muy popular a Flow. TypeScript es una extensión de Java-Script que añade tipos así como otras características del lenguaje. El compilador de TypeScript "tsc" compila programas TypeScript en programas JavaScript y en el proceso los analiza e informa de errores de tipo de la misma manera que lo hace Flow. tsc no es un plugin de Babel: es su propio compilador independiente.</p>
      <p>Las anotaciones de tipo simples en TypeScript se escriben normalmente de forma idéntica a las mismas anotaciones en Flow. Para tipado más avanzado, la sintaxis de las dos extensiones diverge, pero la intención y el valor de las dos extensiones es el mismo. Mi objetivo en esta sección es explicar los beneficios de las anotaciones de tipo y el análisis estático de código. Lo haré con ejemplos basados en Flow, pero todo lo demostrado aquí también se puede lograr con TypeScript con cambios de sintaxis relativamente simples.</p>
      <p>TypeScript fue lanzado en 2012, antes de ES6, cuando JavaScript no tenía una palabra clave <codeinline>class</codeinline> o un bucle <codeinline>for/of</codeinline> o módulos o Promises. Flow es una extensión limitada del lenguaje que añade anotaciones de tipo a JavaScript y nada más. TypeScript, por el contrario, fue diseñado como un nuevo lenguaje. Como su nombre indica, añadir tipos a JavaScript es el propósito principal de TypeScript, y es la razón por la que la gente lo usa hoy en día. Pero los tipos no son la única característica que TypeScript añade a JavaScript: el lenguaje TypeScript tiene palabras clave <codeinline>enum</codeinline> y <codeinline>namespace</codeinline> que simplemente no existen en JavaScript. En 2020, TypeScript tiene una mejor integración con IDEs y editores de código (particularmente VSCode, que, como TypeScript, es de Microsoft) que Flow.</p>
      <p>En última instancia, este es un libro sobre JavaScript, y estoy cubriendo Flow aquí en lugar de TypeScript porque no quiero quitarle protagonismo a JavaScript. Pero todo lo que aprendas aquí sobre añadir tipos a JavaScript te será útil si decides adoptar TypeScript para tus proyectos.</p>
    </article>
    <p>Usar Flow requiere compromiso, pero he descubierto que para proyectos medianos y grandes, el esfuerzo extra merece la pena. Lleva un tiempo extra añadir anotaciones de tipo a tu código, ejecutar Flow cada vez que editas el código, y corregir los errores de tipo que reporta. Pero a cambio, Flow impondrá una buena disciplina de codificación y no te permitirá tomar atajos que puedan dar lugar a errores. Cuando he trabajado en proyectos que utilizan Flow, me ha impresionado el número de errores que ha encontrado en mi propio código. Ser capaz de solucionar esos problemas antes de que se conviertan en bugs es una gran sensación y me da una confianza extra de que mi código es correcto.</p>
    <p>Cuando empecé a usar Flow, a veces me resultaba difícil entender por qué se quejaba de mi código. Con un poco de práctica, sin embargo, llegué a entender sus mensajes de error y descubrí que por lo general era fácil hacer pequeñas correcciones. cambios en mi código para hacerlo más seguro y satisfacer a Flow.<sup>1</sup> No recomiendo utilizar Flow si aún sientes que estás aprendiendo JavaScript por sí mismo. Pero una vez que te sientas seguro con el lenguaje, añadir Flow a tus proyectos JavaScript te empujará a llevar tus habilidades de programación al siguiente nivel. Y ésta, realmente, es la razón por la que dedico la última sección de este libro a un tutorial de Flow: porque aprender sobre los sistemas de tipos de JavaScript ofrece una visión de otro nivel, u otro estilo, de programación.</p>
    <p>Esta sección es un tutorial y no pretende cubrir Flow de forma exhaustiva. Si decides probar Flow, es casi seguro que acabarás dedicando tiempo a leer la documentación en <a href="https://flow.org">https://flow.org</a>. Por otro lado, no necesitas dominar el sistema de tipos de Flow antes de que puedas empezar a hacer un uso práctico de él en tus proyectos: los usos simples de Flow descritos aquí te llevarán muy lejos.</p>
  </section>
  <section id="8-1" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.1 Instalación y funcionamiento de Flow</h2>
    <p>Al igual que las otras herramientas descritas en este capítulo, puedes instalar la herramienta de comprobación de tipos Flow utilizando un gestor de paquetes, con un comando como <codeinline>npm install -g flow-bin</codeinline> o <codeinline>npm install --save-dev flow-bin</codeinline>. Si instalas la herramienta globalmente con <codeinline>-g</codeinline>, entonces puedes ejecutarla con <codeinline>flow</codeinline>. Y si la instalas localmente en tu proyecto con <codeinline>--save-dev</codeinline>, entonces puedes ejecutarla con <codeinline>npx flow</codeinline>. Antes de usar Flow para hacer la comprobación de tipos, la primera vez ejecútalo como <codeinline>flow --init</codeinline> en el directorio raíz de tu proyecto para crear un archivo de configuración <codeinline>.flowcon fig</codeinline>. Puede que nunca necesites añadir nada a este archivo, pero Flow lo necesita para saber dónde está la raíz de tu proyecto.</p>
    <p>Cuando ejecutes Flow, encontrará todo el código fuente JavaScript de tu proyecto, pero sólo informará de errores de tipo para los archivos que hayan "optado" por la comprobación de tipo añadiendo un comentario <codeinline>// @flow</codeinline> en la parte superior del archivo. Este comportamiento es importante porque significa que puedes adoptar Flow para proyectos existentes y luego comenzar a verificar tu código archivo por archivo, sin ser molestado por errores y advertencias en archivos que aún no han sido convertidos.</p>
    <p>Flow puede ser capaz de encontrar errores en tu código incluso si todo lo que haces es optar por un comentario <codeinline>// @flow</codeinline>. Incluso si no utilizas la extensión de lenguaje Flow y no añades anotaciones de tipo a tu código, la herramienta de comprobación de tipos de Flow puede hacer inferencias sobre los valores de tu programa y alertarte cuando los utilices de forma inconsistente.</p>
    <p>Considere el siguiente mensaje de error Flow:</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ variableReassignment.js:6:3

    Cannot assign 1 to i.r because:

    • property r is missing in number [1].
    
        2│ let i = &lbrace; r: 0, i: 1 }; // El número complejo 0+1i
    [1] 3│ for(i = 0; i &lt; 10; i++) &lbrace; // ¡Ups! La variable de bucle sobrescribe i
        4│    console.log(i);
        5│ }
        6│ i.r = 1; // Flow detecta el error aquí</pre>
    <p>En este caso, declaramos la variable i y le asignamos un objeto. Luego usamos i de nuevo como una variable de bucle, sobrescribiendo el objeto. Flow se da cuenta de esto y marca un error cuando intentamos usar <codeinline>i</codeinline> como si todavía contuviera un objeto. (Una solución sencilla sería escribir <codeinline>for(let i = 0;</codeinline> haciendo que la variable de bucle sea local al bucle).</p>
    <p>He aquí otro error que Flow detecta incluso sin anotaciones de tipo:</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size.js:3:14
      
    Cannot get x.length because property length is missing in Number [1].
        1│ // @flow
        2│ function size(x) &lbrace;
        3│    return x.length;
        4│ }
    [1] 5│ let s = size(1000);</pre>
    <p>Flow ve que la función <codeinline>size()</codeinline> toma un único argumento. No sabe el tipo de ese argumento, pero puede ver que se espera que el argumento tenga una propiedad <codeinline>length</codeinline>. Cuando ve que se llama a esta función <codeinline>size()</codeinline> con un argumento numérico, correctamente lo marca como un error porque los números no tienen propiedades de <codeinline>length</codeinline>.</p>
  </section>
  <section id="8-2">
    <h2>17.8.2 Uso de anotaciones de tipo</h2>
    <p>Cuando declaras una variable JavaScript, puedes añadirle una anotación de tipo Flow siguiendo el nombre de la variable con dos puntos y el tipo:</p>
    <pre>
    <code class="language-js">let message: string = "Hello world";
    let flag: boolean = false;
    let n: number = 42;</code></pre>
    <p>Flow conocería los tipos de estas variables incluso si no las anotaras: puede ver qué valores asignas a cada variable, y hace un seguimiento de ello. Sin embargo, si añades anotaciones de tipo, Flow conoce tanto el tipo de la variable como que has expresado la intención de que la variable sea siempre de ese tipo. Así que si usas la anotación de tipo, Flow marcará un error si alguna vez asignas un valor de un tipo diferente a esa variable. Las anotaciones de tipo para variables también son particularmente útiles si tiendes a declarar todas tus variables en la parte superior de una función antes de que se utilicen.</p>
    <p>Las anotaciones de tipo para argumentos de función son como las anotaciones para variables: siguen al nombre del argumento de función con dos puntos y el nombre del tipo. Cuando se anota una función, normalmente también se añade una anotación para el tipo de retorno de la función.</p>
    <p>Va entre el paréntesis de cierre y la llave abierta del cuerpo de la función. Las funciones que no devuelven nada utilizan el tipo de flujo <codeinline>void</codeinline>.</p>
    <p>En el ejemplo anterior definimos una función <codeinline>size()</codeinline> que esperaba un argumento con una propiedad de <codeinline>length</codeinline>. Así es como podríamos cambiar esa función para especificar explícitamente que espera un argumento de cadena y devuelve un número. Fíjate, Flow ahora marca un error si pasamos un array a la función, aunque la función funcionaría en ese caso:</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size2.js:5:18

    Cannot call size with array literal bound to s because array literal [1]
    is incompatible with string [2].

    [2] 2│ function size(s: string): number &lbrace;
        3│    return s.length;
        4│ }
    [1] 5│ console.log(size([1,2,3]));</pre>
    <p>También es posible utilizar anotaciones de tipo con funciones de flecha, aunque puede convertir esta sintaxis normalmente sucinta en algo más verboso:</p>
    <pre>
    <code class="language-js">const size = (s: string): number => s.length;</code></pre>
    <p>Una cosa importante a entender sobre Flow es que el valor JavaScript <codeinline>null</codeinline> tiene el tipo Flow <codeinline>null</codeinline> y el valor JavaScript <codeinline>undefined</codeinline> tiene el tipo Flow <codeinline>void</codeinline>. Pero ninguno de estos valores es miembro de ningún otro tipo (a menos que lo añadas explícitamente). Si declaras que un parámetro de función es una cadena, entonces debe ser una cadena, y es un error pasar <codeinline>null</codeinline> o pasar <codeinline>undefined</codeinline> u omitir el argumento (que es básicamente lo mismo que pasar <codeinline>undefined</codeinline>):</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size3.js:3:18

    Cannot call size with null bound to s because null [1] is incompatible
    with string [2].
        1│ // @flow
    [2] 2│ const size = (s: string): number => s.length;
    [1] 3│ console.log(size(null));</pre>
    <p>Si desea permitir <codeinline>null</codeinline> e <codeinline>undefined</codeinline> como valores legales para una variable o argumento de función, simplemente anteponga un signo de interrogación al tipo. Por ejemplo, utiliza <codeinline>?string</codeinline> o <codeinline>?number</codeinline> en lugar de <codeinline>string</codeinline> o <codeinline>number</codeinline>. Si cambiamos nuestra función <codeinline>size()</codeinline> para que espere un argumento de tipo <codeinline>?string</codeinline>, Flow no se quejará cuando pasemos <codeinline>null</codeinline> a la función. Pero ahora tiene algo más de lo que quejarse:</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size4.js:3:14

    Cannot get s.length because property length is missing in null or
    undefined [1].
        1│ // @flow
    [1] 2│ function size(s: ?string): number &lbrace;
        3│    return s.length;
        4│ }
        5│ console.log(size(null));</pre>
    <p>Lo que Flow nos está diciendo aquí es que no es seguro escribir <codeinline>s.length</codeinline> porque, en este lugar de nuestro código, <codeinline>s</codeinline> podría ser <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, y esos valores no tienen propiedades de <codeinline>length</codeinline>. Aquí es donde Flow se asegura de que no tomemos atajos. Si un valor puede ser <codeinline>null</codeinline>, Flow insistirá en que comprobemos ese caso antes de hacer cualquier cosa que dependa de que el valor no sea <codeinline>null</codeinline>.</p>
    <p>En este caso, podemos solucionar el problema cambiando el cuerpo de la función de la siguiente manera:</p>
    <pre class="language-js">
    <code>function size(s: ?string): number &lbrace;
      // En este punto del código, s podría ser una cadena o nulo o indefinido.
      if (s === null || s === undefined) &lbrace;
        // En este bloque, Flow sabe que s es nulo o indefinido.
        return -1;
      } else &lbrace;
        // Y en este bloque, Flow sabe que s es una cadena.
        return s.length;
      }
    }</code></pre>
    <p>Cuando se llama a la función por primera vez, el parámetro puede tener más de un tipo. Pero añadiendo código de comprobación de tipo, creamos un bloque dentro del código donde Flow sabe con seguridad que el parámetro es una cadena. Cuando usamos <codeinline>s.length</codeinline> dentro de ese bloque, Flow no se queja. Ten en cuenta que Flow no requiere que escribas código verboso como este. Flow también estaría satisfecho si simplemente reemplazáramos el cuerpo de la función <codeinline>size()</codeinline> con <codeinline>return s ? s.length : -1;</codeinline>.</p>
    <p>La sintaxis de flujo permite un signo de interrogación antes de cualquier especificación de tipo para indicar que, además del tipo especificado, también se permiten <codeinline>null</codeinline> e indefinido. Los signos de interrogación también pueden aparecer después del nombre de un parámetro para indicar que el parámetro en sí es opcional. Así, si cambiamos la declaración del parámetro <codeinline>s</codeinline> de <codeinline>s: ?string a s? : string</codeinline>, eso significaría que está bien llamar a <codeinline>size()</codeinline> sin argumentos (o con el valor <codeinline>undefined</codeinline>, que es lo mismo que omitirlo), pero que si la llamamos con un parámetro distinto de <codeinline>undefined</codeinline>, ese parámetro debe ser una cadena. En este caso, <codeinline>null</codeinline> no es un valor legal.</p>
    <p>Hasta ahora, hemos discutido los tipos primitivos <codeinline>string</codeinline>, <codeinline>number</codeinline>, <codeinline>boolean</codeinline>, <codeinline>null</codeinline> y <codeinline>void</codeinline> y hemos demostrado cómo puedes usarlos con declaraciones de variables, parámetros de funciones y valores de retorno de funciones. Las subsecciones siguientes describen algunos tipos más complejos soportados por Flow.</p>
  </section>
  <section id="8-3" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.3 Tipos de clases</h2>
    <p>Además de los tipos primitivos que Flow conoce, también conoce todas las clases incorporadas de JavaScript y te permite utilizar nombres de clases como tipos. La siguiente función, por ejemplo, utiliza anotaciones de tipo para indicar que debe ser invocada con un objeto Date y un objeto RegExp:</p>
    <pre class="language-js">
    <code>// @flow
    // Devuelve verdadero si la representación ISO de la fecha especificada coincide
    // con el patrón especificado, o falso en caso contrario. 
    // E.g: const isTodayChristmas = dateMatches(new Date(), /^\d&lbrace;4}-12-25T/);
    export function dateMatches(d: Date, p: RegExp): boolean &lbrace;
      return p.test(d.toISOString());
    }</code></pre>
    <p>Si defines tus propias clases con la palabra clave <codeinline>class</codeinline>, esas clases se convierten automáticamente en tipos Flow válidos. Sin embargo, para que esto funcione, Flow requiere que utilices anotaciones de tipo en la clase. En particular, cada propiedad de la clase debe tener su tipo declarado. Aquí hay una simple clase de números complejos que demuestra esto:</p>
    <pre class="language-js">
    <code>// @flow
    export default class Complex &lbrace;
      // Flow requiere una sintaxis de clase extendida que incluya anotaciones
      // de tipo para cada una de las propiedades utilizadas por la clase.
      i: number;
      r: number;
      static i: Complex;

      constructor(r: number, i:number) &lbrace;
        // Cualquier propiedad inicializada por el constructor debe tener 
        // anotaciones de tipo Flow arriba.

        this.r = r;
        this.i = i;
      }

      add(that: Complex) &lbrace;
        return new Complex(this.r + that.r, this.i + that.i);
      }
    }

    // Flow no permitiría esta asignación si no hubiera una anotación 
    // de tipo para i dentro de la clase.
    Complex.i = new Complex(0,1);</code></pre>
  </section>
  <section id="8-4">
    <h2>17.8.4 Tipos de objetos</h2>
    <p>El tipo Flow para describir un objeto se parece mucho a un literal de objeto, salvo que los valores de propiedad se sustituyen por tipos de propiedad. Aquí, por ejemplo, hay una función que espera un objeto con propiedades numéricas <codeinline>x</codeinline> e <codeinline>y</codeinline>:</p>
    <pre>
    <code class="language-js">// @flow
    // Dado un objeto con propiedades numéricas x e y, devuelve la 
    // distancia desde el origen hasta el punto (x,y) como un número.
    export default function distance(point: &lbrace;x:number, y:number}): number &lbrace;
      return Math.hypot(point.x, point.y);
    }</code></pre>
    <p>En este código, el texto <codeinline>&lbrace;x:number, y:number}</codeinline> es un tipo Flow, como lo son <codeinline>string</codeinline> o <codeinline>Date</codeinline>. Como con cualquier tipo, puedes añadir un signo de interrogación al principio para indicar que <codeinline>null</codeinline> e <codeinline>undefined</codeinline> también deberían estar permitidos.</p>
    <p>Dentro de un tipo de objeto, cualquier nombre de propiedad puede ir seguido de un signo de interrogación para indicar que esa propiedad es opcional y puede omitirse. Por ejemplo, puede escribir así el tipo de un objeto que represente un punto 2D o 3D:</p>
    <pre>
    <code class="language-js">&lbrace;x: number, y: number, z?: number}</code></pre>
    <p>Si una propiedad no está marcada como opcional en un tipo de objeto, entonces es requerida, y Flow informará de un error si una propiedad apropiada no está presente en el valor real. Sin embargo, Flow no tolera propiedades extra. Si pasaras un objeto que tuviera una propiedad <codeinline>w</codeinline> a la función <codeinline>distance()</codeinline> anterior, Flow no se quejaría.</p>
    <p>Si quieres que Flow imponga estrictamente que un objeto no tiene propiedades distintas de las declaradas explícitamente en su tipo, puedes declarar un <em>tipo de objeto exacto</em> añadiendo barras verticales a las llaves:</p>
    <pre>
    <code class="language-js">&lbrace;| x: number, y: number |}</code></pre>
    <p>Los objetos de JavaScript se utilizan a veces como diccionarios o mapas de cadena a valor. Cuando se utilizan así, los nombres de las propiedades no se conocen de antemano y no pueden declararse en un tipo Flow. Si utilizas objetos de esta forma, puedes seguir utilizando Flow para describir la estructura de datos. Supongamos que tienes un objeto cuyas propiedades son los nombres de las principales ciudades del mundo y los valores de esas propiedades son objetos que especifican la ubicación geo- gráfica de esas ciudades. Podrías declarar esta estructura de datos así:</p>
    <pre>
    <code class="language-js">// @flow
    const cityLocations : &lbrace;[string]: &lbrace;longitude:number, latitude:number}} = &lbrace;
      "Seattle": &lbrace; longitude: 47.6062, latitude: -122.3321 },
      // TODO: si hay otras ciudades importantes, agrégalas aquí.
    };
    export default cityLocations;</code></pre>
  </section>
  <section id="8-5" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.5 Alias de tipo</h2>
    <p>Los objetos pueden tener muchas propiedades, y el tipo Flow que describe un objeto de este tipo será largo y difícil de escribir. E incluso los tipos de objeto relativamente cortos pueden ser confusos porque se parecen mucho a los literales de objeto. Una vez que vamos más allá de tipos simples como <codeinline>number</codeinline> y <codeinline>?string</codeinline>, a menudo es útil poder definir nombres para nuestros tipos Flow. Y de hecho, Flow utiliza la palabra clave <codeinline>type</codeinline> para hacer exactamente eso. Sigue el <codeinline>type</codeinline> con un identificador, un signo igual y un tipo de flujo. Una vez hecho esto, el identificador será un alias para el tipo. He aquí, por ejemplo, cómo podríamos reescribir la función <codeinline>distance()</codeinline> de la sección anterior con un tipo <codeinline>Point</codeinline> definido explícitamente:</p>
    <pre>
    <code class="language-js">// @flow
    export type Point = &lbrace;
      x: number,
      y: number
    };

    // Dado un objeto Point, devuelve su distancia desde el origen.
    export default function distance(point: Point): number &lbrace;
      return Math.hypot(point.x, point.y);
    }</code></pre>
    <p>Ten en cuenta que este código exporta la función <codeinline>distance()</codeinline> y también exporta el tipo <codeinline>Point</codeinline>. Otros módulos pueden usar el <codeinline>import type Point from './distance.js'</codeinline> si quieren usar esa definición de tipo. Ten en cuenta, sin embargo, que <codeinline>import type</codeinline> es una extensión del lenguaje Flow y no una directiva real de importación de JavaScript. Las importaciones y exportaciones de tipos son utilizadas por el comprobador de tipos de Flow, pero como todas las demás extensiones del lenguaje Flow, son eliminadas del código antes de que se ejecute.</p>
    <p>Por último, cabe señalar que en lugar de definir un nombre para un tipo de objeto Flow que represente un punto, probablemente sería más sencillo y limpio definir simplemente una clase Point y utilizar esa clase como tipo.</p>
  </section>
  <section id="8-6">
    <h2>17.8.6 Tipos de matrices</h2>
    <p>El tipo de Flow para describir un array es un tipo compuesto que también incluye el tipo de los elementos del array. Aquí, por ejemplo, hay una función que espera un array de números, y el error que Flow reporta si intentas llamar a la función con un array que tiene elementos no numéricos:</p>
    <pre class="language-js">
    Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ average.js:8:16

    Cannot call average with array literal bound to data because string [1]
    is incompatible with number [2] in array element.
    [2] 2│ function average(data: Array&lt;number>) &lbrace;
        3│    let sum = 0;
        4│    for(let x of data) sum += x;
        5│    return sum/data.length;
        6│ }
        7│
    [1] 8│ average([1, 2, "three"]);</pre>
    <p>El tipo de flujo para un array es <codeinline>Array</codeinline> seguido del tipo de elemento entre paréntesis angulares. También puedes expresar un tipo de matriz siguiendo el tipo de elemento con apertura y cierre corchetes. Así que en este ejemplo podríamos haber escrito <codeinline>number[]</codeinline> en lugar de <codeinline>Array&lt;number></codeinline>. Prefiero la notación de corchetes angulares porque, como veremos, hay otros tipos de Flow que utilizan esta sintaxis de corchetes angulares.</p>
    <p>La sintaxis de tipo Array mostrada funciona para arrays con un número arbitrario de elementos, todos los cuales tienen el mismo tipo. Flow tiene una sintaxis diferente para describir el tipo de una <em>tupla</em>: una matriz con un número fijo de elementos, cada uno de los cuales puede tener un tipo diferente. Para expresar el tipo de una tupla, simplemente escribe el tipo de cada uno de sus elementos, sepáralos con comas y enciérralos entre corchetes.</p>
    <pre>
    <code class="language-js">function getStatus():[number, string] &lbrace;
      return [getStatusCode(), getStatusMessage()];
    }</code></pre>
    <p>Una función que devuelva un código de estado HTTP y un mensaje podría tener este aspecto, por ejemplo:</p>
    <pre>
    <code class="language-js">let [code, message] = getStatus();</code></pre>
    <p>Las funciones que devuelven tuplas son difíciles de manejar a menos que se utilice la asignación desestructurante:</p>
    <pre>
    <code class="language-js">// @flow
    export type Color = [number, number, number, number]; // [r, g, b, opacity]

    function gray(level: number): Color &lbrace;
      return [level, level, level, 1];
    }

    function fade([r,g,b,a]: Color, factor: number): Color &lbrace;
      return [r, g, b, a/factor];
    }

    let [r, g, b, a] = fade(gray(75), 3);</code></pre>
    <p>La asignación de desestructuración, además de las capacidades de aliasing de tipos de Flow, hacen que las tuplas sean lo suficientemente fáciles de trabajar como para considerarlas una alternativa a las clases para tipos de datos simples:</p>
    <p>Ahora que tenemos una forma de expresar el tipo de una matriz, volvamos a la función <codeinline>size()</codeinline> de antes y modifiquémosla para que espere un argumento de matriz en lugar de un argumento de cadena. Queremos que la función sea capaz de aceptar un array de cualquier longitud, por lo que un tipo tupla no es apropiado. Pero no queremos restringir nuestra función a trabajar sólo para matrices donde todos los elementos tienen el mismo tipo. La solución es el tipo <codeinline>Array&lt;mixto></codeinline>:</p>
    <pre>
    <code class="language-js">// @flow
    function size(s: Array&lt;mixed>): number &lbrace;
      return s.length;
    }
    console.log(size([1,true,"three"]));</code></pre>
    <p>El tipo de elemento <codeinline>mixed</codeinline> indica que los elementos del array pueden ser de cualquier tipo. Si nuestra función realmente indexara el array e intentara usar cualquiera de esos elementos, Flow insistiría en que usáramos comprobaciones <codeinline>typeof</codeinline> u otras pruebas para determinar el tipo del elemento antes de realizar cualquier operación insegura sobre él. (Si estás dispuesto a renunciar a la comprobación de tipo, también puedes usar <codeinline>any</codeinline> en lugar de <codeinline>mixed</codeinline>: te permite hacer lo que quieras con los valores del array sin asegurarte de que los valores son del tipo que esperas).</p>
  </section>
  <section id="8-7" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.7 Otros tipos parametrizados</h2>
    <p>Hemos visto que cuando anotas un valor como <codeinline>Array</codeinline>, Flow requiere que especifiques también el tipo de los elementos del array dentro de los corchetes angulares. Este tipo adicional se conoce como un <em>parámetro</em> de tipo, y Array no es la única clase JavaScript que es parametrizada.</p>
    <p>La clase Set de JavaScript es una colección de elementos, como lo es un array, y no puedes usar Set como tipo por sí mismo, sino que tienes que incluir un parámetro de tipo entre paréntesis angulares para especificar el tipo de los valores contenidos en el conjunto. (Aunque puedes utilizar <codeinline>mixed</codeinline> o <codeinline>any</codeinline> si el conjunto puede contener valores de varios tipos). He aquí un ejemplo:</p>
    <pre>
    <code class="language-js">// @flow
    // Devuelve un conjunto de números con miembros que sean exactamente 
    // el doble de los del conjunto de números de entrada.
    function double(s: Set&lt;number>): Set&lt;number> &lbrace;
      let doubled: Set&lt;number> = new Set();
      for(let n of s) doubled.add(n * 2);
      return doubled;
    }
    console.log(double(new Set([1,2,3]))); // Imprime "Set &lbrace;2, 4, 6}"</code></pre>
    <p>Map es otro tipo parametrizado. En este caso, hay dos parámetros de tipo que deben especificarse; el tipo de las claves y los tipos de los valores:</p>
    <pre>
    <code class="language-js">// @flow
    import type &lbrace; Color } from "./Color.js";

    let colorNames: Map&lt;string, Color> = new Map([
      ["red", [1, 0, 0, 1]],
      ["green", [0, 1, 0, 1]],
      ["blue", [0, 0, 1, 1]]
    ]);</code></pre>
    <p>Flow también te permite definir parámetros de tipo para tus propias clases. El siguiente código define una clase Resultado pero parametriza esa clase con un tipo Error y un tipo Valor. Utilizamos marcadores de posición <codeinline>E</codeinline> y <codeinline>V</codeinline> en el código para representar estos parámetros de tipo. Cuando el usuario de esta clase declare una variable de tipo Resultado, especificará los tipos reales a sustituir por <codeinline>E</codeinline> y <codeinline>V</codeinline>. La declaración de la variable podría tener este aspecto:</p>
    <pre>
    <code class="language-js">let result: Result&lt;TypeError, Set&lt;string>>;</code></pre>
    <p>Y así es como se define la clase parametrizada:</p>
    <pre>
    <code class="language-js">// @flow
    // Esta clase representa el resultado de una operación que puede generar 
    // un error de tipo E o un valor de tipo V.
    export class Result&lt;E, V> &lbrace;
      error: ?E;
      value: ?V;

      constructor(error: ?E, value: ?V) &lbrace;
        this.error = error;
        this.value = value;
      }

      threw(): ?E &lbrace; return this.error; }
      returned(): ?V &lbrace; return this.value; }
      
      get():V &lbrace;
        if (this.error) &lbrace;
          throw this.error;
        } else if (this.value === null || this.value === undefined) &lbrace;
          throw new TypeError("Error and value must not both be null");
        } else &lbrace;
          return this.value;
        }
      }
    }</code></pre>
    <p>Incluso puede definir parámetros de tipo para las funciones:</p>
    <pre>
    <code class="language-js">// @flow
    // Combina los elementos de dos matrices en una matriz de pares
    function zip&lt;A,B>(a:Array&lt;A>, b:Array&lt;B>): Array&lt;[?A,?B]> &lbrace;
      let result:Array&lt;[?A,?B]> = [];
      let len = Math.max(a.length, b.length);
      for(let i = 0; i &lt; len; i++) &lbrace;
        result.push([a[i], b[i]]);
      }
      return result;
    }

    // Crea el array [[1,'a'], [2,'b'], [3,'c'], [4,undefined]]
    let pairs: Array&lt;[?number,?string]> = zip([1,2,3,4], ['a','b','c'])</code></pre>
  </section>
  <section id="8-8">
    <h2>17.8.8 Tipos de sólo lectura</h2>
    <p>Flow define algunos "tipos de utilidad" parametrizados especiales que tienen nombres que comienzan con <codeinline>$</codeinline>. La mayoría de estos tipos tienen casos de uso avanzados que no vamos a cubrir aquí. Pero dos de ellos son bastante útiles en la práctica. Si tienes un tipo de objeto T y quieres hacer una versión de sólo lectura de ese tipo, simplemente escribe <codeinline>$ReadOnly&lt;T></codeinline>. Del mismo modo, puedes escribir <codeinline>$ReadOnlyArray&lt;T></codeinline> para describir un array de sólo lectura con elementos de tipo T.</p>
    <p>La razón para usar estos tipos no es porque ofrezcan alguna garantía de que un objeto o array no pueda ser modificado (ver <codeinline>Object.freeze()</codeinline> en <a href="capitulo-14#2">§14.2</a> si quieres verdaderos objetos de sólo lectura) sino porque te permite detectar errores causados por modificaciones no intencionadas. Si escribes una función que toma un objeto o array como argumento y no cambia ninguna de las propiedades del objeto o los elementos del array, entonces puedes anotar el parámetro de la función con uno de los tipos de sólo lectura de Flow. Si haces esto, Flow informará de un error si te olvidas y accidentalmente modificas el valor de entrada. Aquí tienes dos ejemplos:</p>
    <pre>
    <code class="language-js">// @flow
    type Point = &lbrace;x:number, y:number};
    
    // Esta función toma un objeto Point pero promete no modificarlo
    function distance(p: $ReadOnly&lt;Point>): number &lbrace;
      return Math.hypot(p.x, p.y);
    }

    let p: Point = &lbrace;x:3, y:4};
    distance(p) // => 5
    
    // Esta función toma un array de números que no modificará
    function average(data: $ReadOnlyArray&lt;number>): number &lbrace;
      let sum = 0;
      for(let i = 0; i &lt; data.length; i++) sum += data[i];
      return sum/data.length;
    }

    let data: Array&lt;number> = [1,2,3,4,5];
    average(data) // => 3</code></pre>
  </section>
  <section id="8-9" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.9 Tipos de funciones</h2>
    <p>Hemos visto cómo añadir anotaciones de tipo para especificar los tipos de los parámetros de una función y su tipo de retorno. Pero cuando uno de los parámetros de una función es a su vez una función, necesitamos poder especificar el tipo de ese parámetro de función.</p>
    <p>Para expresar el tipo de una función con Flow, escriba los tipos de cada parámetro, sepárelos con comas, enciérrelos entre paréntesis y, a continuación, escriba una flecha y el tipo de retorno de la función.</p>
    <p>He aquí una función de ejemplo que espera que se le pase una función callback. Observe cómo hemos definido un alias de tipo para el tipo de la función de devolución de llamada:</p>
    <pre>
    <code class="language-js">// @flow
    // El tipo de la función de devolución de llamada utilizada en fetchText() a continuación
    export type FetchTextCallback = (?Error, ?number, ?string) => void;

    export default function fetchText(url: string, callback: FetchTextCallback) &lbrace;
      let status = null;
      fetch(url)
      .then(response => &lbrace;
        status = response.status;
        return response.text()
      })
      .then(body => &lbrace;
        callback(null, status, body);
      })
      .catch(error => &lbrace;
        callback(error, status, null);
      });
    }</code></pre>
  </section>
  <section id="8-10">
    <h2>17.8.10 Tipos de sindicatos</h2>
    <p>Volvamos una vez más a la función <codeinline>size()</codeinline>. Realmente no tiene sentido tener una función que no hace otra cosa que devolver la longitud de un array. Los arrays tienen una propiedad de <codeinline>length</codeinline> perfectamente buena para eso. Pero <codeinline>size()</codeinline> podría ser útil si pudiera tomar cualquier tipo de objeto de colección (una matriz, un conjunto o un mapa) y devolver el número de elementos de la colección. En JavaScript normal sin tipado sería fácil escribir una función <codeinline>size()</codeinline> como esa. Con Flow, necesitamos una forma de expresar un tipo que permita arrays, Sets y Maps, pero que no permita valores de ningún otro tipo.</p>
    <p>Flow denomina a los tipos de este tipo <em>Tipos de unión</em> y permite expresarlos simplemente enumerando los tipos deseados y separándolos con caracteres de barra vertical:</p>
    <pre>
    <code class="language-js">// @flow
    function size(collection: Array&lt;mixed>|Set&lt;mixed>|Map&lt;mixed,mixed>): number &lbrace;
      if (Array.isArray(collection)) &lbrace;
        return collection.length;
      } else &lbrace;
        return collection.size;
      }
    }
    size([1,true,"three"]) + size(new Set([true,false])) // => 5</code></pre>
    <p>Los tipos de unión pueden leerse utilizando la palabra "or" - "una matriz o un conjunto o un mapa"-, por lo que el hecho de que esta sintaxis de Flow utilice el mismo carácter de barra vertical que los operadores OR de JavaScript es intencionado.</p>
    <p>Hemos visto antes que anteponer un signo de interrogación a un tipo permite valores <codeinline>null</codeinline> e <codeinline>undefined</codeinline>. Y ahora puedes ver que un prefijo <codeinline>?</codeinline> es simplemente un atajo para añadir un sufijo <codeinline>|null|</codeinline> void a un tipo.</p>
    <p>En general, cuando anotas un valor con un tipo Union, Flow no te permitirá usar ese valor hasta que hayas hecho suficientes pruebas para averiguar cuál es el tipo del valor real. En el ejemplo de <codeinline>size()</codeinline> que acabamos de ver, necesitamos comprobar explícitamente si el argumento es un array antes de intentar acceder a la propiedad <codeinline>length</codeinline> del argumento. Observe que no tenemos que distinguir un argumento Set de un argumento Map, sin embargo: ambas clases definen una propiedad <codeinline>size</codeinline>, por lo que el código de la cláusula <codeinline>else</codeinline> es seguro siempre que el argumento no sea un array.</p>
  </section>
  <section id="8-11" class="py-4 xs:py-5 sm:py-6">
    <h2>17.8.11 Tipos enumerados y uniones discriminadas</h2>
    <p>Flow te permite usar literales primitivos como tipos que consisten en un único valor. Si escribes <codeinline>let x:3;</codeinline>, entonces Flow no te permitirá asignar ningún valor a esa variable que no sea 3. No suele ser útil definir tipos que tengan un único miembro, pero una unión de tipos literales puede ser útil. Probablemente puedes imaginar un uso para tipos como estos, por ejemplo:</p>
    <pre>
    <code class="language-js">type Answer = "yes" | "no";
    type Digit = 0|1|2|3|4|5|6|7|8|9;</code></pre>
    <p>Si utiliza tipos formados por literales, debe comprender que sólo se permiten valores literales:</p>
    <pre>
    <code class="language-js">let a: Answer = "Yes".toLowerCase();    // Error: no se puede asignar un string a Answer
    let d: Digit = 3+4;         // Error: no se puede asignar un número a Dígito</code></pre>
    <p>Cuando Flow comprueba tus tipos, en realidad no hace los cálculos: sólo comprueba los tipos de los cálculos. Flow sabe que <codeinline>toLowerCase()</codeinline> devuelve una cadena y que el operador <codeinline>+</codeinline> en números devuelve un número. Aunque sabemos que ambos cálculos devuelven valores que están dentro del tipo, Flow no puede saberlo y marca errores en ambas líneas.</p>
    <p>Un tipo de unión de tipos literales como <codeinline>Answer</codeinline> y <codeinline>Digit</codeinline> es un ejemplo de <em>tipo enumerado</em>, o <em>enum</em>. Un caso de uso canónico para los tipos enum es representar los palos de las cartas:</p>
    <pre>
    <code class="language-js">type Suit = "Clubs" | "Diamonds" | "Hearts" | "Spades";</code></pre>
    <p>Un ejemplo más relevante podrían ser los códigos de estado HTTP:</p>
    <pre>
    <code class="language-js">type HTTPStatus =
      | 200     // OK
      | 304     // Not Modified
      | 403     // Forbidden
      | 404;    // Not Found</code></pre>
    <p>Uno de los consejos que escuchan a menudo los nuevos programadores es que eviten utilizar literales en su código y que, en su lugar, definan constantes simbólicas para representar esos valores. Una razón práctica para ello es evitar el problema de los errores tipográficos: si escribe mal una cadena literal como "Diamonds", JavaScript nunca se quejará, pero es posible que su código no funcione correctamente. En cambio, si escribes mal un identificador, es probable que JavaScript lance un error que notarás. Con Flow, este consejo no siempre se aplica. Si anotas una variable con el tipo Traje, y luego intentas asignarle un traje mal escrito, Flow te avisará del error.</p>
    <p>Otro uso importante de los tipos literales es la creación de <em>uniones discriminadas</em>. Cuando se trabaja con uniones (formadas por diferentes tipos, no por literales), normalmente hay que escribir código para discriminar entre los posibles tipos. En la sección anterior, escribimos una función que podía tomar un array o un Set o un Map como argumento y tuvimos que escribir código para discriminar la entrada array de la entrada Set o Map. Si quieres crear una unión de tipos Object, puedes hacer que estos tipos sean fáciles de discriminar utilizando un tipo literal dentro de cada uno de los tipos Object individuales.</p>
    <p>Un ejemplo lo aclarará. Supongamos que estás usando un hilo trabajador en Node (<a href="capitulo-16#11">§16.11</a>) y estás usando <codeinline>postMessage()</codeinline> y eventos "mensaje" para enviar mensajes basados en objetos entre el hilo principal y el hilo trabajador. Hay múltiples tipos de mensajes que el trabajador puede querer enviar al hilo principal, pero nos gustaría escribir un tipo de Flow Union que describa todos los mensajes posibles. Considera este código:</p>
    <pre>
    <code class="language-js">// @flow
    // El trabajador envía un mensaje de este tipo cuando termina 
    // de reticular las splines que le enviamos.
    export type ResultMessage = &lbrace;
      messageType: "result",
      result: Array&lt;ReticulatedSpline>, // Supongamos que este tipo está definido en otro lugar.
    };

    // El trabajador envía un mensaje de este tipo si su código falló con una excepción.
    export type ErrorMessage = &lbrace;
      messageType: "error",
      error: Error,
    };

    // El trabajador envía un mensaje de este tipo para informar las estadísticas de uso.
    export type StatisticsMessage = &lbrace;
      messageType: "stats",
      splinesReticulated: number,
      splinesPerSecond: number
    };

    // Cuando recibimos un mensaje del trabajador, será un WorkerMessage.
    export type WorkerMessage = ResultMessage | ErrorMessage | StatisticsMessage;

    // El hilo principal tendrá una función de controlador de eventos a la que 
    // se le pasa un WorkerMessage. Pero debido a que hemos definido cuidadosamente 
    // cada uno de los tipos de mensajes para que tengan una propiedad messageType 
    // con un tipo literal, el controlador de eventos puede discriminar 
    // fácilmente entre los posibles mensajes:
    function handleMessageFromReticulator(message: WorkerMessage) &lbrace;
      if (message.messageType === "result") &lbrace;
        // Solo ResultMessage tiene una propiedad messageType con este valor, 
        // por lo que Flow sabe que es seguro usar message.result aquí. 
        // Y Flow se quejará si intenta usar cualquier otra propiedad.
        console.log(message.result);
      } else if (message.messageType === "error") &lbrace;
        // Solo ErrorMessage tiene una propiedad messageType con el valor "error", 
        // por lo que sabe que es seguro usar message.error aquí.
        throw message.error;
      } else if (message.messageType === "stats") &lbrace;
        // Solo StatisticsMessage tiene una propiedad messageType con el valor "stats", 
        // por lo que sabe que es seguro usar message.splinesPerSecond aquí.
        console.info(message.splinesPerSecond);
      }
    }</code></pre>
  </section>
  <section id="9" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>17.9 Resumen</h2>
    <p>JavaScript es el lenguaje de programación más utilizado actualmente en el mundo. Es un lenguaje vivo, que sigue evolucionando y mejorando, rodeado de un floreciente ecosistema de bibliotecas, herramientas y extensiones. En este capítulo se han presentado algunas de estas herramientas y extensiones, pero hay muchas más sobre las que aprender. El ecosistema JavaScript florece porque la comunidad de desarrolladores JavaScript es activa y vibrante, llena de compañeros que comparten sus conocimientos a través de blogs, vídeos y conferencias. Cuando cierres este libro y salgas a unirte a esta comunidad, no te faltarán fuentes de información para seguir aprendiendo sobre JavaScript.</p>
  </section>
  </Layoutjavascript>