---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-4" capSiguiente="capitulo-6" />
  <section class="fadeIn">
    <header class="flex justify-between">
      <img class="h-10" src="/public/javascript/cinco.svg" alt="Capitulo Cinco">
      <h1 class="text-right">Declaraciones</h1>
    </header>
    <p>El <a href="capitulo-4">cap√≠tulo 4</a> describ√≠a las expresiones como frases de JavaScript. Por esa analog√≠a, las <em>expresiones</em> son frases o comandos de JavaScript. Del mismo modo que las frases en ingl√©s se terminan y separan entre s√≠ con puntos, las sentencias en JavaScript se terminan con puntos y coma (<a href="capitulo-2#6">¬ß2.6</a>). Las expresiones se <em>eval√∫an</em> para producir un valor, pero las sentencias se <em>ejecutan</em> para que ocurra algo.</p>
    <p>Una forma de "hacer que ocurra algo" es evaluar una expresi√≥n que tenga efectos secundarios. Las expresiones con efectos secundarios, como las asignaciones y las invocaciones de funciones, pueden funcionar por s√≠ solas como sentencias y, cuando se utilizan de este modo, se conocen como <em>sentencias de expresi√≥n</em>. Una categor√≠a similar de sentencias son las <em>sentencias de declaraci√≥n</em> que declaran nuevas variables y definen nuevas funciones.</p>
    <p>Los programas JavaScript no son m√°s que una secuencia de sentencias a ejecutar. Por defecto, el int√©rprete de JavaScript ejecuta estas sentencias una tras otra en el orden en que est√°n escritas. Otra forma de "hacer que algo suceda" es alterar este orden de ejecuci√≥n predeterminado, y JavaScript tiene una serie de sentencias o <em>estructuras de control</em> que hacen precisamente esto:
    </p>
    <div class="">
      <p><em>Condicionales</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>if</codeinline> y <codeinline>switch</codeinline> que hacen que el int√©rprete de JavaScript ejecute u omita otras sentencias en funci√≥n del valor de una expresi√≥n.</p>
    </div>
    <div class="">
      <p><em>Bucles</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>while</codeinline> y <codeinline>for</codeinline> que ejecutan otras sentencias de forma repetitiva</p>
    </div>
    <div class="">
      <p><em>Saltos</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>break</codeinline>, <codeinline>return</codeinline> y <codeinline>throw</codeinline> que hacen que el int√©rprete salte a otra parte del programa.</p>
    </div>
    <p>Las secciones siguientes describen las distintas sentencias de JavaScript y explican su sintaxis. La <a href="tabla5-1">Tabla 5-1</a> al final del cap√≠tulo, resume la sintaxis. Un programa JavaScript es simplemente una secuencia de sentencias, separadas entre s√≠ por punto y coma, por lo que una vez que se familiarice con las sentencias de JavaScript, podr√° empezar a escribir programas JavaScript.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>5.1 Sentencias de expresi√≥n</h2>
    <p>Los tipos m√°s simples de sentencias en JavaScript son las expresiones que tienen efectos secundarios. Este tipo de sentencia se mostr√≥ en el <a href="capitulo-4">cap√≠tulo 4</a>. Las sentencias de asignaci√≥n son una de las principales categor√≠as de sentencias de expresi√≥n. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">greeting = "Hello " + name;
    i *= 3;</code></pre>
    <p>Los operadores de incremento y decremento, <codeinline>++</codeinline> y <codeinline>--</codeinline>, est√°n relacionados con los estados de asignaci√≥n. Tienen el efecto secundario de cambiar el valor de una variable, como si se hubiera realizado una asignaci√≥n:</p>
    <pre class="language-js">
    <code class="language-js">counter++;</code></pre>
    <p>El operador <codeinline>delete</codeinline> tiene el importante efecto secundario de borrar la propiedad de un objeto. Por lo tanto, casi siempre se utiliza como una sentencia, en lugar de como parte de una expresi√≥n m√°s amplia:</p>
    <pre class="language-js">
    <code class="language-js">delete o.x;</code></pre>
    <p>Las llamadas a funciones son otra categor√≠a importante de expresiones. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">console.log(debugMessage);
    displaySpinner(); // Una hipotetica funci√≥n que muestra un spinne en la aplicaci√≥n web</code></pre>
    <p>Estas llamadas a funciones son expresiones, pero tienen efectos secundarios que afectan al entorno anfitri√≥n o al estado del programa, y se utilizan aqu√≠ como sentencias. Si una funci√≥n no tiene efectos secundarios, no tiene sentido llamarla, a menos que forme parte de una expresi√≥n mayor o de una sentencia de asignaci√≥n. Por ejemplo, no calcular√≠as un coseno y descartar√≠as el resultado:</p>
    <pre class="language-js">
    <code class="language-js">Math.cos(x);</code></pre>
    <p>Pero bien podr√≠a calcular el valor y asignarlo a una variable para su uso futuro:</p>
    <pre class="language-js">
    <code class="language-js">cx = Math.cos(x);</code></pre>
    <p>Observe que cada l√≠nea de c√≥digo de estos ejemplos termina con un punto y com</p>
  </section>
  <section id="2">
    <h2>5.2 Enunciados compuestos y vac√≠os</h2>
    <p>Al igual que el operador coma (<a href="#13-7">¬ß4.13.7</a>) combina varias expresiones en una sola, un <em>bloque de sentencias</em> combina varias sentencias en una sola <em>sentencia compuesta</em>. Un bloque de sentencias es simplemente una secuencia de sentencias encerradas entre llaves. As√≠, las siguientes l√≠neas act√∫an como una √∫nica sentencia y pueden utilizarse en cualquier lugar en el que JavaScript espere una √∫nica sentencia:</p>
    <pre class="language-js">
    <code class="language-js">&lbrace;
      x = Math.PI;
      cx = Math.cos(x);
      console.log("cos(œÄ) = " + cx);
    }</code></pre>
    <p>Hay que tener en cuenta algunas cosas sobre este bloque de sentencia. En primer lugar, <em>no</em> termina con punto y coma. Las sentencias primitivas dentro del bloque terminan en punto y coma, pero el bloque en s√≠ no. En segundo lugar, las l√≠neas dentro del bloque est√°n sangradas con respecto a las llaves que las encierran. Esto es opcional, pero facilita la lectura y comprensi√≥n del c√≥digo.</p>
    <p>Del mismo modo que las expresiones suelen contener subexpresiones, muchas sentencias de JavaScript contienen sustantivos. Formalmente, la sintaxis de JavaScript suele permitir una √∫nica sentencia. Por ejemplo, la sintaxis del bucle <codeinline>while</codeinline> incluye una √∫nica sentencia que sirve como cuerpo del bucle. Utilizando un bloque de sentencias, puede colocar cualquier n√∫mero de sentencias dentro de esta √∫nica sustanciaci√≥n permitida.</p>
    <p>Una sentencia compuesta le permite utilizar varias sentencias donde la sintaxis de JavaScript espera una √∫nica sentencia. La <em>sentencia empty</em> es lo contrario: permite no incluir ninguna sentencia donde se espera una. La sentencia empty tiene el siguiente aspecto:</p>
    <pre class="language-js">
    ;</pre>
    <p>El int√©rprete de JavaScript no realiza ninguna acci√≥n cuando ejecuta una sentencia vac√≠a. La sentencia empty es √∫til ocasionalmente cuando se desea crear un bucle con un cuerpo vac√≠o. Considere el siguiente bucle <codeinline>for</codeinline> (los bucles <codeinline>for</codeinline> se tratar√°n en <a href="#4.3">¬ß5.4.3</a>):</p>
    <pre class="language-js">
    <code class="language-js">// Inializa un array a
      for(let i = 0; i &lt; a.length; a[i++] = 0) ;</code></pre>
    <p>En este bucle, todo el trabajo lo realiza la expresi√≥n <codeinline>a[i++] = 0</codeinline>, y no es necesario ning√∫n cuerpo de bucle. Sin embargo, la sintaxis de JavaScript requiere una expresi√≥n como cuerpo del bucle, por lo que se utiliza una expresi√≥n vac√≠a, s√≥lo un punto y coma.</p>
    <p>Tenga en cuenta que la inclusi√≥n accidental de un punto y coma despu√©s del par√©ntesis derecho de un bucle <codeinline>for</codeinline>, un bucle <codeinline>while</codeinline> o una sentencia <codeinline>if</codeinline> puede provocar errores frustrantes dif√≠ciles de detectar. Por ejemplo, el siguiente c√≥digo probablemente no hace lo que el autor pretend√≠a:</p>
    <pre class="language-js">
    <code class="language-js">if ((a === 0) || (b === 0)); // Ups..! Esta linea no hace nada
      o = null;                  // y esta linea siempre se ejecuta</code></pre>
    <p>Cuando utilice intencionadamente la sentencia empty, es una buena idea comentar su c√≥digo de forma que quede claro que lo hace a prop√≥sito. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; a.length; a[i++] = 0) /* vacio */ ;</code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3 Condicionales</h2>
    <p>Las sentencias condicionales ejecutan u omiten otras sentencias en funci√≥n del valor de una expresi√≥n especificada. Estas sentencias son los puntos de decisi√≥n de su c√≥digo, y tambi√©n se conocen a veces como "ramas". Si imagina un int√©rprete de JavaScript siguiendo un camino a trav√©s de su c√≥digo, las sentencias condicionales son los lugares donde el c√≥digo se bifurca en dos o m√°s caminos y el int√©rprete debe elegir qu√© camino seguir.</p>
    <p>Las siguientes subsecciones explican la condicional b√°sica de JavaScript, el estado <codeinline>if/else</codeinline>, y tambi√©n cubren <codeinline>switch</codeinline>, una sentencia de bifurcaci√≥n multidireccional m√°s complicada.</p>
  </section>
  <section id="3-1">
    <h2>5.3.1 If</h2>
    <p>La sentencia <codeinline>if</codeinline> es la sentencia de control fundamental que permite a JavaScript tomar decisiones o, m√°s exactamente, ejecutar sentencias condicionalmente. Esta sentencia tiene dos formas. La primera es:</p>
    <pre class="language-js">
    if (expression)
      statement</pre>
    <p>En este formulario, se eval√∫a la expresi√≥n. Si el valor resultante es verdadero, se ejecuta la <em>sentencia</em>. Si la <em>expresi√≥n</em> es falsa, la <em>sentencia</em> no se ejecuta. (V√©ase <a href="capitulo-3#4">¬ß3.4</a> para una definici√≥n de los valores verdadero y falso): Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">if (usuario == null)    // Si el usuario es null o undefined
      usuario = "John Doe"; // definelo</code></pre>
    <p>O algo parecido:</p>
    <pre class="language-js">
    <code class="language-js">// Si usuario es null, undefined, false, 0, "" o NaN dale un nuevo valor
    if (!usuario) usuario = "John Doe";</code></pre>
    <p>Tenga en cuenta que los par√©ntesis alrededor de la <em>expresi√≥n</em> son una parte obligatoria de la sintaxis de la sentencia <codeinline>if</codeinline>.</p>
    <p>La sintaxis de JavaScript requiere una √∫nica sentencia despu√©s de la palabra clave <codeinline>if</codeinline> y la expresi√≥n entre par√©ntesis, pero puede utilizar un bloque de sentencias para combinar varias sentencias en una sola. As√≠ que la sentencia <codeinline>if</codeinline> tambi√©n podr√≠a tener este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">if (!address) &lbrace;
      address = "";
      message = "Por favor ingrese su direcci√≥n de correo.";
    }</code></pre>
    <p>La segunda forma de la sentencia <codeinline>if</codeinline> introduce una cl√°usula <codeinline>else</codeinline> que se ejecuta cuando es la <em>expresi√≥n</em> es <codeinline>false</codeinline>. Su sintaxis es:</p>
    <pre class="language-js">
      if (expression)
      statement1
      else
      statement2</pre>
    <p>Esta forma de la sentencia ejecuta la <codeinline>sentencia1</codeinline> si la <em>expresi√≥n</em> es verdadera y ejecuta <codeinline>statement2</codeinline> si la <em>expresi√≥n</em> es falsa. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1)
      console.log("Tines un mensaje nuevo.");
    else
      console.log(`Tienes $&lbrace;n} mensajes nuevos.`);</code></pre>
    <p>Cuando se han anidado sentencias <codeinline>if</codeinline> con cl√°usulas <codeinline>else</codeinline>, se requiere cierta precauci√≥n para asegurar que la cl√°usula <codeinline>else</codeinline> va con la sentencia <codeinline>if</codeinline> apropiada. Considere las siguientes l√≠neas:</p>
    <pre class="language-js">
    <code class="language-js">i = j = 1;
    k = 2;
    if (i === j)
      if (j === k)
        console.log("i es igual a k");
    else
      console.log("i no es igual a  j"); // MAL!!</code></pre>
    <p>En este ejemplo, la sentencia <codeinline>if</codeinline> interna forma la √∫nica sentencia permitida por la sintaxis de la sentencia <codeinline>if</codeinline> externa. Desafortunadamente, no est√° claro (excepto por la pista dada por la sangr√≠a) con qu√© <codeinline>if</codeinline> va el <codeinline>else</codeinline>. Y en este ejemplo, la sangr√≠a es incorrecta, porque un int√©rprete de JavaScript interpreta el ejemplo anterior como:</p>
    <pre class="language-js">
    <code class="language-js">if (i === j) &lbrace;
      if (j === k)
        console.log("i es igual k");
      else
        console.log("i no es igual j"); // UPS!
    }</code></pre>
    <p>La regla en JavaScript (como en la mayor√≠a de los lenguajes de programaci√≥n) es que, por defecto, una cl√°usula <codeinline>else</codeinline> forma parte de la sentencia <codeinline>if</codeinline> m√°s pr√≥xima. Para que este ejemplo sea menos ambiguo y m√°s f√°cil de leer, entender, mantener y depurar, debe utilizar llaves:</p>
    <pre class="language-js">
    <code class="language-js">if (i === j) &lbrace;
      if (j === k) &lbrace;
        console.log("i es igual k");
      }
    } else &lbrace; // Que diferencia hace la ubicaci√≥n de las llaves!
      console.log("i no es igual a j");
    }</code></pre>
    <p>Muchos programadores acostumbran a encerrar los cuerpos de las sentencias <codeinline>if</codeinline> y <codeinline>else</codeinline> (as√≠ como otras sentencias compuestas, como los bucles <codeinline>while</codeinline>) entre llaves, incluso cuando el cuerpo consta de una sola sentencia. Si lo hace de forma sistem√°tica, puede evitar el tipo de problema que se acaba de mostrar, por lo que le aconsejo que adopte esta pr√°ctica. En este libro impreso, hago hincapi√© en mantener el c√≥digo de ejemplo verticalmente compacto, y no siempre sigo mis propios consejos al respecto.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3.2 else if</h2>
    <p>La sentencia <codeinline>if/else</codeinline> eval√∫a una expresi√≥n y ejecuta uno o dos fragmentos de c√≥digo, en funci√≥n del resultado. Pero, ¬øqu√© ocurre cuando es necesario ejecutar uno de varios fragmentos de c√≥digo? Una forma de hacerlo es con una sentencia <codeinline>else if</codeinline>. <codeinline>else if</codeinline> no es realmente una sentencia JavaScript, sino simplemente un lenguaje de programaci√≥n de uso frecuente que resulta cuando se utilizan sentencias <codeinline>if/else</codeinline> repetidas:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el c√≥digo del bloque #1
    } else if (n === 2) &lbrace;
      // Ejecuta el c√≥digo del bloque #2
    } else if (n === 3) &lbrace;
      // Ejecuta el c√≥digo del bloque #3
    } else &lbrace;
      // Si todo falla, ejecuta el c√≥digo del bloque #4
    }</code></pre>
    <p>Este c√≥digo no tiene nada de especial. Es simplemente una serie de sentencias <codeinline>if</codeinline>, donde cada <codeinline>if</codeinline> siguiente es parte de la cl√°usula <codeinline>else</codeinline> de la sentencia anterior. Usar el lenguaje <codeinline>else if</codeinline> es preferible y m√°s legible que escribir estas sentencias en su forma sint√°cticamente equivalente, completamente anidada:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el c√≥digo del bloque #1
    }
    else &lbrace;
      if (n === 2) &lbrace;
        // Execute code block #2
      }
      else &lbrace;
        if (n === 3) &lbrace;
          // Ejecuta el c√≥digo del bloque #3
        }
        else &lbrace;
          // Si todo falla, ejecuta el c√≥digo del bloque #4
        }
      }
    }</code></pre>
  </section>
  <section id="3-3">
    <h2>5.3.3 switch</h2>
    <p>Una sentencia <codeinline>if</codeinline> provoca una bifurcaci√≥n en el flujo de ejecuci√≥n de un programa, y puede utilizar la expresi√≥n <codeinline>else if</codeinline> para realizar una bifurcaci√≥n multidireccional. Sin embargo, esta no es la mejor soluci√≥n cuando todas las ramas dependen del valor de la misma expresi√≥n. En este caso, es un desperdicio evaluar repetidamente esa expresi√≥n en m√∫ltiples sentencias <codeinline>if</codeinline>.</p>
    <p>La sentencia <codeinline>switch</codeinline> trata exactamente esta situaci√≥n. La palabra clave <codeinline>switch</codeinline> va seguida de una expresi√≥n entre par√©ntesis y un bloque de c√≥digo entre llaves:</p>
    <pre class="language-js">
    switch(expression) &lbrace;
      statements
    }</pre>
    <p>Sin embargo, la sintaxis completa de una sentencia <codeinline>switch</codeinline> es m√°s compleja que esto. Varias ubicaciones en el bloque de c√≥digo se etiquetan con la palabra clave <codeinline>clase</codeinline> seguida de una expresi√≥n y dos puntos. Cuando se ejecuta un <codeinline>switch</codeinline>, calcula el valor de la <em>expresi√≥n</em> y busca una etiqueta <codeinline>case</codeinline> cuya expresi√≥n se eval√∫e con el mismo valor (donde la igualdad viene determinada por el operador <codeinline>===</codeinline>). Si encuentra uno, comienza a ejecutar el bloque de c√≥digo en la sentencia etiquetada por <codeinline>case</codeinline>. Si no encuentra un <codeinline>case</codeinline> con un valor coincidente, busca una sentencia etiquetada como <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta el bloque de c√≥digo.</p>
    <p><codeinline>switch</codeinline> es una sentencia confusa de explicar; su funcionamiento queda mucho m√°s claro con un ejemplo. La siguiente sentencia <codeinline>switch</codeinline> es equivalente a las sentencias <codeinline>if/else</codeinline> repetidas mostradas en la secci√≥n anterior:</p>
    <pre class="language-js">
    <code class="language-js">switch(n) &lbrace;
    case 1: // Empieza aqu√≠ si n === 1
      // Execute code block #1.
      break; // Se detiene aqu√≠
    case 2: // Empieza aqu√≠ si n === 2
      // Execute code block #2.
      break; // Se detiene aqu√≠
    case 3: // Empieza aqu√≠ si n === 3
      // Execute code block #3.
      break; // Se detiene aqu√≠
    default: // Si todo falla,
      // Ejecuta el c√≥digo del bloque #4
      break; // Se detiene aqu√≠
    }</code></pre>
    <p>Observe la palabra clave <codeinline>break</codeinline> utilizada al final de cada caso en este c√≥digo. El estado <codeinline>break</codeinline>, descrito m√°s adelante en este cap√≠tulo, hace que el int√©rprete salte al final (o "salga") de la sentencia <codeinline>switch</codeinline> y contin√∫e con la sentencia que le sigue. Las cl√°usulas <codeinline>case</codeinline> en una sentencia <codeinline>switch</codeinline> especifican s√≥lo el <em>punto de inicio</em> del c√≥digo deseado; no especifican ning√∫n punto final. En ausencia de sentencias <codeinline>break</codeinline>, una sentencia <codeinline>switch</codeinline> comienza a ejecutar su bloque de c√≥digo en la etiqueta <codeinline>case</codeinline> que coincide con la sentencia de su <em>expresi√≥n</em> y contin√∫a ejecutando sentencias hasta que llega al final del bloque. En raras ocasiones, es √∫til escribir c√≥digo como este que "pasa" de una etiqueta <codeinline>case</codeinline> a la siguiente, pero el 99% de las veces debe tener cuidado de terminar cada <codeinline>case</codeinline> con una sentencia <codeinline>break</codeinline>. (Sin embargo, cuando use <codeinline>switch</codeinline> dentro de una funci√≥n, puede usar una sentencia <codeinline>return</codeinline> en lugar de una sentencia <codeinline>break</codeinline>. Ambas sirven para terminar la sentencia <codeinline>switch</codeinline> y evitar que la ejecuci√≥n pase al siguiente <codeinline>case</codeinline>).</p>
    <p>He aqu√≠ un ejemplo m√°s realista de la sentencia <codeinline>switch</codeinline>; convierte un valor en una cadena de una forma que depende del tipo del valor:</p>
    <pre class="language-js">
    <code class="language-js">function convert(x) &lbrace;
      switch(typeof x) &lbrace;
      case "number": // Convierte el n√∫mero en hexadecimal
        return x.toString(16);
      case "string": // Devuelve la cadena entre comillas
        return '"' + x + '"';
      default: // Convierte cualquier otro tipo en una cadena
        return String(x);
      }
    }</code></pre>
    <p>Observe que en los dos ejemplos anteriores, las palabras clave <codeinline>case</codeinline> van seguidas de literales num√©ricos y de cadena, respectivamente. As√≠ es como la sentencia <codeinline>switch</codeinline> se utiliza m√°s a menudo en la pr√°ctica, pero tenga en cuenta que el est√°ndar ECMAScript permite que cada <codeinline>case</codeinline> vaya seguido de una expresi√≥n arbitraria.</p>
    <p>La sentencia <codeinline>switch</codeinline> eval√∫a primero la expresi√≥n que sigue a la palabra clave <codeinline>switch</codeinline> y luego eval√∫a las expresiones <codeinline>case</codeinline>, en el orden en que aparecen, hasta encontrar un valor que coincida.<sup>1</sup> El caso coincidente se determina utilizando el operador de identidad <codeinline>===</codeinline>, no el operador de igualdad <codeinline>==</codeinline>, por lo que las expresiones deben coincidir sin ninguna conversi√≥n de tipo.</p>
    <p>Dado que no todas las expresiones <codeinline>case</codeinline> se eval√∫an cada vez que se ejecuta la sentencia <codeinline>switch</codeinline>, debe evitar el uso de expresiones <codeinline>case</codeinline> que contengan efectos secundarios como llamadas a funciones o asignaciones. Lo m√°s seguro es limitar las expresiones <codeinline>case</codeinline> a expresiones constantes.</p>
    <p>Como se explic√≥ anteriormente, si ninguna de las expresiones <codeinline>case</codeinline> coincide con la expresi√≥n <codeinline>switch</codeinline>, la sentencia <codeinline>switch</codeinline> comienza a ejecutar su cuerpo en la sentencia etiquetada <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta todo su cuerpo. Observe que en los ejemplos mostrados, la etiqueta <codeinline>default:</codeinline> aparece al final del cuerpo de la sentencia <codeinline>switch</codeinline>, despu√©s de todas las etiquetas <codeinline>case</codeinline>. Este es un lugar l√≥gico y com√∫n para ella, pero en realidad puede aparecer en cualquier lugar dentro del cuerpo de la declaraci√≥n.</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4 Bucles (loops)</h2>
    <p>Para entender las sentencias condicionales, imaginemos que el int√©rprete de JavaScript sigue un camino ramificado a trav√©s del c√≥digo fuente. Las <em>sentencias de bucle</em> son las que doblan ese camino sobre s√≠ mismo para repetir partes del c√≥digo. JavaScript tiene cinco sentencias de bucle: <codeinline>while</codeinline>, <codeinline>do/while</codeinline>, <codeinline>for</codeinline>, <codeinline>for/of</codeinline> (y su variante <codeinline>for/await</codeinline>), y <codeinline>for/in</codeinline>. Las siguientes subsecciones explican cada una de ellas. Un uso com√∫n de los bucles es iterar sobre los elementos de un array. <a href="capitulo-7#6">¬ß7.6</a> discute este tipo de bucle en detalle y cubre los m√©todos especiales de bucle definidos por la clase Array.
    </p>
  </section>
  <section id="4-1">
    <h2>5.4.1 While</h2>
    <p>Al igual que la sentencia <codeinline>if</codeinline> es el condicional b√°sico de JavaScript, la sentencia <codeinline>while</codeinline> es el bucle b√°sico de JavaS cript. Su sintaxis es la siguiente:</p>
    <pre class="language-js">
    while (expression)
      statement</pre>
    <p>Para ejecutar una sentencia <codeinline>while</codeinline>, el int√©rprete eval√∫a primero la <em>expresi√≥n</em>. Si el valor de la expresi√≥n es falso, el int√©rprete se salta la <em>sentencia</em> que sirve de cuerpo del bucle y pasa a la siguiente sentencia del programa. Si, por el contrario, la <em>expresi√≥n</em> es verdadera, el int√©rprete ejecuta la <em>sentencia</em> y repite, saltando de nuevo al principio del bucle y evaluando de nuevo la <em>expresi√≥n</em>. Otra forma de decir esto es que el int√©rprete ejecuta la <em>sentencia</em> repetidamente <em>mientras</em> la <em>expresi√≥n</em> es verdadera. Tenga en cuenta que puede crear un bucle infinito con la sintaxis <codeinline>while(true)</codeinline>.</p>
    <p>Normalmente, no se desea que JavaScript realice exactamente la misma operaci√≥n una y otra vez. En casi todos los bucles, una o m√°s variables cambian con cada <em>iteraci√≥n</em> del bucle. Dado que las variables cambian, las acciones realizadas al ejecutar la <em>sentencia</em> pueden diferir cada vez que se repite el bucle. Adem√°s, si la variable o variables que cambian est√°n involucradas en una <em>expresi√≥n</em>, el valor de la expresi√≥n puede ser diferente cada vez que se repite el bucle. Esto es importante; de lo contrario, una expresi√≥n que comienza siendo verdadera nunca cambiar√≠a, ¬°y el bucle nunca terminar√≠a! He aqu√≠ un ejemplo de un bucle <codeinline>while</codeinline> que imprime los n√∫meros del 0 al 9:</p>
    <pre class="language-js">
    <code class="language-js">let count = 0;
    while(count &lt; 10) &lbrace;
      console.log(count);
      count++;
    }</code></pre>
    <p>Como puedes ver, la variable <codeinline>count</codeinline> empieza en 0 y se incrementa cada vez que se ejecuta el cuerpo del bucle. Una vez que el bucle se ha ejecutado 10 veces, la expresi√≥n se convierte en <codeinline>false</codeinline> (es decir, la variable <codeinline>count</codeinline> ya no es inferior a 10), la sentencia <codeinline>while</codeinline> finaliza y el int√©rprete puede pasar a la siguiente sentencia del programa. Muchos bucles tienen una variable contador como <codeinline>count</codeinline>. Los nombres de variables <codeinline>i</codeinline>, <codeinline>j</codeinline>, y <codeinline>k</codeinline> se usan com√∫nmente como contadores de bucle, aunque deber√≠a usar nombres m√°s descriptivossihacequesuc√≥digo sea m√°sf√°cildeentender.</p>
  </section>
  <section id="4-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.2 Do/While</h2>
    <p>El bucle <codeinline>do/while</codeinline> es como un bucle <codeinline>while</codeinline>, salvo que la expresi√≥n del bucle se comprueba al final del bucle en lugar de al principio. Esto significa que el cuerpo del bucle siempre se ejecuta al menos una vez. La sintaxis es:</p>
    <pre class="language-js">
    do
      statement
    while (expression);</pre>
    <p>El bucle <codeinline>do/while</codeinline> es menos com√∫nmente usado que su primo <codeinline>while</codeinline> en la pr√°ctica, es algo poco com√∫n estar seguro de que quieres que un bucle se ejecute al menos una vez. Aqu√≠ hay un ejemplo de un bucle <codeinline>do/while</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">function printArray(a) &lbrace;
      let len = a.length, i = 0;
      if (len === 0) &lbrace;
        console.log("Empty Array");
      } else &lbrace;
        do &lbrace;
          console.log(a[i]);
        } while(++i &lt; len);
      }
    }</code></pre>
    <p>Hay un par de diferencias sint√°cticas entre el bucle <codeinline>do/while</codeinline> y el bucle <codeinline>while</codeinline> ordinario. En primer lugar, el bucle <codeinline>do</codeinline> requiere tanto la palabra clave <codeinline>do</codeinline> (para marcar el inicio del bucle) como la palabra clave <codeinline>while</codeinline> (para marcar el final e introducir la condici√≥n del bucle). Adem√°s, el bucle <codeinline>do</codeinline> debe terminar siempre con punto y coma. El bucle <codeinline>while</codeinline> no necesita punto y coma si el cuerpo del bucle est√° encerrado entre llaves.</p>
  </section>
  <section id="4-3">
    <h2>5.4.3 for</h2>
    <p>La sentencia <codeinline>for</codeinline> proporciona una construcci√≥n de bucle que a menudo es m√°s conveniente que la sentencia <codeinline>while</codeinline>. La sentencia <codeinline>for</codeinline> simplifica los bucles que siguen un patr√≥n com√∫n. La mayor√≠a de los bucles tienen una variable contadora de alg√∫n tipo. Esta variable se inicializa antes de que comience el bucle y se comprueba antes de cada iteraci√≥n del bucle. Finalmente, la variable contador se incrementa o se actualiza al final del bucle, justo antes de que la variable se compruebe de nuevo. En este tipo de bucle, la inicializaci√≥n, la prueba y la actualizaci√≥n son las tres manipulaciones cruciales de una variable de bucle. La sentencia <codeinline>for</codeinline> codifica cada una de estas tres manipulaciones como una expresi√≥n y las convierte en parte expl√≠cita de la sintaxis del bucle:r</p>
    <pre class="language-js">
    for(initialize ; test ; increment)
      statement</pre>
    <p><em>inicializar</em>, <em>probar</em> e <em>incrementar</em> son tres expresiones (separadas por punto y coma) que son responsables de inicializar, probar e incrementar la variable del bucle. Ponerlas todas en la primera l√≠nea del bucle facilita la comprensi√≥n de lo que est√° haciendo un bucle <codeinline>for</codeinline> y evita errores como olvidar inicializar o incrementar la variable del bucle.</p>
    <p>La forma m√°s sencilla de explicar c√≥mo funciona un bucle <codeinline>for</codeinline> es mostrar el <codeinline>while</codeinline> equivalente bucle:<sup>2</sup></p>
    <pre class="language-js">
    initialize;
    while(test) &lbrace;
      statement
      increment;
    }</pre>
    <p>En otras palabras, la expresi√≥n <em>inicializar</em> se eval√∫a una vez, antes de que comience el bucle. Para ser √∫til, esta expresi√≥n debe tener efectos secundarios (normalmente una asignaci√≥n). JavaScript tambi√©n permite que <em>initialize</em> sea una sentencia de declaraci√≥n de variable, de modo que se puede declarar e inicializar un contador de bucle al mismo tiempo. La expresi√≥n <em>test</em> se eval√∫a antes de cada iteraci√≥n y controla si se ejecuta el cuerpo del bucle. Si el valor de <em>test</em> es verdadero, se ejecuta la <em>sentencia</em> que constituye el cuerpo del bucle. Por √∫ltimo, se eval√∫a la em de <em>incremento</em>. De nuevo, debe ser una expresi√≥n con efectos secundarios para ser √∫til. Generalmente, es una expresi√≥n de asignaci√≥n, o utiliza los operadores <codeinline>++</codeinline> o <codeinline>--</codeinline>.</p>
    <p>Podemos imprimir los n√∫meros del 0 al 9 con un bucle <codeinline>for</codeinline> como el siguiente. Contr√°stalo con el bucle <codeinline>while</codeinline> equivalente mostrado en la secci√≥n anterior:</p>
    <pre class="language-js">
    <code class="language-js">for(let count = 0; count &lt; 10; count++) &lbrace;
      console.log(count);
    }</code></pre>
    <p>Los bucles pueden llegar a ser mucho m√°s complejos que este sencillo ejemplo, por supuesto, y a veces m√∫ltiples variables cambian con cada iteraci√≥n del bucle. Esta situaci√≥n es el √∫nico lugar donde el operador coma se utiliza com√∫nmente en JavaScript; proporciona una manera de combinar m√∫ltiples expresiones de inicializaci√≥n e incremento en una sola expresi√≥n adecuada para su uso en un bucle <codeinline>for</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let i, j, sum = 0;
      for(i = 0, j = 10 ; i &lt; 10 ; i++, j--) &lbrace;
      sum += i * j;
    }</code></pre>
    <p>En todos nuestros ejemplos de bucles hasta ahora, la variable del bucle ha sido num√©rica. Esto es bastante com√∫n, pero no es necesario. El siguiente c√≥digo utiliza un bucle <codeinline>for</codeinline> para recorrer una estructura de datos de lista enlazada y devolver el √∫ltimo objeto de la lista (es decir, el primer objeto que no tiene una propiedad <codeinline>next</codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">function tail(o) &lbrace; // Devuelve la ultima de la lista enlazada
      for(; o.next; o = o.next) /* empty */ ; // Recorre mientras o.next sea verdadero
      return o;
    }</code></pre>
    <p>Observe que este c√≥digo no tiene ninguna expresi√≥n de <em>inicializaci√≥n</em>. Cualquiera de las tres expresiones puede omitirse en un bucle <codeinline>for</codeinline>, pero los dos puntos y coma son obligatorios. Si omite la expresi√≥n de <em>prueba</em>, el bucle se repite para siempre, y <codeinline>for(;;)</codeinline> es otra forma de escribir un bucle infinito, como <codeinline>while(true)</codeinline>.</p>
  </section>
  <section id="4-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.4 for/of</h2>
    <p>ES6 define una nueva sentencia de bucle: <codeinline>for/of</codeinline>. Este nuevo tipo de bucle utiliza la palabra clave <codeinline>for</codeinline>, pero es un tipo de bucle completamente diferente del bucle <codeinline>for</codeinline> normal. (Tambi√©n es completamente diferente del antiguo bucle <codeinline>for/in</codeinline> que describiremos en <a href="capitulo-5#4-5">¬ß5.4.5</a>.)</p>
    <p>El bucle <codeinline>for/of</codeinline> funciona con objetos <em>iterables</em>. Explicaremos exactamente qu√© significa que un objeto sea iterable en el <a href="capitulo-12">Cap√≠tulo 12</a>, pero para este cap√≠tulo, es suficiente saber que los arrays, cadenas, conjuntos y mapas son iterables: representan una secuencia o conjunto de elementos que puedes recorrer usando un bucle <codeinline>for/of</codeinline>.</p>
    <p>Aqu√≠, por ejemplo, podemos utilizar <codeinline>for/of</codeinline> para recorrer los elementos de una matriz de n√∫meros y calcular su suma:</p>
    <pre class="language-js">
    <code class="language-js">let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
    for(let element of data) &lbrace;
      sum += element;
    }
    sum // => 45</code></pre>
    <p>Superficialmente, la sintaxis se parece a la de un bucle <codeinline>for</codeinline> normal: la palabra clave <codeinline>for</codeinline> va seguida de par√©ntesis que contienen detalles sobre lo que debe hacer el bucle. En este caso, los par√©ntesis contienen una declaraci√≥n de variable (o, para variables que ya han sido declaradas, simplemente el nombre de la variable) seguida por la palabra clave <codeinline>of</codeinline> y una expresi√≥n que eval√∫a a un objeto iterable, como el array de <codeinline>date</codeinline> en este caso. Como con todos los bucles, el cuerpo de un bucle <codeinline>for/of</codeinline> sigue a los par√©ntesis, normalmente entre llaves.</p>
    <p>En el c√≥digo que se acaba de mostrar, el cuerpo del bucle se ejecuta una vez por cada elemento de la matriz de <codeinline>data</codeinline>. Antes de cada ejecuci√≥n del cuerpo del bucle, el siguiente elemento de la matriz se asigna a la variable element. Los elementos del array se iteran en orden del primero al √∫ltimo.</p>
    <p>Los arrays se iteran "en vivo"-los cambios realizados durante la iteraci√≥n pueden afectar al resultado de la misma. Si modificamos el c√≥digo anterior a√±adiendo la l√≠nea <codeinline>data.push(sum);</codeinline> dentro del cuerpo del bucle, entonces creamos un bucle infinito porque la iteraci√≥n nunca puede alcanzar el √∫ltimo elemento del array.</p>
    <p class="title-article text-left">for/of con objectos</p>
    <p>Los objetos no son iterables (por defecto). El intento de utilizar <codeinline>for/of</codeinline> en un objeto normal produce un TypeError en tiempo de ejecuci√≥n:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    for(let element of o) &lbrace; // Throws TypeError porque o no es iterable
      console.log(element);
    }</code></pre>
    <p>Si quieres iterar a trav√©s de las propiedades de un objeto, puedes utilizar el bucle <codeinline>for/in</codeinline> (introducido en <a href="capitulo-5#4-5">¬ß5.4.5</a>), o utilizar <codeinline>for/of</codeinline> con el m√©todo <codeinline>Object.keys()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let keys = "";
    for(let k of Object.keys(o)) &lbrace;
      keys += k;
    }
    keys // => "xyz"</code></pre>
    <p>Esto funciona porque <codeinline>Object.keys()</codeinline> devuelve un array de nombres de propiedades de un objeto, y los arrays son iterables con <codeinline>for/of</codeinline>. Tenga en cuenta tambi√©n que esta iteraci√≥n de las claves de un objeto no es en vivo como en el ejemplo de la matriz anterior - los cambios en el objeto o realizados en el cuerpo del bucle no tendr√°n ning√∫n efecto sobre la iteraci√≥n. Si no te importan las claves de un objeto, tambi√©n puedes iterar a trav√©s de sus valores correspondientes as√≠:</p>
    <pre class="language-js">
    <code class="language-js">let sum = 0;
    for(let v of Object.values(o)) &lbrace;
      sum += v;
    }
    sum // => 6</code></pre>
    <p>Y si est√° interesado tanto en las claves como en los valores de las propiedades de un objeto, puede utilizar <codeinline>for/of</codeinline> con <codeinline>Object.entries()</codeinline> y la asignaci√≥n de desestructuraci√≥n:</p>
    <pre class="language-js">
    <code class="language-js">let pairs = "";
    for(let [k, v] of Object.entries(o)) &lbrace;
      pairs += k + v;
    }
    pairs // => "x1y2z3"</code></pre>
    <p><codeinline>Object.entries()</codeinline> devuelve una matriz de matrices, donde cada matriz interna representa un par clave/valor para una propiedad del objeto. En este ejemplo de c√≥digo utilizamos la asignaci√≥n de desestructuraci√≥n para descomponer esas matrices internas en dos variables individuales.</p>
    <p class="title-article text-left">for/of con strings</p>
    <p>Las cadenas son iterables car√°cter a car√°cter en ES6:</p>
    <pre class="language-js">
    <code class="language-js">let frequency = &lbrace;};
    for(let letter of "mississippi") &lbrace;
      if (frequency[letter]) &lbrace;
        frequency[letter]++;
      } else &lbrace;
        frequency[letter] = 1;
      }
    }
    frequency // => &lbrace;m: 1, i: 4, s: 4, p: 2}</code></pre>
    <p>Tenga en cuenta que las cadenas se iteran por punto de c√≥digo Unicode, no por car√°cter UTF-16. La cadena "I ‚ù§ üê∂" tiene una <codeinline>.length</codeinline> de 5 (porque cada uno de los dos caracteres emoji requiere dos caracteres UTF-16 para representarse). Pero si iteras esa cadena con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecutar√° tres veces, una por cada uno de los tres puntos de c√≥digo "I", "‚ù§" y "üê∂."</p>
    <p class="title-article text-left">for/of con Set y Map</p>
    <p>Las clases incorporadas Set y Map de ES6 son iterables. Cuando iteras un Set con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecuta una vez por cada elemento del set. Puede utilizar c√≥digo como √©ste para imprimir las palabras √∫nicas en una cadena de texto:</p>
    <pre class="language-js">
    <code class="language-js">let text = "Na na na na na na na na Batman!";
    let wordSet = new Set(text.split(" "));
    let unique = [];
    for(let word of wordSet) &lbrace;
      unique.push(word);
    }
    unique // => ["Na", "na", "Batman!"]</code></pre>
    <p>Los Mapas son un caso interesante porque el iterador de un objeto Mapa no itera las claves del Mapa, ni los valores del Mapa, sino pares clave/valor. En cada iteraci√≥n, el iterador devuelve un array cuyo primer elemento es una clave y cuyo segundo elemento es el valor correspondiente. Dado un Map <codeinline>m</codeinline>, podr√≠as iterar y desestructurar sus pares clave/valor as√≠:</p>
    <pre class="language-js">
    <code class="language-js">let m = new Map([[1, "one"]]);
    for(let [key, value] of m) &lbrace;
      key // => 1
      value // => "one"
    }</code></pre>
    <p class="title-article text-left">Iteraci√≥n as√≠ncrona con for/await</p>
    <p>ES2018 introduce un nuevo tipo de iterador, conocido como <em>iterador as√≠ncrono</em>, y una variante del bucle <codeinline>for/of</codeinline>, conocida como bucle <codeinline>for/await</codeinline>, que funciona con iteradores as√≠ncronos.</p>
    <p>Tendr√°s que leer los Cap√≠tulos <a href="capitulo-12">12</a> y <a href="capitulo-13">13</a> para entender el bucle <codeinline>for/await</codeinline>, pero aqu√≠ tienes c√≥mo se ve en c√≥digo:</p>
    <pre class="language-js">
    <code class="language-js">// Leer trozos de un flujo iterable asincrono e imprimirlos
    async function printStream(stream) &lbrace;
      for await (let chunk of stream) &lbrace;
        console.log(chunk);
      }
    }</code></pre>
  </section>
  <section id="4-5">
    <h2>5.4.5 for/in</h2>
    <p>Un bucle <codeinline>for/in</codeinline> se parece mucho a un bucle <codeinline>for/of</codeinline>, con la palabra clave <codeinline>of</codeinline> cambiada por <codeinline>in</codeinline>. Mientras que un bucle <codeinline>for/of</codeinline> requiere un objeto iterable despu√©s de <codeinline>of</codeinline>, un bucle <codeinline>for/in</codeinline> funciona con cualquier objeto despu√©s de <codeinline>in</codeinline>. El bucle <codeinline>for/of</codeinline> es nuevo en ES6, pero <codeinline>for/in</codeinline> ha formado parte de JavaScript desde el principio (por eso tiene una sintaxis m√°s natural).</p>
    <p>La sentencia <codeinline>for/in</codeinline> recorre en bucle los nombres de las propiedades de un objeto especificado. La sintaxis es la siguiente:</p>
    <pre class="language-js">
    for (variable in object)
      statement</pre>
    <p><em>variable</em> normalmente nombra una variable, pero puede ser una declaraci√≥n de variable o cualquier cosa adecuada como el lado izquierdo de una expresi√≥n de asignaci√≥n. <em>object</em> es una expresi√≥n que se eval√∫a a un objeto. Como de costumbre, <em>statement</em> es la sentencia o bloque de sentencias que sirve como cuerpo del bucle.</p>
    <p>Y podr√≠as usar un bucle <codeinline>for/in</codeinline> como este:</p>
    <pre class="language-js">
    <code class="language-js">for(let p in o) &lbrace; // Asigna los nombres de las propiedades de o a la variable p
      console.log(o[p]); // Imprime el valor de cada propiedad
    }</code></pre>
    <p>Para ejecutar una sentencia <codeinline>for/in</codeinline>, el int√©rprete de JavaScript eval√∫a primero la expresi√≥n del <em>objeto</em>. Si es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, el int√©rprete omite el bucle y pasa a la siguiente sentencia. El int√©rprete ejecuta ahora el cuerpo del bucle una vez por cada propiedad enumerable del objeto. Antes de cada iteraci√≥n, sin embargo, el int√©rprete eval√∫a la expresi√≥n de la <em>variable</em> y le asigna el nombre de la propiedad (un valor de cadena).</p>
    <p>Tenga en cuenta que la <em>variable</em> en el bucle <codeinline>for/in</codeinline> puede ser una expresi√≥n arbitraria, siempre y cuando se eval√∫e a algo adecuado para el lado izquierdo de una asignaci√≥n. Esta expresi√≥n es se eval√∫a cada vez que se pasa por el bucle, lo que significa que puede evaluarse de forma diferente cada vez. Por ejemplo, puede utilizar c√≥digo como el siguiente para copiar los nombres de todas las propiedades del objeto en un array:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let a = [], i = 0;
    for(a[i++] in o) /* empty */;</code></pre>
    <p>Las matrices de JavaScript son simplemente un tipo especializado de objeto, y los √≠ndices de las matrices son propiedades de los objetos que pueden enumerarse con un bucle <codeinline>for/in</codeinline>. Por ejemplo, siguiendo el c√≥digo anterior con esta l√≠nea se enumeran los √≠ndices 0, 1 y 2 del array:</p>
    <pre class="language-js">
    <code class="language-js">for(let i in a) console.log(i);</code></pre>
    <p>Encuentro que una fuente com√∫n de errores en mi propio c√≥digo es el uso accidental de <codeinline>for/in</codeinline> con arrays cuando quer√≠a usar <codeinline>for/of</codeinline>. Cuando se trabaja con matrices, casi siempre es mejor usar <codeinline>for/of</codeinline> en lugar de <codeinline>for/in</codeinline>.</p>
    <p>El bucle <codeinline>for/in</codeinline> no enumera todas las propiedades de un objeto. No enumera las propiedades cuyos nombres son s√≠mbolos. Y de las propiedades cuyos nombres son cadenas, s√≥lo hace un bucle sobre las propiedades <em>enumerables</em> (v√©ase <a href="capitulo-6#14-1">¬ß14.1</a>). Los diversos m√©todos incorporados definidos por el n√∫cleo de JavaScript no son enumerables. Todos los objetos tienen un m√©todo <codeinline>toString()</codeinline>, por ejemplo, pero el bucle <codeinline>for/in</codeinline> no enumera esta propiedad <codeinline>toString()</codeinline>. Adem√°s de los m√©todos incorporados, muchas otras propiedades de los objetos incorporados no son enumerables. Todas las propiedades y m√©todos definidos por su c√≥digo son enumerables, por defecto. (Puede hacerlos no enumerables utilizando t√©cnicas explicadas en <a href="capitulo-6#14-1">¬ß14.1</a>.)</p>
    <p>Las propiedades heredadas enumerables (v√©ase <a href="capitulo-6#3-2">¬ß6.3.2</a>) tambi√©n son enumeradas por el bucle <codeinline>for/in</codeinline>. Esto significa que si utilizas bucles <codeinline>for/in</codeinline> y tambi√©n utilizas c√≥digo que define propiedades que son heredadas por todos los objetos, entonces tu bucle puede no comportarse de la manera que esperas. Por esta raz√≥n, muchos programadores prefieren utilizar un bucle <codeinline>for/of</codeinline> con <codeinline>Object.keys()</codeinline> en lugar de un bucle <codeinline>for/in</codeinline>.</p>
    <p>Si el cuerpo de un bucle <codeinline>for/in</codeinline> borra una propiedad que a√∫n no ha sido enumerada, esa propiedad no ser√° enumerada. Si el cuerpo del bucle define nuevas propiedades en el objeto, esas propiedades pueden o no ser enumeradas. V√©ase <a href="capitulo-6#6-1">¬ß6.6.1</a> para m√°s informaci√≥n sobre el orden en que <codeinline>for/in</codeinline> enumera las propiedades de un objeto.</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5 Jumps</h2>
    <p>Otra categor√≠a de sentencias JavaScript son las <em>sentencias jump</em>. Como su nombre indica, hacen que el int√©rprete de JavaScript salte a una nueva ubicaci√≥n en el c√≥digo fuente. La sentencia <codeinline>break</codeinline> hace que el int√©rprete salte al final de un bucle u otro estado. <codeinline>continue</codeinline> hace que el int√©rprete se salte el resto del cuerpo de un bucle y vuelva al principio de un bucle para comenzar una nueva iteraci√≥n. JavaScript permite que las sentencias con nombre o <em>etiqueta</em>, y <codeinline>break</codeinline> y <codeinline>continue</codeinline> pueden identificar el bucle de destino u otra etiqueta de estado.</p>
    <p>La sentencia <codeinline>return</codeinline> hace que el int√©rprete salte desde la invocaci√≥n de una funci√≥n de vuelta al c√≥digo que la invoc√≥ y tambi√©n proporciona el valor de la invocaci√≥n. La sentencia <codeinline>throw</codeinline> es una especie de retorno provisional de una funci√≥n generadora. La sentencia <codeinline>throw</codeinline> levanta, o <em>lanza</em>, una excepci√≥n y est√° dise√±ada para trabajar con la sentencia <codeinline>try/catch/finally</codeinline>, que establece un bloque de c√≥digo de gesti√≥n de excepciones. Se trata de un tipo de sentencia de salto: cuando se lanza una excepci√≥n, el int√©rprete salta al manejador de excepciones m√°s cercano, que puede estar en la misma funci√≥n o m√°s arriba en la pila de llamadas de una funci√≥n invocadora.</p>
    <p>Los detalles sobre cada una de estas declaraciones de salto se encuentran en las secciones siguientes.</p>
  </section>
  <section id="5-1">
    <h2>5.5.1 Declaraciones etiquetadas</h2>
    <p>Cualquier declaraci√≥n puede <em>etiquetarse</em> precedi√©ndola de un identificador y dos puntos:</p>
    <pre class="language-js">
    identificador: declaraci√≥n</pre>
    <p>Al etiquetar una sentencia, le da un nombre que puede utilizar para referirse a ella en cualquier parte de su programa. Puede etiquetar cualquier sentencia, aunque s√≥lo es √∫til para etiquetar sentencias que tienen cuerpo, como bucles y condicionales. Al dar un nombre a un bucle, puede utilizar las sentencias <codeinline>break</codeinline> y <codeinline>continue</codeinline> dentro del cuerpo del bucle para salir del bucle o para saltar directamente a la parte superior del bucle para comenzar la siguiente iteraci√≥n. <codeinline>break</codeinline> y <codeinline>continue</codeinline> son las √∫nicas sentencias de JavaScript que utilizan etiquetas de sentencia; se tratan en las siguientes subsecciones. A continuaci√≥n se muestra un ejemplo de un bucle <codeinline>while</codeinline> etiquetado y una sentencia <codeinline>continue</codeinline> que utiliza la etiqueta.</p>
    <pre class="language-js">
    <code class="language-js">mainloop: while(token !== null) &lbrace;
      // Codigo omitido...
      continue mainloop; // Salta a la siguiente iteraci√≥n del bucle
      // Mas codigo omitido...
    }</code></pre>
    <p>El <em>identificador</em> que se utiliza para etiquetar una sentencia puede ser cualquier identificador legal de JavaScript que no sea una palabra reservada. El espacio de nombres para etiquetas es diferente del espacio de nombres para variables y funciones, por lo que puede utilizar el mismo identificador como etiqueta de sentencia y como nombre de variable o funci√≥n. Las etiquetas de sentencia s√≥lo se definen dentro de la sentencia a la que se aplican (y dentro de sus sustituciones, por supuesto). Una sentencia no puede tener la misma etiqueta que la sentencia que la contiene, pero dos sentencias pueden tener la misma etiqueta siempre que ninguna est√© anidada dentro de la otra. Las sentencias etiquetadas pueden ser a su vez etiquetadas. Esto significa que cualquier sentencia puede tener varias etiquetas.</p>
  </section>
  <section id="5-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.2 break</h2>
    <p>La sentencia <codeinline>break</codeinline>, utilizada por s√≠ sola, hace que el bucle o <codeinline>switch</codeinline> que la encierra en su interior
      para salir inmediatamente. Su sintaxis es sencilla:</p>
    <pre class="language-js">
    break;</pre>
    <p>Dado que provoca la salida de un bucle o <codeinline>switch</codeinline>, esta forma de la sentencia <codeinline>break</codeinline> s√≥lo es legal si aparece dentro de una de estas sentencias.</p>
    <p>Ya ha visto ejemplos de la sentencia <codeinline>break</codeinline> dentro de una sentencia <codeinline>switch</codeinline>. En los bucles, se utiliza normalmente para salir prematuramente cuando, por cualquier raz√≥n, ya no hay necesidad de completar el bucle. Cuando un bucle tiene condiciones de terminaci√≥n complejas, a menudo es m√°s f√°cil implementar algunas de estas condiciones con sentencias <codeinline>break</codeinline> en lugar de intentar expresarlas todas en una √∫nica expresi√≥n de bucle. El siguiente c√≥digo busca un valor determinado en los elementos de una matriz. El bucle termina de forma normal cuando alcanza el final del array; termina con una sentencia <codeinline>break</codeinline> si encuentra lo que est√° buscando en el array:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; a.length; i++) &lbrace;
      if (a[i] === target) break;
    }</code></pre>
    <p>JavaScript tambi√©n permite que la palabra clave <codeinline>break</codeinline> vaya seguida de una etiqueta de sentencia (s√≥lo el identificador, sin dos puntos):</p>
    <pre class="language-js">
    break labelname;</pre>
    <p>Cuando se utiliza <codeinline>break</codeinline> con una etiqueta, salta al final o termina la sentencia adjunta que tiene la etiqueta especificada. Es un error de sintaxis utilizar <codeinline>break</codeinline> de esta forma si no hay una sentencia anexa con la etiqueta especificada. Con esta forma de la sentencia <codeinline>break</codeinline>, no es necesario que la sentencia nombrada sea un bucle o un <codeinline>switch:break</codeinline> puede "salir" de cualquier sentencia adjunta. Esta sentencia puede ser incluso un bloque de sentencias agrupado entre llaves con el √∫nico prop√≥sito de nombrar el bloque con una etiqueta.</p>
    <p>No se permite una nueva l√≠nea entre la palabra clave <codeinline>break</codeinline> y el nombre de la <em>etiqueta</em>. Esto se debe a que JavaScript inserta autom√°ticamente el punto y coma omitido: si se coloca un punto y coma entre la palabra clave <codeinline>break</codeinline> y la etiqueta que le sigue, JavaScript asume que se pretende utilizar la forma simple y sin etiqueta de la sentencia y trata el punto y coma como un punto y coma. (V√©ase <a href="capitulo-2#6">¬ß2.6</a>.)</p>
    <p>Necesitar√° la forma etiquetada de la sentencia <codeinline>break</codeinline> cuando desee salir de una sentencia que no sea el bucle o <codeinline>switch</codeinline> m√°s cercano. El siguiente c√≥digo lo demuestra:</p>
    <pre class="language-js">
    <code class="language-js">let matrix = getData(); // Obtiene una matriz 2D de n√∫meros de alguna manera
      // Ahora suma todos los n√∫meros en la matriz.
      let sum = 0, success = false;
      // Empieza con una sentencia etiquetada que podemos salir de si ocurre un error
      computeSum: if (matrix) &lbrace;
        for(let x = 0; x &lt; matrix.length; x++) &lbrace;
          let row = matrix[x];
          if (!row) break computeSum;
          for(let y = 0; y &lt; row.length; y++) &lbrace;
            let cell = row[y];
            if (isNaN(cell)) break computeSum;
            sum += cell;
          }
        }
        success = true;
      }
      // La sentencia break salta aqu√≠. Si llegamos aqu√≠ con success == false
      // entonces hubo algo malo con la matriz que nos dieron.
      // Caso contrario sum contiene la suma de todas las celdas de la matriz</code></pre>
    <p>Por √∫ltimo, tenga en cuenta que una sentencia <codeinline>break</codeinline>, con o sin etiqueta, no puede transferir el control a trav√©s de los l√≠mites de la funci√≥n. No puede etiquetar una sentencia de definici√≥n de funci√≥n, por ejemplo, y luego utilizar esa etiqueta dentro de la funci√≥n.</p>
  </section>
  <section id="5-3">
    <h2>5.5.3 continue</h2>
    <p>La sentencia <codeinline>continue</codeinline> es similar a la sentencia <codeinline>break</codeinline>. Sin embargo, en lugar de salir de un bucle, <codeinline>continue</codeinline> lo reinicia en la siguiente iteraci√≥n. La sintaxis de la sentencia <codeinline>continue</codeinline> es tan sencilla como la de la sentencia <codeinline>break</codeinline>:</p>
    <pre class="language-js">
    continue;</pre>
    <p>La sentencia <codeinline>continue</codeinline> tambi√©n puede utilizarse con una etiqueta:</p>
    <pre class="language-js">
    continue labelname;</pre>
    <p>La sentencia <codeinline>continue</codeinline>, tanto en su forma etiquetada como sin etiquetar, s√≥lo puede utilizarse dentro del cuerpo de un bucle. Su uso en cualquier otro lugar provoca un error de sintaxis.</p>
    <p>Cuando se ejecuta la sentencia <codeinline>continue</codeinline>, finaliza la iteraci√≥n actual del bucle que lo encierra y comienza la siguiente iteraci√≥n. Esto significa cosas diferentes para los distintos tipos de bucles:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En un bucle <codeinline>while</codeinline>, la <em>expresi√≥n</em> especificada al principio del bucle se comprueba de nuevo y, si es <codeinline>true</codeinline>, el cuerpo del bucle se ejecuta empezando por arriba.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En un bucle <codeinline>do/while</codeinline>, la ejecuci√≥n salta a la parte inferior del bucle, donde la condici√≥n del bucle se comprueba de nuevo antes de reiniciar el bucle en la parte superior.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En un bucle <codeinline>for</codeinline>, se eval√∫a la expresi√≥n de <em>incremento</em> y se vuelve a comprobar la expresi√≥n de <em>prueba</em> para determinar si debe realizarse otra iteraci√≥n.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En un bucle <codeinline>for/of</codeinline> o <codeinline>for/in</codeinline>, el bucle comienza de nuevo con el siguiente valor iterado o el siguiente nombre de propiedad que se asigna a la variable especificada.
        </p>
      </li>
    </ul>
    <p>Observe la diferencia en el comportamiento de la sentencia <codeinline>continue</codeinline> en los bucles <codeinline>while</codeinline> y <codeinline>for</codeinline>: un bucle <codeinline>while</codeinline> vuelve directamente a su condici√≥n, pero un bucle <codeinline>for</codeinline> eval√∫a primero su expresi√≥n de <em>incremento</em> y luego vuelve a su condici√≥n. Anteriormente, consideramos el comportamiento del bucle <codeinline>for</codeinline> en t√©rminos de un bucle <codeinline>while</codeinline> "equivalente". Sin embargo, debido a que el estado <codeinline>continue</codeinline> se comporta de forma diferente para estos dos bucles, en realidad no es posible simular perfectamente un bucle <codeinline>for</codeinline> s√≥lo con un bucle <codeinline>while</codeinline>.</p>
    <p>El siguiente ejemplo muestra una sentencia <codeinline>continue</codeinline> sin etiquetar que se utiliza para saltarse el resto de la iteraci√≥n actual de un bucle cuando se produce un error:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; data.length; i++) &lbrace;
      if (!data[i]) continue; // No puedo proceder son datos indefinidos
      total += data[i];
    }</code></pre>
    <p>Al igual que la sentencia <codeinline>break</codeinline>, la sentencia <codeinline>continue</codeinline> puede utilizarse en su forma etiquetada dentro de bucles anidados cuando el bucle a reiniciar no es el bucle inmediatamente adyacente. Adem√°s, al igual que con la sentencia <codeinline>break</codeinline>, no se permiten saltos de l√≠nea entre la sentencia <codeinline>continue</codeinline> y su <em>labelname</em>.</p>
  </section>
  <section id="5-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.4 return</h2>
    <p>Recordemos que las invocaciones a funciones son expresiones y que todas las expresiones tienen valores. Una sentencia <codeinline>return</codeinline> dentro de una funci√≥n especifica el valor de las invocaciones de esa funci√≥n. Esta es la sintaxis de la sentencia <codeinline>return</codeinline>:</p>
    <pre class="language-js">
    return expression;</pre>
    <p>Una sentencia <codeinline>return</codeinline> s√≥lo puede aparecer dentro del cuerpo de una funci√≥n. Es un error sint√°ctico que aparezca en cualquier otro lugar. Cuando se ejecuta la sentencia <codeinline>return</codeinline>, la funci√≥n que la contiene devuelve el valor de la <em>expresi√≥n</em> a su invocador. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">function square(x) &lbrace; return x*x; } // Una funci√≥n que devuelve el cuadrado de su argumento
    square(2) // => 4</code></pre>
    <p>Sin sentencia <codeinline>return</codeinline>, una invocaci√≥n de funci√≥n simplemente ejecuta cada uno de los estados del cuerpo de la funci√≥n por turnos hasta que llega al final de la funci√≥n y entonces devuelve a su invocador. En este caso, la expresi√≥n de invocaci√≥n se eval√∫a como <codeinline>undefined</codeinline>. La sentencia <codeinline>return</codeinline> aparece a menudo como la √∫ltima sentencia de una funci√≥n, pero no tiene por qu√© ser la √∫ltima: una funci√≥n vuelve a su invocador cuando se ejecuta una sentencia <codeinline>return</codeinline>, aunque queden otras sentencias en el cuerpo de la funci√≥n.</p>
    <p>La sentencia <codeinline>return</codeinline> tambi√©n puede utilizarse sin una <em>expresi√≥n</em> para hacer que la funci√≥n devuelva <codeinline>undefined</codeinline> asuinvocador. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">function displayObject(o) &lbrace;
      // Regresa inmediatamente si el argumento es null o undefined
      if (!o) return;
      // El resto de la funci√≥n va aqu√≠
    }</code></pre>
    <p>Debido a la inserci√≥n autom√°tica de punto y coma de JavaScript (<a href="capitulo-2#6">¬ß2.6</a>) no puede incluir un salto de l√≠nea entre la palabra clave <codeinline>return</codeinline> y la expresi√≥n que le sigue.</p>
  </section>
  <section id="5-5">
    <h2>5.5.5 yield</h2>
    <p>La sentencia <codeinline>yield</codeinline> es muy parecida a la sentencia <codeinline>return</codeinline>, pero s√≥lo se utiliza en funciones generadoras ES6 (v√©ase <a href="capitulo-12#3">¬ß12.3</a>) para producir el siguiente valor en la secuencia generada de valores sin devolverlo:</p>
    <pre class="language-js">
    <code class="language-js">// Una funci√≥n generadora que produce un rango de n√∫meros
    function* range(from, to) &lbrace;
      for(let i = from; i &lt;= to; i++) &lbrace;
      yield i;
      }
    }</code></pre>
    <p>Para entender <codeinline>yield</codeinline>, debe entender los iteradores y generadores, que no se tratar√°n hasta el <a href="capitulo-12">cap√≠tulo 12</a>. Sin embargo, <codeinline>yield</codeinline> se incluye aqu√≠ para completar el tema. (T√©cnicamente, sin embargo, <codeinline>yield</codeinline> es un operador m√°s que una sentencia, como se explica en <a href="capitulo-12#4-2">¬ß12.4.2</a>.)</p>
  </section>
  <section id="5-6" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.6 throw</h2>
    <p>Una <em>excepci√≥n</em> es una se√±al que indica que se ha producido alg√∫n tipo de condici√≥n excepcional o error. <em>Lanzar</em> una excepci√≥n es se√±alar un error o una condici√≥n excepcional. <em>Atrapar</em> una excepci√≥n es manejarla, es decir, tomar las medidas necesarias o apropiadas para recuperarse de la excepci√≥n. En JavaScript, las excepciones se lanzan siempre que se produce un error en tiempo de ejecuci√≥n y siempre que el programa las lanza expl√≠citamente utilizando la sentencia <codeinline>throw</codeinline>. Las excepciones se capturan con el estado <codeinline>try/catch/finally</codeinline>, que se describe en la siguiente secci√≥n.</p>
    <p>La sentencia <codeinline>throw</codeinline> tiene la siguiente sintaxis:</p>
    <pre class="language-js">
    throw expression;</pre>
    <p><em>expression</em> puede evaluarse a un valor de cualquier tipo. Puede lanzar un n√∫mero que represente un c√≥digo de error o una cadena que contenga un mensaje de error legible por humanos. La clase Error y sus subclases se utilizan cuando el propio int√©rprete de JavaScript lanza un error, y usted tambi√©n puede utilizarlas. Un objeto Error tiene una propiedad <codeinline>name</codeinline> que especifica el tipo de error y una propiedad <codeinline>message</codeinline> que contiene la cadena pasada a la funci√≥n constructora. A continuaci√≥n se muestra una funci√≥n de ejemplo que lanza un objeto Error cuando se invoca con un argumento no v√°lido:</p>
    <pre class="language-js">
    <code class="language-js">function factorial(x) &lbrace;
      // Si el argumento de entrada e invalido, lanza una excepci√≥n!.
      if (x &lt; 0) throw new Error("x no debe ser negativo");
      // Caso contrario, calcula el valor y lo devuelve.
      let f;
      for(f = 1; x > 1; f *= x, x--) /* empty */ ;
      return f;
    }
    factorial(4) // => 24</code></pre>
    <p>Cuando se lanza una excepci√≥n, el int√©rprete de JavaScript detiene inmediatamente la ejecuci√≥n normal del programa y salta al manejador de excepciones m√°s cercano. Los manejadores de excepciones se escriben utilizando la cl√°usula <codeinline>catch</codeinline> de la sentencia <codeinline>try/catch/finally</codeinline>, que se describe en la siguiente secci√≥n. Si el bloque de c√≥digo en el que se lanz√≥ la excepci√≥n no tiene una cl√°usula <codeinline>catch</codeinline> asociada, el int√©rprete comprueba el siguiente bloque de c√≥digo m√°s alto para ver si tiene un manejador de excepciones asociado. Esto contin√∫a hasta que se encuentra un manejador. Si se lanza una excepci√≥n en una funci√≥n que no contiene una sentencia <codeinline>try/catch/finally</codeinline> para manejarla, la excepci√≥n se propaga hasta el c√≥digo que invoc√≥ la funci√≥n. De este modo, las excepciones se propagan por la estructura l√©xica de los m√©todos de JavaScript y por la pila de llamadas. Si no se encuentra ning√∫n manejador de excepciones, la excepci√≥n se trata como un error y se notifica al usuario.</p>
  </section>
  <section id="5-7">
    <h2>5.5.7 try/catch/nally</h2>
    <p>La sentencia <codeinline>try/catch/finally</codeinline> es el mecanismo de gesti√≥n de excepciones de JavaScript. La cl√°usula <codeinline>try</codeinline> de esta sentencia simplemente define el bloque de c√≥digo cuyas excepciones deben tratarse. El bloque <codeinline>try</codeinline> va seguido de una cl√°usula <codeinline>catch</codeinline>, que es un bloque de sentencias que se invocan cuando se produce una excepci√≥n en cualquier parte del bloque <codeinline>try</codeinline>. La cl√°usula <codeinline>catch</codeinline> va seguida de un bloque <codeinline>finally</codeinline> que contiene c√≥digo de limpieza que est√° garantizado que se ejecute, independientemente de lo que ocurra en el bloque <codeinline>try</codeinline>. Los bloques <codeinline>catch</codeinline> y <codeinline>finally</codeinline> son opcionales, pero un bloque <codeinline>try</codeinline> debe ir acompa√±ado de al menos uno de estos bloques. Los bloques <codeinline>try</codeinline>, <codeinline>catch</codeinline> y <codeinline>finally</codeinline> comienzan y terminan con llaves. Estas llaves son una parte obligatoria de la sintaxis y no pueden omitirse, incluso si una cl√°usula contiene una √∫nica sentencia.</p>


    <p>El siguiente c√≥digo ilustra la sintaxis y el prop√≥sito de <codeinline>try/catch/finally</codeinline> declaraci√≥n:</p>
    <pre class="language-js">
    <code class="language-js">try &lbrace;
      // Normalmente, este codigo se ejecuta desde la parte superior hasta la 
      // parte inferior sin problemas. Pero a veces, puede producirse una 
      // excepci√≥n ya sea directamente, con una sentencia throw, o indirectamente 
      // llamando a un metodo que lanza una excepci√≥n.
    }
    catch(e) &lbrace;
      // La sentencia de este bloque se ejecuta si, y solo si el bloque try
      // lanza una excepci√≥n. Esta sentencia puede utilizar la variable local
      // e para referirse para el objeto Error o cualquier otro valor lanzado.
      // Este bloque puede manejar la excepci√≥n alguna manera, puede ignorar
      // la excepci√≥n haciendo nada, o puede lanzar otra excepci√≥n con throw.
    }
    finally &lbrace;
      // Este bloque contiene sentencias que siempre se ejecutan, independientemente
      // que ocurra en el bloque try. Estas sentencias se ejecutan siempre que el
      // bloque terminal:
      // 1) normalmente, despu√©s de llegar al final del bloque
      // 2) debido a una sentencia break, continue o return
      // 3) con una excepci√≥n que se gestiona por una cl√°usula catch anterior
      // 4) con una excepci√≥n no capturada que se esta propagando
    }
    </code></pre>
    <p>Tenga en cuenta que la palabra clave <codeinline>catch</codeinline> suele ir seguida de un identificador entre par√©ntesis. Este identificador es como un par√°metro de funci√≥n. Cuando se captura una excepci√≥n, el valor asociado con la excepci√≥n (un objeto Error, por ejemplo) se asigna a este par√°metro. El identificador asociado a una cl√°usula <codeinline>catch</codeinline> tiene alcance de bloque: s√≥lo se define dentro del bloque <codeinline>catch</codeinline>.</p>
    <p>He aqu√≠ un ejemplo realista de la sentencia <codeinline>try/catch</codeinline>. Utiliza el m√©todo <codeinline>factorial()</codeinline> definido en la secci√≥n anterior y los m√©todos JavaScript del lado del cliente <codeinline>prompt()</codeinline> y <codeinline>alert()</codeinline> para la entrada y la salida:</p>
    <pre class="language-js">
    <code class="language-js">try &lbrace;
      // Pedir al usuario que introduzca un n√∫mero
      let n = Number(prompt("Por favor ingrese un n√∫mero entero", ""));
      // Calcula el factorial del n√∫mero, asuimiendo que sea v√°lido
      let f = factorial(n);
      // Mostrar el resultado
      alert(n + "! = " + f);
    }
    catch(ex) &lbrace;   // Si la entrada del usuario no es valida, termina aqu√≠
      alert(ex);  // Indica al usuario cual es el error
    }</code></pre>
    <p>Este ejemplo es una sentencia <codeinline>try/catch</codeinline> sin cl√°usula <codeinline>finally</codeinline>. Aunque <codeinline>finally</codeinline> no se utiliza tan a menudo como <codeinline>catch</codeinline>, puede ser √∫til. Sin embargo, su comportamiento requiere una explicaci√≥n adicional. Se garantiza la ejecuci√≥n de la cl√°usula <codeinline>finally</codeinline> si se ejecuta cualquier parte del bloque <codeinline>try</codeinline>, independientemente de c√≥mo finalice el c√≥digo del bloque <codeinline>try</codeinline>. Generalmente se utiliza para limpiar despu√©s del c√≥digo en la cl√°usula <codeinline>try</codeinline>.</p>
    <p>En el caso normal, el int√©rprete de JavaScript llega al final del bloque <codeinline>try</codeinline> y pasa al bloque <codeinline>finally</codeinline>, que realiza cualquier limpieza necesaria. Si el int√©rprete abandon√≥ el bloque <codeinline>try</codeinline> debido a una sentencia <codeinline>return</codeinline>, <codeinline>continue</codeinline> o <codeinline>break</codeinline>, el bloque <codeinline>finally</codeinline> se ejecuta antes de que el int√©rprete salte a su nuevo destino.</p>
    <p>Si se produce una excepci√≥n en el bloque <codeinline>try</codeinline> y hay un bloque <codeinline>catch</codeinline> asociado para manejar la excepci√≥n, el int√©rprete ejecuta primero el bloque <codeinline>catch</codeinline> y luego el bloque <codeinline>finally</codeinline>. Si no hay un bloque <codeinline>catch</codeinline> local para manejar la excepci√≥n, el int√©rprete ejecuta primero el bloque <codeinline>finally</codeinline> y luego salta a la cl√°usula <codeinline>catch</codeinline> m√°s cercana.</p>
    <p>Si el propio bloque <codeinline>finally</codeinline> provoca un salto con una sentencia <codeinline>return</codeinline>, <codeinline>continue</codeinline>, <codeinline>break</codeinline> o <codeinline>throw</codeinline>, o llamando a un m√©todo que lanza una excepci√≥n, el int√©rprete abandona cualquier salto que estuviera pendiente y realiza el nuevo salto. Por ejemplo, si una cl√°usula <codeinline>finally</codeinline> lanza una excepci√≥n, esa excepci√≥n sustituye a cualquier excepci√≥n que estuviera en proceso de ser lanzada. Si una cl√°usula <codeinline>finally</codeinline> emite una sentencia <codeinline>return</codeinline>, el m√©todo retorna normalmente, incluso si se ha lanzado una excepci√≥n y a√∫n no ha sido manejada.</p>
    <p><codeinline>try</codeinline> y <codeinline>finally</codeinline> pueden usarse juntos sin una cl√°usula <codeinline>catch</codeinline>. En este caso, el bloque <codeinline>finally</codeinline> es simplemente c√≥digo de limpieza cuya ejecuci√≥n est√° garantizada, independientemente de lo que ocurra en el bloque <codeinline>try</codeinline>. Recordemos que no podemos simular completamente un bucle <codeinline>for</codeinline> con un bucle <codeinline>while</codeinline> porque la sentencia <codeinline>continue</codeinline> se comporta de forma diferente en los dos bucles. Si a√±adimos una sentencia <codeinline>try/finally</codeinline>, podemos escribir un bucle <codeinline>while</codeinline> que funcione como un bucle <codeinline>for</codeinline> y que maneje correctamente las sentencias <codeinline>continue</codeinline>:</p>
    <pre class="language-js">
    // Simula for(initialize ; test ;increment ) body;
    initialize ;
    while( test ) &lbrace;
      try &lbrace; body ; }
      finally &lbrace; increment ; }
    }</pre>
    <p>Tenga en cuenta, sin embargo, que un <em>cuerpo</em> que contiene una sentencia <codeinline>break</codeinline> se comporta de forma ligeramente diferente (provocando un incremento extra antes de salir) en el bucle <codeinline>while</codeinline> que en el bucle <codeinline>for</codeinline>, por lo que incluso con la cl√°usula <codeinline>finally</codeinline>, no es posible simular completamente el bucle <codeinline>for</codeinline> con <codeinline>while</codeinline>.</p>
    <article>
      <p class="title-article">Cl√°usulas de salvaguardia</p>
      <p>Ocasionalmente puedes encontrarte utilizando una cl√°usula <codeinline>catch</codeinline> √∫nicamente para detectar y detener la propagaci√≥n de una excepci√≥n, aunque no te importe el tipo o el valor de la excepci√≥n. En ES2019 y posteriores, puedes omitir los par√©ntesis y el identificador y utilizar la palabra clave <codeinline>catch</codeinline> desnuda en este caso. He aqu√≠ un ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// Como JSON.parse(), pero devuelve undefined en lugar de lanzar un error
    function parseJSON(s) &lbrace;
      try &lbrace;
        return JSON.parse(s);
      } catch &lbrace;
      // Algo salio mal pero no nos importa, devolvemos undefined
        return undefined;
      }
    }</code></pre>
    </article>
  </section>
  <section id="6" class="py-4 xs:py-5 sm:py-6">
    <h2>5.6 Declaraciones varias</h2>
    <p>Esta secci√≥n describe las tres sentencias JavaScript restantes: <codeinline>with</codeinline>, <codeinline>debugger</codeinline> y <codeinline>"use strict"</codeinline>.</p>
  </section>
  <section id="6-1">
    <h2>5.6.1 with</h2>
    <p>La sentencia <codeinline>with</codeinline> ejecuta un bloque de c√≥digo como si las propiedades de un objeto especificado fueran variables en el √°mbito de ese c√≥digo. Su sintaxis es la siguiente:</p>
    <pre class="language-js">
    with (object)
      statements
    }</pre>
    <p>Esta sentencia crea un √°mbito temporal con las propiedades del <em>object</em> como variables y luego ejecuta la <em>sentencia</em> dentro de ese √°mbito.</p>
    <p>La sentencia <codeinline>with</codeinline> est√° prohibida en modo estricto (v√©ase <a href="#6-3">¬ß5.6.3</a>) y debe considerarse obsoleta en modo no estricto: evite su uso siempre que sea posible. El c√≥digo JavaScript que utiliza <codeinline>with</codeinline> es dif√≠cil de optimizar y es probable que se ejecute significativamente m√°s despacio que el c√≥digo equivalente escrito sin la sentencia <codeinline>with</codeinline>.</p>
    <p>El uso habitual de la sentencia <codeinline>with</codeinline> es facilitar el trabajo con jerarqu√≠as de objetos muy definidas. En JavaScript del lado del cliente, por ejemplo, es posible que tenga que escribir expresiones como √©sta para acceder a los elementos de un formulario HTML:</p>
    <pre class="language-js">
    <code class="language-js">document.forms[0].address.value</code></pre>
    <p>Si necesita escribir expresiones como √©sta varias veces, puede utilizar la funci√≥n <codeinline>with</codeinline> con para tratar las propiedades del objeto formulario como variables:</p>
    <pre class="language-js">
    <code class="language-js">with(document.forms[0]) &lbrace;
      // Acceso 
      name.value = "";
      address.value = "";
      email.value = "";
    }</code></pre>
    <p>Esto reduce la cantidad de escritura que tiene que hacer: ya no necesita anteponer a cada nombre de propiedad de formulario <codeinline>document.forms[0]</codeinline>. Es igual de sencillo, por supuesto, evitar la sentencia <codeinline>with</codeinline> y escribir el c√≥digo anterior as√≠:</p>
    <pre class="language-js">
    <code class="language-js">let f = document.forms[0];
    f.name.value = "";
    f.address.value = "";
    f.email.value = "";
    </code></pre>
    <p>Tenga en cuenta que si utiliza <codeinline>const</codeinline> o <codeinline>let</codeinline> o <codeinline>var</codeinline> para declarar una variable o constante dentro del cuerpo de una sentencia <codeinline>with</codeinline>, se crea una variable ordinaria y no se define una nueva propiedad dentro del objeto especificado.</p>
  </section>
  <section id="6-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.6.2 debugger</h2>
    <p>La sentencia <codeinline>debugger</codeinline> normalmente no hace nada. Sin embargo, si se dispone de un programa de depuraci√≥n y se est√° ejecutando, entonces una implementaci√≥n puede (aunque no est√° obligada a) realizar alg√∫n tipo de acci√≥n de depuraci√≥n. En la pr√°ctica, esta sentencia act√∫a como un punto de interrupci√≥n: la ejecuci√≥n del c√≥digo JavaScript se detiene, y puede utilizar el depurador para imprimir los valores de las variables, examinar la pila de llamadas, etc. Supongamos, por ejemplo, que est√°s recibiendo una excepci√≥n en tu funci√≥n <codeinline>f()</codeinline> porque est√° siendo llamada con un argumento indefinido, y no puedes averiguar de d√≥nde viene esta llamada. Para ayudarte en la depuraci√≥n de este problema, podr√≠as alterar <codeinline>f()</codeinline> para que comience as√≠:</p>
    <pre class="language-js">
    <code class="language-js">function f(o) &lbrace;
      if (o === undefined) debugger; // Linea temporal para proposito de depuraci√≥n
      ...                            // El resto de la funci√≥n va aqu√≠
      }</code></pre>
    <p>Ahora, cuando <codeinline>f()</codeinline> es llamada sin argumento, la ejecuci√≥n se detendr√°, y puedes usar el depurador para inspeccionar la pila de llamadas y averiguar de d√≥nde viene esta llamada incorrecta.</p>
    <p>Ten en cuenta que no basta con tener un depurador disponible: la sentencia <codeinline>debugger</codeinline> no iniciar√° el depurador por ti. Sin embargo, si est√°s utilizando un navegador web y tienes abierta la consola de herramientas de desarrollador, esta sentencia provocar√° un punto de interrupci√≥n.</p>
  </section>
  <section id="6-3">
    <h2>5.6.3 "use strict"</h2>
    <p><codeinline>"use strict"</codeinline> es una <em>directiva</em> introducida en ES5. Las directivas no son sentencias (pero se parecen lo suficiente como para que <codeinline>"use strict"</codeinline> se documente aqu√≠). Hay dos diferencias importantes entre la directiva <codeinline>"use strict"</codeinline> y las sentencias normales:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          No incluye ninguna palabra clave del lenguaje: la directiva es s√≥lo una declaraci√≥n de expresi√≥n que consiste en un literal de cadena especial (entre comillas simples o dobles).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          S√≥lo puede aparecer al principio de una secuencia de comandos o al principio del cuerpo de una funci√≥n, antes de que aparezca ninguna sentencia real.
        </p>
      </li>
    </ul>
    <p>El prop√≥sito de una directiva <codeinline>"use strict"</codeinline> es indicar que el c√≥digo que sigue (en el script o funci√≥n) es <em>c√≥digo estricto</em>. El c√≥digo de nivel superior (no funci√≥n) de un script es c√≥digo estricto si el script tiene una directiva <codeinline>"use strict"</codeinline>. El cuerpo de una funci√≥n es c√≥digo estricto si est√° definido dentro de c√≥digo estricto o si tiene una directiva <codeinline>"use strict"</codeinline>. El c√≥digo pasado al m√©todo <codeinline>eval()</codeinline> es c√≥digo estricto si <codeinline>eval()</codeinline> se llama desde c√≥digo estricto o si la cadena de c√≥digo incluye una directiva <codeinline>"use strict"</codeinline>. Adem√°s del c√≥digo declarado expl√≠citamente como estricto, cualquier c√≥digo en el cuerpo de una <codeinline>class</codeinline> (<a href="capitulo-9">Cap√≠tulo 9</a>) o en un m√≥dulo ES6 (<a href="capitulo-10#3">¬ß10.3</a>) es autom√°ticamente c√≥digo estricto. Esto significa que si todo tu c√≥digo JavaScript est√° escrito como m√≥dulos, entonces es autom√°ticamente estricto, y nunca necesitar√°s usar una directiva <codeinline>"use strict"</codeinline> expl√≠cita.</p>
    <p>El c√≥digo estricto se ejecuta en <em>modo estricto</em>. El modo estricto es un subconjunto restringido del lenguaje que corrige importantes deficiencias del lenguaje y proporciona una comprobaci√≥n de errores m√°s s√≥lida y una mayor seguridad. Dado que el modo estricto no es el predeterminado, el c√≥digo JavaScript antiguo que a√∫n utiliza las caracter√≠sticas heredadas deficientes del lenguaje seguir√° ejecut√°ndose correctamente. Las diferencias entre el modo estricto y el modo no estricto son las siguientes (las tres primeras son especialmente importantes):</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          La sentencia <codeinline>with</codeinline> no est√° permitida en modo estricto.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, todas las variables deben ser declaradas: se lanza un ReferenceError si asignas un valor a un identificador que no es una variable declarada, funci√≥n, par√°metro de funci√≥n, par√°metro de cl√°usula <codeinline>catch</codeinline>, o propiedad del objeto global. (En modo no estricto, esto declara impl√≠citamente una variable global a√±adiendo una nueva propiedad al objeto global).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, las funciones invocadas como funciones (en lugar de como m√©todos) tienen un valor <codeinline>this</codeinline> de <codeinline>undefined</codeinline>. (En modo no estricto, a las funciones invocadas como funciones siempre se les pasa el objeto global como su valor <codeinline>this</codeinline>). Adem√°s, en modo estricto, cuando una funci√≥n se invoca con <codeinline>call()</codeinline> o <codeinline>apply()</codeinline> (<a href="capitulo-8#7-4">¬ß8.7.4</a>) el valor <codeinline>this</codeinline> es exactamente el valor pasado como primer argumento a <codeinline>call()</codeinline> o <codeinline>apply()</codeinline>. (En modo no estricto, los valores <codeinline>null</codeinline> e <codeinline>undefined</codeinline> se sustituyen por el objeto global y los valores que no son objetos se convierten en objetos).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, las asignaciones a propiedades no escribibles y los intentos de crear nuevas propiedades en objetos no extensibles lanzan un TypeError. (En modo no estricto, estos intentos fallan silenciosamente).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, el c√≥digo pasado a <codeinline>eval()</codeinline> no puede declarar variables o definir funciones en el √°mbito del invocador, como puede hacerlo en modo no estricto. En su lugar, las definiciones de variables y funciones viven en un nuevo √°mbito creado para <codeinline>eval()</codeinline>. Este √°mbito se descarta cuando vuelve <codeinline>eval()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, el objeto Arguments (<a href="capitulo-8#8-3-3">¬ß8.3.3</a>) de una funci√≥n contiene una copia est√°tica de los valores pasados a la funci√≥n. En modo no estricto, el objeto Arguments tiene un comportamiento <codeinline>"m√°gico"</codeinline> en el que los elementos de la matriz y los par√°metros con nombre de la funci√≥n se refieren al mismo valor.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, se lanza un SyntaxError si el operador <codeinline>delete</codeinline> va seguido de un identificador no cualificado como una variable, funci√≥n o par√°metro de funci√≥n. (En modo no estricto, una expresi√≥n <codeinline>delete</codeinline> de este tipo no hace nada y se eval√∫a como <codeinline>false</codeinline>).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, un intento de borrar una propiedad no configurable lanza un TypeError. (En modo no estricto, el intento falla y la expresi√≥n de <codeinline>delete</codeinline> se eval√∫a como <codeinline>false</codeinline>).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, es un error sint√°ctico que un literal de objeto defina dos o m√°s propiedades con el mismo nombre. (En modo no estricto, no se produce ning√∫n error).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, es un error sint√°ctico que una declaraci√≥n de funci√≥n tenga dos o m√°s par√°metros con el mismo nombre. (En modo no estricto, no se produce ning√∫n error).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, no se permiten los literales enteros octales (que empiezan por 0 y no van seguidos de una x). (En modo no estricto, algunas implementaciones permiten literales octales).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, los identificadores <codeinline>eval</codeinline> y <codeinline>arguments</codeinline> se tratan como palabras clave, y no se permite cambiar su valor. No puedes asignar un valor a estos identificadores, declararlos como variables, usarlos como nombres de funci√≥n, usarlos como nombres de par√°metros de funci√≥n o usarlos como identificador de un bloque <codeinline>catch</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">‚è∫</span>
        <p>
          En modo estricto, la capacidad de examinar la pila de llamadas est√° restringida. <codeinline>arguments.caller</codeinline> y <codeinline>arguments.callee</codeinline> lanzan un TypeError dentro de una funci√≥n en modo estricto o . Las funciones en modo estricto tambi√©n tienen propiedades <codeinline>caller</codeinline> y <codeinline>arguments</codeinline> que lanzan un TypeError cuando se leen. (Algunas implementaciones definen estas propiedades no est√°ndar en funciones no estrictas).
        </p>
      </li>
    </ul>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7 Declaraciones</h2>
    <p>Las palabras clave <codeinline>const</codeinline>, <codeinline>let</codeinline>, <codeinline>var</codeinline>, <codeinline>function</codeinline>, <codeinline>class</codeinline>, <codeinline>import</codeinline> y <codeinline>export</codeinline> no son t√©cnicamente sentencias, pero se parecen mucho a las sentencias, y este libro se refiere informalmente a ellas como sentencias, por lo que merecen una menci√≥n en este cap√≠tulo.</p>
    <p>Estas palabras clave se describen mejor como <em>declaraciones</em> que como sentencias. Dijimos al principio de este cap√≠tulo que las declaraciones "hacen que algo suceda". Las declaraciones sirven para definir nuevos valores y darles nombres que podemos usar para referirnos a esos valores. No hacen mucho por s√≠ mismas, pero al proporcionar nombres para los valores, en un sentido importante, definen el significado de las otras declaraciones en su programa.</p>
    <p>Cuando un programa se ejecuta, son las expresiones del programa las que se eval√∫an y las declaraciones del programa las que se ejecutan. Las declaraciones de un programa no se "ejecutan" de la misma manera: en su lugar, definen la estructura del propio programa. En t√©rminos generales, se puede pensar en las declaraciones como las partes del programa que se procesan antes de que el c√≥digo comience a ejecutarse.</p>
    <p>Las declaraciones de JavaScript se utilizan para definir constantes, variables, funciones y clases, as√≠ como para importar y exportar valores entre m√≥dulos. Las siguientes subsecciones dan ejemplos de todas estas declaraciones. Todas ellas se tratan con mucho m√°s detalle en otras partes de este libro.</p>
  </section>
  <section id="7-1">
    <h2>5.7.1 const, let, y var</h2>
    <p>Las declaraciones <codeinline>const</codeinline>, <codeinline>let</codeinline> y <codeinline>var</codeinline> se tratan en <a href="capitulo-3#10">¬ß3.10</a>. En ES6 y posteriores, <codeinline>const</codeinline> declara constantes, y <codeinline>let</codeinline> declara variables. Antes de ES6, la palabra clave <codeinline>var</codeinline> era la √∫nica forma de declarar variables y no hab√≠a forma de declarar constantes. Las variables declaradas con <codeinline>var</codeinline> se asignan a la funci√≥n que las contiene en lugar de al bloque que las contiene. Esto puede ser una fuente de errores, y en el JavaScript moderno no hay realmente ninguna raz√≥n para usar <codeinline>var</codeinline> en lugar de <codeinline>let</codeinline>.</p>
    <pre class="language-js">
    <code class="language-js">const TAU = 2*Math.PI;
    let radius = 3;
    var circumference = TAU * radius;</code></pre>
  </section>
  <section id="7-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7.2 function</h2>
    <p>La declaraci√≥n de <codeinline>function</codeinline> se utiliza para definir funciones, que se tratan en detalle en el <a href="capitulo-8">Cap√≠tulo 8</a>. (Tambi√©n vimos la <codeinline>function</codeinline> en <a href="capitulo-4#3">¬ß4.3</a>, donde se utiliz√≥ como parte de una expresi√≥n de funci√≥n en lugar de una declaraci√≥n de funci√≥n). Una declaraci√≥n de funci√≥n tiene este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">function area(radius) &lbrace;
      return Math.PI * radius * radius;
    }</code></pre>
    <p>Una declaraci√≥n de funci√≥n crea un objeto de funci√≥n y lo asigna al nombre especificado -<codeinline>area</codeinline> en este ejemplo. En cualquier parte de nuestro programa, podemos referirnos a la funci√≥n- y ejecutar el c√≥digo que contiene- utilizando este nombre. Las declaraciones de funci√≥n de cualquier bloque de c√≥digo JavaScript se procesan antes de que se ejecute el c√≥digo, y los nombres de funci√≥n se vinculan a los objetos de funci√≥n de todo el bloque. Decimos que las declaraciones de funci√≥n se "elevan" porque es como si todas se hubieran movido a la parte superior del √°mbito en el que se definen. El resultado es que el c√≥digo que invoca una funci√≥n puede existir en el programa antes que el c√≥digo que declara la funci√≥n.</p>
    <p><a href="capitulo-12#3">¬ß12.3</a> describe un tipo especial de funci√≥n conocida como <em>generador</em>. Las declaraciones de generador utilizan la palabra clave <codeinline>function</codeinline> pero van seguidas de un asterisco. En <a href="capitulo-13#3">¬ß13.3</a> se describen las funciones as√≠ncronas, que tambi√©n se declaran con la palabra clave <codeinline>function</codeinline> pero van precedidas de la palabra clave <codeinline>async</codeinline>.</p>
  </section>
  <section id="7-3">
    <h2>5.7.3 class</h2>
    <p>En ES6 y posteriores, la declaraci√≥n de <codeinline>class</codeinline> crea una nueva clase y le da un nombre que podemos utilizar para referirnos a ella. Las clases se describen en detalle en el <a href="capitulo-9">Cap√≠tulo 9</a> Una declaraci√≥n de clase simple puede tener este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">class Circle &lbrace;
      constructor(radius) &lbrace; this.r = radius; }
      area() &lbrace; return Math.PI * this.r * this.r; }
      circumference() &lbrace; return 2 * Math.PI * this.r; }
    }</code></pre>
    <p>A diferencia de las funciones, las declaraciones de clase no son hoisted, y no se puede utilizar una clase declarada de esta manera en el c√≥digo que aparece antes de la declaraci√≥n.</p>
  </section>
  <section id="7-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7.4 import y export</h2>
    <p>Las declaraciones <codeinline>import</codeinline> y <codeinline>export</codeinline> se utilizan conjuntamente para que los valores definidos en un m√≥dulo de c√≥digo JavaScript est√©n disponibles en otro m√≥dulo. Un m√≥dulo es un archivo de c√≥digo JavaScript con su propio espacio de nombres global, completamente independiente de todos los dem√°s m√≥dulos. La √∫nica manera de que un valor (como una funci√≥n o una clase) definido en un m√≥dulo pueda utilizarse en otro m√≥dulo es que el m√≥dulo que lo define lo exporte con <codeinline>export</codeinline> y el m√≥dulo que lo utiliza lo importe con <codeinline>import</codeinline>. Los m√≥dulos son el tema del <a href="capitulo-10">Cap√≠tulo 10</a> y la <codeinline>import</codeinline> y la <codeinline>export</codeinline> se tratan en detalle en <a href="capitulo-10#3">¬ß10.3</a>.</p>
    <p>Las directivas <codeinline>import</codeinline> se utilizan para importar uno o m√°s valores de otro archivo de c√≥digo Java-Script y asignarles nombres dentro del m√≥dulo actual. La directiva <codeinline>import</codeinline> viene de diferente forma. He aqu√≠ algunos ejemplos:</p>
    <pre class="language-js">
    <code class="language-js">import Circle from './geometry/circle.js';
    import &lbrace; PI, TAU } from './geometry/constants.js';
    import &lbrace; magnitude as hypotenuse } from './vectors/utils.js';</code></pre>
    <p>Los valores de un m√≥dulo JavaScript son privados y no pueden importarse a otros m√≥dulos a menos que se hayan exportado expl√≠citamente. La directiva <codeinline>export</codeinline> hace esto: declara que uno o m√°s valores definidos en el m√≥dulo actual son exportados y por lo tanto disponibles para ser importados por otros m√≥dulos. La directiva <codeinline>export</codeinline> tiene m√°s variables que la directiva <codeinline>import</codeinline>. He aqu√≠ una de ellas:</p>
    <pre class="language-js">
    <code class="language-js">// geometry/constants.js
    const PI = Math.PI;
    const TAU = 2 * PI;
    export &lbrace; PI, TAU };</code></pre>
    <p>La palabra clave <codeinline>export</codeinline> se utiliza a veces como modificador de otras declaraciones, dando lugar a una especie de declaraci√≥n compuesta que define una constante, variable, funci√≥n o clase y la exporta al mismo tiempo. Y cuando un m√≥dulo exporta un √∫nico valor, suele hacerse con la forma especial <codeinline>export default</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">export const TAU = 2 * Math.PI;
    export function magnitude(x,y) &lbrace; return Math.sqrt(x*x + y*y); }
    export default class Circle &lbrace; /* class definition omitted here */ }</code></pre>
  </section>
  <section id="8" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>5.8 Resumen de las declaraciones de JavaScript</h2>
    <p>En este cap√≠tulo se ha presentado cada una de las sentencias del lenguaje JavaScript, que se resumen en la <a href="tabla5-1">Tabla 5-1</a>.</p>
    <div id="tabla5-1" class="flex flex-col items-center">
      <p><em>Tabla 5-1. Sintaxis de sentencias de JavaScript</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="w-24 text-center">Declaraci√≥n</td>
            <td class="max-w-lg pl-4">Proposito</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="w-24 pl-4">break</td>
              <td class="max-w-lg pl-4">Salir de bucle o<codeinline class="md:text-base bg-transparent">switch</codeinline>interno o de una declaraci√≥n envolvente nombrada</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">case</td>
              <td class="max-w-lg pl-4">Etiqueta una sentencia dentro de un<codeinline class="md:text-base bg-transparent">switch</codeinline></td>
            </tr>
            <tr>
              <td class="w-24 pl-4">class</td>
              <td class="max-w-lg pl-4">Declara una clase</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">const</td>
              <td class="max-w-lg pl-4">Declara una o mas constantes</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">continue</td>
              <td class="max-w-lg pl-4">Empieza la siguiente iteraci√≥n de un bucle interno o del bucle con nombre</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">debugger</td>
              <td class="max-w-lg pl-4">Punto de interrupci√≥n del depurador</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">default</td>
              <td class="max-w-lg pl-4">Etiqueta la sentencia por defecto dentro de un<codeinline class="md:text-base bg-transparent">switch</codeinline></td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">do/while</td>
              <td class="max-w-lg pl-4">Una alternativa al bucle<codeinline class="md:text-base bg-transparent">while</codeinline></td>
            </tr>
            <tr>
              <td class="w-24 pl-4">export</td>
              <td class="max-w-lg pl-4">Declara valores que se pueden importar en otros m√≥dulos</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">for</td>
              <td class="max-w-lg pl-4">Un bucle facil de usar</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">for/await</td>
              <td class="max-w-lg pl-4">Itera de forma asincr√≥nica los valores de un iterador.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">for/in</td>
              <td class="max-w-lg pl-4">Enumara los nombres de las propiedades de un objeto.</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">for/of</td>
              <td class="max-w-lg pl-4">Enumera los valores de un objeto iterable como un array</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">function</td>
              <td class="max-w-lg pl-4">Declara una funci√≥n</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">if/else</td>
              <td class="max-w-lg pl-4">Ejecuta una sentencia u otra funci√≥n de una condici√≥n</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">import</td>
              <td class="max-w-lg pl-4">Declara nombres para valores definidos en otros m√≥dulos</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">label</td>
              <td class="max-w-lg pl-4">Dar un nombre a una sentencia para usar con<codeinline class="md:text-base bg-transparent">break</codeinline>o<codeinline class="md:text-base bg-transparent">continue</codeinline></td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">let</td>
              <td class="max-w-lg pl-4">Declara e inicializa una o mas variables (nueva sintaxis).</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">return</td>
              <td class="max-w-lg pl-4">Devuelve un valor de una funci√≥n</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">switch</td>
              <td class="max-w-lg pl-4">Bifurcaci√≥n multidireccional <codeinline class="md:text-base bg-transparent">case</codeinline>o<codeinline class="md:text-base bg-transparent">default:</codeinline>etiqueta</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">throw</td>
              <td class="max-w-lg pl-4">Lanza una excepci√≥n</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">try/catch/nally</td>
              <td class="max-w-lg pl-4">Gesti√≥n de excepciones y limpieza de c√≥digo</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">‚Äúuse strict‚Äù</td>
              <td class="max-w-lg pl-4">Aplicar restricciones de modo estricto a script o funciones</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">var</td>
              <td class="max-w-lg pl-4">Declara e inicializa una o mas variables (antigua sintaxis).</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">while</td>
              <td class="max-w-lg pl-4">Una construcci√≥n de bucle b√°sica</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">with</td>
              <td class="max-w-lg pl-4">Extender la cadena de alcance (obsoleto y prohibido en modo estricto)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">yield</td>
              <td class="max-w-lg pl-4">Proporciona un valor para ser iterado; solo se utiliza en funciones generadoras</td>
            </tr>
        </tbody>
      </table>
    </div>
  </section>
</Layoutjavascript>