---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-4" capSiguiente="capitulo-6" />
  <section class="fadeIn">
    <header class="flex justify-between">
      <img class="h-10" src="/public/javascript/cinco.svg" alt="Capitulo Cinco">
      <h1 class="text-right">Declaraciones</h1>
    </header>
    <p>El <a href="capitulo-4">capítulo 4</a> describía las expresiones como frases de JavaScript. Por esa analogía, las <em>expresiones</em> son frases o comandos de JavaScript. Del mismo modo que las frases en inglés se terminan y separan entre sí con puntos, las sentencias en JavaScript se terminan con puntos y coma (<a href="capitulo-2#6">§2.6</a>). Las expresiones se <em>evalúan</em> para producir un valor, pero las sentencias se <em>ejecutan</em> para que ocurra algo.</p>
    <p>Una forma de "hacer que ocurra algo" es evaluar una expresión que tenga efectos secundarios. Las expresiones con efectos secundarios, como las asignaciones y las invocaciones de funciones, pueden funcionar por sí solas como sentencias y, cuando se utilizan de este modo, se conocen como <em>sentencias de expresión</em>. Una categoría similar de sentencias son las <em>sentencias de declaración</em> que declaran nuevas variables y definen nuevas funciones.</p>
    <p>Los programas JavaScript no son más que una secuencia de sentencias a ejecutar. Por defecto, el intérprete de JavaScript ejecuta estas sentencias una tras otra en el orden en que están escritas. Otra forma de "hacer que algo suceda" es alterar este orden de ejecución predeterminado, y JavaScript tiene una serie de sentencias o <em>estructuras de control</em> que hacen precisamente esto:
    </p>
    <div class="">
      <p><em>Condicionales</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>if</codeinline> y <codeinline>switch</codeinline> que hacen que el intérprete de JavaScript ejecute u omita otras sentencias en función del valor de una expresión.</p>
    </div>
    <div class="">
      <p><em>Bucles</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>while</codeinline> y <codeinline>for</codeinline> que ejecutan otras sentencias de forma repetitiva</p>
    </div>
    <div class="">
      <p><em>Saltos</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>break</codeinline>, <codeinline>return</codeinline> y <codeinline>throw</codeinline> que hacen que el intérprete salte a otra parte del programa.</p>
    </div>
    <p>Las secciones siguientes describen las distintas sentencias de JavaScript y explican su sintaxis. La <a href="tabla5-1">Tabla 5-1</a> al final del capítulo, resume la sintaxis. Un programa JavaScript es simplemente una secuencia de sentencias, separadas entre sí por punto y coma, por lo que una vez que se familiarice con las sentencias de JavaScript, podrá empezar a escribir programas JavaScript.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>5.1 Sentencias de expresión</h2>
    <p>Los tipos más simples de sentencias en JavaScript son las expresiones que tienen efectos secundarios. Este tipo de sentencia se mostró en el <a href="capitulo-4">capítulo 4</a>. Las sentencias de asignación son una de las principales categorías de sentencias de expresión. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">greeting = "Hello " + name;
    i *= 3;</code></pre>
    <p>Los operadores de incremento y decremento, <codeinline>++</codeinline> y <codeinline>--</codeinline>, están relacionados con los estados de asignación. Tienen el efecto secundario de cambiar el valor de una variable, como si se hubiera realizado una asignación:</p>
    <pre class="language-js">
    <code class="language-js">counter++;</code></pre>
    <p>El operador <codeinline>delete</codeinline> tiene el importante efecto secundario de borrar la propiedad de un objeto. Por lo tanto, casi siempre se utiliza como una sentencia, en lugar de como parte de una expresión más amplia:</p>
    <pre class="language-js">
    <code class="language-js">delete o.x;</code></pre>
    <p>Las llamadas a funciones son otra categoría importante de expresiones. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">console.log(debugMessage);
    displaySpinner(); // Una hipotetica función que muestra un spinne en la aplicación web</code></pre>
    <p>Estas llamadas a funciones son expresiones, pero tienen efectos secundarios que afectan al entorno anfitrión o al estado del programa, y se utilizan aquí como sentencias. Si una función no tiene efectos secundarios, no tiene sentido llamarla, a menos que forme parte de una expresión mayor o de una sentencia de asignación. Por ejemplo, no calcularías un coseno y descartarías el resultado:</p>
    <pre class="language-js">
    <code class="language-js">Math.cos(x);</code></pre>
    <p>Pero bien podría calcular el valor y asignarlo a una variable para su uso futuro:</p>
    <pre class="language-js">
    <code class="language-js">cx = Math.cos(x);</code></pre>
    <p>Observe que cada línea de código de estos ejemplos termina con un punto y com</p>
  </section>
  <section id="2">
    <h2>5.2 Enunciados compuestos y vacíos</h2>
    <p>Al igual que el operador coma (<a href="#13-7">§4.13.7</a>) combina varias expresiones en una sola, un <em>bloque de sentencias</em> combina varias sentencias en una sola <em>sentencia compuesta</em>. Un bloque de sentencias es simplemente una secuencia de sentencias encerradas entre llaves. Así, las siguientes líneas actúan como una única sentencia y pueden utilizarse en cualquier lugar en el que JavaScript espere una única sentencia:</p>
    <pre class="language-js">
    <code class="language-js">&lbrace;
      x = Math.PI;
      cx = Math.cos(x);
      console.log("cos(π) = " + cx);
    }</code></pre>
    <p>Hay que tener en cuenta algunas cosas sobre este bloque de sentencia. En primer lugar, <em>no</em> termina con punto y coma. Las sentencias primitivas dentro del bloque terminan en punto y coma, pero el bloque en sí no. En segundo lugar, las líneas dentro del bloque están sangradas con respecto a las llaves que las encierran. Esto es opcional, pero facilita la lectura y comprensión del código.</p>
    <p>Del mismo modo que las expresiones suelen contener subexpresiones, muchas sentencias de JavaScript contienen sustantivos. Formalmente, la sintaxis de JavaScript suele permitir una única sentencia. Por ejemplo, la sintaxis del bucle <codeinline>while</codeinline> incluye una única sentencia que sirve como cuerpo del bucle. Utilizando un bloque de sentencias, puede colocar cualquier número de sentencias dentro de esta única sustanciación permitida.</p>
    <p>Una sentencia compuesta le permite utilizar varias sentencias donde la sintaxis de JavaScript espera una única sentencia. La <em>sentencia empty</em> es lo contrario: permite no incluir ninguna sentencia donde se espera una. La sentencia empty tiene el siguiente aspecto:</p>
    <pre class="language-js">
    ;</pre>
    <p>El intérprete de JavaScript no realiza ninguna acción cuando ejecuta una sentencia vacía. La sentencia empty es útil ocasionalmente cuando se desea crear un bucle con un cuerpo vacío. Considere el siguiente bucle <codeinline>for</codeinline> (los bucles <codeinline>for</codeinline> se tratarán en <a href="#4.3">§5.4.3</a>):</p>
    <pre class="language-js">
    <code class="language-js">// Inializa un array a
      for(let i = 0; i &lt; a.length; a[i++] = 0) ;</code></pre>
    <p>En este bucle, todo el trabajo lo realiza la expresión <codeinline>a[i++] = 0</codeinline>, y no es necesario ningún cuerpo de bucle. Sin embargo, la sintaxis de JavaScript requiere una expresión como cuerpo del bucle, por lo que se utiliza una expresión vacía, sólo un punto y coma.</p>
    <p>Tenga en cuenta que la inclusión accidental de un punto y coma después del paréntesis derecho de un bucle <codeinline>for</codeinline>, un bucle <codeinline>while</codeinline> o una sentencia <codeinline>if</codeinline> puede provocar errores frustrantes difíciles de detectar. Por ejemplo, el siguiente código probablemente no hace lo que el autor pretendía:</p>
    <pre class="language-js">
    <code class="language-js">if ((a === 0) || (b === 0)); // Ups..! Esta linea no hace nada
      o = null;                  // y esta linea siempre se ejecuta</code></pre>
    <p>Cuando utilice intencionadamente la sentencia empty, es una buena idea comentar su código de forma que quede claro que lo hace a propósito. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; a.length; a[i++] = 0) /* vacio */ ;</code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3 Condicionales</h2>
    <p>Las sentencias condicionales ejecutan u omiten otras sentencias en función del valor de una expresión especificada. Estas sentencias son los puntos de decisión de su código, y también se conocen a veces como "ramas". Si imagina un intérprete de JavaScript siguiendo un camino a través de su código, las sentencias condicionales son los lugares donde el código se bifurca en dos o más caminos y el intérprete debe elegir qué camino seguir.</p>
    <p>Las siguientes subsecciones explican la condicional básica de JavaScript, el estado <codeinline>if/else</codeinline>, y también cubren <codeinline>switch</codeinline>, una sentencia de bifurcación multidireccional más complicada.</p>
  </section>
  <section id="3-1">
    <h2>5.3.1 If</h2>
    <p>La sentencia <codeinline>if</codeinline> es la sentencia de control fundamental que permite a JavaScript tomar decisiones o, más exactamente, ejecutar sentencias condicionalmente. Esta sentencia tiene dos formas. La primera es:</p>
    <pre class="language-js">
    if (expression)
      statement</pre>
    <p>En este formulario, se evalúa la expresión. Si el valor resultante es verdadero, se ejecuta la <em>sentencia</em>. Si la <em>expresión</em> es falsa, la <em>sentencia</em> no se ejecuta. (Véase <a href="capitulo-3#4">§3.4</a> para una definición de los valores verdadero y falso): Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">if (usuario == null)    // Si el usuario es null o undefined
      usuario = "John Doe"; // definelo</code></pre>
    <p>O algo parecido:</p>
    <pre class="language-js">
    <code class="language-js">// Si usuario es null, undefined, false, 0, "" o NaN dale un nuevo valor
    if (!usuario) usuario = "John Doe";</code></pre>
    <p>Tenga en cuenta que los paréntesis alrededor de la <em>expresión</em> son una parte obligatoria de la sintaxis de la sentencia <codeinline>if</codeinline>.</p>
    <p>La sintaxis de JavaScript requiere una única sentencia después de la palabra clave <codeinline>if</codeinline> y la expresión entre paréntesis, pero puede utilizar un bloque de sentencias para combinar varias sentencias en una sola. Así que la sentencia <codeinline>if</codeinline> también podría tener este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">if (!address) &lbrace;
      address = "";
      message = "Por favor ingrese su dirección de correo.";
    }</code></pre>
    <p>La segunda forma de la sentencia <codeinline>if</codeinline> introduce una cláusula <codeinline>else</codeinline> que se ejecuta cuando es la <em>expresión</em> es <codeinline>false</codeinline>. Su sintaxis es:</p>
    <pre class="language-js">
      if (expression)
      statement1
      else
      statement2</pre>
    <p>Esta forma de la sentencia ejecuta la <codeinline>sentencia1</codeinline> si la <em>expresión</em> es verdadera y ejecuta <codeinline>statement2</codeinline> si la <em>expresión</em> es falsa. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1)
      console.log("Tines un mensaje nuevo.");
    else
      console.log(`Tienes $&lbrace;n} mensajes nuevos.`);</code></pre>
    <p>Cuando se han anidado sentencias <codeinline>if</codeinline> con cláusulas <codeinline>else</codeinline>, se requiere cierta precaución para asegurar que la cláusula <codeinline>else</codeinline> va con la sentencia <codeinline>if</codeinline> apropiada. Considere las siguientes líneas:</p>
    <pre class="language-js">
    <code class="language-js">i = j = 1;
    k = 2;
    if (i === j)
      if (j === k)
        console.log("i es igual a k");
    else
      console.log("i no es igual a  j"); // MAL!!</code></pre>
    <p>En este ejemplo, la sentencia <codeinline>if</codeinline> interna forma la única sentencia permitida por la sintaxis de la sentencia <codeinline>if</codeinline> externa. Desafortunadamente, no está claro (excepto por la pista dada por la sangría) con qué <codeinline>if</codeinline> va el <codeinline>else</codeinline>. Y en este ejemplo, la sangría es incorrecta, porque un intérprete de JavaScript interpreta el ejemplo anterior como:</p>
    <pre class="language-js">
    <code class="language-js">if (i === j) &lbrace;
      if (j === k)
        console.log("i es igual k");
      else
        console.log("i no es igual j"); // UPS!
    }</code></pre>
    <p>La regla en JavaScript (como en la mayoría de los lenguajes de programación) es que, por defecto, una cláusula <codeinline>else</codeinline> forma parte de la sentencia <codeinline>if</codeinline> más próxima. Para que este ejemplo sea menos ambiguo y más fácil de leer, entender, mantener y depurar, debe utilizar llaves:</p>
    <pre class="language-js">
    <code class="language-js">if (i === j) &lbrace;
      if (j === k) &lbrace;
        console.log("i es igual k");
      }
    } else &lbrace; // Que diferencia hace la ubicación de las llaves!
      console.log("i no es igual a j");
    }</code></pre>
    <p>Muchos programadores acostumbran a encerrar los cuerpos de las sentencias <codeinline>if</codeinline> y <codeinline>else</codeinline> (así como otras sentencias compuestas, como los bucles <codeinline>while</codeinline>) entre llaves, incluso cuando el cuerpo consta de una sola sentencia. Si lo hace de forma sistemática, puede evitar el tipo de problema que se acaba de mostrar, por lo que le aconsejo que adopte esta práctica. En este libro impreso, hago hincapié en mantener el código de ejemplo verticalmente compacto, y no siempre sigo mis propios consejos al respecto.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3.2 else if</h2>
    <p>La sentencia <codeinline>if/else</codeinline> evalúa una expresión y ejecuta uno o dos fragmentos de código, en función del resultado. Pero, ¿qué ocurre cuando es necesario ejecutar uno de varios fragmentos de código? Una forma de hacerlo es con una sentencia <codeinline>else if</codeinline>. <codeinline>else if</codeinline> no es realmente una sentencia JavaScript, sino simplemente un lenguaje de programación de uso frecuente que resulta cuando se utilizan sentencias <codeinline>if/else</codeinline> repetidas:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el código del bloque #1
    } else if (n === 2) &lbrace;
      // Ejecuta el código del bloque #2
    } else if (n === 3) &lbrace;
      // Ejecuta el código del bloque #3
    } else &lbrace;
      // Si todo falla, ejecuta el código del bloque #4
    }</code></pre>
    <p>Este código no tiene nada de especial. Es simplemente una serie de sentencias <codeinline>if</codeinline>, donde cada <codeinline>if</codeinline> siguiente es parte de la cláusula <codeinline>else</codeinline> de la sentencia anterior. Usar el lenguaje <codeinline>else if</codeinline> es preferible y más legible que escribir estas sentencias en su forma sintácticamente equivalente, completamente anidada:</p>
    <pre class="language-js">
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el código del bloque #1
    }
    else &lbrace;
      if (n === 2) &lbrace;
        // Execute code block #2
      }
      else &lbrace;
        if (n === 3) &lbrace;
          // Ejecuta el código del bloque #3
        }
        else &lbrace;
          // Si todo falla, ejecuta el código del bloque #4
        }
      }
    }</code></pre>
  </section>
  <section id="3-3">
    <h2>5.3.3 switch</h2>
    <p>Una sentencia <codeinline>if</codeinline> provoca una bifurcación en el flujo de ejecución de un programa, y puede utilizar la expresión <codeinline>else if</codeinline> para realizar una bifurcación multidireccional. Sin embargo, esta no es la mejor solución cuando todas las ramas dependen del valor de la misma expresión. En este caso, es un desperdicio evaluar repetidamente esa expresión en múltiples sentencias <codeinline>if</codeinline>.</p>
    <p>La sentencia <codeinline>switch</codeinline> trata exactamente esta situación. La palabra clave <codeinline>switch</codeinline> va seguida de una expresión entre paréntesis y un bloque de código entre llaves:</p>
    <pre class="language-js">
    switch(expression) &lbrace;
      statements
    }</pre>
    <p>Sin embargo, la sintaxis completa de una sentencia <codeinline>switch</codeinline> es más compleja que esto. Varias ubicaciones en el bloque de código se etiquetan con la palabra clave <codeinline>clase</codeinline> seguida de una expresión y dos puntos. Cuando se ejecuta un <codeinline>switch</codeinline>, calcula el valor de la <em>expresión</em> y busca una etiqueta <codeinline>case</codeinline> cuya expresión se evalúe con el mismo valor (donde la igualdad viene determinada por el operador <codeinline>===</codeinline>). Si encuentra uno, comienza a ejecutar el bloque de código en la sentencia etiquetada por <codeinline>case</codeinline>. Si no encuentra un <codeinline>case</codeinline> con un valor coincidente, busca una sentencia etiquetada como <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta el bloque de código.</p>
    <p><codeinline>switch</codeinline> es una sentencia confusa de explicar; su funcionamiento queda mucho más claro con un ejemplo. La siguiente sentencia <codeinline>switch</codeinline> es equivalente a las sentencias <codeinline>if/else</codeinline> repetidas mostradas en la sección anterior:</p>
    <pre class="language-js">
    <code class="language-js">switch(n) &lbrace;
    case 1: // Empieza aquí si n === 1
      // Execute code block #1.
      break; // Se detiene aquí
    case 2: // Empieza aquí si n === 2
      // Execute code block #2.
      break; // Se detiene aquí
    case 3: // Empieza aquí si n === 3
      // Execute code block #3.
      break; // Se detiene aquí
    default: // Si todo falla,
      // Ejecuta el código del bloque #4
      break; // Se detiene aquí
    }</code></pre>
    <p>Observe la palabra clave <codeinline>break</codeinline> utilizada al final de cada caso en este código. El estado <codeinline>break</codeinline>, descrito más adelante en este capítulo, hace que el intérprete salte al final (o "salga") de la sentencia <codeinline>switch</codeinline> y continúe con la sentencia que le sigue. Las cláusulas <codeinline>case</codeinline> en una sentencia <codeinline>switch</codeinline> especifican sólo el <em>punto de inicio</em> del código deseado; no especifican ningún punto final. En ausencia de sentencias <codeinline>break</codeinline>, una sentencia <codeinline>switch</codeinline> comienza a ejecutar su bloque de código en la etiqueta <codeinline>case</codeinline> que coincide con la sentencia de su <em>expresión</em> y continúa ejecutando sentencias hasta que llega al final del bloque. En raras ocasiones, es útil escribir código como este que "pasa" de una etiqueta <codeinline>case</codeinline> a la siguiente, pero el 99% de las veces debe tener cuidado de terminar cada <codeinline>case</codeinline> con una sentencia <codeinline>break</codeinline>. (Sin embargo, cuando use <codeinline>switch</codeinline> dentro de una función, puede usar una sentencia <codeinline>return</codeinline> en lugar de una sentencia <codeinline>break</codeinline>. Ambas sirven para terminar la sentencia <codeinline>switch</codeinline> y evitar que la ejecución pase al siguiente <codeinline>case</codeinline>).</p>
    <p>He aquí un ejemplo más realista de la sentencia <codeinline>switch</codeinline>; convierte un valor en una cadena de una forma que depende del tipo del valor:</p>
    <pre class="language-js">
    <code class="language-js">function convert(x) &lbrace;
      switch(typeof x) &lbrace;
      case "number": // Convierte el número en hexadecimal
        return x.toString(16);
      case "string": // Devuelve la cadena entre comillas
        return '"' + x + '"';
      default: // Convierte cualquier otro tipo en una cadena
        return String(x);
      }
    }</code></pre>
    <p>Observe que en los dos ejemplos anteriores, las palabras clave <codeinline>case</codeinline> van seguidas de literales numéricos y de cadena, respectivamente. Así es como la sentencia <codeinline>switch</codeinline> se utiliza más a menudo en la práctica, pero tenga en cuenta que el estándar ECMAScript permite que cada <codeinline>case</codeinline> vaya seguido de una expresión arbitraria.</p>
    <p>La sentencia <codeinline>switch</codeinline> evalúa primero la expresión que sigue a la palabra clave <codeinline>switch</codeinline> y luego evalúa las expresiones <codeinline>case</codeinline>, en el orden en que aparecen, hasta encontrar un valor que coincida.<sup>1</sup> El caso coincidente se determina utilizando el operador de identidad <codeinline>===</codeinline>, no el operador de igualdad <codeinline>==</codeinline>, por lo que las expresiones deben coincidir sin ninguna conversión de tipo.</p>
    <p>Dado que no todas las expresiones <codeinline>case</codeinline> se evalúan cada vez que se ejecuta la sentencia <codeinline>switch</codeinline>, debe evitar el uso de expresiones <codeinline>case</codeinline> que contengan efectos secundarios como llamadas a funciones o asignaciones. Lo más seguro es limitar las expresiones <codeinline>case</codeinline> a expresiones constantes.</p>
    <p>Como se explicó anteriormente, si ninguna de las expresiones <codeinline>case</codeinline> coincide con la expresión <codeinline>switch</codeinline>, la sentencia <codeinline>switch</codeinline> comienza a ejecutar su cuerpo en la sentencia etiquetada <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta todo su cuerpo. Observe que en los ejemplos mostrados, la etiqueta <codeinline>default:</codeinline> aparece al final del cuerpo de la sentencia <codeinline>switch</codeinline>, después de todas las etiquetas <codeinline>case</codeinline>. Este es un lugar lógico y común para ella, pero en realidad puede aparecer en cualquier lugar dentro del cuerpo de la declaración.</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4 Bucles (loops)</h2>
    <p>Para entender las sentencias condicionales, imaginemos que el intérprete de JavaScript sigue un camino ramificado a través del código fuente. Las <em>sentencias de bucle</em> son las que doblan ese camino sobre sí mismo para repetir partes del código. JavaScript tiene cinco sentencias de bucle: <codeinline>while</codeinline>, <codeinline>do/while</codeinline>, <codeinline>for</codeinline>, <codeinline>for/of</codeinline> (y su variante <codeinline>for/await</codeinline>), y <codeinline>for/in</codeinline>. Las siguientes subsecciones explican cada una de ellas. Un uso común de los bucles es iterar sobre los elementos de un array. <a href="capitulo-7#6">§7.6</a> discute este tipo de bucle en detalle y cubre los métodos especiales de bucle definidos por la clase Array.
    </p>
  </section>
  <section id="4-1">
    <h2>5.4.1 While</h2>
    <p>Al igual que la sentencia <codeinline>if</codeinline> es el condicional básico de JavaScript, la sentencia <codeinline>while</codeinline> es el bucle básico de JavaS cript. Su sintaxis es la siguiente:</p>
    <pre class="language-js">
    while (expression)
      statement</pre>
    <p>Para ejecutar una sentencia <codeinline>while</codeinline>, el intérprete evalúa primero la <em>expresión</em>. Si el valor de la expresión es falso, el intérprete se salta la <em>sentencia</em> que sirve de cuerpo del bucle y pasa a la siguiente sentencia del programa. Si, por el contrario, la <em>expresión</em> es verdadera, el intérprete ejecuta la <em>sentencia</em> y repite, saltando de nuevo al principio del bucle y evaluando de nuevo la <em>expresión</em>. Otra forma de decir esto es que el intérprete ejecuta la <em>sentencia</em> repetidamente <em>mientras</em> la <em>expresión</em> es verdadera. Tenga en cuenta que puede crear un bucle infinito con la sintaxis <codeinline>while(true)</codeinline>.</p>
    <p>Normalmente, no se desea que JavaScript realice exactamente la misma operación una y otra vez. En casi todos los bucles, una o más variables cambian con cada <em>iteración</em> del bucle. Dado que las variables cambian, las acciones realizadas al ejecutar la <em>sentencia</em> pueden diferir cada vez que se repite el bucle. Además, si la variable o variables que cambian están involucradas en una <em>expresión</em>, el valor de la expresión puede ser diferente cada vez que se repite el bucle. Esto es importante; de lo contrario, una expresión que comienza siendo verdadera nunca cambiaría, ¡y el bucle nunca terminaría! He aquí un ejemplo de un bucle <codeinline>while</codeinline> que imprime los números del 0 al 9:</p>
    <pre class="language-js">
    <code class="language-js">let count = 0;
    while(count &lt; 10) &lbrace;
      console.log(count);
      count++;
    }</code></pre>
    <p>Como puedes ver, la variable <codeinline>count</codeinline> empieza en 0 y se incrementa cada vez que se ejecuta el cuerpo del bucle. Una vez que el bucle se ha ejecutado 10 veces, la expresión se convierte en <codeinline>false</codeinline> (es decir, la variable <codeinline>count</codeinline> ya no es inferior a 10), la sentencia <codeinline>while</codeinline> finaliza y el intérprete puede pasar a la siguiente sentencia del programa. Muchos bucles tienen una variable contador como <codeinline>count</codeinline>. Los nombres de variables <codeinline>i</codeinline>, <codeinline>j</codeinline>, y <codeinline>k</codeinline> se usan comúnmente como contadores de bucle, aunque debería usar nombres más descriptivossihacequesucódigo sea másfácildeentender.</p>
  </section>
  <section id="4-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.2 Do/While</h2>
    <p>El bucle <codeinline>do/while</codeinline> es como un bucle <codeinline>while</codeinline>, salvo que la expresión del bucle se comprueba al final del bucle en lugar de al principio. Esto significa que el cuerpo del bucle siempre se ejecuta al menos una vez. La sintaxis es:</p>
    <pre class="language-js">
    do
      statement
    while (expression);</pre>
    <p>El bucle <codeinline>do/while</codeinline> es menos comúnmente usado que su primo <codeinline>while</codeinline> en la práctica, es algo poco común estar seguro de que quieres que un bucle se ejecute al menos una vez. Aquí hay un ejemplo de un bucle <codeinline>do/while</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">function printArray(a) &lbrace;
      let len = a.length, i = 0;
      if (len === 0) &lbrace;
        console.log("Empty Array");
      } else &lbrace;
        do &lbrace;
          console.log(a[i]);
        } while(++i &lt; len);
      }
    }</code></pre>
    <p>Hay un par de diferencias sintácticas entre el bucle <codeinline>do/while</codeinline> y el bucle <codeinline>while</codeinline> ordinario. En primer lugar, el bucle <codeinline>do</codeinline> requiere tanto la palabra clave <codeinline>do</codeinline> (para marcar el inicio del bucle) como la palabra clave <codeinline>while</codeinline> (para marcar el final e introducir la condición del bucle). Además, el bucle <codeinline>do</codeinline> debe terminar siempre con punto y coma. El bucle <codeinline>while</codeinline> no necesita punto y coma si el cuerpo del bucle está encerrado entre llaves.</p>
  </section>
  <section id="4-3">
    <h2>5.4.3 for</h2>
    <p>La sentencia <codeinline>for</codeinline> proporciona una construcción de bucle que a menudo es más conveniente que la sentencia <codeinline>while</codeinline>. La sentencia <codeinline>for</codeinline> simplifica los bucles que siguen un patrón común. La mayoría de los bucles tienen una variable contadora de algún tipo. Esta variable se inicializa antes de que comience el bucle y se comprueba antes de cada iteración del bucle. Finalmente, la variable contador se incrementa o se actualiza al final del bucle, justo antes de que la variable se compruebe de nuevo. En este tipo de bucle, la inicialización, la prueba y la actualización son las tres manipulaciones cruciales de una variable de bucle. La sentencia <codeinline>for</codeinline> codifica cada una de estas tres manipulaciones como una expresión y las convierte en parte explícita de la sintaxis del bucle:r</p>
    <pre class="language-js">
    for(initialize ; test ; increment)
      statement</pre>
    <p><em>inicializar</em>, <em>probar</em> e <em>incrementar</em> son tres expresiones (separadas por punto y coma) que son responsables de inicializar, probar e incrementar la variable del bucle. Ponerlas todas en la primera línea del bucle facilita la comprensión de lo que está haciendo un bucle <codeinline>for</codeinline> y evita errores como olvidar inicializar o incrementar la variable del bucle.</p>
    <p>La forma más sencilla de explicar cómo funciona un bucle <codeinline>for</codeinline> es mostrar el <codeinline>while</codeinline> equivalente bucle:<sup>2</sup></p>
    <pre class="language-js">
    initialize;
    while(test) &lbrace;
      statement
      increment;
    }</pre>
    <p>En otras palabras, la expresión <em>inicializar</em> se evalúa una vez, antes de que comience el bucle. Para ser útil, esta expresión debe tener efectos secundarios (normalmente una asignación). JavaScript también permite que <em>initialize</em> sea una sentencia de declaración de variable, de modo que se puede declarar e inicializar un contador de bucle al mismo tiempo. La expresión <em>test</em> se evalúa antes de cada iteración y controla si se ejecuta el cuerpo del bucle. Si el valor de <em>test</em> es verdadero, se ejecuta la <em>sentencia</em> que constituye el cuerpo del bucle. Por último, se evalúa la em de <em>incremento</em>. De nuevo, debe ser una expresión con efectos secundarios para ser útil. Generalmente, es una expresión de asignación, o utiliza los operadores <codeinline>++</codeinline> o <codeinline>--</codeinline>.</p>
    <p>Podemos imprimir los números del 0 al 9 con un bucle <codeinline>for</codeinline> como el siguiente. Contrástalo con el bucle <codeinline>while</codeinline> equivalente mostrado en la sección anterior:</p>
    <pre class="language-js">
    <code class="language-js">for(let count = 0; count &lt; 10; count++) &lbrace;
      console.log(count);
    }</code></pre>
    <p>Los bucles pueden llegar a ser mucho más complejos que este sencillo ejemplo, por supuesto, y a veces múltiples variables cambian con cada iteración del bucle. Esta situación es el único lugar donde el operador coma se utiliza comúnmente en JavaScript; proporciona una manera de combinar múltiples expresiones de inicialización e incremento en una sola expresión adecuada para su uso en un bucle <codeinline>for</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let i, j, sum = 0;
      for(i = 0, j = 10 ; i &lt; 10 ; i++, j--) &lbrace;
      sum += i * j;
    }</code></pre>
    <p>En todos nuestros ejemplos de bucles hasta ahora, la variable del bucle ha sido numérica. Esto es bastante común, pero no es necesario. El siguiente código utiliza un bucle <codeinline>for</codeinline> para recorrer una estructura de datos de lista enlazada y devolver el último objeto de la lista (es decir, el primer objeto que no tiene una propiedad <codeinline>next</codeinline>):</p>
    <pre class="language-js">
    <code class="language-js">function tail(o) &lbrace; // Devuelve la ultima de la lista enlazada
      for(; o.next; o = o.next) /* empty */ ; // Recorre mientras o.next sea verdadero
      return o;
    }</code></pre>
    <p>Observe que este código no tiene ninguna expresión de <em>inicialización</em>. Cualquiera de las tres expresiones puede omitirse en un bucle <codeinline>for</codeinline>, pero los dos puntos y coma son obligatorios. Si omite la expresión de <em>prueba</em>, el bucle se repite para siempre, y <codeinline>for(;;)</codeinline> es otra forma de escribir un bucle infinito, como <codeinline>while(true)</codeinline>.</p>
  </section>
  <section id="4-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.4 for/of</h2>
    <p>ES6 define una nueva sentencia de bucle: <codeinline>for/of</codeinline>. Este nuevo tipo de bucle utiliza la palabra clave <codeinline>for</codeinline>, pero es un tipo de bucle completamente diferente del bucle <codeinline>for</codeinline> normal. (También es completamente diferente del antiguo bucle <codeinline>for/in</codeinline> que describiremos en <a href="capitulo-5#4-5">§5.4.5</a>.)</p>
    <p>El bucle <codeinline>for/of</codeinline> funciona con objetos <em>iterables</em>. Explicaremos exactamente qué significa que un objeto sea iterable en el <a href="capitulo-12">Capítulo 12</a>, pero para este capítulo, es suficiente saber que los arrays, cadenas, conjuntos y mapas son iterables: representan una secuencia o conjunto de elementos que puedes recorrer usando un bucle <codeinline>for/of</codeinline>.</p>
    <p>Aquí, por ejemplo, podemos utilizar <codeinline>for/of</codeinline> para recorrer los elementos de una matriz de números y calcular su suma:</p>
    <pre class="language-js">
    <code class="language-js">let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
    for(let element of data) &lbrace;
      sum += element;
    }
    sum // => 45</code></pre>
    <p>Superficialmente, la sintaxis se parece a la de un bucle <codeinline>for</codeinline> normal: la palabra clave <codeinline>for</codeinline> va seguida de paréntesis que contienen detalles sobre lo que debe hacer el bucle. En este caso, los paréntesis contienen una declaración de variable (o, para variables que ya han sido declaradas, simplemente el nombre de la variable) seguida por la palabra clave <codeinline>of</codeinline> y una expresión que evalúa a un objeto iterable, como el array de <codeinline>date</codeinline> en este caso. Como con todos los bucles, el cuerpo de un bucle <codeinline>for/of</codeinline> sigue a los paréntesis, normalmente entre llaves.</p>
    <p>En el código que se acaba de mostrar, el cuerpo del bucle se ejecuta una vez por cada elemento de la matriz de <codeinline>data</codeinline>. Antes de cada ejecución del cuerpo del bucle, el siguiente elemento de la matriz se asigna a la variable element. Los elementos del array se iteran en orden del primero al último.</p>
    <p>Los arrays se iteran "en vivo"-los cambios realizados durante la iteración pueden afectar al resultado de la misma. Si modificamos el código anterior añadiendo la línea <codeinline>data.push(sum);</codeinline> dentro del cuerpo del bucle, entonces creamos un bucle infinito porque la iteración nunca puede alcanzar el último elemento del array.</p>
    <p class="title-article text-left">for/of con objectos</p>
    <p>Los objetos no son iterables (por defecto). El intento de utilizar <codeinline>for/of</codeinline> en un objeto normal produce un TypeError en tiempo de ejecución:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    for(let element of o) &lbrace; // Throws TypeError porque o no es iterable
      console.log(element);
    }</code></pre>
    <p>Si quieres iterar a través de las propiedades de un objeto, puedes utilizar el bucle <codeinline>for/in</codeinline> (introducido en <a href="capitulo-5#4-5">§5.4.5</a>), o utilizar <codeinline>for/of</codeinline> con el método <codeinline>Object.keys()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let keys = "";
    for(let k of Object.keys(o)) &lbrace;
      keys += k;
    }
    keys // => "xyz"</code></pre>
    <p>Esto funciona porque <codeinline>Object.keys()</codeinline> devuelve un array de nombres de propiedades de un objeto, y los arrays son iterables con <codeinline>for/of</codeinline>. Tenga en cuenta también que esta iteración de las claves de un objeto no es en vivo como en el ejemplo de la matriz anterior - los cambios en el objeto o realizados en el cuerpo del bucle no tendrán ningún efecto sobre la iteración. Si no te importan las claves de un objeto, también puedes iterar a través de sus valores correspondientes así:</p>
    <pre class="language-js">
    <code class="language-js">let sum = 0;
    for(let v of Object.values(o)) &lbrace;
      sum += v;
    }
    sum // => 6</code></pre>
    <p>Y si está interesado tanto en las claves como en los valores de las propiedades de un objeto, puede utilizar <codeinline>for/of</codeinline> con <codeinline>Object.entries()</codeinline> y la asignación de desestructuración:</p>
    <pre class="language-js">
    <code class="language-js">let pairs = "";
    for(let [k, v] of Object.entries(o)) &lbrace;
      pairs += k + v;
    }
    pairs // => "x1y2z3"</code></pre>
    <p><codeinline>Object.entries()</codeinline> devuelve una matriz de matrices, donde cada matriz interna representa un par clave/valor para una propiedad del objeto. En este ejemplo de código utilizamos la asignación de desestructuración para descomponer esas matrices internas en dos variables individuales.</p>
    <p class="title-article text-left">for/of con strings</p>
    <p>Las cadenas son iterables carácter a carácter en ES6:</p>
    <pre class="language-js">
    <code class="language-js">let frequency = &lbrace;};
    for(let letter of "mississippi") &lbrace;
      if (frequency[letter]) &lbrace;
        frequency[letter]++;
      } else &lbrace;
        frequency[letter] = 1;
      }
    }
    frequency // => &lbrace;m: 1, i: 4, s: 4, p: 2}</code></pre>
    <p>Tenga en cuenta que las cadenas se iteran por punto de código Unicode, no por carácter UTF-16. La cadena "I ❤ 🐶" tiene una <codeinline>.length</codeinline> de 5 (porque cada uno de los dos caracteres emoji requiere dos caracteres UTF-16 para representarse). Pero si iteras esa cadena con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecutará tres veces, una por cada uno de los tres puntos de código "I", "❤" y "🐶."</p>
    <p class="title-article text-left">for/of con Set y Map</p>
    <p>Las clases incorporadas Set y Map de ES6 son iterables. Cuando iteras un Set con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecuta una vez por cada elemento del set. Puede utilizar código como éste para imprimir las palabras únicas en una cadena de texto:</p>
    <pre class="language-js">
    <code class="language-js">let text = "Na na na na na na na na Batman!";
    let wordSet = new Set(text.split(" "));
    let unique = [];
    for(let word of wordSet) &lbrace;
      unique.push(word);
    }
    unique // => ["Na", "na", "Batman!"]</code></pre>
    <p>Los Mapas son un caso interesante porque el iterador de un objeto Mapa no itera las claves del Mapa, ni los valores del Mapa, sino pares clave/valor. En cada iteración, el iterador devuelve un array cuyo primer elemento es una clave y cuyo segundo elemento es el valor correspondiente. Dado un Map <codeinline>m</codeinline>, podrías iterar y desestructurar sus pares clave/valor así:</p>
    <pre class="language-js">
    <code class="language-js">let m = new Map([[1, "one"]]);
    for(let [key, value] of m) &lbrace;
      key // => 1
      value // => "one"
    }</code></pre>
    <p class="title-article text-left">Iteración asíncrona con for/await</p>
    <p>ES2018 introduce un nuevo tipo de iterador, conocido como <em>iterador asíncrono</em>, y una variante del bucle <codeinline>for/of</codeinline>, conocida como bucle <codeinline>for/await</codeinline>, que funciona con iteradores asíncronos.</p>
    <p>Tendrás que leer los Capítulos <a href="capitulo-12">12</a> y <a href="capitulo-13">13</a> para entender el bucle <codeinline>for/await</codeinline>, pero aquí tienes cómo se ve en código:</p>
    <pre class="language-js">
    <code class="language-js">// Leer trozos de un flujo iterable asincrono e imprimirlos
    async function printStream(stream) &lbrace;
      for await (let chunk of stream) &lbrace;
        console.log(chunk);
      }
    }</code></pre>
  </section>
  <section id="4-5">
    <h2>5.4.5 for/in</h2>
    <p>Un bucle <codeinline>for/in</codeinline> se parece mucho a un bucle <codeinline>for/of</codeinline>, con la palabra clave <codeinline>of</codeinline> cambiada por <codeinline>in</codeinline>. Mientras que un bucle <codeinline>for/of</codeinline> requiere un objeto iterable después de <codeinline>of</codeinline>, un bucle <codeinline>for/in</codeinline> funciona con cualquier objeto después de <codeinline>in</codeinline>. El bucle <codeinline>for/of</codeinline> es nuevo en ES6, pero <codeinline>for/in</codeinline> ha formado parte de JavaScript desde el principio (por eso tiene una sintaxis más natural).</p>
    <p>La sentencia <codeinline>for/in</codeinline> recorre en bucle los nombres de las propiedades de un objeto especificado. La sintaxis es la siguiente:</p>
    <pre class="language-js">
    for (variable in object)
      statement</pre>
    <p><em>variable</em> normalmente nombra una variable, pero puede ser una declaración de variable o cualquier cosa adecuada como el lado izquierdo de una expresión de asignación. <em>object</em> es una expresión que se evalúa a un objeto. Como de costumbre, <em>statement</em> es la sentencia o bloque de sentencias que sirve como cuerpo del bucle.</p>
    <p>Y podrías usar un bucle <codeinline>for/in</codeinline> como este:</p>
    <pre class="language-js">
    <code class="language-js">for(let p in o) &lbrace; // Asigna los nombres de las propiedades de o a la variable p
      console.log(o[p]); // Imprime el valor de cada propiedad
    }</code></pre>
    <p>Para ejecutar una sentencia <codeinline>for/in</codeinline>, el intérprete de JavaScript evalúa primero la expresión del <em>objeto</em>. Si es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, el intérprete omite el bucle y pasa a la siguiente sentencia. El intérprete ejecuta ahora el cuerpo del bucle una vez por cada propiedad enumerable del objeto. Antes de cada iteración, sin embargo, el intérprete evalúa la expresión de la <em>variable</em> y le asigna el nombre de la propiedad (un valor de cadena).</p>
    <p>Tenga en cuenta que la <em>variable</em> en el bucle <codeinline>for/in</codeinline> puede ser una expresión arbitraria, siempre y cuando se evalúe a algo adecuado para el lado izquierdo de una asignación. Esta expresión es se evalúa cada vez que se pasa por el bucle, lo que significa que puede evaluarse de forma diferente cada vez. Por ejemplo, puede utilizar código como el siguiente para copiar los nombres de todas las propiedades del objeto en un array:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let a = [], i = 0;
    for(a[i++] in o) /* empty */;</code></pre>
    <p>Las matrices de JavaScript son simplemente un tipo especializado de objeto, y los índices de las matrices son propiedades de los objetos que pueden enumerarse con un bucle <codeinline>for/in</codeinline>. Por ejemplo, siguiendo el código anterior con esta línea se enumeran los índices 0, 1 y 2 del array:</p>
    <pre class="language-js">
    <code class="language-js">for(let i in a) console.log(i);</code></pre>
    <p>Encuentro que una fuente común de errores en mi propio código es el uso accidental de <codeinline>for/in</codeinline> con arrays cuando quería usar <codeinline>for/of</codeinline>. Cuando se trabaja con matrices, casi siempre es mejor usar <codeinline>for/of</codeinline> en lugar de <codeinline>for/in</codeinline>.</p>
    <p>El bucle <codeinline>for/in</codeinline> no enumera todas las propiedades de un objeto. No enumera las propiedades cuyos nombres son símbolos. Y de las propiedades cuyos nombres son cadenas, sólo hace un bucle sobre las propiedades <em>enumerables</em> (véase <a href="capitulo-6#14-1">§14.1</a>). Los diversos métodos incorporados definidos por el núcleo de JavaScript no son enumerables. Todos los objetos tienen un método <codeinline>toString()</codeinline>, por ejemplo, pero el bucle <codeinline>for/in</codeinline> no enumera esta propiedad <codeinline>toString()</codeinline>. Además de los métodos incorporados, muchas otras propiedades de los objetos incorporados no son enumerables. Todas las propiedades y métodos definidos por su código son enumerables, por defecto. (Puede hacerlos no enumerables utilizando técnicas explicadas en <a href="capitulo-6#14-1">§14.1</a>.)</p>
    <p>Las propiedades heredadas enumerables (véase <a href="capitulo-6#3-2">§6.3.2</a>) también son enumeradas por el bucle <codeinline>for/in</codeinline>. Esto significa que si utilizas bucles <codeinline>for/in</codeinline> y también utilizas código que define propiedades que son heredadas por todos los objetos, entonces tu bucle puede no comportarse de la manera que esperas. Por esta razón, muchos programadores prefieren utilizar un bucle <codeinline>for/of</codeinline> con <codeinline>Object.keys()</codeinline> en lugar de un bucle <codeinline>for/in</codeinline>.</p>
    <p>Si el cuerpo de un bucle <codeinline>for/in</codeinline> borra una propiedad que aún no ha sido enumerada, esa propiedad no será enumerada. Si el cuerpo del bucle define nuevas propiedades en el objeto, esas propiedades pueden o no ser enumeradas. Véase <a href="capitulo-6#6-1">§6.6.1</a> para más información sobre el orden en que <codeinline>for/in</codeinline> enumera las propiedades de un objeto.</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5 Jumps</h2>
    <p>Otra categoría de sentencias JavaScript son las <em>sentencias jump</em>. Como su nombre indica, hacen que el intérprete de JavaScript salte a una nueva ubicación en el código fuente. La sentencia <codeinline>break</codeinline> hace que el intérprete salte al final de un bucle u otro estado. <codeinline>continue</codeinline> hace que el intérprete se salte el resto del cuerpo de un bucle y vuelva al principio de un bucle para comenzar una nueva iteración. JavaScript permite que las sentencias con nombre o <em>etiqueta</em>, y <codeinline>break</codeinline> y <codeinline>continue</codeinline> pueden identificar el bucle de destino u otra etiqueta de estado.</p>
    <p>La sentencia <codeinline>return</codeinline> hace que el intérprete salte desde la invocación de una función de vuelta al código que la invocó y también proporciona el valor de la invocación. La sentencia <codeinline>throw</codeinline> es una especie de retorno provisional de una función generadora. La sentencia <codeinline>throw</codeinline> levanta, o <em>lanza</em>, una excepción y está diseñada para trabajar con la sentencia <codeinline>try/catch/finally</codeinline>, que establece un bloque de código de gestión de excepciones. Se trata de un tipo de sentencia de salto: cuando se lanza una excepción, el intérprete salta al manejador de excepciones más cercano, que puede estar en la misma función o más arriba en la pila de llamadas de una función invocadora.</p>
    <p>Los detalles sobre cada una de estas declaraciones de salto se encuentran en las secciones siguientes.</p>
  </section>
  <section id="5-1">
    <h2>5.5.1 Declaraciones etiquetadas</h2>
    <p>Cualquier declaración puede <em>etiquetarse</em> precediéndola de un identificador y dos puntos:</p>
    <pre class="language-js">
    identificador: declaración</pre>
    <p>Al etiquetar una sentencia, le da un nombre que puede utilizar para referirse a ella en cualquier parte de su programa. Puede etiquetar cualquier sentencia, aunque sólo es útil para etiquetar sentencias que tienen cuerpo, como bucles y condicionales. Al dar un nombre a un bucle, puede utilizar las sentencias <codeinline>break</codeinline> y <codeinline>continue</codeinline> dentro del cuerpo del bucle para salir del bucle o para saltar directamente a la parte superior del bucle para comenzar la siguiente iteración. <codeinline>break</codeinline> y <codeinline>continue</codeinline> son las únicas sentencias de JavaScript que utilizan etiquetas de sentencia; se tratan en las siguientes subsecciones. A continuación se muestra un ejemplo de un bucle <codeinline>while</codeinline> etiquetado y una sentencia <codeinline>continue</codeinline> que utiliza la etiqueta.</p>
    <pre class="language-js">
    <code class="language-js">mainloop: while(token !== null) &lbrace;
      // Codigo omitido...
      continue mainloop; // Salta a la siguiente iteración del bucle
      // Mas codigo omitido...
    }</code></pre>
    <p>El <em>identificador</em> que se utiliza para etiquetar una sentencia puede ser cualquier identificador legal de JavaScript que no sea una palabra reservada. El espacio de nombres para etiquetas es diferente del espacio de nombres para variables y funciones, por lo que puede utilizar el mismo identificador como etiqueta de sentencia y como nombre de variable o función. Las etiquetas de sentencia sólo se definen dentro de la sentencia a la que se aplican (y dentro de sus sustituciones, por supuesto). Una sentencia no puede tener la misma etiqueta que la sentencia que la contiene, pero dos sentencias pueden tener la misma etiqueta siempre que ninguna esté anidada dentro de la otra. Las sentencias etiquetadas pueden ser a su vez etiquetadas. Esto significa que cualquier sentencia puede tener varias etiquetas.</p>
  </section>
  <section id="5-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.2 break</h2>
    <p>La sentencia <codeinline>break</codeinline>, utilizada por sí sola, hace que el bucle o <codeinline>switch</codeinline> que la encierra en su interior
      para salir inmediatamente. Su sintaxis es sencilla:</p>
    <pre class="language-js">
    break;</pre>
    <p>Dado que provoca la salida de un bucle o <codeinline>switch</codeinline>, esta forma de la sentencia <codeinline>break</codeinline> sólo es legal si aparece dentro de una de estas sentencias.</p>
    <p>Ya ha visto ejemplos de la sentencia <codeinline>break</codeinline> dentro de una sentencia <codeinline>switch</codeinline>. En los bucles, se utiliza normalmente para salir prematuramente cuando, por cualquier razón, ya no hay necesidad de completar el bucle. Cuando un bucle tiene condiciones de terminación complejas, a menudo es más fácil implementar algunas de estas condiciones con sentencias <codeinline>break</codeinline> en lugar de intentar expresarlas todas en una única expresión de bucle. El siguiente código busca un valor determinado en los elementos de una matriz. El bucle termina de forma normal cuando alcanza el final del array; termina con una sentencia <codeinline>break</codeinline> si encuentra lo que está buscando en el array:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; a.length; i++) &lbrace;
      if (a[i] === target) break;
    }</code></pre>
    <p>JavaScript también permite que la palabra clave <codeinline>break</codeinline> vaya seguida de una etiqueta de sentencia (sólo el identificador, sin dos puntos):</p>
    <pre class="language-js">
    break labelname;</pre>
    <p>Cuando se utiliza <codeinline>break</codeinline> con una etiqueta, salta al final o termina la sentencia adjunta que tiene la etiqueta especificada. Es un error de sintaxis utilizar <codeinline>break</codeinline> de esta forma si no hay una sentencia anexa con la etiqueta especificada. Con esta forma de la sentencia <codeinline>break</codeinline>, no es necesario que la sentencia nombrada sea un bucle o un <codeinline>switch:break</codeinline> puede "salir" de cualquier sentencia adjunta. Esta sentencia puede ser incluso un bloque de sentencias agrupado entre llaves con el único propósito de nombrar el bloque con una etiqueta.</p>
    <p>No se permite una nueva línea entre la palabra clave <codeinline>break</codeinline> y el nombre de la <em>etiqueta</em>. Esto se debe a que JavaScript inserta automáticamente el punto y coma omitido: si se coloca un punto y coma entre la palabra clave <codeinline>break</codeinline> y la etiqueta que le sigue, JavaScript asume que se pretende utilizar la forma simple y sin etiqueta de la sentencia y trata el punto y coma como un punto y coma. (Véase <a href="capitulo-2#6">§2.6</a>.)</p>
    <p>Necesitará la forma etiquetada de la sentencia <codeinline>break</codeinline> cuando desee salir de una sentencia que no sea el bucle o <codeinline>switch</codeinline> más cercano. El siguiente código lo demuestra:</p>
    <pre class="language-js">
    <code class="language-js">let matrix = getData(); // Obtiene una matriz 2D de números de alguna manera
      // Ahora suma todos los números en la matriz.
      let sum = 0, success = false;
      // Empieza con una sentencia etiquetada que podemos salir de si ocurre un error
      computeSum: if (matrix) &lbrace;
        for(let x = 0; x &lt; matrix.length; x++) &lbrace;
          let row = matrix[x];
          if (!row) break computeSum;
          for(let y = 0; y &lt; row.length; y++) &lbrace;
            let cell = row[y];
            if (isNaN(cell)) break computeSum;
            sum += cell;
          }
        }
        success = true;
      }
      // La sentencia break salta aquí. Si llegamos aquí con success == false
      // entonces hubo algo malo con la matriz que nos dieron.
      // Caso contrario sum contiene la suma de todas las celdas de la matriz</code></pre>
    <p>Por último, tenga en cuenta que una sentencia <codeinline>break</codeinline>, con o sin etiqueta, no puede transferir el control a través de los límites de la función. No puede etiquetar una sentencia de definición de función, por ejemplo, y luego utilizar esa etiqueta dentro de la función.</p>
  </section>
  <section id="5-3">
    <h2>5.5.3 continue</h2>
    <p>La sentencia <codeinline>continue</codeinline> es similar a la sentencia <codeinline>break</codeinline>. Sin embargo, en lugar de salir de un bucle, <codeinline>continue</codeinline> lo reinicia en la siguiente iteración. La sintaxis de la sentencia <codeinline>continue</codeinline> es tan sencilla como la de la sentencia <codeinline>break</codeinline>:</p>
    <pre class="language-js">
    continue;</pre>
    <p>La sentencia <codeinline>continue</codeinline> también puede utilizarse con una etiqueta:</p>
    <pre class="language-js">
    continue labelname;</pre>
    <p>La sentencia <codeinline>continue</codeinline>, tanto en su forma etiquetada como sin etiquetar, sólo puede utilizarse dentro del cuerpo de un bucle. Su uso en cualquier otro lugar provoca un error de sintaxis.</p>
    <p>Cuando se ejecuta la sentencia <codeinline>continue</codeinline>, finaliza la iteración actual del bucle que lo encierra y comienza la siguiente iteración. Esto significa cosas diferentes para los distintos tipos de bucles:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En un bucle <codeinline>while</codeinline>, la <em>expresión</em> especificada al principio del bucle se comprueba de nuevo y, si es <codeinline>true</codeinline>, el cuerpo del bucle se ejecuta empezando por arriba.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En un bucle <codeinline>do/while</codeinline>, la ejecución salta a la parte inferior del bucle, donde la condición del bucle se comprueba de nuevo antes de reiniciar el bucle en la parte superior.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En un bucle <codeinline>for</codeinline>, se evalúa la expresión de <em>incremento</em> y se vuelve a comprobar la expresión de <em>prueba</em> para determinar si debe realizarse otra iteración.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En un bucle <codeinline>for/of</codeinline> o <codeinline>for/in</codeinline>, el bucle comienza de nuevo con el siguiente valor iterado o el siguiente nombre de propiedad que se asigna a la variable especificada.
        </p>
      </li>
    </ul>
    <p>Observe la diferencia en el comportamiento de la sentencia <codeinline>continue</codeinline> en los bucles <codeinline>while</codeinline> y <codeinline>for</codeinline>: un bucle <codeinline>while</codeinline> vuelve directamente a su condición, pero un bucle <codeinline>for</codeinline> evalúa primero su expresión de <em>incremento</em> y luego vuelve a su condición. Anteriormente, consideramos el comportamiento del bucle <codeinline>for</codeinline> en términos de un bucle <codeinline>while</codeinline> "equivalente". Sin embargo, debido a que el estado <codeinline>continue</codeinline> se comporta de forma diferente para estos dos bucles, en realidad no es posible simular perfectamente un bucle <codeinline>for</codeinline> sólo con un bucle <codeinline>while</codeinline>.</p>
    <p>El siguiente ejemplo muestra una sentencia <codeinline>continue</codeinline> sin etiquetar que se utiliza para saltarse el resto de la iteración actual de un bucle cuando se produce un error:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lt; data.length; i++) &lbrace;
      if (!data[i]) continue; // No puedo proceder son datos indefinidos
      total += data[i];
    }</code></pre>
    <p>Al igual que la sentencia <codeinline>break</codeinline>, la sentencia <codeinline>continue</codeinline> puede utilizarse en su forma etiquetada dentro de bucles anidados cuando el bucle a reiniciar no es el bucle inmediatamente adyacente. Además, al igual que con la sentencia <codeinline>break</codeinline>, no se permiten saltos de línea entre la sentencia <codeinline>continue</codeinline> y su <em>labelname</em>.</p>
  </section>
  <section id="5-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.4 return</h2>
    <p>Recordemos que las invocaciones a funciones son expresiones y que todas las expresiones tienen valores. Una sentencia <codeinline>return</codeinline> dentro de una función especifica el valor de las invocaciones de esa función. Esta es la sintaxis de la sentencia <codeinline>return</codeinline>:</p>
    <pre class="language-js">
    return expression;</pre>
    <p>Una sentencia <codeinline>return</codeinline> sólo puede aparecer dentro del cuerpo de una función. Es un error sintáctico que aparezca en cualquier otro lugar. Cuando se ejecuta la sentencia <codeinline>return</codeinline>, la función que la contiene devuelve el valor de la <em>expresión</em> a su invocador. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">function square(x) &lbrace; return x*x; } // Una función que devuelve el cuadrado de su argumento
    square(2) // => 4</code></pre>
    <p>Sin sentencia <codeinline>return</codeinline>, una invocación de función simplemente ejecuta cada uno de los estados del cuerpo de la función por turnos hasta que llega al final de la función y entonces devuelve a su invocador. En este caso, la expresión de invocación se evalúa como <codeinline>undefined</codeinline>. La sentencia <codeinline>return</codeinline> aparece a menudo como la última sentencia de una función, pero no tiene por qué ser la última: una función vuelve a su invocador cuando se ejecuta una sentencia <codeinline>return</codeinline>, aunque queden otras sentencias en el cuerpo de la función.</p>
    <p>La sentencia <codeinline>return</codeinline> también puede utilizarse sin una <em>expresión</em> para hacer que la función devuelva <codeinline>undefined</codeinline> asuinvocador. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">function displayObject(o) &lbrace;
      // Regresa inmediatamente si el argumento es null o undefined
      if (!o) return;
      // El resto de la función va aquí
    }</code></pre>
    <p>Debido a la inserción automática de punto y coma de JavaScript (<a href="capitulo-2#6">§2.6</a>) no puede incluir un salto de línea entre la palabra clave <codeinline>return</codeinline> y la expresión que le sigue.</p>
  </section>
  <section id="5-5">
    <h2>5.5.5 yield</h2>
    <p>La sentencia <codeinline>yield</codeinline> es muy parecida a la sentencia <codeinline>return</codeinline>, pero sólo se utiliza en funciones generadoras ES6 (véase <a href="capitulo-12#3">§12.3</a>) para producir el siguiente valor en la secuencia generada de valores sin devolverlo:</p>
    <pre class="language-js">
    <code class="language-js">// Una función generadora que produce un rango de números
    function* range(from, to) &lbrace;
      for(let i = from; i &lt;= to; i++) &lbrace;
      yield i;
      }
    }</code></pre>
    <p>Para entender <codeinline>yield</codeinline>, debe entender los iteradores y generadores, que no se tratarán hasta el <a href="capitulo-12">capítulo 12</a>. Sin embargo, <codeinline>yield</codeinline> se incluye aquí para completar el tema. (Técnicamente, sin embargo, <codeinline>yield</codeinline> es un operador más que una sentencia, como se explica en <a href="capitulo-12#4-2">§12.4.2</a>.)</p>
  </section>
  <section id="5-6" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.6 throw</h2>
    <p>Una <em>excepción</em> es una señal que indica que se ha producido algún tipo de condición excepcional o error. <em>Lanzar</em> una excepción es señalar un error o una condición excepcional. <em>Atrapar</em> una excepción es manejarla, es decir, tomar las medidas necesarias o apropiadas para recuperarse de la excepción. En JavaScript, las excepciones se lanzan siempre que se produce un error en tiempo de ejecución y siempre que el programa las lanza explícitamente utilizando la sentencia <codeinline>throw</codeinline>. Las excepciones se capturan con el estado <codeinline>try/catch/finally</codeinline>, que se describe en la siguiente sección.</p>
    <p>La sentencia <codeinline>throw</codeinline> tiene la siguiente sintaxis:</p>
    <pre class="language-js">
    throw expression;</pre>
    <p><em>expression</em> puede evaluarse a un valor de cualquier tipo. Puede lanzar un número que represente un código de error o una cadena que contenga un mensaje de error legible por humanos. La clase Error y sus subclases se utilizan cuando el propio intérprete de JavaScript lanza un error, y usted también puede utilizarlas. Un objeto Error tiene una propiedad <codeinline>name</codeinline> que especifica el tipo de error y una propiedad <codeinline>message</codeinline> que contiene la cadena pasada a la función constructora. A continuación se muestra una función de ejemplo que lanza un objeto Error cuando se invoca con un argumento no válido:</p>
    <pre class="language-js">
    <code class="language-js">function factorial(x) &lbrace;
      // Si el argumento de entrada e invalido, lanza una excepción!.
      if (x &lt; 0) throw new Error("x no debe ser negativo");
      // Caso contrario, calcula el valor y lo devuelve.
      let f;
      for(f = 1; x > 1; f *= x, x--) /* empty */ ;
      return f;
    }
    factorial(4) // => 24</code></pre>
    <p>Cuando se lanza una excepción, el intérprete de JavaScript detiene inmediatamente la ejecución normal del programa y salta al manejador de excepciones más cercano. Los manejadores de excepciones se escriben utilizando la cláusula <codeinline>catch</codeinline> de la sentencia <codeinline>try/catch/finally</codeinline>, que se describe en la siguiente sección. Si el bloque de código en el que se lanzó la excepción no tiene una cláusula <codeinline>catch</codeinline> asociada, el intérprete comprueba el siguiente bloque de código más alto para ver si tiene un manejador de excepciones asociado. Esto continúa hasta que se encuentra un manejador. Si se lanza una excepción en una función que no contiene una sentencia <codeinline>try/catch/finally</codeinline> para manejarla, la excepción se propaga hasta el código que invocó la función. De este modo, las excepciones se propagan por la estructura léxica de los métodos de JavaScript y por la pila de llamadas. Si no se encuentra ningún manejador de excepciones, la excepción se trata como un error y se notifica al usuario.</p>
  </section>
  <section id="5-7">
    <h2>5.5.7 try/catch/nally</h2>
    <p>La sentencia <codeinline>try/catch/finally</codeinline> es el mecanismo de gestión de excepciones de JavaScript. La cláusula <codeinline>try</codeinline> de esta sentencia simplemente define el bloque de código cuyas excepciones deben tratarse. El bloque <codeinline>try</codeinline> va seguido de una cláusula <codeinline>catch</codeinline>, que es un bloque de sentencias que se invocan cuando se produce una excepción en cualquier parte del bloque <codeinline>try</codeinline>. La cláusula <codeinline>catch</codeinline> va seguida de un bloque <codeinline>finally</codeinline> que contiene código de limpieza que está garantizado que se ejecute, independientemente de lo que ocurra en el bloque <codeinline>try</codeinline>. Los bloques <codeinline>catch</codeinline> y <codeinline>finally</codeinline> son opcionales, pero un bloque <codeinline>try</codeinline> debe ir acompañado de al menos uno de estos bloques. Los bloques <codeinline>try</codeinline>, <codeinline>catch</codeinline> y <codeinline>finally</codeinline> comienzan y terminan con llaves. Estas llaves son una parte obligatoria de la sintaxis y no pueden omitirse, incluso si una cláusula contiene una única sentencia.</p>


    <p>El siguiente código ilustra la sintaxis y el propósito de <codeinline>try/catch/finally</codeinline> declaración:</p>
    <pre class="language-js">
    <code class="language-js">try &lbrace;
      // Normalmente, este codigo se ejecuta desde la parte superior hasta la 
      // parte inferior sin problemas. Pero a veces, puede producirse una 
      // excepción ya sea directamente, con una sentencia throw, o indirectamente 
      // llamando a un metodo que lanza una excepción.
    }
    catch(e) &lbrace;
      // La sentencia de este bloque se ejecuta si, y solo si el bloque try
      // lanza una excepción. Esta sentencia puede utilizar la variable local
      // e para referirse para el objeto Error o cualquier otro valor lanzado.
      // Este bloque puede manejar la excepción alguna manera, puede ignorar
      // la excepción haciendo nada, o puede lanzar otra excepción con throw.
    }
    finally &lbrace;
      // Este bloque contiene sentencias que siempre se ejecutan, independientemente
      // que ocurra en el bloque try. Estas sentencias se ejecutan siempre que el
      // bloque terminal:
      // 1) normalmente, después de llegar al final del bloque
      // 2) debido a una sentencia break, continue o return
      // 3) con una excepción que se gestiona por una cláusula catch anterior
      // 4) con una excepción no capturada que se esta propagando
    }
    </code></pre>
    <p>Tenga en cuenta que la palabra clave <codeinline>catch</codeinline> suele ir seguida de un identificador entre paréntesis. Este identificador es como un parámetro de función. Cuando se captura una excepción, el valor asociado con la excepción (un objeto Error, por ejemplo) se asigna a este parámetro. El identificador asociado a una cláusula <codeinline>catch</codeinline> tiene alcance de bloque: sólo se define dentro del bloque <codeinline>catch</codeinline>.</p>
    <p>He aquí un ejemplo realista de la sentencia <codeinline>try/catch</codeinline>. Utiliza el método <codeinline>factorial()</codeinline> definido en la sección anterior y los métodos JavaScript del lado del cliente <codeinline>prompt()</codeinline> y <codeinline>alert()</codeinline> para la entrada y la salida:</p>
    <pre class="language-js">
    <code class="language-js">try &lbrace;
      // Pedir al usuario que introduzca un número
      let n = Number(prompt("Por favor ingrese un número entero", ""));
      // Calcula el factorial del número, asuimiendo que sea válido
      let f = factorial(n);
      // Mostrar el resultado
      alert(n + "! = " + f);
    }
    catch(ex) &lbrace;   // Si la entrada del usuario no es valida, termina aquí
      alert(ex);  // Indica al usuario cual es el error
    }</code></pre>
    <p>Este ejemplo es una sentencia <codeinline>try/catch</codeinline> sin cláusula <codeinline>finally</codeinline>. Aunque <codeinline>finally</codeinline> no se utiliza tan a menudo como <codeinline>catch</codeinline>, puede ser útil. Sin embargo, su comportamiento requiere una explicación adicional. Se garantiza la ejecución de la cláusula <codeinline>finally</codeinline> si se ejecuta cualquier parte del bloque <codeinline>try</codeinline>, independientemente de cómo finalice el código del bloque <codeinline>try</codeinline>. Generalmente se utiliza para limpiar después del código en la cláusula <codeinline>try</codeinline>.</p>
    <p>En el caso normal, el intérprete de JavaScript llega al final del bloque <codeinline>try</codeinline> y pasa al bloque <codeinline>finally</codeinline>, que realiza cualquier limpieza necesaria. Si el intérprete abandonó el bloque <codeinline>try</codeinline> debido a una sentencia <codeinline>return</codeinline>, <codeinline>continue</codeinline> o <codeinline>break</codeinline>, el bloque <codeinline>finally</codeinline> se ejecuta antes de que el intérprete salte a su nuevo destino.</p>
    <p>Si se produce una excepción en el bloque <codeinline>try</codeinline> y hay un bloque <codeinline>catch</codeinline> asociado para manejar la excepción, el intérprete ejecuta primero el bloque <codeinline>catch</codeinline> y luego el bloque <codeinline>finally</codeinline>. Si no hay un bloque <codeinline>catch</codeinline> local para manejar la excepción, el intérprete ejecuta primero el bloque <codeinline>finally</codeinline> y luego salta a la cláusula <codeinline>catch</codeinline> más cercana.</p>
    <p>Si el propio bloque <codeinline>finally</codeinline> provoca un salto con una sentencia <codeinline>return</codeinline>, <codeinline>continue</codeinline>, <codeinline>break</codeinline> o <codeinline>throw</codeinline>, o llamando a un método que lanza una excepción, el intérprete abandona cualquier salto que estuviera pendiente y realiza el nuevo salto. Por ejemplo, si una cláusula <codeinline>finally</codeinline> lanza una excepción, esa excepción sustituye a cualquier excepción que estuviera en proceso de ser lanzada. Si una cláusula <codeinline>finally</codeinline> emite una sentencia <codeinline>return</codeinline>, el método retorna normalmente, incluso si se ha lanzado una excepción y aún no ha sido manejada.</p>
    <p><codeinline>try</codeinline> y <codeinline>finally</codeinline> pueden usarse juntos sin una cláusula <codeinline>catch</codeinline>. En este caso, el bloque <codeinline>finally</codeinline> es simplemente código de limpieza cuya ejecución está garantizada, independientemente de lo que ocurra en el bloque <codeinline>try</codeinline>. Recordemos que no podemos simular completamente un bucle <codeinline>for</codeinline> con un bucle <codeinline>while</codeinline> porque la sentencia <codeinline>continue</codeinline> se comporta de forma diferente en los dos bucles. Si añadimos una sentencia <codeinline>try/finally</codeinline>, podemos escribir un bucle <codeinline>while</codeinline> que funcione como un bucle <codeinline>for</codeinline> y que maneje correctamente las sentencias <codeinline>continue</codeinline>:</p>
    <pre class="language-js">
    // Simula for(initialize ; test ;increment ) body;
    initialize ;
    while( test ) &lbrace;
      try &lbrace; body ; }
      finally &lbrace; increment ; }
    }</pre>
    <p>Tenga en cuenta, sin embargo, que un <em>cuerpo</em> que contiene una sentencia <codeinline>break</codeinline> se comporta de forma ligeramente diferente (provocando un incremento extra antes de salir) en el bucle <codeinline>while</codeinline> que en el bucle <codeinline>for</codeinline>, por lo que incluso con la cláusula <codeinline>finally</codeinline>, no es posible simular completamente el bucle <codeinline>for</codeinline> con <codeinline>while</codeinline>.</p>
    <article>
      <p class="title-article">Cláusulas de salvaguardia</p>
      <p>Ocasionalmente puedes encontrarte utilizando una cláusula <codeinline>catch</codeinline> únicamente para detectar y detener la propagación de una excepción, aunque no te importe el tipo o el valor de la excepción. En ES2019 y posteriores, puedes omitir los paréntesis y el identificador y utilizar la palabra clave <codeinline>catch</codeinline> desnuda en este caso. He aquí un ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// Como JSON.parse(), pero devuelve undefined en lugar de lanzar un error
    function parseJSON(s) &lbrace;
      try &lbrace;
        return JSON.parse(s);
      } catch &lbrace;
      // Algo salio mal pero no nos importa, devolvemos undefined
        return undefined;
      }
    }</code></pre>
    </article>
  </section>
  <section id="6" class="py-4 xs:py-5 sm:py-6">
    <h2>5.6 Declaraciones varias</h2>
    <p>Esta sección describe las tres sentencias JavaScript restantes: <codeinline>with</codeinline>, <codeinline>debugger</codeinline> y <codeinline>"use strict"</codeinline>.</p>
  </section>
  <section id="6-1">
    <h2>5.6.1 with</h2>
    <p>La sentencia <codeinline>with</codeinline> ejecuta un bloque de código como si las propiedades de un objeto especificado fueran variables en el ámbito de ese código. Su sintaxis es la siguiente:</p>
    <pre class="language-js">
    with (object)
      statements
    }</pre>
    <p>Esta sentencia crea un ámbito temporal con las propiedades del <em>object</em> como variables y luego ejecuta la <em>sentencia</em> dentro de ese ámbito.</p>
    <p>La sentencia <codeinline>with</codeinline> está prohibida en modo estricto (véase <a href="#6-3">§5.6.3</a>) y debe considerarse obsoleta en modo no estricto: evite su uso siempre que sea posible. El código JavaScript que utiliza <codeinline>with</codeinline> es difícil de optimizar y es probable que se ejecute significativamente más despacio que el código equivalente escrito sin la sentencia <codeinline>with</codeinline>.</p>
    <p>El uso habitual de la sentencia <codeinline>with</codeinline> es facilitar el trabajo con jerarquías de objetos muy definidas. En JavaScript del lado del cliente, por ejemplo, es posible que tenga que escribir expresiones como ésta para acceder a los elementos de un formulario HTML:</p>
    <pre class="language-js">
    <code class="language-js">document.forms[0].address.value</code></pre>
    <p>Si necesita escribir expresiones como ésta varias veces, puede utilizar la función <codeinline>with</codeinline> con para tratar las propiedades del objeto formulario como variables:</p>
    <pre class="language-js">
    <code class="language-js">with(document.forms[0]) &lbrace;
      // Acceso 
      name.value = "";
      address.value = "";
      email.value = "";
    }</code></pre>
    <p>Esto reduce la cantidad de escritura que tiene que hacer: ya no necesita anteponer a cada nombre de propiedad de formulario <codeinline>document.forms[0]</codeinline>. Es igual de sencillo, por supuesto, evitar la sentencia <codeinline>with</codeinline> y escribir el código anterior así:</p>
    <pre class="language-js">
    <code class="language-js">let f = document.forms[0];
    f.name.value = "";
    f.address.value = "";
    f.email.value = "";
    </code></pre>
    <p>Tenga en cuenta que si utiliza <codeinline>const</codeinline> o <codeinline>let</codeinline> o <codeinline>var</codeinline> para declarar una variable o constante dentro del cuerpo de una sentencia <codeinline>with</codeinline>, se crea una variable ordinaria y no se define una nueva propiedad dentro del objeto especificado.</p>
  </section>
  <section id="6-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.6.2 debugger</h2>
    <p>La sentencia <codeinline>debugger</codeinline> normalmente no hace nada. Sin embargo, si se dispone de un programa de depuración y se está ejecutando, entonces una implementación puede (aunque no está obligada a) realizar algún tipo de acción de depuración. En la práctica, esta sentencia actúa como un punto de interrupción: la ejecución del código JavaScript se detiene, y puede utilizar el depurador para imprimir los valores de las variables, examinar la pila de llamadas, etc. Supongamos, por ejemplo, que estás recibiendo una excepción en tu función <codeinline>f()</codeinline> porque está siendo llamada con un argumento indefinido, y no puedes averiguar de dónde viene esta llamada. Para ayudarte en la depuración de este problema, podrías alterar <codeinline>f()</codeinline> para que comience así:</p>
    <pre class="language-js">
    <code class="language-js">function f(o) &lbrace;
      if (o === undefined) debugger; // Linea temporal para proposito de depuración
      ...                            // El resto de la función va aquí
      }</code></pre>
    <p>Ahora, cuando <codeinline>f()</codeinline> es llamada sin argumento, la ejecución se detendrá, y puedes usar el depurador para inspeccionar la pila de llamadas y averiguar de dónde viene esta llamada incorrecta.</p>
    <p>Ten en cuenta que no basta con tener un depurador disponible: la sentencia <codeinline>debugger</codeinline> no iniciará el depurador por ti. Sin embargo, si estás utilizando un navegador web y tienes abierta la consola de herramientas de desarrollador, esta sentencia provocará un punto de interrupción.</p>
  </section>
  <section id="6-3">
    <h2>5.6.3 "use strict"</h2>
    <p><codeinline>"use strict"</codeinline> es una <em>directiva</em> introducida en ES5. Las directivas no son sentencias (pero se parecen lo suficiente como para que <codeinline>"use strict"</codeinline> se documente aquí). Hay dos diferencias importantes entre la directiva <codeinline>"use strict"</codeinline> y las sentencias normales:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          No incluye ninguna palabra clave del lenguaje: la directiva es sólo una declaración de expresión que consiste en un literal de cadena especial (entre comillas simples o dobles).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Sólo puede aparecer al principio de una secuencia de comandos o al principio del cuerpo de una función, antes de que aparezca ninguna sentencia real.
        </p>
      </li>
    </ul>
    <p>El propósito de una directiva <codeinline>"use strict"</codeinline> es indicar que el código que sigue (en el script o función) es <em>código estricto</em>. El código de nivel superior (no función) de un script es código estricto si el script tiene una directiva <codeinline>"use strict"</codeinline>. El cuerpo de una función es código estricto si está definido dentro de código estricto o si tiene una directiva <codeinline>"use strict"</codeinline>. El código pasado al método <codeinline>eval()</codeinline> es código estricto si <codeinline>eval()</codeinline> se llama desde código estricto o si la cadena de código incluye una directiva <codeinline>"use strict"</codeinline>. Además del código declarado explícitamente como estricto, cualquier código en el cuerpo de una <codeinline>class</codeinline> (<a href="capitulo-9">Capítulo 9</a>) o en un módulo ES6 (<a href="capitulo-10#3">§10.3</a>) es automáticamente código estricto. Esto significa que si todo tu código JavaScript está escrito como módulos, entonces es automáticamente estricto, y nunca necesitarás usar una directiva <codeinline>"use strict"</codeinline> explícita.</p>
    <p>El código estricto se ejecuta en <em>modo estricto</em>. El modo estricto es un subconjunto restringido del lenguaje que corrige importantes deficiencias del lenguaje y proporciona una comprobación de errores más sólida y una mayor seguridad. Dado que el modo estricto no es el predeterminado, el código JavaScript antiguo que aún utiliza las características heredadas deficientes del lenguaje seguirá ejecutándose correctamente. Las diferencias entre el modo estricto y el modo no estricto son las siguientes (las tres primeras son especialmente importantes):</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La sentencia <codeinline>with</codeinline> no está permitida en modo estricto.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, todas las variables deben ser declaradas: se lanza un ReferenceError si asignas un valor a un identificador que no es una variable declarada, función, parámetro de función, parámetro de cláusula <codeinline>catch</codeinline>, o propiedad del objeto global. (En modo no estricto, esto declara implícitamente una variable global añadiendo una nueva propiedad al objeto global).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, las funciones invocadas como funciones (en lugar de como métodos) tienen un valor <codeinline>this</codeinline> de <codeinline>undefined</codeinline>. (En modo no estricto, a las funciones invocadas como funciones siempre se les pasa el objeto global como su valor <codeinline>this</codeinline>). Además, en modo estricto, cuando una función se invoca con <codeinline>call()</codeinline> o <codeinline>apply()</codeinline> (<a href="capitulo-8#7-4">§8.7.4</a>) el valor <codeinline>this</codeinline> es exactamente el valor pasado como primer argumento a <codeinline>call()</codeinline> o <codeinline>apply()</codeinline>. (En modo no estricto, los valores <codeinline>null</codeinline> e <codeinline>undefined</codeinline> se sustituyen por el objeto global y los valores que no son objetos se convierten en objetos).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, las asignaciones a propiedades no escribibles y los intentos de crear nuevas propiedades en objetos no extensibles lanzan un TypeError. (En modo no estricto, estos intentos fallan silenciosamente).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, el código pasado a <codeinline>eval()</codeinline> no puede declarar variables o definir funciones en el ámbito del invocador, como puede hacerlo en modo no estricto. En su lugar, las definiciones de variables y funciones viven en un nuevo ámbito creado para <codeinline>eval()</codeinline>. Este ámbito se descarta cuando vuelve <codeinline>eval()</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, el objeto Arguments (<a href="capitulo-8#8-3-3">§8.3.3</a>) de una función contiene una copia estática de los valores pasados a la función. En modo no estricto, el objeto Arguments tiene un comportamiento <codeinline>"mágico"</codeinline> en el que los elementos de la matriz y los parámetros con nombre de la función se refieren al mismo valor.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, se lanza un SyntaxError si el operador <codeinline>delete</codeinline> va seguido de un identificador no cualificado como una variable, función o parámetro de función. (En modo no estricto, una expresión <codeinline>delete</codeinline> de este tipo no hace nada y se evalúa como <codeinline>false</codeinline>).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, un intento de borrar una propiedad no configurable lanza un TypeError. (En modo no estricto, el intento falla y la expresión de <codeinline>delete</codeinline> se evalúa como <codeinline>false</codeinline>).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, es un error sintáctico que un literal de objeto defina dos o más propiedades con el mismo nombre. (En modo no estricto, no se produce ningún error).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, es un error sintáctico que una declaración de función tenga dos o más parámetros con el mismo nombre. (En modo no estricto, no se produce ningún error).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, no se permiten los literales enteros octales (que empiezan por 0 y no van seguidos de una x). (En modo no estricto, algunas implementaciones permiten literales octales).
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, los identificadores <codeinline>eval</codeinline> y <codeinline>arguments</codeinline> se tratan como palabras clave, y no se permite cambiar su valor. No puedes asignar un valor a estos identificadores, declararlos como variables, usarlos como nombres de función, usarlos como nombres de parámetros de función o usarlos como identificador de un bloque <codeinline>catch</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          En modo estricto, la capacidad de examinar la pila de llamadas está restringida. <codeinline>arguments.caller</codeinline> y <codeinline>arguments.callee</codeinline> lanzan un TypeError dentro de una función en modo estricto o . Las funciones en modo estricto también tienen propiedades <codeinline>caller</codeinline> y <codeinline>arguments</codeinline> que lanzan un TypeError cuando se leen. (Algunas implementaciones definen estas propiedades no estándar en funciones no estrictas).
        </p>
      </li>
    </ul>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7 Declaraciones</h2>
    <p>Las palabras clave <codeinline>const</codeinline>, <codeinline>let</codeinline>, <codeinline>var</codeinline>, <codeinline>function</codeinline>, <codeinline>class</codeinline>, <codeinline>import</codeinline> y <codeinline>export</codeinline> no son técnicamente sentencias, pero se parecen mucho a las sentencias, y este libro se refiere informalmente a ellas como sentencias, por lo que merecen una mención en este capítulo.</p>
    <p>Estas palabras clave se describen mejor como <em>declaraciones</em> que como sentencias. Dijimos al principio de este capítulo que las declaraciones "hacen que algo suceda". Las declaraciones sirven para definir nuevos valores y darles nombres que podemos usar para referirnos a esos valores. No hacen mucho por sí mismas, pero al proporcionar nombres para los valores, en un sentido importante, definen el significado de las otras declaraciones en su programa.</p>
    <p>Cuando un programa se ejecuta, son las expresiones del programa las que se evalúan y las declaraciones del programa las que se ejecutan. Las declaraciones de un programa no se "ejecutan" de la misma manera: en su lugar, definen la estructura del propio programa. En términos generales, se puede pensar en las declaraciones como las partes del programa que se procesan antes de que el código comience a ejecutarse.</p>
    <p>Las declaraciones de JavaScript se utilizan para definir constantes, variables, funciones y clases, así como para importar y exportar valores entre módulos. Las siguientes subsecciones dan ejemplos de todas estas declaraciones. Todas ellas se tratan con mucho más detalle en otras partes de este libro.</p>
  </section>
  <section id="7-1">
    <h2>5.7.1 const, let, y var</h2>
    <p>Las declaraciones <codeinline>const</codeinline>, <codeinline>let</codeinline> y <codeinline>var</codeinline> se tratan en <a href="capitulo-3#10">§3.10</a>. En ES6 y posteriores, <codeinline>const</codeinline> declara constantes, y <codeinline>let</codeinline> declara variables. Antes de ES6, la palabra clave <codeinline>var</codeinline> era la única forma de declarar variables y no había forma de declarar constantes. Las variables declaradas con <codeinline>var</codeinline> se asignan a la función que las contiene en lugar de al bloque que las contiene. Esto puede ser una fuente de errores, y en el JavaScript moderno no hay realmente ninguna razón para usar <codeinline>var</codeinline> en lugar de <codeinline>let</codeinline>.</p>
    <pre class="language-js">
    <code class="language-js">const TAU = 2*Math.PI;
    let radius = 3;
    var circumference = TAU * radius;</code></pre>
  </section>
  <section id="7-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7.2 function</h2>
    <p>La declaración de <codeinline>function</codeinline> se utiliza para definir funciones, que se tratan en detalle en el <a href="capitulo-8">Capítulo 8</a>. (También vimos la <codeinline>function</codeinline> en <a href="capitulo-4#3">§4.3</a>, donde se utilizó como parte de una expresión de función en lugar de una declaración de función). Una declaración de función tiene este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">function area(radius) &lbrace;
      return Math.PI * radius * radius;
    }</code></pre>
    <p>Una declaración de función crea un objeto de función y lo asigna al nombre especificado -<codeinline>area</codeinline> en este ejemplo. En cualquier parte de nuestro programa, podemos referirnos a la función- y ejecutar el código que contiene- utilizando este nombre. Las declaraciones de función de cualquier bloque de código JavaScript se procesan antes de que se ejecute el código, y los nombres de función se vinculan a los objetos de función de todo el bloque. Decimos que las declaraciones de función se "elevan" porque es como si todas se hubieran movido a la parte superior del ámbito en el que se definen. El resultado es que el código que invoca una función puede existir en el programa antes que el código que declara la función.</p>
    <p><a href="capitulo-12#3">§12.3</a> describe un tipo especial de función conocida como <em>generador</em>. Las declaraciones de generador utilizan la palabra clave <codeinline>function</codeinline> pero van seguidas de un asterisco. En <a href="capitulo-13#3">§13.3</a> se describen las funciones asíncronas, que también se declaran con la palabra clave <codeinline>function</codeinline> pero van precedidas de la palabra clave <codeinline>async</codeinline>.</p>
  </section>
  <section id="7-3">
    <h2>5.7.3 class</h2>
    <p>En ES6 y posteriores, la declaración de <codeinline>class</codeinline> crea una nueva clase y le da un nombre que podemos utilizar para referirnos a ella. Las clases se describen en detalle en el <a href="capitulo-9">Capítulo 9</a> Una declaración de clase simple puede tener este aspecto:</p>
    <pre class="language-js">
    <code class="language-js">class Circle &lbrace;
      constructor(radius) &lbrace; this.r = radius; }
      area() &lbrace; return Math.PI * this.r * this.r; }
      circumference() &lbrace; return 2 * Math.PI * this.r; }
    }</code></pre>
    <p>A diferencia de las funciones, las declaraciones de clase no son hoisted, y no se puede utilizar una clase declarada de esta manera en el código que aparece antes de la declaración.</p>
  </section>
  <section id="7-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.7.4 import y export</h2>
    <p>Las declaraciones <codeinline>import</codeinline> y <codeinline>export</codeinline> se utilizan conjuntamente para que los valores definidos en un módulo de código JavaScript estén disponibles en otro módulo. Un módulo es un archivo de código JavaScript con su propio espacio de nombres global, completamente independiente de todos los demás módulos. La única manera de que un valor (como una función o una clase) definido en un módulo pueda utilizarse en otro módulo es que el módulo que lo define lo exporte con <codeinline>export</codeinline> y el módulo que lo utiliza lo importe con <codeinline>import</codeinline>. Los módulos son el tema del <a href="capitulo-10">Capítulo 10</a> y la <codeinline>import</codeinline> y la <codeinline>export</codeinline> se tratan en detalle en <a href="capitulo-10#3">§10.3</a>.</p>
    <p>Las directivas <codeinline>import</codeinline> se utilizan para importar uno o más valores de otro archivo de código Java-Script y asignarles nombres dentro del módulo actual. La directiva <codeinline>import</codeinline> viene de diferente forma. He aquí algunos ejemplos:</p>
    <pre class="language-js">
    <code class="language-js">import Circle from './geometry/circle.js';
    import &lbrace; PI, TAU } from './geometry/constants.js';
    import &lbrace; magnitude as hypotenuse } from './vectors/utils.js';</code></pre>
    <p>Los valores de un módulo JavaScript son privados y no pueden importarse a otros módulos a menos que se hayan exportado explícitamente. La directiva <codeinline>export</codeinline> hace esto: declara que uno o más valores definidos en el módulo actual son exportados y por lo tanto disponibles para ser importados por otros módulos. La directiva <codeinline>export</codeinline> tiene más variables que la directiva <codeinline>import</codeinline>. He aquí una de ellas:</p>
    <pre class="language-js">
    <code class="language-js">// geometry/constants.js
    const PI = Math.PI;
    const TAU = 2 * PI;
    export &lbrace; PI, TAU };</code></pre>
    <p>La palabra clave <codeinline>export</codeinline> se utiliza a veces como modificador de otras declaraciones, dando lugar a una especie de declaración compuesta que define una constante, variable, función o clase y la exporta al mismo tiempo. Y cuando un módulo exporta un único valor, suele hacerse con la forma especial <codeinline>export default</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">export const TAU = 2 * Math.PI;
    export function magnitude(x,y) &lbrace; return Math.sqrt(x*x + y*y); }
    export default class Circle &lbrace; /* class definition omitted here */ }</code></pre>
  </section>
  <section id="8" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>5.8 Resumen de las declaraciones de JavaScript</h2>
    <p>En este capítulo se ha presentado cada una de las sentencias del lenguaje JavaScript, que se resumen en la <a href="tabla5-1">Tabla 5-1</a>.</p>
    <div id="tabla5-1" class="flex flex-col items-center">
      <p><em>Tabla 5-1. Sintaxis de sentencias de JavaScript</em></p>
      <table>
        <thead class="bg-amber-900 text-[#f6e4c5]">
          <tr>
            <td class="w-24 text-center">Declaración</td>
            <td class="max-w-lg pl-4">Proposito</td>
          </tr>
        </thead>
        <tbody>
            <tr>
              <td class="w-24 pl-4">break</td>
              <td class="max-w-lg pl-4">Salir de bucle o<codeinline class="md:text-base bg-transparent">switch</codeinline>interno o de una declaración envolvente nombrada</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">case</td>
              <td class="max-w-lg pl-4">Etiqueta una sentencia dentro de un<codeinline class="md:text-base bg-transparent">switch</codeinline></td>
            </tr>
            <tr>
              <td class="w-24 pl-4">class</td>
              <td class="max-w-lg pl-4">Declara una clase</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">const</td>
              <td class="max-w-lg pl-4">Declara una o mas constantes</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">continue</td>
              <td class="max-w-lg pl-4">Empieza la siguiente iteración de un bucle interno o del bucle con nombre</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">debugger</td>
              <td class="max-w-lg pl-4">Punto de interrupción del depurador</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">default</td>
              <td class="max-w-lg pl-4">Etiqueta la sentencia por defecto dentro de un<codeinline class="md:text-base bg-transparent">switch</codeinline></td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">do/while</td>
              <td class="max-w-lg pl-4">Una alternativa al bucle<codeinline class="md:text-base bg-transparent">while</codeinline></td>
            </tr>
            <tr>
              <td class="w-24 pl-4">export</td>
              <td class="max-w-lg pl-4">Declara valores que se pueden importar en otros módulos</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">for</td>
              <td class="max-w-lg pl-4">Un bucle facil de usar</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">for/await</td>
              <td class="max-w-lg pl-4">Itera de forma asincrónica los valores de un iterador.</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">for/in</td>
              <td class="max-w-lg pl-4">Enumara los nombres de las propiedades de un objeto.</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">for/of</td>
              <td class="max-w-lg pl-4">Enumera los valores de un objeto iterable como un array</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">function</td>
              <td class="max-w-lg pl-4">Declara una función</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">if/else</td>
              <td class="max-w-lg pl-4">Ejecuta una sentencia u otra función de una condición</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">import</td>
              <td class="max-w-lg pl-4">Declara nombres para valores definidos en otros módulos</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">label</td>
              <td class="max-w-lg pl-4">Dar un nombre a una sentencia para usar con<codeinline class="md:text-base bg-transparent">break</codeinline>o<codeinline class="md:text-base bg-transparent">continue</codeinline></td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">let</td>
              <td class="max-w-lg pl-4">Declara e inicializa una o mas variables (nueva sintaxis).</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">return</td>
              <td class="max-w-lg pl-4">Devuelve un valor de una función</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">switch</td>
              <td class="max-w-lg pl-4">Bifurcación multidireccional <codeinline class="md:text-base bg-transparent">case</codeinline>o<codeinline class="md:text-base bg-transparent">default:</codeinline>etiqueta</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">throw</td>
              <td class="max-w-lg pl-4">Lanza una excepción</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">try/catch/nally</td>
              <td class="max-w-lg pl-4">Gestión de excepciones y limpieza de código</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">“use strict”</td>
              <td class="max-w-lg pl-4">Aplicar restricciones de modo estricto a script o funciones</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">var</td>
              <td class="max-w-lg pl-4">Declara e inicializa una o mas variables (antigua sintaxis).</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">while</td>
              <td class="max-w-lg pl-4">Una construcción de bucle básica</td>
            </tr>
            <tr class="bg-[#f6e4c5]">
              <td class="w-24 pl-4">with</td>
              <td class="max-w-lg pl-4">Extender la cadena de alcance (obsoleto y prohibido en modo estricto)</td>
            </tr>
            <tr>
              <td class="w-24 pl-4">yield</td>
              <td class="max-w-lg pl-4">Proporciona un valor para ser iterado; solo se utiliza en funciones generadoras</td>
            </tr>
        </tbody>
      </table>
    </div>
  </section>
</Layoutjavascript>