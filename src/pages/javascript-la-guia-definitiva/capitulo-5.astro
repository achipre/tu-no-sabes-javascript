---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-4" capSiguiente="capitulo-6" />
  <section class="fadeIn">
    <h1>Declaraciones</h1>
    <p>El <a href="capitulo-4">cap√≠tulo 4</a> describ√≠a las expresiones como frases de JavaScript. Por esa analog√≠a, las <em>expresiones</em> son frases o comandos de JavaScript. Del mismo modo que las frases en ingl√©s se terminan y separan entre s√≠ con puntos, las sentencias en JavaScript se terminan con puntos y coma (<a href="capitulo-2#6">¬ß2.6</a>). Las expresiones se <em>eval√∫an</em> para producir un valor, pero las sentencias se <em>ejecutan</em> para que ocurra algo.</p>
    <p>Una forma de "hacer que ocurra algo" es evaluar una expresi√≥n que tenga efectos secundarios. Las expresiones con efectos secundarios, como las asignaciones y las invocaciones de funciones, pueden funcionar por s√≠ solas como sentencias y, cuando se utilizan de este modo, se conocen como <em>sentencias de expresi√≥n</em>. Una categor√≠a similar de sentencias son las <em>sentencias de declaraci√≥n</em> que declaran nuevas variables y definen nuevas funciones.</p>
    <p>Los programas JavaScript no son m√°s que una secuencia de sentencias a ejecutar. Por defecto, el int√©rprete de JavaScript ejecuta estas sentencias una tras otra en el orden en que est√°n escritas. Otra forma de "hacer que algo suceda" es alterar este orden de ejecuci√≥n predeterminado, y JavaScript tiene una serie de sentencias o <em>estructuras de control</em> que hacen precisamente esto:
    </p>
    <div class="">
      <p><em>Condicionales</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>if</codeinline> y <codeinline>switch</codeinline> que hacen que el int√©rprete de JavaScript ejecute u omita otras sentencias en funci√≥n del valor de una expresi√≥n.</p>
    </div>
    <div class="">
      <p><em>Bucles</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>while</codeinline> y <codeinline>for</codeinline> que ejecutan otras sentencias de forma repetitiva</p>
    </div>
    <div class="">
      <p><em>Saltos</em></p>
      <p class="pl-2 xs:pl-3 sm:pl-4 md:pl-5 lg:pl-6">Sentencias como <codeinline>break</codeinline>, <codeinline>return</codeinline> y <codeinline>throw</codeinline> que hacen que el int√©rprete salte a otra parte del programa.</p>
    </div>
    <p>Las secciones siguientes describen las distintas sentencias de JavaScript y explican su sintaxis. La <a href="tabla5-1">Tabla 5-1</a> al final del cap√≠tulo, resume la sintaxis. Un programa JavaScript es simplemente una secuencia de sentencias, separadas entre s√≠ por punto y coma, por lo que una vez que se familiarice con las sentencias de JavaScript, podr√° empezar a escribir programas JavaScript.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>5.1 Sentencias de expresi√≥n</h2>
    <p>Los tipos m√°s simples de sentencias en JavaScript son las expresiones que tienen efectos secundarios. Este tipo de sentencia se mostr√≥ en el <a href="capitulo-4">cap√≠tulo 4</a>. Las sentencias de asignaci√≥n son una de las principales categor√≠as de sentencias de expresi√≥n. Por ejemplo:</p>
    <pre>
    <code class="language-js">greeting = "Hello " + name;
    i *= 3;</code></pre>
    <p>Los operadores de incremento y decremento, <codeinline>++</codeinline> y <codeinline>--</codeinline>, est√°n relacionados con los estados de asignaci√≥n. Tienen el efecto secundario de cambiar el valor de una variable, como si se hubiera realizado una asignaci√≥n:</p>
    <pre>
    <code class="language-js">counter++;</code></pre>
    <p>El operador <codeinline>delete</codeinline> tiene el importante efecto secundario de borrar la propiedad de un objeto. Por lo tanto, casi siempre se utiliza como una sentencia, en lugar de como parte de una expresi√≥n m√°s amplia:</p>
    <pre>
    <code class="language-js">delete o.x;</code></pre>
    <p>Las llamadas a funciones son otra categor√≠a importante de expresiones. Por ejemplo:</p>
    <pre>
    <code class="language-js">console.log(debugMessage);
    displaySpinner(); // Una hipotetica funci√≥n que muestra un spinne en la aplicaci√≥n web</code></pre>
    <p>Estas llamadas a funciones son expresiones, pero tienen efectos secundarios que afectan al entorno anfitri√≥n o al estado del programa, y se utilizan aqu√≠ como sentencias. Si una funci√≥n no tiene efectos secundarios, no tiene sentido llamarla, a menos que forme parte de una expresi√≥n mayor o de una sentencia de asignaci√≥n. Por ejemplo, no calcular√≠as un coseno y descartar√≠as el resultado:</p>
    <pre>
    <code class="language-js">Math.cos(x);</code></pre>
    <p>Pero bien podr√≠a calcular el valor y asignarlo a una variable para su uso futuro:</p>
    <pre>
    <code class="language-js">cx = Math.cos(x);</code></pre>
    <p>Observe que cada l√≠nea de c√≥digo de estos ejemplos termina con un punto y com</p>
  </section>
  <section id="2">
    <h2>5.2 Enunciados compuestos y vac√≠os</h2>
    <p>Al igual que el operador coma (<a href="#13-7">¬ß4.13.7</a>) combina varias expresiones en una sola, un <em>bloque de sentencias</em> combina varias sentencias en una sola <em>sentencia compuesta</em>. Un bloque de sentencias es simplemente una secuencia de sentencias encerradas entre llaves. As√≠, las siguientes l√≠neas act√∫an como una √∫nica sentencia y pueden utilizarse en cualquier lugar en el que JavaScript espere una √∫nica sentencia:</p>
    <pre>
    <code class="language-js">&lbrace;
      x = Math.PI;
      cx = Math.cos(x);
      console.log("cos(œÄ) = " + cx);
    }</code></pre>
    <p>Hay que tener en cuenta algunas cosas sobre este bloque de sentencia. En primer lugar, <em>no</em> termina con punto y coma. Las sentencias primitivas dentro del bloque terminan en punto y coma, pero el bloque en s√≠ no. En segundo lugar, las l√≠neas dentro del bloque est√°n sangradas con respecto a las llaves que las encierran. Esto es opcional, pero facilita la lectura y comprensi√≥n del c√≥digo.</p>
    <p>Del mismo modo que las expresiones suelen contener subexpresiones, muchas sentencias de JavaScript contienen sustantivos. Formalmente, la sintaxis de JavaScript suele permitir una √∫nica sentencia. Por ejemplo, la sintaxis del bucle <codeinline>while</codeinline> incluye una √∫nica sentencia que sirve como cuerpo del bucle. Utilizando un bloque de sentencias, puede colocar cualquier n√∫mero de sentencias dentro de esta √∫nica sustanciaci√≥n permitida.</p>
    <p>Una sentencia compuesta le permite utilizar varias sentencias donde la sintaxis de JavaScript espera una √∫nica sentencia. La <em>sentencia empty</em> es lo contrario: permite no incluir ninguna sentencia donde se espera una. La sentencia empty tiene el siguiente aspecto:</p>
    <pre class="language-js">
    ;</pre>
    <p>El int√©rprete de JavaScript no realiza ninguna acci√≥n cuando ejecuta una sentencia vac√≠a. La sentencia empty es √∫til ocasionalmente cuando se desea crear un bucle con un cuerpo vac√≠o. Considere el siguiente bucle <codeinline>for</codeinline> (los bucles <codeinline>for</codeinline> se tratar√°n en <a href="#4.3">¬ß5.4.3</a>):</p>
    <pre>
    <code class="language-js">// Inializa un array a
      for(let i = 0; i &lt; a.length; a[i++] = 0) ;</code></pre>
    <p>En este bucle, todo el trabajo lo realiza la expresi√≥n <codeinline>a[i++] = 0</codeinline>, y no es necesario ning√∫n cuerpo de bucle. Sin embargo, la sintaxis de JavaScript requiere una expresi√≥n como cuerpo del bucle, por lo que se utiliza una expresi√≥n vac√≠a, s√≥lo un punto y coma.</p>
    <p>Tenga en cuenta que la inclusi√≥n accidental de un punto y coma despu√©s del par√©ntesis derecho de un bucle <codeinline>for</codeinline>, un bucle <codeinline>while</codeinline> o una sentencia <codeinline>if</codeinline> puede provocar errores frustrantes dif√≠ciles de detectar. Por ejemplo, el siguiente c√≥digo probablemente no hace lo que el autor pretend√≠a:</p>
    <pre>
    <code class="language-js">if ((a === 0) || (b === 0)); // Ups..! Esta linea no hace nada
      o = null;                  // y esta linea siempre se ejecuta</code></pre>
    <p>Cuando utilice intencionadamente la sentencia empty, es una buena idea comentar su c√≥digo de forma que quede claro que lo hace a prop√≥sito. Por ejemplo:</p>
    <pre>
    <code class="language-js">for(let i = 0; i &lt; a.length; a[i++] = 0) /* vacio */ ;</code></pre>
  </section>
  <section id="3" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3 Condicionales</h2>
    <p>Las sentencias condicionales ejecutan u omiten otras sentencias en funci√≥n del valor de una expresi√≥n especificada. Estas sentencias son los puntos de decisi√≥n de su c√≥digo, y tambi√©n se conocen a veces como "ramas". Si imagina un int√©rprete de JavaScript siguiendo un camino a trav√©s de su c√≥digo, las sentencias condicionales son los lugares donde el c√≥digo se bifurca en dos o m√°s caminos y el int√©rprete debe elegir qu√© camino seguir.</p>
    <p>Las siguientes subsecciones explican la condicional b√°sica de JavaScript, el estado <codeinline>if/else</codeinline>, y tambi√©n cubren <codeinline>switch</codeinline>, una sentencia de bifurcaci√≥n multidireccional m√°s complicada.</p>
  </section>
  <section id="3-1">
    <h2>5.3.1 If</h2>
    <p>La sentencia <codeinline>if</codeinline> es la sentencia de control fundamental que permite a JavaScript tomar decisiones o, m√°s exactamente, ejecutar sentencias condicionalmente. Esta sentencia tiene dos formas. La primera es:</p>
    <pre class="language-js">
    if (expression)
      statement</pre>
    <p>En este formulario, se eval√∫a la expresi√≥n. Si el valor resultante es verdadero, se ejecuta la <em>sentencia</em>. Si la <em>expresi√≥n</em> es falsa, la <em>sentencia</em> no se ejecuta. (V√©ase <a href="capitulo-3#4">¬ß3.4</a> para una definici√≥n de los valores verdadero y falso): Por ejemplo:</p>
    <pre>
    <code class="language-js">if (usuario == null)    // Si el usuario es null o undefined
      usuario = "John Doe"; // definelo</code></pre>
    <p>O algo parecido:</p>
    <pre>
    <code class="language-js">// Si usuario es null, undefined, false, 0, "" o NaN dale un nuevo valor
    if (!usuario) usuario = "John Doe";</code></pre>
    <p>Tenga en cuenta que los par√©ntesis alrededor de la <em>expresi√≥n</em> son una parte obligatoria de la sintaxis de la sentencia <codeinline>if</codeinline>.</p>
    <p>La sintaxis de JavaScript requiere una √∫nica sentencia despu√©s de la palabra clave <codeinline>if</codeinline> y la expresi√≥n entre par√©ntesis, pero puede utilizar un bloque de sentencias para combinar varias sentencias en una sola. As√≠ que la sentencia <codeinline>if</codeinline> tambi√©n podr√≠a tener este aspecto:</p>
    <pre>
    <code class="language-js">if (!address) &lbrace;
      address = "";
      message = "Por favor ingrese su direcci√≥n de correo.";
    }</code></pre>
    <p>La segunda forma de la sentencia <codeinline>if</codeinline> introduce una cl√°usula <codeinline>else</codeinline> que se ejecuta cuando es la <em>expresi√≥n</em> es <codeinline>false</codeinline>. Su sintaxis es:</p>
    <pre class="language-js">
      if (expression)
      statement1
      else
      statement2</pre>
    <p>Esta forma de la sentencia ejecuta la <codeinline>sentencia1</codeinline> si la <em>expresi√≥n</em> es verdadera y ejecuta <codeinline>statement2</codeinline> si la <em>expresi√≥n</em> es falsa. Por ejemplo:</p>
    <pre>
    <code class="language-js">if (n === 1)
      console.log("Tines un mensaje nuevo.");
    else
      console.log(`Tienes $&lbrace;n} mensajes nuevos.`);</code></pre>
    <p>Cuando se han anidado sentencias <codeinline>if</codeinline> con cl√°usulas <codeinline>else</codeinline>, se requiere cierta precauci√≥n para asegurar que la cl√°usula <codeinline>else</codeinline> va con la sentencia <codeinline>if</codeinline> apropiada. Considere las siguientes l√≠neas:</p>
    <pre>
    <code class="language-js">i = j = 1;
    k = 2;
    if (i === j)
      if (j === k)
        console.log("i es igual a k");
    else
      console.log("i no es igual a  j"); // MAL!!</code></pre>
    <p>En este ejemplo, la sentencia <codeinline>if</codeinline> interna forma la √∫nica sentencia permitida por la sintaxis de la sentencia <codeinline>if</codeinline> externa. Desafortunadamente, no est√° claro (excepto por la pista dada por la sangr√≠a) con qu√© <codeinline>if</codeinline> va el <codeinline>else</codeinline>. Y en este ejemplo, la sangr√≠a es incorrecta, porque un int√©rprete de JavaScript interpreta el ejemplo anterior como:</p>
    <pre>
    <code class="language-js">if (i === j) &lbrace;
      if (j === k)
        console.log("i es igual k");
      else
        console.log("i no es igual j"); // UPS!
    }</code></pre>
    <p>La regla en JavaScript (como en la mayor√≠a de los lenguajes de programaci√≥n) es que, por defecto, una cl√°usula <codeinline>else</codeinline> forma parte de la sentencia <codeinline>if</codeinline> m√°s pr√≥xima. Para que este ejemplo sea menos ambiguo y m√°s f√°cil de leer, entender, mantener y depurar, debe utilizar llaves:</p>
    <pre>
    <code class="language-js">if (i === j) &lbrace;
      if (j === k) &lbrace;
        console.log("i es igual k");
      }
    } else &lbrace; // Que diferencia hace la ubicaci√≥n de las llaves!
      console.log("i no es igual a j");
    }</code></pre>
    <p>Muchos programadores acostumbran a encerrar los cuerpos de las sentencias <codeinline>if</codeinline> y <codeinline>else</codeinline> (as√≠ como otras sentencias compuestas, como los bucles <codeinline>while</codeinline>) entre llaves, incluso cuando el cuerpo consta de una sola sentencia. Si lo hace de forma sistem√°tica, puede evitar el tipo de problema que se acaba de mostrar, por lo que le aconsejo que adopte esta pr√°ctica. En este libro impreso, hago hincapi√© en mantener el c√≥digo de ejemplo verticalmente compacto, y no siempre sigo mis propios consejos al respecto.</p>
  </section>
  <section id="3-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.3.2 else if</h2>
    <p>La sentencia <codeinline>if/else</codeinline> eval√∫a una expresi√≥n y ejecuta uno o dos fragmentos de c√≥digo, en funci√≥n del resultado. Pero, ¬øqu√© ocurre cuando es necesario ejecutar uno de varios fragmentos de c√≥digo? Una forma de hacerlo es con una sentencia <codeinline>else if</codeinline>. <codeinline>else if</codeinline> no es realmente una sentencia JavaScript, sino simplemente un lenguaje de programaci√≥n de uso frecuente que resulta cuando se utilizan sentencias <codeinline>if/else</codeinline> repetidas:</p>
    <pre>
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el c√≥digo del bloque #1
    } else if (n === 2) &lbrace;
      // Ejecuta el c√≥digo del bloque #2
    } else if (n === 3) &lbrace;
      // Ejecuta el c√≥digo del bloque #3
    } else &lbrace;
      // Si todo falla, ejecuta el c√≥digo del bloque #4
    }</code></pre>
    <p>Este c√≥digo no tiene nada de especial. Es simplemente una serie de sentencias <codeinline>if</codeinline>, donde cada <codeinline>if</codeinline> siguiente es parte de la cl√°usula <codeinline>else</codeinline> de la sentencia anterior. Usar el lenguaje <codeinline>else if</codeinline> es preferible y m√°s legible que escribir estas sentencias en su forma sint√°cticamente equivalente, completamente anidada:</p>
    <pre>
    <code class="language-js">if (n === 1) &lbrace;
      // Ejecuta el c√≥digo del bloque #1
    }
    else &lbrace;
      if (n === 2) &lbrace;
        // Execute code block #2
      }
      else &lbrace;
        if (n === 3) &lbrace;
          // Ejecuta el c√≥digo del bloque #3
        }
        else &lbrace;
          // Si todo falla, ejecuta el c√≥digo del bloque #4
        }
      }
    }</code></pre>
  </section>
  <section id="3-3">
    <h2>5.3.3 switch</h2>
    <p>Una sentencia <codeinline>if</codeinline> provoca una bifurcaci√≥n en el flujo de ejecuci√≥n de un programa, y puede utilizar la expresi√≥n <codeinline>else if</codeinline> para realizar una bifurcaci√≥n multidireccional. Sin embargo, esta no es la mejor soluci√≥n cuando todas las ramas dependen del valor de la misma expresi√≥n. En este caso, es un desperdicio evaluar repetidamente esa expresi√≥n en m√∫ltiples sentencias <codeinline>if</codeinline>.</p>
    <p>La sentencia <codeinline>switch</codeinline> trata exactamente esta situaci√≥n. La palabra clave <codeinline>switch</codeinline> va seguida de una expresi√≥n entre par√©ntesis y un bloque de c√≥digo entre llaves:</p>
    <pre class="language-js">
    switch(expression) &lbrace;
      statements
    }</pre>
    <p>Sin embargo, la sintaxis completa de una sentencia <codeinline>switch</codeinline> es m√°s compleja que esto. Varias ubicaciones en el bloque de c√≥digo se etiquetan con la palabra clave <codeinline>clase</codeinline> seguida de una expresi√≥n y dos puntos. Cuando se ejecuta un <codeinline>switch</codeinline>, calcula el valor de la <em>expresi√≥n</em> y busca una etiqueta <codeinline>case</codeinline> cuya expresi√≥n se eval√∫e con el mismo valor (donde la igualdad viene determinada por el operador <codeinline>===</codeinline>). Si encuentra uno, comienza a ejecutar el bloque de c√≥digo en la sentencia etiquetada por <codeinline>case</codeinline>. Si no encuentra un <codeinline>case</codeinline> con un valor coincidente, busca una sentencia etiquetada como <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta el bloque de c√≥digo.</p>
    <p><codeinline>switch</codeinline> es una sentencia confusa de explicar; su funcionamiento queda mucho m√°s claro con un ejemplo. La siguiente sentencia <codeinline>switch</codeinline> es equivalente a las sentencias <codeinline>if/else</codeinline> repetidas mostradas en la secci√≥n anterior:</p>
    <pre>
    <code class="language-js">switch(n) &lbrace;
    case 1: // Empieza aqu√≠ si n === 1
      // Execute code block #1.
      break; // Se detiene aqu√≠
    case 2: // Empieza aqu√≠ si n === 2
      // Execute code block #2.
      break; // Se detiene aqu√≠
    case 3: // Empieza aqu√≠ si n === 3
      // Execute code block #3.
      break; // Se detiene aqu√≠
    default: // Si todo falla,
      // Ejecuta el c√≥digo del bloque #4
      break; // Se detiene aqu√≠
    }</code></pre>
    <p>Observe la palabra clave <codeinline>break</codeinline> utilizada al final de cada caso en este c√≥digo. El estado <codeinline>break</codeinline>, descrito m√°s adelante en este cap√≠tulo, hace que el int√©rprete salte al final (o "salga") de la sentencia <codeinline>switch</codeinline> y contin√∫e con la sentencia que le sigue. Las cl√°usulas <codeinline>case</codeinline> en una sentencia <codeinline>switch</codeinline> especifican s√≥lo el <em>punto de inicio</em> del c√≥digo deseado; no especifican ning√∫n punto final. En ausencia de sentencias <codeinline>break</codeinline>, una sentencia <codeinline>switch</codeinline> comienza a ejecutar su bloque de c√≥digo en la etiqueta <codeinline>case</codeinline> que coincide con la sentencia de su <em>expresi√≥n</em> y contin√∫a ejecutando sentencias hasta que llega al final del bloque. En raras ocasiones, es √∫til escribir c√≥digo como este que "pasa" de una etiqueta <codeinline>case</codeinline> a la siguiente, pero el 99% de las veces debe tener cuidado de terminar cada <codeinline>case</codeinline> con una sentencia <codeinline>break</codeinline>. (Sin embargo, cuando use <codeinline>switch</codeinline> dentro de una funci√≥n, puede usar una sentencia <codeinline>return</codeinline> en lugar de una sentencia <codeinline>break</codeinline>. Ambas sirven para terminar la sentencia <codeinline>switch</codeinline> y evitar que la ejecuci√≥n pase al siguiente <codeinline>case</codeinline>).</p>
    <p>He aqu√≠ un ejemplo m√°s realista de la sentencia <codeinline>switch</codeinline>; convierte un valor en una cadena de una forma que depende del tipo del valor:</p>
    <pre>
    <code class="language-js">function convert(x) &lbrace;
      switch(typeof x) &lbrace;
      case "number": // Convierte el n√∫mero en hexadecimal
        return x.toString(16);
      case "string": // Devuelve la cadena entre comillas
        return '"' + x + '"';
      default: // Convierte cualquier otro tipo en una cadena
        return String(x);
      }
    }</code></pre>
    <p>Observe que en los dos ejemplos anteriores, las palabras clave <codeinline>case</codeinline> van seguidas de literales num√©ricos y de cadena, respectivamente. As√≠ es como la sentencia <codeinline>switch</codeinline> se utiliza m√°s a menudo en la pr√°ctica, pero tenga en cuenta que el est√°ndar ECMAScript permite que cada <codeinline>case</codeinline> vaya seguido de una expresi√≥n arbitraria.</p>
    <p>La sentencia <codeinline>switch</codeinline> eval√∫a primero la expresi√≥n que sigue a la palabra clave <codeinline>switch</codeinline> y luego eval√∫a las expresiones <codeinline>case</codeinline>, en el orden en que aparecen, hasta encontrar un valor que coincida.<sup>1</sup> El caso coincidente se determina utilizando el operador de identidad <codeinline>===</codeinline>, no el operador de igualdad <codeinline>==</codeinline>, por lo que las expresiones deben coincidir sin ninguna conversi√≥n de tipo.</p>
    <p>Dado que no todas las expresiones <codeinline>case</codeinline> se eval√∫an cada vez que se ejecuta la sentencia <codeinline>switch</codeinline>, debe evitar el uso de expresiones <codeinline>case</codeinline> que contengan efectos secundarios como llamadas a funciones o asignaciones. Lo m√°s seguro es limitar las expresiones <codeinline>case</codeinline> a expresiones constantes.</p>
    <p>Como se explic√≥ anteriormente, si ninguna de las expresiones <codeinline>case</codeinline> coincide con la expresi√≥n <codeinline>switch</codeinline>, la sentencia <codeinline>switch</codeinline> comienza a ejecutar su cuerpo en la sentencia etiquetada <codeinline>defalut:</codeinline>. Si no hay ninguna etiqueta <codeinline>default:</codeinline>, la sentencia <codeinline>switch</codeinline> se salta todo su cuerpo. Observe que en los ejemplos mostrados, la etiqueta <codeinline>default:</codeinline> aparece al final del cuerpo de la sentencia <codeinline>switch</codeinline>, despu√©s de todas las etiquetas <codeinline>case</codeinline>. Este es un lugar l√≥gico y com√∫n para ella, pero en realidad puede aparecer en cualquier lugar dentro del cuerpo de la declaraci√≥n.</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4 Bucles (loops)</h2>
    <p>Para entender las sentencias condicionales, imaginemos que el int√©rprete de JavaScript sigue un camino ramificado a trav√©s del c√≥digo fuente. Las <em>sentencias de bucle</em> son las que doblan ese camino sobre s√≠ mismo para repetir partes del c√≥digo. JavaScript tiene cinco sentencias de bucle: <codeinline>while</codeinline>, <codeinline>do/while</codeinline>, <codeinline>for</codeinline>, <codeinline>for/of</codeinline> (y su variante <codeinline>for/await</codeinline>), y <codeinline>for/in</codeinline>. Las siguientes subsecciones explican cada una de ellas. Un uso com√∫n de los bucles es iterar sobre los elementos de un array. <a href="capitulo-7#6">¬ß7.6</a> discute este tipo de bucle en detalle y cubre los m√©todos especiales de bucle definidos por la clase Array.
    </p>
  </section>
  <section id="4-1">
    <h2>5.4.1 While</h2>
    <p>Al igual que la sentencia <codeinline>if</codeinline> es el condicional b√°sico de JavaScript, la sentencia <codeinline>while</codeinline> es el bucle b√°sico de JavaS cript. Su sintaxis es la siguiente:</p>
    <pre class="language-js">
    while (expression)
      statement</pre>
    <p>Para ejecutar una sentencia <codeinline>while</codeinline>, el int√©rprete eval√∫a primero la <em>expresi√≥n</em>. Si el valor de la expresi√≥n es falso, el int√©rprete se salta la <em>sentencia</em> que sirve de cuerpo del bucle y pasa a la siguiente sentencia del programa. Si, por el contrario, la <em>expresi√≥n</em> es verdadera, el int√©rprete ejecuta la <em>sentencia</em> y repite, saltando de nuevo al principio del bucle y evaluando de nuevo la <em>expresi√≥n</em>. Otra forma de decir esto es que el int√©rprete ejecuta la <em>sentencia</em> repetidamente <em>mientras</em> la <em>expresi√≥n</em> es verdadera. Tenga en cuenta que puede crear un bucle infinito con la sintaxis <codeinline>while(true)</codeinline>.</p>
    <p>Normalmente, no se desea que JavaScript realice exactamente la misma operaci√≥n una y otra vez. En casi todos los bucles, una o m√°s variables cambian con cada <em>iteraci√≥n</em> del bucle. Dado que las variables cambian, las acciones realizadas al ejecutar la <em>sentencia</em> pueden diferir cada vez que se repite el bucle. Adem√°s, si la variable o variables que cambian est√°n involucradas en una <em>expresi√≥n</em>, el valor de la expresi√≥n puede ser diferente cada vez que se repite el bucle. Esto es importante; de lo contrario, una expresi√≥n que comienza siendo verdadera nunca cambiar√≠a, ¬°y el bucle nunca terminar√≠a! He aqu√≠ un ejemplo de un bucle <codeinline>while</codeinline> que imprime los n√∫meros del 0 al 9:</p>
    <pre>
    <code class="language-js">let count = 0;
    while(count &lt; 10) &lbrace;
      console.log(count);
      count++;
    }</code></pre>
    <p>Como puedes ver, la variable <codeinline>count</codeinline> empieza en 0 y se incrementa cada vez que se ejecuta el cuerpo del bucle. Una vez que el bucle se ha ejecutado 10 veces, la expresi√≥n se convierte en <codeinline>false</codeinline> (es decir, la variable <codeinline>count</codeinline> ya no es inferior a 10), la sentencia <codeinline>while</codeinline> finaliza y el int√©rprete puede pasar a la siguiente sentencia del programa. Muchos bucles tienen una variable contador como <codeinline>count</codeinline>. Los nombres de variables <codeinline>i</codeinline>, <codeinline>j</codeinline>, y <codeinline>k</codeinline> se usan com√∫nmente como contadores de bucle, aunque deber√≠a usar nombres m√°s descriptivossihacequesuc√≥digo sea m√°sf√°cildeentender.</p>
  </section>
  <section id="4-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.2 Do/While</h2>
    <p>El bucle <codeinline>do/while</codeinline> es como un bucle <codeinline>while</codeinline>, salvo que la expresi√≥n del bucle se comprueba al final del bucle en lugar de al principio. Esto significa que el cuerpo del bucle siempre se ejecuta al menos una vez. La sintaxis es:</p>
    <pre class="language-js">
    do
      statement
    while (expression);</pre>
    <p>El bucle <codeinline>do/while</codeinline> es menos com√∫nmente usado que su primo <codeinline>while</codeinline> en la pr√°ctica, es algo poco com√∫n estar seguro de que quieres que un bucle se ejecute al menos una vez. Aqu√≠ hay un ejemplo de un bucle <codeinline>do/while</codeinline>:</p>
    <pre>
    <code class="language-js">function printArray(a) &lbrace;
      let len = a.length, i = 0;
      if (len === 0) &lbrace;
        console.log("Empty Array");
      } else &lbrace;
        do &lbrace;
          console.log(a[i]);
        } while(++i &lt; len);
      }
    }</code></pre>
    <p>Hay un par de diferencias sint√°cticas entre el bucle <codeinline>do/while</codeinline> y el bucle <codeinline>while</codeinline> ordinario. En primer lugar, el bucle <codeinline>do</codeinline> requiere tanto la palabra clave <codeinline>do</codeinline> (para marcar el inicio del bucle) como la palabra clave <codeinline>while</codeinline> (para marcar el final e introducir la condici√≥n del bucle). Adem√°s, el bucle <codeinline>do</codeinline> debe terminar siempre con punto y coma. El bucle <codeinline>while</codeinline> no necesita punto y coma si el cuerpo del bucle est√° encerrado entre llaves.</p>
  </section>
  <section id="4-3">
    <h2>5.4.3 for</h2>
    <p>La sentencia <codeinline>for</codeinline> proporciona una construcci√≥n de bucle que a menudo es m√°s conveniente que la sentencia <codeinline>while</codeinline>. La sentencia <codeinline>for</codeinline> simplifica los bucles que siguen un patr√≥n com√∫n. La mayor√≠a de los bucles tienen una variable contadora de alg√∫n tipo. Esta variable se inicializa antes de que comience el bucle y se comprueba antes de cada iteraci√≥n del bucle. Finalmente, la variable contador se incrementa o se actualiza al final del bucle, justo antes de que la variable se compruebe de nuevo. En este tipo de bucle, la inicializaci√≥n, la prueba y la actualizaci√≥n son las tres manipulaciones cruciales de una variable de bucle. La sentencia <codeinline>for</codeinline> codifica cada una de estas tres manipulaciones como una expresi√≥n y las convierte en parte expl√≠cita de la sintaxis del bucle:r</p>
    <pre class="language-js">
    for(initialize ; test ; increment)
      statement</pre>
    <p><em>inicializar</em>, <em>probar</em> e <em>incrementar</em> son tres expresiones (separadas por punto y coma) que son responsables de inicializar, probar e incrementar la variable del bucle. Ponerlas todas en la primera l√≠nea del bucle facilita la comprensi√≥n de lo que est√° haciendo un bucle <codeinline>for</codeinline> y evita errores como olvidar inicializar o incrementar la variable del bucle.</p>
    <p>La forma m√°s sencilla de explicar c√≥mo funciona un bucle <codeinline>for</codeinline> es mostrar el <codeinline>while</codeinline> equivalente bucle:<sup>2</sup></p>
    <pre class="language-js">
    initialize;
    while(test) &lbrace;
      statement
      increment;
    }</pre>
    <p>En otras palabras, la expresi√≥n <em>inicializar</em> se eval√∫a una vez, antes de que comience el bucle. Para ser √∫til, esta expresi√≥n debe tener efectos secundarios (normalmente una asignaci√≥n). JavaScript tambi√©n permite que <em>initialize</em> sea una sentencia de declaraci√≥n de variable, de modo que se puede declarar e inicializar un contador de bucle al mismo tiempo. La expresi√≥n <em>test</em> se eval√∫a antes de cada iteraci√≥n y controla si se ejecuta el cuerpo del bucle. Si el valor de <em>test</em> es verdadero, se ejecuta la <em>sentencia</em> que constituye el cuerpo del bucle. Por √∫ltimo, se eval√∫a la em de <em>incremento</em>. De nuevo, debe ser una expresi√≥n con efectos secundarios para ser √∫til. Generalmente, es una expresi√≥n de asignaci√≥n, o utiliza los operadores <codeinline>++</codeinline> o <codeinline>--</codeinline>.</p>
    <p>Podemos imprimir los n√∫meros del 0 al 9 con un bucle <codeinline>for</codeinline> como el siguiente. Contr√°stalo con el bucle <codeinline>while</codeinline> equivalente mostrado en la secci√≥n anterior:</p>
    <pre>
    <code class="language-js">for(let count = 0; count &lt; 10; count++) &lbrace;
      console.log(count);
    }</code></pre>
    <p>Los bucles pueden llegar a ser mucho m√°s complejos que este sencillo ejemplo, por supuesto, y a veces m√∫ltiples variables cambian con cada iteraci√≥n del bucle. Esta situaci√≥n es el √∫nico lugar donde el operador coma se utiliza com√∫nmente en JavaScript; proporciona una manera de combinar m√∫ltiples expresiones de inicializaci√≥n e incremento en una sola expresi√≥n adecuada para su uso en un bucle <codeinline>for</codeinline>:</p>
    <pre>
    <code class="language-js">let i, j, sum = 0;
      for(i = 0, j = 10 ; i &lt; 10 ; i++, j--) &lbrace;
      sum += i * j;
    }</code></pre>
    <p>En todos nuestros ejemplos de bucles hasta ahora, la variable del bucle ha sido num√©rica. Esto es bastante com√∫n, pero no es necesario. El siguiente c√≥digo utiliza un bucle <codeinline>for</codeinline> para recorrer una estructura de datos de lista enlazada y devolver el √∫ltimo objeto de la lista (es decir, el primer objeto que no tiene una propiedad <codeinline>next</codeinline>):</p>
    <pre>
    <code class="language-js">function tail(o) &lbrace; // Devuelve la ultima de la lista enlazada
      for(; o.next; o = o.next) /* empty */ ; // Recorre mientras o.next sea verdadero
      return o;
    }</code></pre>
    <p>Observe que este c√≥digo no tiene ninguna expresi√≥n de <em>inicializaci√≥n</em>. Cualquiera de las tres expresiones puede omitirse en un bucle <codeinline>for</codeinline>, pero los dos puntos y coma son obligatorios. Si omite la expresi√≥n de <em>prueba</em>, el bucle se repite para siempre, y <codeinline>for(;;)</codeinline> es otra forma de escribir un bucle infinito, como <codeinline>while(true)</codeinline>.</p>
  </section>
  <section id="4-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.4.4 for/of</h2>
    <p>ES6 define una nueva sentencia de bucle: <codeinline>for/of</codeinline>. Este nuevo tipo de bucle utiliza la palabra clave <codeinline>for</codeinline>, pero es un tipo de bucle completamente diferente del bucle <codeinline>for</codeinline> normal. (Tambi√©n es completamente diferente del antiguo bucle <codeinline>for/in</codeinline> que describiremos en <a href="capitulo-5#4-5">¬ß5.4.5</a>.)</p>
    <p>El bucle <codeinline>for/of</codeinline> funciona con objetos <em>iterables</em>. Explicaremos exactamente qu√© significa que un objeto sea iterable en el <a href="capitulo-12">Cap√≠tulo 12</a>, pero para este cap√≠tulo, es suficiente saber que los arrays, cadenas, conjuntos y mapas son iterables: representan una secuencia o conjunto de elementos que puedes recorrer usando un bucle <codeinline>for/of</codeinline>.</p>
    <p>Aqu√≠, por ejemplo, podemos utilizar <codeinline>for/of</codeinline> para recorrer los elementos de una matriz de n√∫meros y calcular su suma:</p>
    <pre>
    <code class="language-js">let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
    for(let element of data) &lbrace;
      sum += element;
    }
    sum // => 45</code></pre>
    <p>Superficialmente, la sintaxis se parece a la de un bucle <codeinline>for</codeinline> normal: la palabra clave <codeinline>for</codeinline> va seguida de par√©ntesis que contienen detalles sobre lo que debe hacer el bucle. En este caso, los par√©ntesis contienen una declaraci√≥n de variable (o, para variables que ya han sido declaradas, simplemente el nombre de la variable) seguida por la palabra clave <codeinline>of</codeinline> y una expresi√≥n que eval√∫a a un objeto iterable, como el array de <codeinline>date</codeinline> en este caso. Como con todos los bucles, el cuerpo de un bucle <codeinline>for/of</codeinline> sigue a los par√©ntesis, normalmente entre llaves.</p>
    <p>En el c√≥digo que se acaba de mostrar, el cuerpo del bucle se ejecuta una vez por cada elemento de la matriz de <codeinline>data</codeinline>. Antes de cada ejecuci√≥n del cuerpo del bucle, el siguiente elemento de la matriz se asigna a la variable element. Los elementos del array se iteran en orden del primero al √∫ltimo.</p>
    <p>Los arrays se iteran "en vivo"-los cambios realizados durante la iteraci√≥n pueden afectar al resultado de la misma. Si modificamos el c√≥digo anterior a√±adiendo la l√≠nea <codeinline>data.push(sum);</codeinline> dentro del cuerpo del bucle, entonces creamos un bucle infinito porque la iteraci√≥n nunca puede alcanzar el √∫ltimo elemento del array.</p>
    <p class="title-article text-left">for/of con objectos</p>
    <p>Los objetos no son iterables (por defecto). El intento de utilizar <codeinline>for/of</codeinline> en un objeto normal produce un TypeError en tiempo de ejecuci√≥n:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    for(let element of o) &lbrace; // Throws TypeError porque o no es iterable
      console.log(element);
    }</code></pre>
    <p>Si quieres iterar a trav√©s de las propiedades de un objeto, puedes utilizar el bucle <codeinline>for/in</codeinline> (introducido en <a href="capitulo-5#4-5">¬ß5.4.5</a>), o utilizar <codeinline>for/of</codeinline> con el m√©todo <codeinline>Object.keys()</codeinline>:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let keys = "";
    for(let k of Object.keys(o)) &lbrace;
      keys += k;
    }
    keys // => "xyz"</code></pre>
    <p>Esto funciona porque <codeinline>Object.keys()</codeinline> devuelve un array de nombres de propiedades de un objeto, y los arrays son iterables con <codeinline>for/of</codeinline>. Tenga en cuenta tambi√©n que esta iteraci√≥n de las claves de un objeto no es en vivo como en el ejemplo de la matriz anterior - los cambios en el objeto o realizados en el cuerpo del bucle no tendr√°n ning√∫n efecto sobre la iteraci√≥n. Si no te importan las claves de un objeto, tambi√©n puedes iterar a trav√©s de sus valores correspondientes as√≠:</p>
    <pre>
    <code class="language-js">let sum = 0;
    for(let v of Object.values(o)) &lbrace;
      sum += v;
    }
    sum // => 6</code></pre>
    <p>Y si est√° interesado tanto en las claves como en los valores de las propiedades de un objeto, puede utilizar <codeinline>for/of</codeinline> con <codeinline>Object.entries()</codeinline> y la asignaci√≥n de desestructuraci√≥n:</p>
    <pre>
    <code class="language-js">let pairs = "";
    for(let [k, v] of Object.entries(o)) &lbrace;
      pairs += k + v;
    }
    pairs // => "x1y2z3"</code></pre>
    <p><codeinline>Object.entries()</codeinline> devuelve una matriz de matrices, donde cada matriz interna representa un par clave/valor para una propiedad del objeto. En este ejemplo de c√≥digo utilizamos la asignaci√≥n de desestructuraci√≥n para descomponer esas matrices internas en dos variables individuales.</p>
    <p class="title-article text-left">for/of con strings</p>
    <p>Las cadenas son iterables car√°cter a car√°cter en ES6:</p>
    <pre>
    <code class="language-js">let frequency = &lbrace;};
    for(let letter of "mississippi") &lbrace;
      if (frequency[letter]) &lbrace;
        frequency[letter]++;
      } else &lbrace;
        frequency[letter] = 1;
      }
    }
    frequency // => &lbrace;m: 1, i: 4, s: 4, p: 2}</code></pre>
    <p>Tenga en cuenta que las cadenas se iteran por punto de c√≥digo Unicode, no por car√°cter UTF-16. La cadena "I ‚ù§ üê∂" tiene una <codeinline>.length</codeinline> de 5 (porque cada uno de los dos caracteres emoji requiere dos caracteres UTF-16 para representarse). Pero si iteras esa cadena con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecutar√° tres veces, una por cada uno de los tres puntos de c√≥digo "I", "‚ù§" y "üê∂."</p>
    <p class="title-article text-left">for/of con Set y Map</p>
    <p>Las clases incorporadas Set y Map de ES6 son iterables. Cuando iteras un Set con <codeinline>for/of</codeinline>, el cuerpo del bucle se ejecuta una vez por cada elemento del set. Puede utilizar c√≥digo como √©ste para imprimir las palabras √∫nicas en una cadena de texto:</p>
    <pre>
    <code class="language-js">let text = "Na na na na na na na na Batman!";
    let wordSet = new Set(text.split(" "));
    let unique = [];
    for(let word of wordSet) &lbrace;
      unique.push(word);
    }
    unique // => ["Na", "na", "Batman!"]</code></pre>
    <p>Los Mapas son un caso interesante porque el iterador de un objeto Mapa no itera las claves del Mapa, ni los valores del Mapa, sino pares clave/valor. En cada iteraci√≥n, el iterador devuelve un array cuyo primer elemento es una clave y cuyo segundo elemento es el valor correspondiente. Dado un Map <codeinline>m</codeinline>, podr√≠as iterar y desestructurar sus pares clave/valor as√≠:</p>
    <pre>
    <code class="language-js">let m = new Map([[1, "one"]]);
    for(let [key, value] of m) &lbrace;
      key // => 1
      value // => "one"
    }</code></pre>
    <p class="title-article text-left">Iteraci√≥n as√≠ncrona con for/await</p>
    <p>ES2018 introduce un nuevo tipo de iterador, conocido como <em>iterador as√≠ncrono</em>, y una variante del bucle <codeinline>for/of</codeinline>, conocida como bucle <codeinline>for/await</codeinline>, que funciona con iteradores as√≠ncronos.</p>
    <p>Tendr√°s que leer los Cap√≠tulos <a href="capitulo-12">12</a> y <a href="capitulo-13">13</a> para entender el bucle <codeinline>for/await</codeinline>, pero aqu√≠ tienes c√≥mo se ve en c√≥digo:</p>
    <pre>
    <code class="language-js">// Leer trozos de un flujo iterable asincrono e imprimirlos
    async function printStream(stream) &lbrace;
      for await (let chunk of stream) &lbrace;
        console.log(chunk);
      }
    }</code></pre>
  </section>
  <section id="4-5">
    <h2>5.4.5 for/in</h2>
    <p>Un bucle <codeinline>for/in</codeinline> se parece mucho a un bucle <codeinline>for/of</codeinline>, con la palabra clave <codeinline>of</codeinline> cambiada por <codeinline>in</codeinline>. Mientras que un bucle <codeinline>for/of</codeinline> requiere un objeto iterable despu√©s de <codeinline>of</codeinline>, un bucle <codeinline>for/in</codeinline> funciona con cualquier objeto despu√©s de <codeinline>in</codeinline>. El bucle <codeinline>for/of</codeinline> es nuevo en ES6, pero <codeinline>for/in</codeinline> ha formado parte de JavaScript desde el principio (por eso tiene una sintaxis m√°s natural).</p>
    <p>La sentencia <codeinline>for/in</codeinline> recorre en bucle los nombres de las propiedades de un objeto especificado. La sintaxis es la siguiente:</p>
    <pre class="language-js">
    for (variable in object)
      statement</pre>
    <p><em>variable</em> normalmente nombra una variable, pero puede ser una declaraci√≥n de variable o cualquier cosa adecuada como el lado izquierdo de una expresi√≥n de asignaci√≥n. <em>object</em> es una expresi√≥n que se eval√∫a a un objeto. Como de costumbre, <em>statement</em> es la sentencia o bloque de sentencias que sirve como cuerpo del bucle.</p>
    <p>Y podr√≠as usar un bucle <codeinline>for/in</codeinline> como este:</p>
    <pre>
    <code class="language-js">for(let p in o) &lbrace; // Asigna los nombres de las propiedades de o a la variable p
      console.log(o[p]); // Imprime el valor de cada propiedad
    }</code></pre>
    <p>Para ejecutar una sentencia <codeinline>for/in</codeinline>, el int√©rprete de JavaScript eval√∫a primero la expresi√≥n del <em>objeto</em>. Si es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>, el int√©rprete omite el bucle y pasa a la siguiente sentencia. El int√©rprete ejecuta ahora el cuerpo del bucle una vez por cada propiedad enumerable del objeto. Antes de cada iteraci√≥n, sin embargo, el int√©rprete eval√∫a la expresi√≥n de la <em>variable</em> y le asigna el nombre de la propiedad (un valor de cadena).</p>
    <p>Tenga en cuenta que la <em>variable</em> en el bucle <codeinline>for/in</codeinline> puede ser una expresi√≥n arbitraria, siempre y cuando se eval√∫e a algo adecuado para el lado izquierdo de una asignaci√≥n. Esta expresi√≥n es se eval√∫a cada vez que se pasa por el bucle, lo que significa que puede evaluarse de forma diferente cada vez. Por ejemplo, puede utilizar c√≥digo como el siguiente para copiar los nombres de todas las propiedades del objeto en un array:</p>
    <pre>
    <code class="language-js">let o = &lbrace; x: 1, y: 2, z: 3 };
    let a = [], i = 0;
    for(a[i++] in o) /* empty */;</code></pre>
    <p>Las matrices de JavaScript son simplemente un tipo especializado de objeto, y los √≠ndices de las matrices son propiedades de los objetos que pueden enumerarse con un bucle <codeinline>for/in</codeinline>. Por ejemplo, siguiendo el c√≥digo anterior con esta l√≠nea se enumeran los √≠ndices 0, 1 y 2 del array:</p>
    <pre>
    <code class="language-js">for(let i in a) console.log(i);</code></pre>
    <p>Encuentro que una fuente com√∫n de errores en mi propio c√≥digo es el uso accidental de <codeinline>for/in</codeinline> con arrays cuando quer√≠a usar <codeinline>for/of</codeinline>. Cuando se trabaja con matrices, casi siempre es mejor usar <codeinline>for/of</codeinline> en lugar de <codeinline>for/in</codeinline>.</p>
    <p>El bucle <codeinline>for/in</codeinline> no enumera todas las propiedades de un objeto. No enumera las propiedades cuyos nombres son s√≠mbolos. Y de las propiedades cuyos nombres son cadenas, s√≥lo hace un bucle sobre las propiedades <em>enumerables</em> (v√©ase <a href="capitulo-6#14-1">¬ß14.1</a>). Los diversos m√©todos incorporados definidos por el n√∫cleo de JavaScript no son enumerables. Todos los objetos tienen un m√©todo <codeinline>toString()</codeinline>, por ejemplo, pero el bucle <codeinline>for/in</codeinline> no enumera esta propiedad <codeinline>toString()</codeinline>. Adem√°s de los m√©todos incorporados, muchas otras propiedades de los objetos incorporados no son enumerables. Todas las propiedades y m√©todos definidos por su c√≥digo son enumerables, por defecto. (Puede hacerlos no enumerables utilizando t√©cnicas explicadas en <a href="capitulo-6#14-1">¬ß14.1</a>.)</p>
    <p>Las propiedades heredadas enumerables (v√©ase <a href="capitulo-6#3-2">¬ß6.3.2</a>) tambi√©n son enumeradas por el bucle <codeinline>for/in</codeinline>. Esto significa que si utilizas bucles <codeinline>for/in</codeinline> y tambi√©n utilizas c√≥digo que define propiedades que son heredadas por todos los objetos, entonces tu bucle puede no comportarse de la manera que esperas. Por esta raz√≥n, muchos programadores prefieren utilizar un bucle <codeinline>for/of</codeinline> con <codeinline>Object.keys()</codeinline> en lugar de un bucle <codeinline>for/in</codeinline>.</p>
    <p>Si el cuerpo de un bucle <codeinline>for/in</codeinline> borra una propiedad que a√∫n no ha sido enumerada, esa propiedad no ser√° enumerada. Si el cuerpo del bucle define nuevas propiedades en el objeto, esas propiedades pueden o no ser enumeradas. V√©ase <a href="capitulo-6#6-1">¬ß6.6.1</a> para m√°s informaci√≥n sobre el orden en que <codeinline>for/in</codeinline> enumera las propiedades de un objeto.</p>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5 Jumps</h2>
    <p>Otra categor√≠a de sentencias JavaScript son las <em>sentencias jump</em>. Como su nombre indica, hacen que el int√©rprete de JavaScript salte a una nueva ubicaci√≥n en el c√≥digo fuente. La sentencia <codeinline>break</codeinline> hace que el int√©rprete salte al final de un bucle u otro estado. <codeinline>continue</codeinline> hace que el int√©rprete se salte el resto del cuerpo de un bucle y vuelva al principio de un bucle para comenzar una nueva iteraci√≥n. JavaScript permite que las sentencias con nombre o <em>etiqueta</em>, y <codeinline>break</codeinline> y <codeinline>continue</codeinline> pueden identificar el bucle de destino u otra etiqueta de estado.</p>
    <p>La sentencia <codeinline>return</codeinline> hace que el int√©rprete salte desde la invocaci√≥n de una funci√≥n de vuelta al c√≥digo que la invoc√≥ y tambi√©n proporciona el valor de la invocaci√≥n. La sentencia <codeinline>throw</codeinline> es una especie de retorno provisional de una funci√≥n generadora. La sentencia <codeinline>throw</codeinline> levanta, o <em>lanza</em>, una excepci√≥n y est√° dise√±ada para trabajar con la sentencia <codeinline>try/catch/finally</codeinline>, que establece un bloque de c√≥digo de gesti√≥n de excepciones. Se trata de un tipo de sentencia de salto: cuando se lanza una excepci√≥n, el int√©rprete salta al manejador de excepciones m√°s cercano, que puede estar en la misma funci√≥n o m√°s arriba en la pila de llamadas de una funci√≥n invocadora.</p>
    <p>Los detalles sobre cada una de estas declaraciones de salto se encuentran en las secciones siguientes.</p>
  </section>
  <section id="5-1">
    <h2>5.5.1 Declaraciones etiquetadas</h2>
    <p>Cualquier declaraci√≥n puede <em>etiquetarse</em> precedi√©ndola de un identificador y dos puntos:</p>
    <pre class="language-js">
    identificador: declaraci√≥n</pre>
    <p>Al etiquetar una sentencia, le da un nombre que puede utilizar para referirse a ella en cualquier parte de su programa. Puede etiquetar cualquier sentencia, aunque s√≥lo es √∫til para etiquetar sentencias que tienen cuerpo, como bucles y condicionales. Al dar un nombre a un bucle, puede utilizar las sentencias <codeinline>break</codeinline> y <codeinline>continue</codeinline> dentro del cuerpo del bucle para salir del bucle o para saltar directamente a la parte superior del bucle para comenzar la siguiente iteraci√≥n. <codeinline>break</codeinline> y <codeinline>continue</codeinline> son las √∫nicas sentencias de JavaScript que utilizan etiquetas de sentencia; se tratan en las siguientes subsecciones. A continuaci√≥n se muestra un ejemplo de un bucle <codeinline>while</codeinline> etiquetado y una sentencia <codeinline>continue</codeinline> que utiliza la etiqueta.</p>
    <pre>
    <code class="language-js">mainloop: while(token !== null) &lbrace;
      // Codigo omitido...
      continue mainloop; // Salta a la siguiente iteraci√≥n del bucle
      // Mas codigo omitido...
    }</code></pre>
    <p>El <em>identificador</em> que se utiliza para etiquetar una sentencia puede ser cualquier identificador legal de JavaScript que no sea una palabra reservada. El espacio de nombres para etiquetas es diferente del espacio de nombres para variables y funciones, por lo que puede utilizar el mismo identificador como etiqueta de sentencia y como nombre de variable o funci√≥n. Las etiquetas de sentencia s√≥lo se definen dentro de la sentencia a la que se aplican (y dentro de sus sustituciones, por supuesto). Una sentencia no puede tener la misma etiqueta que la sentencia que la contiene, pero dos sentencias pueden tener la misma etiqueta siempre que ninguna est√© anidada dentro de la otra. Las sentencias etiquetadas pueden ser a su vez etiquetadas. Esto significa que cualquier sentencia puede tener varias etiquetas.</p>
  </section>
  <section id="5-2" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.2 break</h2>
    <p>La sentencia <codeinline>break</codeinline>, utilizada por s√≠ sola, hace que el bucle o <codeinline>switch</codeinline> que la encierra en su interior
      para salir inmediatamente. Su sintaxis es sencilla:</p>
    <pre class="language-js">
    break;</pre>
    <p>Dado que provoca la salida de un bucle o <codeinline>switch</codeinline>, esta forma de la sentencia <codeinline>break</codeinline> s√≥lo es legal si aparece dentro de una de estas sentencias.</p>
    <p>Ya ha visto ejemplos de la sentencia <codeinline>break</codeinline> dentro de una sentencia <codeinline>switch</codeinline>. En los bucles, se utiliza normalmente para salir prematuramente cuando, por cualquier raz√≥n, ya no hay necesidad de completar el bucle. Cuando un bucle tiene condiciones de terminaci√≥n complejas, a menudo es m√°s f√°cil implementar algunas de estas condiciones con sentencias <codeinline>break</codeinline> en lugar de intentar expresarlas todas en una √∫nica expresi√≥n de bucle. El siguiente c√≥digo busca un valor determinado en los elementos de una matriz. El bucle termina de forma normal cuando alcanza el final del array; termina con una sentencia <codeinline>break</codeinline> si encuentra lo que est√° buscando en el array:</p>
    <pre>
    <code class="language-js">for(let i = 0; i &lt; a.length; i++) &lbrace;
      if (a[i] === target) break;
    }</code></pre>
    <p>JavaScript tambi√©n permite que la palabra clave <codeinline>break</codeinline> vaya seguida de una etiqueta de sentencia (s√≥lo el identificador, sin dos puntos):</p>
    <pre class="language-js">
    break labelname;</pre>
    <p>Cuando se utiliza <codeinline>break</codeinline> con una etiqueta, salta al final o termina la sentencia adjunta que tiene la etiqueta especificada. Es un error de sintaxis utilizar <codeinline>break</codeinline> de esta forma si no hay una sentencia anexa con la etiqueta especificada. Con esta forma de la sentencia <codeinline>break</codeinline>, no es necesario que la sentencia nombrada sea un bucle o un <codeinline>switch:break</codeinline> puede "salir" de cualquier sentencia adjunta. Esta sentencia puede ser incluso un bloque de sentencias agrupado entre llaves con el √∫nico prop√≥sito de nombrar el bloque con una etiqueta.</p>
    <p>No se permite una nueva l√≠nea entre la palabra clave <codeinline>break</codeinline> y el nombre de la <em>etiqueta</em>. Esto se debe a que JavaScript inserta autom√°ticamente el punto y coma omitido: si se coloca un punto y coma entre la palabra clave <codeinline>break</codeinline> y la etiqueta que le sigue, JavaScript asume que se pretende utilizar la forma simple y sin etiqueta de la sentencia y trata el punto y coma como un punto y coma. (V√©ase <a href="capitulo-2#6">¬ß2.6</a>.)</p>
    <p>Necesitar√° la forma etiquetada de la sentencia <codeinline>break</codeinline> cuando desee salir de una sentencia que no sea el bucle o <codeinline>switch</codeinline> m√°s cercano. El siguiente c√≥digo lo demuestra:</p>
    <pre>
    <code class="language-js">let matrix = getData(); // Obtiene una matriz 2D de n√∫meros de alguna manera
      // Ahora suma todos los n√∫meros en la matriz.
      let sum = 0, success = false;
      // Empieza con una sentencia etiquetada que podemos salir de si ocurre un error
      computeSum: if (matrix) &lbrace;
        for(let x = 0; x &lt; matrix.length; x++) &lbrace;
          let row = matrix[x];
          if (!row) break computeSum;
          for(let y = 0; y &lt; row.length; y++) &lbrace;
            let cell = row[y];
            if (isNaN(cell)) break computeSum;
            sum += cell;
          }
        }
        success = true;
      }
      // La sentencia break salta aqu√≠. Si llegamos aqu√≠ con success == false
      // entonces hubo algo malo con la matriz que nos dieron.
      // Caso contrario sum contiene la suma de todas las celdas de la matriz</code></pre>
    <p>Por √∫ltimo, tenga en cuenta que una sentencia <codeinline>break</codeinline>, con o sin etiqueta, no puede transferir el control a trav√©s de los l√≠mites de la funci√≥n. No puede etiquetar una sentencia de definici√≥n de funci√≥n, por ejemplo, y luego utilizar esa etiqueta dentro de la funci√≥n.</p>
  </section>
  <section id="5-3">
    <h2>5.5.3 continue</h2>
    <p>La sentencia <codeinline>continue</codeinline> es similar a la sentencia <codeinline>break</codeinline>. Sin embargo, en lugar de salir de un bucle, <codeinline>continue</codeinline> lo reinicia en la siguiente iteraci√≥n. La sintaxis de la sentencia <codeinline>continue</codeinline> es tan sencilla como la de la sentencia <codeinline>break</codeinline>:</p>
    <pre class="language-js">
    continue;</pre>
    <p>La sentencia <codeinline>continue</codeinline> tambi√©n puede utilizarse con una etiqueta:</p>
    <pre class="language-js">
    continue labelname;</pre>
    <p>La sentencia <codeinline>continue</codeinline>, tanto en su forma etiquetada como sin etiquetar, s√≥lo puede utilizarse dentro del cuerpo de un bucle. Su uso en cualquier otro lugar provoca un error de sintaxis.</p>
    <p>Cuando se ejecuta la sentencia <codeinline>continue</codeinline>, finaliza la iteraci√≥n actual del bucle que lo encierra y comienza la siguiente iteraci√≥n. Esto significa cosas diferentes para los distintos tipos de bucles:</p>
    <ul>
      <li class="font-normal">En un bucle <codeinline>while</codeinline>, la <em>expresi√≥n</em> especificada al principio del bucle se comprueba de nuevo y, si es <codeinline>true</codeinline>, el cuerpo del bucle se ejecuta empezando por arriba.</li>
      <li class="font-normal">En un bucle <codeinline>do/while</codeinline>, la ejecuci√≥n salta a la parte inferior del bucle, donde la condici√≥n del bucle se comprueba de nuevo antes de reiniciar el bucle en la parte superior.</li>
      <li class="font-normal">En un bucle <codeinline>for</codeinline>, se eval√∫a la expresi√≥n de <em>incremento</em> y se vuelve a comprobar la expresi√≥n de <em>prueba</em> para determinar si debe realizarse otra iteraci√≥n.</li>
      <li class="font-normal">En un bucle <codeinline>for/of</codeinline> o <codeinline>for/in</codeinline>, el bucle comienza de nuevo con el siguiente valor iterado o el siguiente nombre de propiedad que se asigna a la variable especificada.</li>
    </ul>
    <p>Observe la diferencia en el comportamiento de la sentencia <codeinline>continue</codeinline> en los bucles <codeinline>while</codeinline> y <codeinline>for</codeinline>: un bucle <codeinline>while</codeinline> vuelve directamente a su condici√≥n, pero un bucle <codeinline>for</codeinline> eval√∫a primero su expresi√≥n de <em>incremento</em> y luego vuelve a su condici√≥n. Anteriormente, consideramos el comportamiento del bucle <codeinline>for</codeinline> en t√©rminos de un bucle <codeinline>while</codeinline> "equivalente". Sin embargo, debido a que el estado <codeinline>continue</codeinline> se comporta de forma diferente para estos dos bucles, en realidad no es posible simular perfectamente un bucle <codeinline>for</codeinline> s√≥lo con un bucle <codeinline>while</codeinline>.</p>
    <p>El siguiente ejemplo muestra una sentencia <codeinline>continue</codeinline> sin etiquetar que se utiliza para saltarse el resto de la iteraci√≥n actual de un bucle cuando se produce un error:</p>
    <pre>
    <code class="language-js">for(let i = 0; i &lt; data.length; i++) &lbrace;
      if (!data[i]) continue; // No puedo proceder son datos indefinidos
      total += data[i];
    }</code></pre>
    <p>Al igual que la sentencia <codeinline>break</codeinline>, la sentencia <codeinline>continue</codeinline> puede utilizarse en su forma etiquetada dentro de bucles anidados cuando el bucle a reiniciar no es el bucle inmediatamente adyacente. Adem√°s, al igual que con la sentencia <codeinline>break</codeinline>, no se permiten saltos de l√≠nea entre la sentencia <codeinline>continue</codeinline> y su <em>labelname</em>.</p>
  </section>
  <section id="5-4" class="py-4 xs:py-5 sm:py-6">
    <h2>5.5.4 return</h2>
    <p>Recordemos que las invocaciones a funciones son expresiones y que todas las expresiones tienen valores. Una sentencia <codeinline>return</codeinline> dentro de una funci√≥n especifica el valor de las invocaciones de esa funci√≥n. Esta es la sintaxis de la sentencia <codeinline>return</codeinline>:</p>
    <pre class="language-js">
    return expression;</pre>
    <p>Una sentencia <codeinline>return</codeinline> s√≥lo puede aparecer dentro del cuerpo de una funci√≥n. Es un error sint√°ctico que aparezca en cualquier otro lugar. Cuando se ejecuta la sentencia <codeinline>return</codeinline>, la funci√≥n que la contiene devuelve el valor de la <em>expresi√≥n</em> a su invocador. Por ejemplo:</p>
    <pre>
    <code class="language-js">function square(x) &lbrace; return x*x; } // Una funci√≥n que devuelve el cuadrado de su argumento
    square(2) // => 4</code></pre>
    <p>Sin sentencia <codeinline>return</codeinline>, una invocaci√≥n de funci√≥n simplemente ejecuta cada uno de los estados del cuerpo de la funci√≥n por turnos hasta que llega al final de la funci√≥n y entonces devuelve a su invocador. En este caso, la expresi√≥n de invocaci√≥n se eval√∫a como <codeinline>undefined</codeinline>. La sentencia <codeinline>return</codeinline> aparece a menudo como la √∫ltima sentencia de una funci√≥n, pero no tiene por qu√© ser la √∫ltima: una funci√≥n vuelve a su invocador cuando se ejecuta una sentencia <codeinline>return</codeinline>, aunque queden otras sentencias en el cuerpo de la funci√≥n.</p>
    <p>La sentencia <codeinline>return</codeinline> tambi√©n puede utilizarse sin una <em>expresi√≥n</em> para hacer que la funci√≥n devuelva <codeinline>undefined</codeinline> asuinvocador. Por ejemplo:</p>
    <pre>
    <code class="language-js">function displayObject(o) &lbrace;
      // Regresa inmediatamente si el argumento es null o undefined
      if (!o) return;
      // El resto de la funci√≥n va aqu√≠
    }</code></pre>
    <p>Debido a la inserci√≥n autom√°tica de punto y coma de JavaScript (<a href="capitulo-2#6">¬ß2.6</a>) no puede incluir un salto de l√≠nea entre la palabra clave <codeinline>return</codeinline> y la expresi√≥n que le sigue.</p>
  </section>
  <section id="5-5">
    <h2>5.5.5 yield</h2>
    <p>La sentencia <codeinline>yield</codeinline> es muy parecida a la sentencia <codeinline>return</codeinline>, pero s√≥lo se utiliza en funciones generadoras ES6 (v√©ase <a href="capitulo-12#3">¬ß12.3</a>) para producir el siguiente valor en la secuencia generada de valores sin devolverlo:</p>
    <pre>
    <code class="language-js">// Una funci√≥n generadora que produce un rango de n√∫meros
    function* range(from, to) &lbrace;
      for(let i = from; i &lt;= to; i++) &lbrace;
      yield i;
      }
    }</code></pre>
    <p>Para entender <codeinline>yield</codeinline>, debe entender los iteradores y generadores, que no se tratar√°n hasta el <a href="capitulo-12">cap√≠tulo 12</a>. Sin embargo, <codeinline>yield</codeinline> se incluye aqu√≠ para completar el tema. (T√©cnicamente, sin embargo, <codeinline>yield</codeinline> es un operador m√°s que una sentencia, como se explica en <a href="capitulo-12#4-2">¬ß12.4.2</a>.)</p>
  </section>
</Layoutjavascript>