---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-7" capSiguiente="capitulo-9" />
  <section class="fadeIn">
    <h1 class="text-right">Funciones</h1>
    <p>Este capítulo trata sobre las funciones de JavaScript. Las funciones son un bloque de construcción fundamental para los programas JavaScript y una característica común en casi todos los lenguajes de programación. Puede que ya estés familiarizado con el concepto de función bajo un nombre como <em>subrutina</em> o <em>procedimiento</em>.</p>
    <p>Una <em>función</em> es un bloque de código JavaScript que se define una vez, pero que puede ejecutarse o <em>invocarse</em> tantas veces como se desee. Las funciones JavaScript están <em>parametrizadas</em>: la definición de una función puede incluir una lista de identificadores, conocidos como <em>parámetros</em>, que funcionan como variables locales para el cuerpo de la función. Las invocaciones de funciones proporcionan valores, o <em>argumentos</em>, para los parámetros de la función. Las funciones suelen utilizar los valores de sus argumentos para calcular un <em>valor de retorno</em> que se convierte en el valor de la expresión de invocación de la función. Además de los argumentos, cada invocación tiene otro valor, el <em>contexto de invocación</em>, que es el valor de la palabra clave <codeinline>this</codeinline>.</p>
    <p>Si una función se asigna a una propiedad de un objeto, se denomina <em>método</em> de ese objeto. Cuando una función es invocada <em>sobre</em> o <em>a través</em> de un objeto, ese objeto es el contexto de invocación o el valor <codeinline>this</codeinline> para la función. Las funciones diseñadas para inicializar un objeto recién creado se llaman <em>constructores</em>. Los constructores se describieron en <a href="capitulo-6#2">§6.2</a> y se tratarán de nuevo en el <a href="capitulo-9">Capítulo 9</a>.</p>
    <p>En JavaScript, las funciones son objetos y pueden ser manipuladas por los programas. Java Script puede asignar funciones a variables y pasarlas a otras funciones, por ejemplo. Como las funciones son objetos, se les pueden asignar propiedades e incluso invocar métodos.</p>
    <p>Las definiciones de funciones JavaScript pueden anidarse dentro de otras funciones, y tienen acceso a cualquier variable que esté en el ámbito en el que se definen. Esto significa que las funciones JavaScript son <em>closures</em>, y permite importantes y potentes técnicas de programación.</p>
  </section>
  <section id="1" class="fadeIn py-4 xs:py-5 sm:py-6">
    <h2>8.1 Definición de funciones</h2>
    <p>La forma más sencilla de definir una función JavaScript es con la palabra clave <codeinline>function</codeinline>, que puede utilizarse como declaración o como expresión. ES6 define una nueva forma importante de definir funciones sin la palabra clave <codeinline>function</codeinline>: las "funciones flecha" tienen una sintaxis particularmente compacta y son útiles cuando se pasa una función como argumento a otra función. Las subsecciones siguientes cubren estas tres formas de definir funciones. Tenga en cuenta que algunos detalles de la sintaxis de definición de funciones que implican parámetros de función se posponen a <a href="#3">§8.3</a>.</p>
    <p>En los literales de objeto y en las definiciones de clase, existe una cómoda sintaxis abreviada para definir métodos. Esta sintaxis abreviada se trató en <a href="capitulo-6#10-5">§6.10.5</a> y es equivalente a utilizar una expresión de definición de función y asignarla a una propiedad de objeto utilizando la sintaxis literal de objeto básica <codeinline>name:value</codeinline>. En otro caso especial, puede utilizar las palabras clave <codeinline>get</codeinline> y <codeinline>set</codeinline> en los literales de objeto para definir métodos getter y setter de propiedades especiales. Esta sintaxis de definición de función se trató en <a href="capitulo-6#10-6">§6.10.6</a>.</p>
    <p>Tenga en cuenta que las funciones también pueden definirse con el constructor <codeinline>Function()</codeinline>, que es el tema de <a href="capitulo-8#7-7">§8.7.7</a>. Además, JavaScript define algunos tipos especializados de funciones. <codeinline>function*</codeinline> define funciones generadoras (véase el <a href="capitulo-12">Capítulo 12</a>) y <codeinline>async function</codeinline> define funciones asíncronas (véase el <a href="capitulo-13">Capítulo 13</a>).</p>
  </section>
  <section id="1-1">
    <h2>8.1.1 Declaraciones de funciones</h2>
    <p>Las declaraciones de funciones constan de la palabra clave <codeinline>function</codeinline>, seguida de estos componentes:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Identificador que da nombre a la función. El nombre es una parte obligatoria de las declaraciones de función: se utiliza como nombre de una variable, y el objeto de función recién definido se asigna a la variable.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un par de paréntesis alrededor de una lista separada por comas de cero o más identificadores. Estos identificadores son los nombres de los parámetros de la función y se comportan como variables locales dentro del cuerpo de la función.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un par de llaves con cero o más sentencias JavaScript en su interior. Estas sentencias son el cuerpo de la función: se ejecutan cada vez que se invoca la función.
        </p>
      </li>
    </ul>
    <p>He aquí algunos ejemplos de declaración de funciones:</p>
    <pre>
    <code class="language-js">// Imprime el nombre y el valor de cada propiedad de o. Retorna undefined.
    function printprops(o) &lbrace;
      for(let p in o) &lbrace;
        console.log(`$&lbrace;p}: $&lbrace;o[p]}\n`);
      }
    }

    // Calcula la distancia entre el punto (x1,y1) y el punto (x2,y2)
    function distance(x1, y1, x2, y2) &lbrace;
      let dx = x2 - x1;
      let dy = y2 - y1;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // Una función recursiva (que se llama a si misma) que calcula factoriales
    // Recordemos que x! es el producto de x por todos los números menores que x
    function factorial(x) &lbrace;
      if (x &lt;= 1) return 1;
      return x * factorial(x-1);
    }</code></pre>
    <p>Una de las cosas importantes que hay que entender sobre las declaraciones de función es que el nombre de la función se convierte en una variable cuyo valor es la propia función. Las declaraciones de función se "elevan" a la parte superior del script, función o bloque que las contiene, de modo que las funciones definidas de este modo pueden invocarse desde el código que aparece antes de la definición. Otra forma de decir esto es que todas las funciones declaradas en un bloque de código JavaScript se definirán a lo largo de ese bloque, y se definirán antes de que el intérprete de JavaScript comience a ejecutar cualquiera de los códigos de ese bloque.</p>
    <p>Las funciones <codeinline>distancia()</codeinline> y <codeinline>factorial()</codeinline> que hemos descrito están diseñadas para calcular un valor, y utilizan return para devolver ese valor a su invocador. La sentencia <codeinline>return</codeinline> hace que la función deje de ejecutarse y devuelva el valor de su expresión (si existe) a quien la llama. Si la sentencia return no tiene una expresión asociada, el valor de retorno de la función es <codeinline>undefined</codeinline>.</p>
    <p>La función <codeinline>printprops()</codeinline> es diferente: su trabajo es mostrar los nombres y valores de las propiedades de un objeto. No es necesario un valor de retorno, y la función no incluye una sentencia return. El valor de una invocación de la función <codeinline>printprops()</codeinline> es siempre <codeinline>undefined</codeinline>. Si una función no contiene una sentencia <codeinline>return</codeinline>, simplemente ejecuta cada sentencia en el cuerpo de la función hasta que llega al final, y devuelve el valor <codeinline>undefined</codeinline> a la persona que la invoca.</p>
    <p>Antes de ES6, las declaraciones de funciones sólo se permitían en el nivel superior dentro de un archivo Java-Script o dentro de otra función. Aunque algunas implementaciones se saltaban la norma, técnicamente no era legal definir funciones dentro del cuerpo de bucles, condicionales u otros bloques. Sin embargo, en el modo estricto de ES6, las declaraciones de funciones están permitidas dentro de los bloques. Una función definida dentro de un bloque sólo existe dentro de ese bloque, sin embargo, y no es visible fuera del bloque.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>8.1.2 Expresiones de función</h2>
    <p>Las expresiones de función se parecen mucho a las declaraciones de función, pero aparecen en el contexto de una expresión o sentencia más amplia, y el nombre es opcional. He aquí algunos ejemplos de expresiones de función:</p>
    <pre>
    <code class="language-js">// Esta función eleva al cuadrado su argumento.
    // Ten en cuenta que lo asignamos a una variable.
    const cuadrado = function(x) &lbrace; return x*x; };

    // La expresión de función pueden incluir nombres lo cual es útil para la recursividad.
    const f = function fact(x) &lbrace; if (x &lt;= 1) return 1; else return x*fact(x-1); };
    
    // La expresión de función también puede ser utilizada como argumento a otras funciones:
    [3,2,1].sort(function(a,b) &lbrace; return a-b; });
    
    // La expresión de función a veces se definen e invocan inmediatamente:
    let diezalcuadrado = (function(x) &lbrace;return x*x;}(10));</code></pre>
    <p>Tenga en cuenta que el nombre de la función es opcional para las funciones definidas como expresiones, y la mayoría de las expresiones de función anteriores que hemos mostrado lo omiten. En realidad, una declaración de función <em>declara</em> una variable y le asigna un objeto de función. Una expresión de función, por otro lado, no declara una variable: depende de usted asignar el objeto de función recién definido a una constante o variable si va a necesitar referirse a él varias veces. Es una buena práctica utilizar <codeinline>const</codeinline> con expresiones de función para no sobrescribir accidentalmente las funciones asignando nuevos valores.</p>
    <p>Se permite un nombre para funciones, como la función factorial, que necesitan referirse a sí mismas. Si una expresión de función incluye un nombre, el ámbito local de la función para esa función incluirá un enlace de ese nombre al objeto de función. En efecto, el nombre de la función se convierte en una variable local dentro de la función. La mayoría de las funciones definidas como expresiones no necesitan nombres, lo que hace que su definición sea más compacta (aunque no tanto como las funciones de flecha, que se describen más adelante).</p>
    <p>Hay una diferencia importante entre definir una función <codeinline>f()</codeinline> con una declaración de función y asignar una función a la variable <codeinline>f</codeinline> después de crearla como una expresión. Cuando se utiliza la forma de declaración, los objetos de función se crean antes de que el código que los contiene comience a ejecutarse, y las definiciones se elevan para que pueda llamar a estas funciones desde el código que aparece sobre la sentencia de definición. Sin embargo, esto no es cierto para las funciones definidas como expresiones: estas funciones no existen hasta que la expresión que las define se evalúa realmente. Además, para invocar una función, hay que poder referirse a ella, y no se puede referir a una función definida como expresión hasta que se asigna a una variable, por lo que las funciones definidas con expresiones no pueden invocarse antes de ser definidas.</p>
  </section>
  <section id="1-3">
    <h2>8.1.3 Funciones flecha</h2>
    <p>En ES6, puede definir funciones utilizando una sintaxis particularmente compacta conocida como "funciones de flecha". Esta sintaxis recuerda a la notación matemática y utiliza una "flecha" <codeinline>=></codeinline> para separar los parámetros de la función del cuerpo de la misma. No se utiliza la palabra clave <codeinline>function</codeinline> y, dado que las funciones en flecha son expresiones en lugar de sentencias, tampoco es necesario un nombre de función. La forma general de una función de flecha es una lista de parámetros separados por comas entre paréntesis, seguida de la flecha <codeinline>=></codeinline> y el cuerpo de la función entre llaves:</p>
    <pre>
    <code class="language-js">const sum = (x, y) => &lbrace; return x + y; };</code></pre>
    <p>Pero las funciones de flecha admiten una sintaxis aún más compacta. Si el cuerpo de la función es una única sentencia <codeinline>return</codeinline>, puede omitir la palabra clave <codeinline>return</codeinline>, el punto y coma que la acompaña y las llaves, y escribir el cuerpo de la función como la expresión cuyo valor se va a devolver:</p>
    <pre>
    <code class="language-js">const sum = (x, y) => x + y;</code></pre>
    <p>Además, si una función de flecha tiene exactamente un parámetro, puede omitir los paréntesis alrededor de la lista de parámetros:</p>
    <pre>
    <code class="language-js">const polynomial = x => x*x + 2*x + 3;</code></pre>
    <p>Tenga en cuenta, sin embargo, que una función de flecha sin argumentos debe escribirse con un par de paréntesis vacíos:</p>
    <pre>
    <code class="language-js">const constantFunc = () => 42;</code></pre>
    <p>Tenga en cuenta que, al escribir una función de flecha, no debe poner una nueva línea entre los parámetros de la función y la flecha <codeinline>=></codeinline>. De lo contrario, podría terminar con una línea como <codeinline>const polinomio = x</codeinline>, que es una sentencia de asignación sintácticamente válida por sí misma.</p>
    <p>Además, si el cuerpo de la función de flecha es una única sentencia <codeinline>return</codeinline>, pero la expresión que se devuelve es un literal de objeto, hay que poner el literal de objeto entre paréntesis para evitar la ambigüedad sintáctica entre las llaves de un cuerpo de función y las llaves de un literal de objeto:</p>
    <pre>
    <code class="language-js">const f = x => &lbrace; return &lbrace; value: x }; }; // Good: f() retorna un objeto
    const g = x => (&lbrace; value: x });           // Good: g() retorna un objeto
    const h = x => &lbrace; value: x };             // Bad: h() no retorna nada
    const i = x => &lbrace; v: x, w: x };           // Bad: Syntax Error</code></pre>
    <p>En la tercera línea de este código, la función <codeinline>h()</codeinline> es realmente ambigua: el código que pretendía ser un literal de objeto puede ser interpretado como una sentencia etiquetada, por lo que se crea una función que devuelve indefinido. En la cuarta línea, sin embargo, el literal de objeto más complicado no es una sentencia válida, y este código ilegal causa un error de sintaxis.</p>
    <p>La sintaxis concisa de las funciones de flecha las hace ideales cuando se necesita pasar una función a otra función, que es algo común de hacer con métodos de array como <codeinline>map()</codeinline>, <codeinline>filter()</codeinline>, y <codeinline>reduce()</codeinline> (ver <a href="capitulo-7#8-1">§7.8.1</a>), por ejemplo:</p>
    <pre>
    <code class="language-js">// Hacer una copia de un array con elementos nulos eliminados.
    let filtered = [1,null,2,3].filter(x => x !== null); // filtered == [1,2,3]
    // Elevar al cuadrado algunos números:
    let squares = [1,2,3,4].map(x => x*x); // squares == [1,4,9,16]</code></pre>
    <p>Las funciones flecha difieren de las funciones definidas de otras formas en un aspecto crítico: heredan el valor de la palabra clave <codeinline>this</codeinline> del entorno en el que se definen en lugar de definir su propio contexto de invocación como hacen las funciones definidas de otras formas. Esta es una característica importante y muy útil de las funciones flecha, y volveremos a ella más adelante en este capítulo. Las funciones flecha también se diferencian de otras funciones en que no tienen una propiedad <codeinline>prototype</codeinline>, lo que significa que no pueden utilizarse como funciones constructoras de nuevas clases (véase <a href="capitulo-9#2">§9.2</a>).</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.1.4 Funciones anidadas</h2>
    <p>En JavaScript, las funciones pueden estar anidadas dentro de otras funciones. Por ejemplo:</p>
    <pre>
    <code class="language-js">function hypotenuse(a, b) &lbrace;
      function square(x) &lbrace; return x*x; }
      return Math.sqrt(square(a) + square(b));
    }</code></pre>
    <p>Lo interesante de las funciones anidadas son sus reglas de alcance de variables: pueden acceder a los parámetros y variables de la función (o funciones) en la que están anidadas. En el código que se muestra aquí, por ejemplo, la función interna <codeinline>square()</codeinline> puede leer y escribir los parámetros <codeinline>a</codeinline> y <codeinline>b</codeinline> definidos por la función externa <codeinline>hypotenuse()</codeinline>. Estas reglas de ámbito para las funciones anidadas son muy importantes, y las volveremos a considerar en <a href="#6">§8.6</a>.</p>
  </section>
  <section id="2">
    <h2>8.2 Invocación de funciones</h2>
    <p>El código JavaScript que compone el cuerpo de una función no se ejecuta cuando se
      define la función, sino cuando se invoca. Las funciones JavaScript pueden invocarse
      de cinco maneras:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Como funciones
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Como métodos
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Como constructores
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Indirectamente a través de sus métodos <codeinline>call()</codeinline> y <codeinline>apply()</codeinline>
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Implícitamente, mediante funciones de
        </p>
      </li>
    </ul>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2 Invocación de funciones</h2>
    <p>Las funciones se invocan como funciones o como métodos con una expresión deinvocación (<a href="capitulo-4#5">§4.5</a>). Una expresión de invocación consiste en una expresión de funciónque se evalúa a un objeto de función seguida de un paréntesis abierto, una listaseparada por comas de cero o más expresiones de argumento y un paréntesis cerrado.Si la expresión de función es una expresión de acceso a una propiedad (si la funciónes la propiedad de un objeto o un elemento de una matriz), se trata de una expresiónde invocación a un método. Ese caso se explicará en el siguiente ejemplo. El siguientecódigo incluye una serie de expresiones regulares de invocación de funciones:</p>
    <pre>
    <code class="language-js">printprops(&lbrace;x: 1});
    let total = distance(0,0,2,1) + distance(2,1,3,5);
    let probability = factorial(5)/factorial(13);</code></pre>
    <p>En una invocación, se evalúa cada expresión del argumento (las que están entreparéntesis) y los valores resultantes se convierten en los argumentos de la función.Estos valores se asignan a los parámetros nombrados en la definición de la función.En el cuerpo de la función, una referencia a un parámetro se evalúa al valor delargumento correspondiente.</p>
    <p>Para la invocación regular de funciones, el valor de retorno de la función se convierteen el valor de la expresión de invocación. Si la función retorna porque el intérpretellega al final, el valor de retorno es <codeinline>undefined</codeinline>. Si la función retorna porque elintérprete ejecuta una sentencia <codeinline>return</codeinline>, entonces el valor de retorno es elvalor de la expresión que sigue al <codeinline>return</codeinline> o es <codeinline>undefined</codeinline> si la sentencia <codeinline>return</codeinline> no tiene valor.</p>
    <article>
      <p class="title-article">Invocación condicional</p>
      <p>En ES2020 puede insertar <codeinline>?.</codeinline> después de la expresión de la función y antes de laparéntesis abierta en una invocación de función para invocar la función sólo si no es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Es decir, la expresión <codeinline>f?.(x)</codeinline> es equivalente (suponiendo que nohaya efectos secundarios) a:</p>
    <pre>
    <code class="language-js">(f !== null && f !== undefined) ? f(x) : undefined</code></pre>
      <p>Encontrará más detalles sobre esta sintaxis de invocación condicional en <a href="capitulo-4#5-1">§4.5.1</a>.</p>
    </article>
    <p>Para la invocación de funciones en modo no estricto, el contexto de invocación (elvalor <codeinline>this</codeinline>) es el objeto global. En modo estricto, sin embargo, el contexto deinvocación es <codeinline>undefined</codeinline>. Tenga en cuenta que las funciones definidas utilizando lasintaxis de flecha se comportan de manera diferente: siempre heredan el valor <codeinline>this</codeinline> que está en vigor donde se definen.</p>
    <p>Las funciones escritas para ser invocadas como funciones (y no como métodos) nosuelen utilizar la palabra clave <codeinline>this</codeinline>. Sin embargo, esta palabra clave puede utilizarse para determinar si el modo estricto está activado:</p>
    <pre>
    <code class="language-js">// Define e invoca una función para determinar si el modo estricto está activado
    const strict = (function() &lbrace; return !this; }());</code></pre>
    <article>
      <p class="title-article">Funciones recursivas y pila</p>
      <p>Una función <em>recursiva</em> es aquella, como la función <codeinline>factorial()</codeinline> del principio de estecapítulo, que se llama a sí misma. Algunos algoritmos, como los que implicanestructuras de datos basadas en árboles, pueden implementarse de formaparticularmente elegante con funciones recursivas. Al escribir una función recursiva,sin embargo, es importante pensar en las restricciones de memoria. Cuando unafunción A llama a la función B y, a continuación, la función B llama a la función C, elintérprete de Java Script debe realizar un seguimiento de los contextos de ejecuciónde las tres funciones. Cuando la función C finaliza, el intérprete necesita saber dóndereanudar la ejecución de la función B, y cuando la función B finaliza, necesita saberdónde reanudar la ejecución de la función A. Puede imaginar estos contextos deejecución como una pila. Cuando una función llama a otra función, un nuevocontexto de ejecución es introducido en la pila. Cuando esa función retorna, sucontexto de ejecución es retirado de la pila. Si una función se llama a sí mismarecursivamente 100 veces, la pila tendrá 100 objetos introducidos en ella, y luego esos100 objetos serán retirados. Esta pila de llamadas ocupa memoria. En el hardwaremoderno, normalmente está bien escribir funciones recursivas que se llamen a símismas cientos de veces. Pero si una función se llama a sí misma diez mil veces, esprobable que falle con un error como "Maximum call-stack size exceeded".</p>
    </article>
  </section>
  <section id="2-2">
    <h2>8.2.2 Invocación de métodos</h2>
    <p>Un <em>método</em> no es más que una función JavaScript que se almacena en una propiedad de un objeto. Si tienes una función <codeinline>f</codeinline> y un objeto <codeinline>o</codeinline>, puedes definir un método llamado <codeinline>m</codeinline> de <codeinline>o</codeinline> con la siguiente línea:</p>
    <pre>
    <code class="language-js">o.m = f;</code></pre>
    <p>Una vez definido el método <codeinline>m()</codeinline> del objeto <codeinline>o</codeinline>, invócalo así:</p>
    <pre>
    <code class="language-js">o.m();</code></pre>
    <p>O, si <codeinline>m()</codeinline> espera dos argumentos, podrías invocarla así:</p>
    <pre>
    <code class="language-js">o.m(x, y);</code></pre>
    <p>El código de este ejemplo es una expresión de invocación: incluye una expresión de función <codeinline>o.m</codeinline> y dos expresiones de argumento, <codeinline>x</codeinline> e <codeinline>y</codeinline>. La expresión de función es en sí misma una expresión de acceso a propiedades, lo que significa que la función se invoca como un método y no como una función normal.</p>
    <p>Los argumentos y el valor de retorno de una invocación de método se tratan exactamente igual que en el caso de una invocación de función normal. Sin embargo, las invocaciones a métodos difieren de las invocaciones a funciones en un aspecto importante: el contexto de invocación. Las expresiones de acceso a propiedades constan de dos partes: un objeto (en este caso <codeinline>o</codeinline>) y un nombre de propiedad (<codeinline>m</codeinline>). En una expresión de invocación de método como ésta, el objeto <codeinline>o</codeinline> se convierte en el contexto de invocación, y el cuerpo de la función puede referirse a ese objeto utilizando la palabra clave <codeinline>this</codeinline>. He aquí un ejemplo concreto:</p>
    <pre>
    <code class="language-js">let calculator = &lbrace; // Un objeto literal
      operand1: 1,
      operand2: 1,
      add() &lbrace; // Estamos usando la sintaxis abreviada de métodos para esta función.
        // Notese el uso de la palabra clave this para referirse al objeto contenedor.
        this.result = this.operand1 + this.operand2;
      }
    };
    calculator.add(); // Una invocación al método para calcular 1+1.
    calculator.result // => 2</code></pre>
    <p>La mayoría de las invocaciones de métodos utilizan la notación de punto para el acceso a propiedades, pero las expresiones de acceso a propiedades que utilizan corchetes también provocan la invocación de métodos. Por ejemplo, las siguientes son invocaciones de métodos:</p>
    <pre>
    <code class="language-js">o["m"](x,y); // Otra forma de escribir a m[o](x,y).
    a[0](z)      // Tambien una invocación a un método (suponiendo que a[0] es una función).</code></pre>
    <p>Las invocaciones de métodos también pueden implicar expresiones de acceso a propiedades más complejas:</p>
    <pre>
    <code class="language-js">customer.surname.toUpperCase(); // Invoca el método en customer.surname
    f().m(); // Invoca el método m() en el retorno de f().</code></pre>
    <p>Los métodos y la palabra clave <codeinline>this</codeinline> son fundamentales en el paradigma de la programación orientada a objetos. A cualquier función que se utilice como método se le pasa un argumento implícito: el objeto a través del cual se invoca. Típicamente, un método realiza algún tipo de operación sobre ese objeto, y la sintaxis de invocación de método es una forma elegante de expresar el hecho de que una función está operando sobre un objeto. Compare las dos líneas siguientes:</p>
    <pre>
    <code class="language-js">rect.setSize(width, height);
    setRectSize(rect, width, height);</code></pre>
    <p>Las hipotéticas funciones invocadas en estas dos líneas de código pueden realizar exactamente la misma operación sobre el (hipotético) objeto <codeinline>rect</codeinline>, pero la sintaxis método-invocación de la primera línea indica más claramente la idea de que es el objeto <codeinline>rect</codeinline> el foco principal de la operación.</p>
    <article>
      <p class="title-article">Encadenamiento de métodos</p>
      <p>Cuando los métodos devuelven objetos, puede utilizar el valor de retorno de una invocación de método como parte de una invocación posterior. Esto da como resultado una serie (o "cadena") de invocaciones a métodos como una única expresión. Cuando se trabaja con operaciones asíncronas basadas en promesas (véase el <a href="capitulo-13">Capítulo 13</a>), por ejemplo, es habitual escribir código estructurado de este modo:</p>
    <pre>
    <code class="language-js">// Corre tres operaciones asíncronas. Maneja errores.
    doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);</code></pre>
      <p>Cuando escriba un método que no tenga un valor de retorno propio, considere la posibilidad de que el método devuelva <codeinline>this</codeinline>. Si hace esto de forma consistente en toda su API, habilitará un estilo de programación conocido como <em>encadenamiento de métodos</em><sup>1</sup> en el que un objeto puede nombrarse una vez y luego pueden invocarse múltiples métodos sobre él:</p>
    <pre>
    <code class="language-js">new Square().x(100).y(100).size(50).outline("red").fill("blue").draw();</code></pre>
    </article>
    <p>Tenga en cuenta que <codeinline>this</codeinline> se trata de una palabra clave, no de un nombre de variable o propiedad. La sintaxis de JavaScript no permite asignarle un valor <codeinline>this</codeinline>.</p>
    <p>La palabra clave <codeinline>this</codeinline> no tiene el mismo ámbito que las variables y, excepto en el caso de las funciones flecha, las funciones anidadas no heredan el valor <codeinline>this</codeinline> de la función que las contiene. Si una función anidada es invocada como un método, su valor <codeinline>this</codeinline> es el objeto sobre el que fue invocada. Si una función anidada (que no es una función de flecha) se invoca como una función, su valor <codeinline>this</codeinline> será el objeto global (modo no estricto) o <codeinline>undefined</codeinline> (modo estricto). Es un error común asumir que una función anidada definida dentro de un método e invocada como función puede utilizar <codeinline>this</codeinline> para obtener el contexto de invocación del método. El siguiente código demuestra el problema:</p>
    <pre>
    <code class="language-js">let o = &lbrace;            // Un objeto o.
      m: function() &lbrace;    // El método m del objeto.
        let self = this; // Guarda el valor "this" en una variable.
        this === o       // => true: "this" es un objeto o.
        f();             // Ahora llama a la función auxiliar f().

        function f() &lbrace;   // Una función anidada f
          this === o     // => false: "this" es global o undefined
          self === o     // => true: self es el valor "this" exterior.
        }
      }
    };
    o.m();               // Invoca el método m en el objeto o.</code></pre>
    <p>Dentro de la función anidada <codeinline>f()</codeinline>, la palabra clave <codeinline>this</codeinline> no es igual al objeto <codeinline>o</codeinline>. Esto es ampliamente considerado como un fallo en el lenguaje JavaScript, y es importante ser consciente de ello. El código anterior muestra una solución común. Dentro del método <codeinline>m</codeinline>, asignamos el valor <codeinline>this</codeinline> a una variable <codeinline>self</codeinline>, y dentro de la función anidada <codeinline>f</codeinline>, podemos usar <codeinline>self</codeinline> en lugar de <codeinline>this</codeinline> para referirnos al objeto contenedor.</p>
    <p>En ES6 y posteriores, otra solución a este problema es convertir la función anidada <codeinline>f</codeinline> en una función de flecha, que heredará correctamente este valor:</p>
    <pre>
    <code class="language-js">const f = () => &lbrace;
      this === o // true, ya que las funciones flechas heredan this.
    };</code></pre>
    <p>Las funciones definidas como expresiones en lugar de sentencias no son hoisted, por lo que para que este código funcione, la definición de función para <codeinline>f</codeinline> tendrá que ser movida dentro del método <codeinline>m</codeinline> para que aparezca antes de ser invocado.</p>
    <p>Otra solución consiste en invocar el método <codeinline>bind()</codeinline> de la función anidada para definir una nueva función que se invoque implícitamente sobre un objeto especificado:</p>
    <pre>
    <code class="language-js">const f = (function() &lbrace;
      this === o // true, ya que vinculamos esta función a la externa this.
    }).bind(this);</code></pre>
    <p>Hablaremos más sobre <codeinline>bind()</codeinline> en <a href="capitulo-8#7-5">§8.7.5</a>.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2.3 Invocación de constructores</h2>
    <p>Si una invocación a una función o método va precedida de la palabra clave <codeinline>new</codeinline>, se trata de una invocación a un constructor. (Las invocaciones a constructores se introdujeron en <a href="capitulo-4#6">§4.6</a> y <a href="capitulo-6#2-2">§6.2.2</a>, y los constructores se tratarán con más detalle en el <a href="capitulo-9">Capítulo 9</a>.) Las invocaciones a constructores difieren de las invocaciones a funciones y métodos en su manejo de argumentos, contexto de invocación y valor de retorno.</p>
    <p>Si una invocación a un constructor incluye una lista de argumentos entre paréntesis, esas expresiones de argumentos son evaluadas y pasadas a la función de la misma forma que lo serían para las invocaciones a funciones y métodos. No es una práctica común, pero puede omitir un par de paréntesis vacíos en una invocación a un constructor. Las dos líneas siguientes, por ejemplo, son equivalentes:</p>
    <pre>
    <code class="language-js">o = new Object();
    o = new Object;</code></pre>
    <p>Una invocación a un constructor crea un nuevo objeto vacío que hereda del objeto especificado por la propiedad <codeinline>prototype</codeinline> del constructor. Las funciones constructoras están pensadas para inicializar objetos, y este objeto recién creado se utiliza como contexto de invocación, por lo que la función constructora puede referirse a él con la palabra clave <codeinline>this</codeinline>. Tenga en cuenta que el nuevo objeto se utiliza como contexto de invocación incluso si la invocación del constructor parece una invocación a un método. Es decir, en la expresión <codeinline>new o.m()</codeinline>, o no se utiliza como contexto de invocación.</p>
    <p>Las funciones constructoras no suelen utilizar la palabra clave <codeinline>return</codeinline>. Normalmente inician el nuevo objeto y luego retornan implícitamente cuando llegan al final de su cuerpo. En este caso, el nuevo objeto es el valor de la expresión de invocación del constructor. Sin embargo, si un constructor utiliza explícitamente la sentencia <codeinline>return</codeinline> para devolver un objeto, entonces ese objeto se convierte en el valor de la expresión de invocación. Si el constructor utiliza <codeinline>return</codeinline> sin ningún valor, o si devuelve un valor primitivo, ese valor de retorno se ignora y el nuevo objeto se utiliza como valor de la invocación.</p>
  </section>
  <section id="2-4">
    <h2>8.2.4 Invocación indirecta</h2>
    <p>Las funciones JavaScript son objetos y, como todos los objetos JavaScript, tienen métodos. Dos de estos métodos, <codeinline>call()</codeinline> y <codeinline>apply()</codeinline>, invocan a la función indirectamente. Ambos métodos permiten especificar explícitamente el valor <codeinline>this</codeinline> para la invocación, lo que significa que se puede invocar cualquier función como método de cualquier objeto, aunque no sea realmente un método de ese objeto. Ambos métodos también permiten especificar los argumentos de la invocación. El método <codeinline>call()</codeinline> utiliza su propia lista de argumentos como argumentos de la función, y el método <codeinline>apply()</codeinline> espera que se utilice una matriz de valores como argumentos. Los métodos <codeinline>call()</codeinline> y <codeinline>apply()</codeinline> se describen en detalle en <a href="capitulo-8#7-4">§8.7.4</a>.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2.5 Invocación implícita de funciones</h2>
    <p>Hay varias características del lenguaje JavaScript que no parecen invocaciones de funciones pero que hacen que se invoquen funciones. Tenga mucho cuidado al escribir funciones que puedan ser invocadas implícitamente, ya que los errores, efectos secundarios y problemas de rendimiento en estas funciones son más difíciles de diagnosticar y solucionar que en las funciones normales por la sencilla razón de que puede que no sea obvio a partir de una simple inspección de su código cuándo están siendo invocadas.</p>
    <p>Las características del lenguaje que pueden causar la invocación implícita de funciones incluyen:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si un objeto tiene definidos getters o setters, entonces la consulta o el establecimiento del valor de sus propiedades puede invocar esos métodos. Para más información, véase <a href="capitulo-6#10-6">§6.10.6</a>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando un objeto se utiliza en un contexto de cadena (como cuando se concatena con una cadena), se llama a su método <codeinline>toString()</codeinline>. Del mismo modo, cuando un objeto se utiliza en un contexto numérico, se invoca a su método <codeinline>valueOf()</codeinline>. Para más detalles, véase <a href="capitulo-3#3-9">§3.9.3</a>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Cuando se realiza un bucle sobre los elementos de un objeto iterable, se producen una serie de llamadas a métodos. El <a href="capitulo-12">Capítulo 12</a> explica cómo funcionan los iteradores a nivel de llamada a funciones y demuestra cómo escribir estos métodos para que puedas definir tus propios tipos de iterables.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un literal de plantilla etiquetado es una invocación a una función disfrazada. <a href="capitulo-14#5">§14.5</a> muestra cómo escribir funciones que pueden usarse junto con cadenas de literales de plantilla.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los objetos proxy (descritos en <a href="capitulo-14#7">§14.7</a>) tienen su comportamiento completamente controlado por funciones. Casi cualquier operación sobre uno de estos objetos hará que se invoque una función.
        </p>
      </li>
    </ul>
  </section >
  <section id="3">
    <h2>8.3 Argumentos y parámetros de las funciones</h2>
    <p>Las definiciones de funciones de JavaScript no especifican un tipo esperado para los parámetros de la función, y las invocaciones de funciones no realizan ninguna comprobación de tipo en los valores de los argumentos que se pasan. De hecho, las invocaciones de funciones JavaScript ni siquiera comprueban el número de argumentos que se pasan. Las subsecciones siguientes describen lo que ocurre cuando se invoca una función con menos argumentos que los parámetros declarados o con más argumentos que los parámetros declarados. También demuestran cómo puede comprobar explícitamente el tipo de argumentos de la función si necesita asegurarse de que una función no se invoca con argumentos inadecuados.</p>
  </section>
  <section id="3-1" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.1 Parámetros opcionales y valores por defecto</h2>
    <p>Cuando se invoca una función con menos argumentos que parámetros declarados, los parámetros adicionales se fijan a su valor por defecto, que normalmente es <codeinline>undefined</codeinline>. A menudo resulta útil escribir funciones de modo que algunos argumentos sean opcionales. A continuación se ofrece un ejemplo:</p>
    <pre>
    <code class="language-js">// Añade los nombres de las enumaerable propiedades de un objeto o de
    // un array, y retorna a. Si se omite, crea y devuelve un nuevo array.
    function getPropertyNames(o, a) &lbrace;
      if (a === undefined) a = []; // Si es undefined, usa un nuevo array
      for(let property in o) a.push(property);
      return a;
    }

    // getPropertyNames() puede ser invocada con una o dos argumentos:
    let o = &lbrace;x: 1}, p = &lbrace;y: 2, z: 3}; // Dos objetos para testear
    let a = getPropertyNames(o); // a == ["x"]; Obteniendo las propiedades de o en un nuevo array
    getPropertyNames(p, a); // a == ["x","y","z"]; agrega las propiedades de p</code></pre>
    <p>En lugar de utilizar una sentencia <codeinline>if</codeinline> en la primera línea de esta función, puede utilizar el operador <codeinline>||</codeinline>. de esta forma idiomática:</p>
    <pre>
    <code class="language-js">a = a || [];</code></pre>
    <p>Recuerde de <a href="capatulo-4#10-2">§4.10.2</a> que el operador <codeinline>||</codeinline> devuelve su primer argumento si es verdadero y, en caso contrario, devuelve su segundo argumento. En este caso, si se pasa cualquier objeto como segundo argumento, la función utilizará ese objeto. Pero si el segundo argumento (o se pasa <codeinline>null</codeinline> u otro valor falso), se utilizará en su lugar una matriz vacía recién creada.</p>
    <p>Tenga en cuenta que cuando diseñe funciones con argumentos opcionales, debe asegurarse de poner los opcionales al final de la lista de argumentos para que puedan ser omitidos. El programador que llame a tu función no puede omitir el primer argumento y pasar el segundo: tendría que pasar explícitamente <codeinline>undefined</codeinline> como primer argumento.</p>
    <p>En ES6 y posteriores, puede definir un valor predeterminado para cada uno de los parámetros de la función directamente en la lista de parámetros de la función. Sólo tiene que seguir el nombre del parámetro con un signo igual y el valor por defecto a utilizar cuando no se proporciona ningún argumento para ese parámetro:</p>
    <pre>
    <code class="language-js">// Añade los nombres de las propiedades enumerables del objeto o al
    // array a, y retorna a. Si a es omitido, crea y devuelve un nuevo array.
    function getPropertyNames(o, a = []) &lbrace;
      for(let property in o) a.push(property);
      return a;
    }</code></pre>
    <p>Las expresiones de parámetros por defecto se evalúan cuando se llama a la función, no cuando se define, por lo que cada vez que se invoca a esta función <codeinline>getPropertyNames()</codeinline> con un argumento, se crea y se pasa una nueva matriz vacía.<sup>2</sup> Probablemente sea más fácil razonar sobre las funciones si los parámetros por defecto son constantes (o expresiones literales como <codeinline>[]</codeinline> y <codeinline>&lbrace;}</codeinline>). Pero esto no es necesario: puede utilizar variables, o invocaciones de funciones, por ejemplo, para calcular el valor por defecto de un parámetro. Un caso interesante es que, para funciones con múltiples parámetros, puede utilizar el valor de un parámetro anterior para definir el valor por defecto de los parámetros que le siguen:</p>
    <pre>
    <code class="language-js">// Esta funcion retorna un objeto que resenta las dimensiones de un rectangulo.
    // Si solo se proporciona un ancho, hazlo el doble de alto que de ancho.
    const rectangle = (width, height=width*2) => (&lbrace;width, height});
    rectangle(1) // => &lbrace; width: 1, height: 2 }</code></pre>
    <p>Este código demuestra que los parámetros por defecto funcionan con las funciones de flecha. Lo mismo ocurre con las funciones de método abreviado y todas las demás formas de definición de funciones.</p>
  </section>
  <section id="3-2">
    <h2>8.3.2 Parámetros restantes y listas de argumentos de longitud variable</h2>
    <p>Los parámetros por defecto nos permiten escribir funciones que pueden invocarse con menos argumentos que parámetros. Los <em>parámetros Rest</em> permiten el caso contrario: nos permiten escribir funciones que pueden invocarse con un número arbitrario de argumentos superior al de parámetros. He aquí un ejemplo de función que espera uno o más argumentos numéricos y devuelve el mayor de ellos:</p>
    <pre>
    <code class="language-js">function max(first=-Infinity, ...rest) &lbrace;
      let maxValue = first; // Empieza asumuendo que el primer argumento es el mayor
      // A continuación, realice un bucle con el resto de los argumentos, buscando los mas grandes.
      for(let n of rest) &lbrace;
        if (n > maxValue) &lbrace;
          maxValue = n;
        }
      }
      // Return the biggest
      return maxValue;
    }

    max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000</code></pre>
    <p>Un parámetro restante va precedido de tres puntos y debe ser el último parámetro de una declaración de función. Cuando se invoca una función con un parámetro restante, los argumentos que se pasan se asignan primero a los parámetros no restantes y, a continuación, los argumentos restantes (es decir, el "resto" de los argumentos) se almacenan en una matriz que se convierte en el valor del parámetro restante. Este último punto es importante: dentro del cuerpo de una función, el valor de un parámetro rest siempre será una matriz. La matriz puede estar vacía, pero un parámetro rest nunca estará <codeinline>undefined</codeinline>. (De esto se deduce que nunca es útil -y no legal- definir un parámetro por defecto para un parámetro rest).</p>
    <p>Las funciones como la del ejemplo anterior que pueden aceptar cualquier número de argumentos se denominan <em>funciones variádicas</em>, <em>funciones de aridad variable</em> o <em>funciones vararg</em>. En este libro se utiliza el término más coloquial, <em>varargs</em>, que data de los primeros días del lenguaje de programación C.</p>
    <p>No confunda el operador <codeinline>...</codeinline> que define un parámetro de reposo en una definición de función con el operador de propagación <codeinline>...</codeinline>, descrito en <a href="#3-4">§8.3.4</a>, que puede utilizarse en invocaciones de funciones.</p>
  </section>
  <section id="3-3" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.3 El objeto Arguments</h2>
    <p>Los parámetros Rest se introdujeron en JavaScript en ES6. Antes de esa versión del lenguaje, las funciones varargs se escribían utilizando el objeto Arguments: dentro del cuerpo de cualquier función, el identificador <codeinline>arguments</codeinline> hace referencia al objeto Arguments para esa invocación. El objeto Arguments es un objeto tipo array (véase <a href="capitulo-7#9">§7.9</a>) que permite recuperar los valores de los argumentos pasados a la función por número, en lugar de por nombre. Aquí está la función <codeinline>max()</codeinline> de antes, reescrita para utilizar el objeto Arguments en lugar de un parámetro rest:</p>
    <pre>
    <code class="language-js">function max(x) &lbrace;
      let maxValue = -Infinity;
      // Recorre los argumentos, buscando y recuperando el mayor.
      for(let i = 0; i &lt; arguments.length; i++) &lbrace;
        if (arguments[i] > maxValue) maxValue = arguments[i];
      }
      // Devuelve el mayor
      return maxValue;
    }

    max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000</code></pre>
    <p>El objeto Arguments se remonta a los primeros días de JavaScript y conlleva un extraño bagaje histórico que lo hace ineficiente y difícil de optimizar, especialmente fuera del modo estricto. Es posible que aún encuentres código que utilice el objeto Arguments, pero deberías evitar utilizarlo en cualquier código nuevo que escribas. Al refactorizar código antiguo, si encuentra una función que utiliza <codeinline>arguments</codeinline>, a menudo puede sustituirla por un parámetro de reposo <codeinline>...args</codeinline>. Parte del desafortunado legado del objeto Arguments es que, en modo estricto, <codeinline>arguments</codeinline> se trata como una palabra reservada, y no puedes declarar un parámetro de función o una variable local con ese nombre.</p>
  </section>
  <section id="3-4">
    <h2>8.3.4 El operador Spread para llamadas a funciones</h2>
    <p>El operador de distribución <codeinline>...</codeinline> se utiliza para descomprimir, o "distribuir", los elementos de una matriz (o cualquier otro objeto iterable, como las cadenas) en un contexto en el que se esperan valores individuales. En <a href="capitulo-7#1-2">§7.1.2</a> hemos visto cómo se utiliza el operador de distribución con los literales de matrices. El operador puede utilizarse, del mismo modo, en invocaciones a funciones:</p>
    <pre>
    <code class="language-js">let numbers = [5, 2, 10, -1, 9, 100, 1];
    Math.min(...numbers) // => -1</code></pre>
    <p>Tenga en cuenta que <codeinline>...</codeinline> no es un operador verdadero en el sentido de que no puede evaluarse para producir un valor. Se trata de una sintaxis especial de JavaScript que puede utilizarse en literales de matrices e invocaciones de funciones.</p>
    <p>Cuando utilizamos la misma sintaxis <codeinline>...</codeinline> en una definición de función en lugar de una invocación de función, tiene el efecto contrario al operador spread. Como vimos en <a href="#3-2">§8.3.2</a>, el uso de <codeinline>...</codeinline> en una definición de función reúne varios argumentos de función en una matriz. Los parámetros Rest y el operador spread son a menudo útiles juntos, como en la siguiente función, que toma un argumento de función y devuelve una versión instrumentada de la función para su comprobación:</p>
    <pre>
    <code class="language-js">// Esta función toma una función y devuelve una versión envuelta
    function timed(f) &lbrace;
      return function(...args) &lbrace; // Recoge los argumentos en un array de parametros restantes
        console.log(`Introducción función $&lbrace;f.name}`);
        let startTime = Date.now();
        try &lbrace;
          // Pasar todos nuestros argumentos a la función envuelta
          return f(...args); // Vuelve a distribuir los argumentos
        }
        finally &lbrace;
          // Antes de devolver el valor, imprime el tiempo de ejecución
          console.log(`Exiting $&lbrace;f.name} after $&lbrace;Date.now()-startTime}ms`);
        }
      };
    }

    // Calcula la suma de los números entre 1 y n por fuerza bruta
    function benchmark(n) &lbrace;
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) sum += i;
    return sum;
    }

    // Ahora invoca la version temporizada de esa funcion de prueba
    timed(benchmark)(1000000) // => 500000500000; esta es la suma de los números.</code></pre>
  </section>
  <section id="3-5" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.5 Desestructuración de argumentos de función en parámetros</h2>
    <p>Cuando se invoca una función con una lista de valores de argumentos, esos valores acaban asignándose a los parámetros declarados en la definición de la función. Esta fase inicial de la invocación de funciones se parece mucho a la asignación de variables. Por tanto, no debe sorprendernos que podamos utilizar las técnicas de asignación desestructurante (véase <a href="capitulo-3#3-10">§3.10.3</a>) con las funciones.</p>
    <p>Si defines una función que tiene nombres de parámetros entre corchetes, le estás diciendo a la función que espere que se pase un valor de matriz por cada par de corchetes. Como parte del proceso de invocación, los argumentos de la matriz se descompondrán en los parámetros nombrados individualmente. Como ejemplo, supongamos que estamos representando vectores 2D como matrices de dos números, donde el primer elemento es la coordenada X y el segundo elemento es la coordenada Y. Con esta simple estructura de datos, podríamos decir a la función que espere un valor de matriz para cada par de corchetes. Con esta simple estructura de datos, podríamos escribir la siguiente función para sumar dos vectores:</p>
    <pre>
    <code class="language-js">function vectorAdd(v1, v2) &lbrace;
    return [v1[0] + v2[0], v1[1] + v2[1]];
    }
    vectorAdd([1,2], [3,4]) // => [4,6]</code></pre>
    <p>El código sería más fácil de entender si desestructuráramos los dos argumentos vectoriales en parámetros con nombres más claros:</p>
    <pre>
    <code class="language-js">function vectorAdd([x1,y1], [x2,y2]) &lbrace; // Descomprimir 2 argumentos en 4 parametros.
      return [x1 + x2, y1 + y2];
    }
    vectorAdd([1,2], [3,4]) // => [4,6]</code></pre>
    <p>Del mismo modo, si está definiendo una función que espera un argumento objeto, puede desestructurar los parámetros de ese objeto. Volvamos a utilizar un ejemplo vectorial, sólo que esta vez supongamos que representamos los vectores como objetos con parámetros <codeinline>x</codeinline> e <codeinline>y</codeinline>:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} por el valor scalar
    function vectorMultiply(&lbrace;x, y}, scalar) &lbrace;
      return &lbrace; x: x*scalar, y: y*scalar };
    }
    vectorMultiply(&lbrace;x: 1, y: 2}, 2) // => &lbrace;x: 2, y: 4 }</code></pre>
    <p>Este ejemplo de desestructuración de un único argumento de objeto en dos parámetros es bastante claro porque los nombres de los parámetros que utilizamos coinciden con los nombres de las propiedades del objeto entrante. La sintaxis es más verbosa y confusa cuando se necesita desestructurar propiedades con un nombre en parámetros con nombres diferentes. Aquí está el ejemplo de suma de vectores, implementado para vectores basados en objetos:</p>
    <pre>
    <code class="language-js">function vectorAdd(
      &lbrace;x: x1, y: y1}, // Desempaqueta el primer objeto en los parametros x1 y y1
      &lbrace;x: x2, y: y2} // Desempaqueta el segundo objeto en los parametros x2 y y2
    )
    &lbrace;
    return &lbrace; x: x1 + x2, y: y1 + y2 };
    }
    vectorAdd(&lbrace;x: 1, y: 2}, &lbrace;x: 3, y: 4}) // => &lbrace;x: 4, y: 6}</code></pre>
    <p>Lo complicado de la sintaxis de desestructuración como <codeinline>&lbrace;x:x1, y:y1}</codeinline> es recordar cuáles son los nombres de las propiedades y cuáles los de los parámetros. La regla a tener en cuenta para desestructurar asignaciones y desestructurar llamadas a funciones es que las variables o parámetros que se declaran van en los lugares donde se esperaría que fueran los valores en un literal de objeto. Así que los nombres de las propiedades siempre van a la izquierda de los dos puntos, y los nombres de los parámetros (o variables) a la derecha.</p>
    <p>Puede definir parámetros por defecto con parámetros desestructurados. He aquí una multiplicación vectorial que funciona con vectores 2D o 3D:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} o &lbrace;x,y,z} por el valor scalar
    function vectorMultiply(&lbrace;x, y, z=0}, scalar) &lbrace;
      return &lbrace; x: x*scalar, y: y*scalar, z: z*scalar };
    }
    vectorMultiply(&lbrace;x: 1, y: 2}, 2) // => &lbrace;x: 2, y: 4, z: 0}</code></pre>
    <p>Algunos lenguajes (como Python) permiten a quien llama a una función invocarla con argumentos especificados en forma <codeinline>name=value</codeinline>, lo que resulta conveniente cuando hay muchos argumentos opcionales o cuando la lista de parámetros es lo suficientemente larga como para que resulte difícil recordar el orden correcto. JavaScript no permite esto directamente, pero se puede aproximar desestructurando un argumento objeto en los parámetros de la función. Consideremos una función que copia un número especificado de elementos de una matriz en otra matriz con desplazamientos iniciales especificados opcionalmente para cada matriz. Puesto que hay cinco parámetros posibles, algunos de los cuales tienen valores por defecto, y sería difícil para un llamador recordar en qué orden pasar los argumentos, podemos definir e invocar la función <codeinline>arraycopy()</codeinline> así:</p>
    <pre>
    <code class="language-js">function arraycopy(&lbrace;from, to=from, n=from.length, fromIndex=0, toIndex=0}) &lbrace;
      let valuesToCopy = from.slice(fromIndex, fromIndex + n);
      to.splice(toIndex, 0, ...valuesToCopy);
      return to;
    }
    let a = [1,2,3,4,5], b = [9,8,7,6,5];
    arraycopy(&lbrace;from: a, n: 3, to: b, toIndex: 4}) // => [9,8,7,6,1,2,3,5]</code></pre>
    <p>Al desestructurar una matriz, puede definir un parámetro de reposo para los valores adicionales dentro de la matriz que se está descomprimiendo. Ese parámetro restante entre corchetes es completamente diferente del verdadero parámetro restante de la función:</p>
    <pre>
    <code class="language-js">// Esta función espera un argumento de array. Los dos primeros elementos
    // de ese array se descomprimen en los parámetros x e y. Los elementos
    // restantes se almacenan en el array de coordenadas. Y los argumentos
    // posteriores al primer array se empaquetan en el array restante.
    function f([x, y, ...coords], ...rest) &lbrace;
    return [x+y, ...rest, ...coords]; // Note: operador de propagación aqui
    }
    f([1, 2, 3, 4], 5, 6) // => [3, 5, 6, 3, 4]</code></pre>
    <p>En ES2018, también se puede utilizar un parámetro rest cuando se desestructura un objeto. El valor de ese parámetro rest será un objeto que tenga las propiedades que no se hayan desestructurado. Los parámetros de reposo de objetos suelen ser útiles con el operador de dispersión de objetos, que también es una nueva función de ES2018:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} o &lbrace;x,y,z} por un valor scalar, conserva otras props
    function vectorMultiply(&lbrace;x, y, z=0, ...props}, scalar) &lbrace;
    return &lbrace; x: x*scalar, y: y*scalar, z: z*scalar, ...props };
    }
    vectorMultiply(&lbrace;x: 1, y: 2, w: -1}, 2) // => &lbrace;x: 2, y: 4, z: 0, w: -1}</code></pre>
    <p>Por último, tenga en cuenta que, además de desestructurar objetos argumento y matrices, también puede desestructurar matrices de objetos, objetos que tienen propiedades de matriz y objetos que tienen propiedades de objeto, básicamente a cualquier profundidad. Consideremos un código gráfico que representa círculos como objetos con propiedades <codeinline>x</codeinline>, <codeinline>y</codeinline>, <codeinline>radius</codeinline> y <codeinline>color</codeinline>, donde la propiedad <codeinline>color</codeinline> es una matriz de componentes de color rojo, verde y azul. Podría definir una función que espera que se le pase un único objeto círculo, pero que desestructura ese objeto círculo en seis parámetros separados:</p>
    <pre>
    <code class="language-js">function drawCircle(&lbrace;x, y, radius, color: [r, g, b]}) &lbrace;
      // Aun no implementado
    }</code></pre>
    <p>Si la desestructuración de los argumentos de la función es más complicada que esto, encuentro que el código se vuelve más difícil de leer, en lugar de más simple. A veces, es más claro ser explícito sobre el acceso a las propiedades de los objetos y la indexación de los arrays.</p>
  </section>
  <section id="3-6">
    <h2>8.3.6 Tipos de argumentos</h2>
    <p>Los parámetros de los métodos JavaScript no tienen tipos declarados, y no se realiza ninguna comprobación de tipos en los valores que se pasan a una función. Puede ayudar a que su código sea autodocumentado eligiendo nombres descriptivos para los argumentos de las funciones y documentándolos cuidadosamente en los comentarios de cada función. (Como alternativa, consulte <a href="capitulo-17#8">§17.8</a> para una extensión del lenguaje que permite superponer la comprobación de tipos al JavaScript normal).</p>
    <p>Como se describe en <a href="capitulo-3#9">§3.9</a>, JavaScript realiza conversiones de tipo liberales según sea necesario. Por lo tanto, si escribes una función que espera un argumento de cadena y luego llamas a esa función con un valor de otro tipo, el valor que pasaste simplemente se convertirá en una cadena cuando la función intente usarlo como una cadena. Todos los tipos primitivos pueden convertirse en cadenas, y todos los objetos tienen métodos <codeinline>toString()</codeinline> (aunque no necesariamente útiles), por lo que nunca se produce un error en este caso.</p>
    <p>Sin embargo, esto no siempre es cierto. Consideremos de nuevo el método <codeinline>arraycopy()</codeinline> mostrado anteriormente. Espera uno o dos argumentos de array y fallará si estos argumentos son del tipo incorrecto. A menos que esté escribiendo una función privada que sólo será llamada desde partes cercanas de su código, puede valer la pena añadir código para comprobar los tipos de argumentos como éste. Es mejor que una función falle inmediatamente y de forma predecible cuando se le pasan valores erróneos que empezar a ejecutarse y fallar más tarde con un mensaje de error que probablemente no sea claro. He aquí una función de ejemplo que realiza la comprobación de tipos:</p>
    <pre>
    <code class="language-js">// Devuelve la suma de los elementos del objeto iterable a.
    // El elemento de a deben ser todos números.
    function sum(a) &lbrace;
      let total = 0;
      for(let element of a) &lbrace; // Lanza TypeError si no es iterable
        if (typeof element !== "number") &lbrace;
        throw new TypeError("sum(): los elementos deben ser números");
        }
        total += element;
      }
      return total;
    }
    sum([1,2,3])    // => 6
    sum(1, 2, 3);   // !TypeError: 1 no es iterable
    sum([1,2,"3"]); // !TypeError: el elemento 2 no es un número</code></pre>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.4 Funciones como valores</h2>
    <p>Las características más importantes de las funciones son que pueden definirse e invocarse. La definición y la invocación de funciones son características sintácticas de JavaScript y de la mayoría de los demás lenguajes de programación. En JavaScript, sin embargo, las funciones no son sólo sintaxis, sino también valores, lo que significa que pueden asignarse a variables, almacenarse en los propios objetos o en los elementos de matrices, pasarse como argumentos a funciones, etc.<sup>3</sup></p>
    <p>Para entender cómo las funciones pueden ser datos de JavaScript así como sintaxis de JavaScript, considere esta definición de función:</p>
    <pre>
    <code class="language-js">function square(x) &lbrace; return x*x; }</code></pre>
    <p>Esta definición crea un nuevo objeto función y lo asigna a la variable <codeinline>square</codeinline>. El nombre de una función es realmente irrelevante; es simplemente el nombre de una variable que hace referencia al objeto función. La función puede asignarse a otra variable y seguir funcionando de la misma manera:</p>
    <pre>
    <code class="language-js">let s = square; // Ahora s se refiere a la misma función que el cuadrado.
    square(4)       // => 16
    s(4)            // => 16</code></pre>
    <p>Las funciones también pueden asignarse a propiedades del objeto en lugar de a variables. Como ya hemos comentado, llamamos a las funciones "métodos" cuando hacemos esto:</p>
    <pre>
    <code class="language-js">let o = &lbrace;square: function(x) &lbrace; return x*x; }}; // Un objeto literal
    let y = o.square(16); // y == 256</code></pre>
    <p>Las funciones ni siquiera requieren nombres, como cuando se asignan a elementos de un array:</p>
    <pre>
    <code class="language-js">let a = [x => x*x, 20]; // Un array literal
    a[0](a[1])              // => 400</code></pre>
    <p>La sintaxis de este último ejemplo parece extraña, pero sigue siendo una expresión de invocación de función legal.</p>
    <p>Como ejemplo de lo útil que es tratar las funciones como valores, considere el método <codeinline>Array.sort()</codeinline>. Este método ordena los elementos de un array. Debido a que hay muchos posibles órdenes para ordenar (orden numérico, orden alfabético, orden de fecha, ascendente, descendente, etc.), el método <codeinline>sort()</codeinline> opcionalmente toma una función como argumento para decirle cómo realizar la ordenación. Esta función tiene una tarea sencilla: para dos valores cualesquiera que se le pasen, devuelve un valor que especifica qué elemento iría primero en una matriz ordenada. Este argumento de función hace que <codeinline>Array.sort()</codeinline> sea perfectamente general e infinitamente flexible; puede ordenar cualquier tipo de datos en cualquier orden concebible. En <a href="capitulo-7#8-6">§7.8.6</a> se muestran ejemplos.</p>
    <p>El <a href="#ejemplo-8-1">Ejemplo 8-1</a> demuestra el tipo de cosas que se pueden hacer cuando se utilizan funciones como valores. Este ejemplo puede ser un poco complicado, pero los comentarios explican lo que está pasando.</p>
    <p id="ejemplo-8-1"><em>Ejemplo 8-1. Uso de funciones como datos</em></p>
    <pre>
    <code class="language-js">// Definimos algunas funciones aqui
    function add(x,y) &lbrace; return x + y; }
    function subtract(x,y) &lbrace; return x - y; }
    function multiply(x,y) &lbrace; return x * y; }
    function divide(x,y) &lbrace; return x / y; }

    // Aquí hay una función que toma una de las funciones anteriores 
    // como argumento y la invoca en dos operandos.
    function operate(operator, operand1, operand2) &lbrace;
      return operator(operand1, operand2);
    }

    // Podríamos invocar esta función de la siguiente manera para calcular el valor (2+3) + (4*5):
    let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));
    
    // Para el bien del ejemplo, implementamos nuevamente las 
    // funciones simples, esta vez dentro de un objeto literal;
    const operators = &lbrace;
      add: (x,y) => x+y,
      subtract: (x,y) => x-y,
      multiply: (x,y) => x*y,
      divide: (x,y) => x/y,
      pow: Math.pow // Esto tambien funciona para funciones predefinidas
    };
    
    // Esta función toma el nombre de un operador, busca dicho operador 
    // en el objeto y luego lo invoca en los operandos suministrados. 
    // Observe la sintaxis utilizada para invocar la función del operador.
    function operate2(operation, operand1, operand2) &lbrace;
      if (typeof operators[operation] === "function") &lbrace;
        return operators[operation](operand1, operand2);
      }
      else throw "unknown operator";
    }

    operate2("add", "hola", operate2("add", " ", "mundo")) // => "hola mundo"
    operate2("pow", 10, 2) // => 100</code></pre>
  </section>
  <section id="4-1">
    <h2>8.4.1 Definición de propiedades de función propias</h2>
    <p>Las funciones no son valores primitivos en JavaScript, sino un tipo especializado de objeto, lo que significa que las funciones pueden tener propiedades. Cuando una función necesita una variable "estática" cuyo valor persiste a través de las invocaciones, a menudo es conveniente utilizar una propiedad de la propia función. Por ejemplo, suponga que desea escribir una función que devuelva un único número entero cada vez que se invoque. La función nunca debe devolver el mismo valor dos veces. Para conseguirlo, la función necesita llevar un registro de los valores que ya ha devuelto, y esta información debe persistir a través de las invocaciones de la función. Podrías almacenar esta información en una variable global, pero es innecesario, porque la información sólo es utilizada por la propia función. Es mejor almacenar la información en una propiedad del objeto Función. A continuación se muestra un ejemplo que devuelve un número entero único cada vez que se llama:</p>
    <pre>
    <code class="language-js">// Inicialice la propiedad del contador del objeto de función. 
    // Las declaraciones de funciones se elevan, por lo que realmente 
    // podemos realizar esta asignación antes de la declaración de la función.
    uniqueInteger.counter = 0;

    // Esta función devuelve un entero diferente cada vez que se la llama. 
    // Utiliza una propiedad propia para recordar el siguiente valor que se devolverá.
    function uniqueInteger() &lbrace;
      return uniqueInteger.counter++; // Propiedad de contador de retorno e incremento
    }
    uniqueInteger()                   // => 0
    uniqueInteger()                   // => 1</code></pre>  
    <p>Como otro ejemplo, considere la siguiente función <codeinline>factorial()</codeinline> que utiliza los valores propios de sí misma (tratándose a sí misma como una matriz) para almacenar en caché los resultados calculados previamente:</p>
    <pre>
    <code class="language-js">// Calcular factoriales y almacenar en caché los resultados como propiedades de la función misma.
    function factorial(n) &lbrace;
      if (Number.isInteger(n) && n > 0) &lbrace;    // Sólo números enteros positivos
        if (!(n in factorial)) &lbrace;             // Si no hay ningún resultado almacenado en caché
          factorial[n] = n * factorial(n-1); // Calcularlo y almacenarlo en caché
        }
        return factorial[n]; // Devuelve el resultado almacenado en caché
      } else &lbrace;
        return NaN;          // Si la entrada fue incorrecta
      }
    }
    factorial[1] = 1; // Inicialice la caché para almacenar este caso base.
    factorial(6)      // => 720
    factorial[5]      // => 120; La llamada anterior almacena en caché este valor</code></pre>
  </section>
  <section id="5" class="py-4 xs:py-5 sm:py-6">
    <h2>8.5 Funciones como espacios de nombres</h2>
    <p>Las variables declaradas dentro de una función no son visibles fuera de ella. Por esta razón, a veces es útil definir una función simplemente para que actúe como un espacio de nombres temporal en el que se pueden definir variables sin saturar el espacio de nombres global.</p>
    <p>Supongamos, por ejemplo, que tiene un fragmento de código JavaScript que desea utilizar en varios programas JavaScript diferentes (o, en el caso de JavaScript del lado del cliente, en varias páginas web diferentes). Supongamos que este código, como la mayoría, define variables para almacenar los resultados intermedios de sus cálculos. El problema es que como este trozo de código se utilizará en muchos programas diferentes, no sabes si las variables que crea entrarán en conflicto con las variables creadas por los programas que lo utilizan. La solución es poner el trozo de código en una función y luego invocar la función. De esta forma, las variables que habrían sido globales pasan a ser locales a la función:</p>
    <pre>
    <code class="language-js">function chunkNamespace() &lbrace;
      // El fragmento de código va aquí
      // Todas las variables definidas en el fragmento son locales 
      // para esta función en lugar de saturar.
      // El espacio de nombres global.
    }
    chunkNamespace(); // ¡Pero no olvides invocar la función!</code></pre>
    <p>Este código define una única variable global: el nombre de la función chunkNamespace. Si definir incluso una sola propiedad es demasiado, puedes definir e invocar una función anónima en una sola expresión:</p>
    <pre>
    <code class="language-js">(function() &lbrace; // chunkNamespace() función reescrita como una expresión sin nombre.
      // Un fragmento de código va aquí
    }()); // Finalice la función literal e invóquela ahora.</code></pre>
    <p>Esta técnica de definir e invocar una función en una única expresión se utiliza con tanta frecuencia que se ha convertido en una expresión idiomática y se le ha dado el nombre de "expresión de función invocada inmediatamente". Observe el uso de paréntesis en el ejemplo de código anterior. El paréntesis abierto antes de la <codeinline>function</codeinline> es necesario porque, sin él, el intérprete de JavaScript intenta interpretar la palabra clave <codeinline>function</codeinline> como una declaración de función. Con el paréntesis, el intérprete reconoce correctamente que se trata de una expresión de definición de función. El paréntesis inicial también ayuda a los lectores humanos a reconocer cuándo se está definiendo una función para invocarla inmediatamente en lugar de definirla para su uso posterior.</p>
    <p>Este uso de funciones como espacios de nombres se vuelve realmente útil cuando definimos una o más funciones dentro de la función del espacio de nombres usando variables dentro de ese espacio de nombres, pero luego las pasamos de vuelta como el valor de retorno de la función del espacio de nombres. Las funciones de este tipo se conocen como <em>closures</em>, y son el tema de la siguiente sección.</p>
  </section>
  <section id="6">
    <h2>8.6 Closures</h2>
    <p>Como la mayoría de los lenguajes de programación modernos, JavaScript utiliza el <em>ámbito léxico</em>. Esto significa que las funciones se ejecutan utilizando el ámbito de la variable que estaba en vigor cuando se definieron, no el ámbito de la variable que está en vigor cuando se invocan. Para implementar el ámbito léxico, el estado interno de un objeto de función JavaScript debe incluir no sólo el código de la función, sino también una referencia al ámbito en el que aparece la definición de la función. Esta combinación de un objeto de función y un ámbito (un conjunto de enlaces de variables) en el que se resuelven las variables de la función se denomina <em>closure</em> en la literatura informática.</p>
    <p>Técnicamente, todas las funciones de JavaScript son cierres, pero como la mayoría de las funciones se invocan desde el mismo ámbito en el que se definieron, normalmente no importa que haya un cierre implicado. Los cierres se vuelven interesantes cuando son invocados desde un ámbito diferente al que fueron definidos. Esto sucede más comúnmente cuando un objeto de función anidada es devuelto desde la función dentro de la cual fue definido. Existen varias técnicas de programación potentes que implican este tipo de cierres de funciones anidadas, y su uso se ha vuelto relativamente común en la programación JavaScript. Los cierres pueden parecer confusos la primera vez que te topas con ellos, pero es importante que los entiendas lo suficientemente bien como para utilizarlos cómodamente.</p>
    <p>El primer paso para entender los cierres es revisar las reglas de alcance léxico de las funciones nes- tadas. Consideremos el siguiente código:</p>
    <pre>
    <code class="language-js">let scope = "global scope";       // Una variable global
    function checkscope() &lbrace;
      let scope = "local scope";      // Una variable local
      function f() &lbrace; return scope; }  // Retorna el valor in scope aquí
      return f();
    }
    checkscope() // => "local scope"</code></pre>
    <p>La función <codeinline>checkscope()</codeinline> declara una variable local y luego define e invoca una función que devuelve el valor de esa variable. Debería quedarte claro por qué la llamada a <codeinline>checkscope()</codeinline> devuelve "ámbito local". Ahora, cambiemos ligeramente el código. ¿Puedes decir qué devolverá este código?</p>
    <pre>
    <code class="language-js">let scope = "global scope";      // Una variable global
    function checkscope() &lbrace;
      let scope = "local scope";     // Una variable local
      function f() &lbrace; return scope; } // Retorna el valor in scope aquí
      return f;
    }
    let s = checkscope()(); // ¿Qué devuelve esto?</code></pre>
    <p>En este código, un par de paréntesis se ha movido de dentro de <codeinline>checkscope()</codeinline> a fuera de él. En lugar de invocar la función anidada y devolver su resultado, <codeinline>checkscope()</codeinline> ahora sólo devuelve el propio objeto de la función anidada. ¿Qué sucede cuando invocamos esa función anidada (con el segundo par de paréntesis en la última línea de código) fuera d e la función en la que fue definida?</p>
    <p>Recuerda la regla fundamental del ámbito léxico: Las funciones JavaScript se ejecutan utilizando el ámbito en el que fueron definidas. La función anidada <codeinline>f()</codeinline> se definió en un ámbito en el que la variable <codeinline>scope</codeinline> estaba vinculada al valor "ámbito local". Esa vinculación sigue vigente cuando se ejecuta <codeinline>f</codeinline>, independientemente del lugar desde el que se ejecute. Así que la última línea del ejemplo de código anterior devuelve "ámbito local", no "ámbito global". Esto, en pocas palabras, es la sorprendente y poderosa naturaleza de los cierres: capturan las variables locales (y parámetros) de la función externa dentro de la cual están definidos.</p>
    <p>En <a href="#4-1">§8.4.1</a>, definimos una función <codeinline>uniqueInteger()</codeinline> que utilizaba una propiedad de la propia función para realizar un seguimiento del siguiente valor a devolver. Una desventaja de este enfoque es que un código malicioso podría reiniciar el contador o ponerlo en un valor que no sea entero, haciendo que la función <codeinline>uniqueInteger()</codeinline> viole la parte "unique" o "integer" de su contrato. Los cierres capturan las variables locales de una única invocación a una función y pueden utilizar esas variables como estado privado. He aquí cómo podríamos reescribir la función <codeinline>uniqueInteger()</codeinline> utilizando una expresión de función de invocación inmediata para definir un espacio de nombres y un cierre que utilice ese espacio de nombres para mantener su estado privado:</p>
    <pre>
    <code class="language-js">let uniqueInteger = (function() &lbrace; // Lo definimos y lo invocamos
      let counter = 0;                // Estado privado de la función a continuación
      return function() &lbrace; return counter++; };
    }());
    uniqueInteger()    // => 0
    uniqueInteger()    // => 1</code></pre>
    <p>Para entender este código, tienes que leerlo detenidamente. A primera vista, la primera línea de código parece que está asignando una función a la variable <codeinline>uniqueInteger</codeinline>. De hecho, el código está definiendo e invocando (como sugiere el paréntesis abierto en la primera línea) una función, por lo que es el valor de retorno de la función el que se asigna a <codeinline>uniqueInteger</codeinline>. Ahora, si estudiamos el cuerpo de la función, vemos que su valor de retorno es otra función. Es este objeto de función anidada el que se asigna a <codeinline>uniqueInteger</codeinline>. La función anidada tiene acceso a las variables de su ámbito y puede utilizar la variable <codeinline>counter</codeinline> definida en la función externa. Una vez que la función externa retorna, ningún otro código puede ver la variable <codeinline>counter</codeinline>: la función interna tiene acceso exclusivo a ella.</p>
    <p>Las variables privadas como <codeinline>counter</codeinline> no tienen por qué ser exclusivas de un único cierre: es perfectamente posible que dos o más funciones anidadas se definan dentro de la misma función externa y compartan el mismo ámbito. Considere el siguiente código:</p>
    <pre>
    <code class="language-js">function counter() &lbrace;
      let n = 0;
      return &lbrace;
        count: function() &lbrace; return n++; },
        reset: function() &lbrace; n = 0; }
      };
    }

    let c = counter(), d = counter(); // Crea dos contadores
    c.count()            // => 0
    d.count()            // => 0: cuentan independientemente
    c.reset();           // los metodos reset() y count() comparten el estado.
    c.count()            // => 0: porque reseteamos c
    d.count()            // => 1: d no se ha reseteado</code></pre>
    <p>La función <codeinline>counter()</codeinline> devuelve un objeto "counter". Este objeto tiene dos métodos: <codeinline>count()</codeinline> devuelve el siguiente entero, y <codeinline>reset()</codeinline> reinicia el estado interno. Lo primero que hay que entender es que los dos métodos comparten el acceso a la variable privada <codeinline>n</codeinline>. Lo segundo que hay que entender es que cada invocación de <codeinline>counter()</codeinline> crea un nuevo ámbito -independientemente de los ámbitos utilizados por las invocaciones anteriores- y una nueva variable privada dentro de ese ámbito. Así que si llamas a <codeinline>counter()</codeinline> dos veces, obtendrás dos objetos contador con diferentes variables privadas. Llamar a <codeinline>count()</codeinline> o <codeinline>reset()</codeinline> en un objeto contador no tiene efecto en el otro.</p>
    <p>Vale la pena señalar aquí que se puede combinar esta técnica de cierre con getters y setters de propiedades. La siguiente versión de la función <codeinline>counter()</codeinline> es una variación del código que apareció en <a href="capitulo-6#10-6">§6.10.6</a>, pero utiliza cierres para el estado privado en lugar de confiar en una propiedad de objeto normal:</p>
    <pre>
    <code class="language-js">function counter(n) &lbrace; // El argumento de función n es la variable privada
      return &lbrace;
        // El método getter de propiedad retorna e incrementa la variable del contador privado.
        get count() &lbrace; return n++; },
        // El establecedor de propiedades no permite que el valor de n disminuya
        set count(m) &lbrace;
          if (m > n) n = m;
          else throw Error("El recuento solo se puede establecer en un valor mayor");
        }
      };
    }
    let c = counter(1000);
    c.count         // => 1000
    c.count         // => 1001
    c.count = 2000;
    c.count         // => 2000
    c.count = 2000; // !Error: el recuento solo se puede establecer en un valor mayor</code></pre>
    <p>Observe que esta versión de la función <codeinlien>counter()</codeinlien> no declara una variable local, sino que sólo utiliza su parámetro n para mantener el estado privado compartido por los métodos de acceso a propiedades. Esto permite a quien llama a <codeinline>counter()</codeinline> especificar el valor inicial de la variable privada.</p>
    <p>El <a href="ejemplo-8-2">Ejemplo 8-2</a> es una generalización del estado privado compartido a través de la técnica de cierres que hemos estado demostrando aquí. Este ejemplo define una función <codeinline>addPrivateProp()</codeinline> que define una variable privada y dos funciones anidadas para obtener y establecer el valor de esa variable. Añade estas funciones anidadas como métodos del objeto que especifiques.</p>
    <p id="ejemplo-8-2"><em>Ejemplo 8-2. Métodos de acceso a propiedades privadas utilizando cierres</em></p>
    <pre>
    <code class="language-js">// Esta función agrega métodos de acceso a propiedades para una propiedad con
    // el nombre especificado al objeto o. Los métodos se denominan get&lt;name>
    // y set&lt;name>. Si se proporciona una función de predicado, el método de
    // establecimiento la utiliza para probar la validez de su argumento antes de almacenarlo.
    // Si el predicado devuelve falso, el método de establecimiento genera una excepción.

    // Lo inusual de esta función es que el valor de la propiedad que se 
    // manipula mediante los métodos getter y setter no se almacena en el 
    // objeto o. En cambio, el valor se almacena solo en una variable local 
    // en esta función. Los métodos getter y setter también se definen localmente 
    // en esta función y, por lo tanto, tienen acceso a esta variable local.
    // Esto significa que el valor es privado para los dos métodos de acceso y no 
    // se puede establecer ni modificar excepto a través del método setter.

    function addPrivateProperty(o, name, predicate) &lbrace;
      let value; // Este es el valor de la propiedad
      // El método getter simplemente devuelve el valor.
      o[`get$&lbrace;name}`] = function() &lbrace; return value; };
      // El método setter almacena el valor o lanza una excepción si el 
      // predicado rechaza el valor.
      o[`set$&lbrace;name}`] = function(v) &lbrace;
        if (predicate && !predicate(v)) &lbrace;
          throw new TypeError(`set$&lbrace;name}: invalid value $&lbrace;v}`);
        } else &lbrace;
          value = v;
        }
      };
    }
    // El siguiente código demuestra el método addPrivateProperty().
    let o = &lbrace;}; // Aquí hay un objeto vacío.
    // Agregar los métodos de acceso a propiedades getName y setName()
    // Asegúrese de que solo se permitan valores de cadena
    addPrivateProperty(o, "Name", x => typeof x === "string");
    o.setName("Frank"); // Establecer el valor de la propiedad
    o.getName()   // => "Frank"
    o.setName(0); // !TypeError: Intente establecer un valor del tipo incorrecto</code></pre>
    <p>Ya hemos visto varios ejemplos en los que dos cierres se definen en el mismo ámbito y comparten el acceso a la misma variable o variables privadas. Esta es una técnica importante, pero es igualmente importante reconocer cuando los cierres comparten inadvertidamente el acceso a una variable que no deberían compartir. Considere el siguiente código:</p>
    <pre>
    <code class="language-js">// Esta función devuelve una función que siempre devuelve v
    function constfunc(v) &lbrace; return () => v; }

    // Crea una matriz de funciones constantes:
    let funcs = [];
    for(var i = 0; i &lt; 10; i++) funcs[i] = constfunc(i);

    // La función en el elemento 5 de la matriz devuelve el valor 5.
    funcs[5]() // => 5</code></pre>
    <p>Cuando se trabaja con código como éste que crea múltiples cierres utilizando un bucle, es un error común intentar mover el bucle dentro de la función que define los cierres. Piense en el siguiente código, por ejemplo:</p>
    <pre>
    <code class="language-js">// Devuelve un array de funciones que devuelven los valores 0-9
    function constfuncs() &lbrace;
      let funcs = [];
      for(var i = 0; i &lt; 10; i++) &lbrace;
        funcs[i] = () => i;
      }
      return funcs;
    }
    let funcs = constfuncs();
    funcs[5]() // => 10; ¿Por qué esto no devuelve 5?</code></pre>
    <p>Este código crea 10 cierres y los almacena en un array. Todos los cierres se definen dentro de la misma invocación de la función, por lo que comparten el acceso a la variable <codeinline>i</codeinline>. Cuando <codeinline>constfuncs()</codeinline> devuelve, el valor de la variable <codeinline>i</codeinline> es 10, y los 10 cierres comparten este valor. Por lo tanto, todas las funciones de la matriz de funciones devuelven el mismo valor, que no es lo que queríamos en absoluto. Es importante recordar que el ámbito asociado a un cierre es "vivo". Las funciones anidadas no hacen copias privadas del ámbito ni instantáneas estáticas de los enlaces de las variables. Fundamentalmente, el problema aquí es que las variables declaradas con <codeinline>var</codeinline> se definen a lo largo de la función. Nuestro bucle <codeinline>for</codeinline> declara la variable del bucle con <codeinline>var i</codeinline>, por lo que la variable <codeinline>i</codeinline> está definida en toda la función en lugar de tener un ámbito más limitado al cuerpo del bucle. El código muestra una categoría común de errores en ES5 y anteriores, pero la introducción de variables de ámbito de bloque en ES6 resuelve el problema. Si sustituimos <codeinline>var</codeinline> por <codeinline>let</codeinline> o <codeinline>const</codeinline>, el problema desaparece. Debido a que <codeinline>let</codeinline> y <codeinline>const</codeinline> tienen ámbito de bloque, cada iteración del bucle define un ámbito que es independiente de los ámbitos de todas las demás iteraciones, y cada uno de estos ámbitos tiene su propio ámbito independiente de <codeinline>i</codeinline>.</p>
    <p>Otra cosa que hay que recordar al escribir cierres es que <codeinline>this</codeinline> es una palabra clave de JavaScript, no una variable. Como se ha comentado antes, las funciones de flecha heredan el valor <codeinline>this</codeinline> de la función que las contiene, pero las funciones definidas con la palabra clave <codeinline>function</codeinline> no lo hacen. Así que si estás escribiendo un cierre que necesita usar el valor <codeinline>this</codeinline> de su función contenedora, deberías usar una función de flecha, o llamar a <codeinline>bind()</codeinline>, en el cierre antes de devolverlo, o asignar el valor <codeinline>this</codeinline> externo a una variable que tu cierre heredará:</p>
    <pre>
    <code class="language-js">const self = this; // Hacer que este valor esté disponible para funciones anidadas</code></pre>
  </section>
  <section id="7" class="py-4 xs:py-5 sm:py-6">
    <h2>8.7 Propiedades, métodos y constructores de funciones</h2>
    <p>Hemos visto que las funciones son valores en los programas JavaScript. El operador <codeinline>typeof</codeinline> devuelve la cadena "function" cuando se aplica a una función, pero las funciones son en realidad un tipo especializado de objeto JavaScript. Dado que las funciones son objetos, pueden tener propiedades y métodos, como cualquier otro objeto. Existe incluso un constructor <codeinline>Function()</codeinline> para crear nuevos objetos función. Las subsecciones siguientes documentan las propiedades <codeinline>length</codeinline>, <codeinline>name</codeinline> y <codeinline>prototype</codeinline>; los métodos <codeinline>call()</codeinline>, <codeinline>apply()</codeinline>, <codeinline>bind()</codeinline> y <codeinline>toString()</codeinline>; y el constructor <codeinline>Function()</codeinline>.</p>
  </section>
  <section id="7-1">
    <h2>8.7.1 La longitud Propiedad</h2>
    <p>La propiedad de <codeinline>length</codeinline> de sólo lectura de una función especifica la <em>aridad</em> de la función: el número de parámetros que declara en su lista de parámetros, que suele ser el número de argumentos que espera la función. Si una función tiene un parámetro restante, ese parámetro no se cuenta a efectos de esta propiedad de <codeinline>length</codeinline>.</p>
  </section>
  <section id="7-2" class="py-4 xs:py-5 sm:py-6">
    <h2>8.7.2 El nombre Propiedad</h2>
    <p>La propiedad <codeinline>name</codeinline> de sólo lectura de una función especifica el nombre que se utilizó cuando se definió la función, si se definió con un nombre, o el nombre de la variable o propiedad a la que se asignó una expresión de función sin nombre cuando se creó por primera vez. Esta propiedad es útil sobre todo cuando se escriben mensajes de depuración o de error.</p>
  </section>
  <section id="7-3">
    <h2>8.7.3 El prototipo Propiedad</h2>
    <p>Todas las funciones, excepto las funciones flecha, tienen una propiedad <codeinline>prototype</codeinline> que hace referencia a un objeto conocido como <em>objeto prototipo</em>. Cada función tiene un objeto prototipo diferente. Cuando una función se utiliza como constructor, el objeto recién creado hereda propiedades del objeto prototipo. Los prototipos y la propiedad <codeinline>prototype</codeinline> se trataron en <a href="capitulo-6#2-3">§6.2.3</a> y se tratará de nuevo en el <a href="capitulo-9">Capítulo 9</a>.</p>
  </section>
  <section id="7-4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.7.4 Los métodos call() y apply()</h2>
    <p><codeinline>call()</codeinline> y <codeinline>apply()</codeinline> permiten invocar indirectamente ( <a href="#2-4">§8.2.4</a> ) una función como si fuera un método de otro objeto. El primer argumento de <codeinline>call()</codeinline> y <codeinline>apply()</codeinline> es el objeto sobre el que se va a invocar la función; este argumento es el contexto de invocación y se convierte en el valor de la palabra clave <codeinline>this</codeinline> dentro del cuerpo de la función. Para invocar la función <codeinline>f()</codeinline> como un método del objeto <codeinline>o</codeinline> (sin pasar argumentos), puede utilizar <codeinline>call()</codeinline> o <codeinline>apply()</codeinline>:</p>
    <pre>
    <code class="language-js">f.call(o);
    f.apply(o);</code></pre>
    <p>Cualquiera de estas líneas de código son similares a las siguientes (que suponen que <codeinline>o</codeinline> no tiene ya una propiedad llamada <codeinline>m</codeinline>):</p>
    <pre>
    <code class="language-js">o.m = f;    // Haga de f un método temporal de o.
    o.m();      // Invocarlo sin pasar ningún argumento.
    delete o.m; // Eliminar el método temporal.</code></pre>
    <p>Recuerde que las funciones de flecha heredan el valor <codeinline>this</codeinline> del contexto donde se definen. Esto no puede anularse con los métodos <codeinline>call()</codeinline> y <codeinline>apply()</codeinline>. Si llama a cualquiera de esos métodos en una función de flecha, el primer argumento es efectivamente ignorado.</p>
    <p>Cualquier argumento a <codeinline>call()</codeinline> después del primer argumento del contexto de invocación son los valores que se pasan a la función que se invoca (y estos argumentos no se ignoran para las funciones de flecha). Por ejemplo, para pasar dos números a la función <codeinline>f()</codeinline> e invocarla como si fuera un método del objeto <codeinline>o</codeinline>, se podría utilizar código como este:</p>
    <pre>
    <code class="language-js">f.call(o, 1, 2);</code></pre>
    <p>El método <codeinline>apply()</codeinline> es como el método <codeinline>call()</codeinline>, salvo que los argumentos que se pasan a la función se especifican como una matriz:</p>
    <pre>
    <code class="language-js">f.apply(o, [1,2]);</code></pre>
    <p>Si una función está definida para aceptar un número arbitrario de argumentos, el método <codeinline>apply()</codeinline> permite invocar esa función sobre el contenido de un array de longitud arbitraria. En ES6 y posteriores, podemos utilizar simplemente el operador spread, pero es posible que veas código ES5 que utiliza <codeinline>apply()</codeinline> en su lugar. Por ejemplo, para encontrar el mayor número en un array de números sin usar el operador spread, podrías usar el mé todo <codeinline>apply()</codeinline> para pasar los elementos del array a la función <codeinline>Math.max()</codeinline>:</p>
    <pre>
    <code class="language-js">let biggest = Math.max.apply(Math, arrayOfNumbers);</code></pre>
    <p>La función <codeinline>trace()</codeinline> definida a continuación es similar a la función <codeinline>timed()</codeinline> definida en <a href="#3-4">§8.3.4</a>, pero funciona para métodos en lugar de funciones. Utiliza el método <codeinline>apply()</codeinline> en lugar de un operador spread, y al hacerlo, es capaz de invocar al método envuelto con los mismos argumentos y el mismo valor <codeinline>this</codeinline> que el método envuelto:</p>
    <pre>
    <code class="language-js">// Reemplace el método llamado m del objeto o con una versión 
    // que registre mensajes antes y después de invocar el método original.
    function trace(o, m) &lbrace;
      let original = o[m];        // Recuerde el método original en el cierre.
      o[m] = function(...args) &lbrace;  // Ahora defina el nuevo método.
        console.log(new Date(), "Entering:", m);  // Mensaje de registro.
        let result = original.apply(this, args);  // Invocar original.
        console.log(new Date(), "Exiting:", m);   // Mensaje de registro.
        return result;                            // Return result.
      };
    }</code></pre>
  </section>
  <section id="7-5">
    <h2>8.7.5 El método bind()</h2>
    <p>El propósito principal de <codeinline>bind()</codeinline> es <em>vincular</em> una función a un objeto. Cuando se invoca el método <codeinline>bind()</codeinline> sobre una función <codeinline>f</codeinline> y se le pasa un objeto <codeinline>o</codeinline>, el método devuelve una nueva función. Al invocar la nueva función (como una función) se invoca la función original <codeinline>f</codeinline> como un método de <codeinline>o</codeinline>. Cualquier argumento que se pase a la nueva función se pasa a la función original. Por ejemplo:</p>
    <pre>
    <code class="language-js">function f(y) &lbrace; return this.x + y; } // Esta función necesita estar vinculada
    let o = &lbrace; x: 1 };      // Un objeto que enlazaremos
    let g = f.bind(o);     // Al llamar a g(x) se invoca a f() en o
    g(2)                   // => 3
    let p = &lbrace; x: 10, g };  // Invocar g() como un método de este objeto
    p.g(2)                 // => 3: g sigue logando a o no a p.</code></pre>
    <p>Las funciones de flecha heredan su valor <codeinline>this</codeinline> del entorno en el que están definidas, y ese valor no se puede sobrescribir con <codeinline>bind()</codeinline>, por lo que si la función <codeinline>f()</codeinline> en el código anterior se definiera como una función de flecha, la vinculación no funcionaría. Sin embargo, el caso de uso más común para llamar a <codeinline>bind()</codeinline> es hacer que las funciones que no son de flecha se comporten como funciones de flecha, por lo que esta limitación en la vinculación de funciones de flecha no es un problema en la práctica.</p>
    <p>Sin embargo, el método <codeinline>bind()</codeinline> no sólo vincula una función a un objeto. También puede realizar una aplicación parcial: cualquier argumento que pase a <codeinline>bind()</codeinline> después del primero se vincula junto con el valor <codeinline>this</codeinline>. Esta característica de aplicación parcial de <codeinline>bind()</codeinline> funciona con funciones de flecha. La aplicación parcial es una técnica común en la programación funcional y a veces se denomina <em>currying</em>. Aquí hay algunos ejemplos del método <codeinline>bind()</codeinline> utilizado para la aplicación parcial:</p>
    <pre>
    <code class="language-js">let sum = (x,y) => x + y;     // Retorna la suma de 2 argumentos
    let succ = sum.bind(null, 1); // Vincula el primer argumentos a 1
    succ(2)             // => 3: x esta ligado a 1, y pasamos 2 para el argumento y

    function f(y,z) &lbrace; return this.x + y + z; }
    let g = f.bind(&lbrace;x: 1}, 2);   // Enlaza this e y
    g(3)               // => 6: this.x esta ligado a 1, y esta ligando a 2 y z es 3</code></pre>
    <p>La propiedad <codeinline>name</codeinline> de la función devuelta por <codeinline>bind()</codeinline> es la propiedad name de la función sobre la que se llamó a <codeinline>bind()</codeinline>, prefijada con la palabra "bound".</p>
  </section>
  <section id="7-6" class="py-4 xs:py-5 sm:py-6">
    <h2>8.7.6 El método toString()</h2>
    <p>Como todos los objetos JavaScript, las funciones tienen un método <codeinline>toString()</codeinline>. La especificación ECMAScript requiere que este método devuelva una cadena que siga la sintaxis de la declaración de la función. En la práctica, la mayoría (pero no todas) de las implementaciones de este método <codeinline>toString()</codeinline> devuelven el código fuente completo de la función. Las funciones incorporadas suelen devolver una cadena que incluye algo como "[código nativo]" como cuerpo de la función</p>
  </section>
  <section id="7-7">
    <h2>8.7.7 El constructor Function()</h2>
    <p>Dado que las funciones son objetos, existe un constructor <codeinline>Function()</codeinline> que puede utilizarse para crear nuevas funciones:</p>
    <pre>
    <code class="language-js">const f = new Function("x", "y", "return x*y;");</code></pre>
    <p>Esta línea de código crea una nueva función que es más o menos equivalente a una función definida con la sintaxis familiar:</p>
    <pre>
    <code class="language-js">const f = function(x, y) &lbrace; return x*y; };</code></pre>
    <p>El constructor <codeinline>Function()</codeinline> espera cualquier número de argumentos de cadena. El último argumento es el texto del cuerpo de la función; puede contener sentencias JavaScript arbitrarias, separadas entre sí por punto y coma. Todos los demás argumentos del constructor son cadenas que especifican los nombres de los parámetros de la función. Si está definiendo una función que no recibe argumentos, simplemente pasaría una única cadena -el cuerpo de la función- al constructor.</p>
    <p>Observe que al constructor <codeinline>Function()</codeinline> no se le pasa ningún argumento que especifique un nombre para la función que crea. Al igual que los literales de función, el constructor <codeinline>Function()</codeinline> crea funciones anónimas.</p>
    <p>Hay algunos puntos que es importante comprender sobre la función <codeinline>Function()</codeinline> constructor:</p>
    <ul class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El constructor <codeinline>Function()</codeinline> permite crear y compilar dinámicamente funciones JavaScript en tiempo de ejecución.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El constructor <codeinline>Function()</codeinline> analiza el cuerpo de la función y crea un nuevo objeto función cada vez que es llamado. Si la llamada al constructor aparece dentro de un bucle o dentro de una función llamada con frecuencia, este proceso puede resultar ineficiente. Por el contrario, las funciones anidadas y las expresiones de función que aparecen dentro de bucles no se recompilan cada vez que se encuentran.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Un último punto muy importante sobre el constructor <codeinline>Function()</codeinline> es que las funciones que crea no utilizan ámbito léxico; en su lugar, siempre se compilan como si fueran funciones de nivel superior, como demuestra el siguiente código:
        </p>
      </li>
    <pre>
    <code class="language-js">let scope = "global";
    function constructFunction() &lbrace;
    let scope = "local";
    return new Function("return scope"); // Doesn't capture local scope!
    }
    // This line returns "global" because the function returned by the
    // Function() constructor does not use the local scope.
    constructFunction()() // => "global"</code></pre>
    </ul>
    <p>El constructor <codeinline>Function()</codeinline> es una versión global de <codeinline>eval()</codeinline> (véase <a href="capitulo-4#12-2">§4.12.2</a>) que define nuevas variables y funciones en su propio ámbito privado. Probablemente nunca necesite utilizar este constructor en su código.</p>
  </section>
  <section id="8" class="py-4 xs:py-5 sm:py-6">
    <h2>8.8 Programación funcional</h2>
    <p>JavaScript no es un lenguaje de programación funcional como Lisp o Haskell, pero el hecho de que JavaScript pueda manipular funciones como objetos significa que podemos utilizar técnicas de programación funcional en JavaScript. Los métodos de array como <codeinline>map()</codeinline> y <codeinline>reduce()</codeinline> se prestan particularmente bien a un estilo de programación funcional. Las secciones siguientes muestran técnicas de programación funcional en JavaScript. Pretenden ser una exploración enriquecedora de la potencia de las funciones de JavaScript, no una prescripción para un buen estilo de programación.</p>
  </section>
  <section id="8-1">
    <h2>8.8.1 Procesamiento de matrices con funciones</h2>
    <p>Supongamos que tenemos una matriz de números y queremos calcular la media y la desviación estándar de esos valores. Podríamos hacerlo en un estilo no funcional como este:</p>
    <pre>
    <code class="language-js">let data = [1,1,3,5,5]; // Esto es un array de números

    // La media es la suma de los elementos dividida por el número de elementos.
    let total = 0;
    for(let i = 0; i &lt; data.length; i++) total += data[i];
    let mean = total/data.length; // mean == 3; La media de nuestros datos es 3

    // Para calcular la desviación estándar, primero sumamos los 
    // cuadrados de la desviación de cada elemento con respecto a la media.
    total = 0;
    for(let i = 0; i &lt; data.length; i++) &lbrace;
    let deviation = data[i] - mean;
    total += deviation * deviation;
    }
    let stddev = Math.sqrt(total/(data.length-1)); // stddev == 2</code></pre>
    <p>Podemos realizar estos mismos cálculos en un estilo funcional conciso utilizando los métodos de array <codeinline>map()</codeinline> y <codeinline>reduce()</codeinline> de esta manera (véase <a href="capitulo-7#8-1">§7.8.1</a> para revisar estos métodos):</p>
    <pre>
    <code class="language-js">// Primero, defina dos funciones simples
    const sum = (x,y) => x+y;
    const square = x => x*x;

    // Luego use esas funciones con métodos de array para calcular la mean y stddev.
    let data = [1,1,3,5,5];
    let mean = data.reduce(sum)/data.length; // mean == 3
    let deviations = data.map(x => x-mean);
    let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
    stddev // => 2</code></pre>
    <p>Esta nueva versión del código parece bastante diferente de la primera, pero sigue invocando métodos sobre objetos, por lo que conserva algunas convenciones orientadas a objetos. Escribamos versiones funcionales de los métodos <codeinline>map()</codeinline> y <codeinline>reduce()</codeinline>:</p>
    <pre>
    <code class="language-js">const map = function(a, ...args) &lbrace; return a.map(...args); };
    const reduce = function(a, ...args) &lbrace; return a.reduce(...args); };</code></pre>
    <p>Con estas funciones <codeinline>map()</codeinline> y <codeinline>reduce()</codeinline> definidas, nuestro código para calcular la media y la desviación típica tiene ahora este aspecto:</p>
    <pre>
    <code class="language-js">const sum = (x,y) => x+y;
    const square = x => x*x;

    let data = [1,1,3,5,5];
    let mean = reduce(data, sum)/data.length;
    let deviations = map(data, x => x-mean);
    let stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length-1));
    stddev // => 2</code></pre>
  </section>
  <section id="8-2" class="py-4 xs:py-5 sm:py-6">
    <h2>8.8.2 Funciones de orden superior</h2>
    <p>Una <em>función de orden superior</em> es una función que opera sobre funciones, tomando una o más funciones como argumentos y devolviendo una nueva función. He aquí un ejemplo:</p>
    <pre>
    <code class="language-js">// Esta función de orden superior devuelve una nueva función que pasa sus 
    // argumentos a f y devuelve la negación lógica del valor de retorno de f;
    function not(f) &lbrace;
      return function(...args) &lbrace;          // Devolver una nueva función
        let result = f.apply(this, args); // Eso llama f
        return !result;                   // y niega su resultado.
      };
    }

    const even = x => x % 2 === 0; // Una función para determinar si un número es par
    const odd = not(even);         // Una nueva función que hace lo contrario
    [1,1,3,5,5].every(odd)         // => true: Cada elemento de la matriz es impar</code></pre>
    <p>Esta función <codeinline>not()</codeinline> es una función de orden superior porque toma un argumento de función y devuelve una nueva función. Como otro ejemplo, considere la función <codeinline>mapper()</codeinline> que sigue. Toma un argumento de función y devuelve una nueva función que mapea una matriz a otra utilizando esa función. Esta función utiliza la función <codeinline>map()</codeinline> definida anteriormente, y es importante que entiendas en qué se diferencian ambas funciones:</p>
    <pre>
    <code class="language-js">// Devuelve una función que espera un argumento de matriz y aplica f 
    // a cada elemento, devolviendo la matriz de valores de retorno. 
    // Compárese con la función map() de antes.
    function mapper(f) &lbrace;
      return a => map(a, f);
    }

    const increment = x => x+1;
    const incrementAll = mapper(increment);
    incrementAll([1,2,3]) // => [2,3,4]</code></pre>
    <p>He aquí otro ejemplo más general que toma dos funciones, <codeinline>f</codeinline> y <codeinline>g</codeinline>, y devuelve una nueva función que calcula <codeinline>f(g())</codeinline>:</p>
    <pre>
    <code class="language-js">// Devuelve una nueva función que calcula f(g(...)).
    // La ​​función devuelta h pasa todos sus argumentos a g, luego pasa 
    // el valor de retorno de g a f y luego devuelve el valor de retorno de f.
    // Tanto f como g se invocan con el mismo valor this con el que se invocó h.
    function compose(f, g) &lbrace;
      return function(...args) &lbrace;
      // Usamos call para f porque estamos pasando un solo valor y 
      // apply para g porque estamos pasando una matriz de valores.
        return f.call(this, g.apply(this, args));
      };
    }
    const sum = (x,y) => x+y;
    const square = x => x*x;
    compose(square, sum)(2,3) // => 25; el cuadrado de la suma</code></pre>
    <p>Las funciones <codeinline>partial()</codeinline> y <codeinline>memoize()</codeinline> definidas en las secciones siguientes son dos funciones de orden superior más importantes.</p>
  </section>
  <section id="8-3">
    <h2>8.8.3 Aplicación parcial de funciones</h2>
    <p>El método <codeinline>bind()</codeinline> de una función <codeinline>f</codeinline> (véase <a href="#7-5">§8.7.5</a>) devuelve una nueva función que invoca a <codeinline>f</codeinline> en un contexto especificado y con un conjunto especificado de argumentos. Decimos que vincula la función a un objeto y aplica parcialmente los argumentos. El método <codeinline>bind()</codeinline> aplica parcialmente los argumentos por la izquierda, es decir, los argumentos que se pasan a <codeinline>bind()</codeinline> se colocan al principio de la lista de argumentos que se pasa a la función original. Pero también es posible aplicar parcialmente los argumentos por la derecha:</p>
    <pre>
    <code class="language-js">// Los argumentos de esta función se pasan a la izquierda.
    function partialLeft(f, ...outerArgs) &lbrace;
      return function(...innerArgs) &lbrace;            // Devuelve esta función
        let args = [...outerArgs, ...innerArgs]; // Construir la lista de argumentos
        return f.apply(this, args);              // Luego invoca f con él
      };
    }

    // Los argumentos de esta función se pasan a la derecha.
    function partialRight(f, ...outerArgs) &lbrace;
      return function(...innerArgs) &lbrace;            // Devuelve esta función
        let args = [...innerArgs, ...outerArgs]; // Construir la lista de argumentos
        return f.apply(this, args);              // Luego invoca f con él
      };
    }

    // Los argumentos de esta función sirven como plantilla. Los valores no 
    // definidos en la lista de argumentos se completan con valores del conjunto interno.
    function partial(f, ...outerArgs) &lbrace;
      return function(...innerArgs) &lbrace;
        let args = [...outerArgs]; // copia local de la plantilla de argumentos externos
        let innerIndex=0;          // ¿Cuál es el siguiente argumento interno?
        // Recorre los argumentos y completa los valores no definidos con los argumentos internos
        for(let i = 0; i &lt; args.length; i++) &lbrace;
          if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
        }
        // Ahora agregue cualquier argumento interno restante
        args.push(...innerArgs.slice(innerIndex));
        return f.apply(this, args);
      };
    }

    // Aquí hay una función con tres argumentos.
    const f = function(x,y,z) &lbrace; return x * (y - z); };
    // Observe cómo difieren estas tres aplicaciones parciales
    partialLeft(f, 2)(3,4)        // => -2: Vincular el primer argumento: 2 * (3 - 4)
    partialRight(f, 2)(3,4)       // => 6: Vincular el último argumento: 3 * (4 - 2)
    partial(f, undefined, 2)(3,4) // => -6: Vincular argumento intermedio: 3 * (2 - 4)</code></pre>
    <p>Estas funciones de aplicación parcial nos permiten definir fácilmente funciones interesantes a partir de funciones que ya tenemos definidas. He aquí algunos ejemplos:</p>
    <pre>
    <code class="language-js">const increment = partialLeft(sum, 1);
    const cuberoot = partialRight(Math.pow, 1/3);
    cuberoot(increment(26)) // => 3</code></pre>
    <p>La aplicación parcial se vuelve aún más interesante cuando la combinamos con otras funciones de orden superior. He aquí, por ejemplo, una forma de definir la función precedente <codeinline>not()</codeinline> que acabamos de mostrar utilizando la composición y la aplicación parcial:</p>
    <pre>
    <code class="language-js">const not = partialLeft(compose, x => !x);
    const even = x => x % 2 === 0;
    const odd = not(even);
    const isNumber = not(isNaN);
    odd(3) && isNumber(2) // => true</code></pre>
    <p>También podemos utilizar la composición y la aplicación parcial para rehacer nuestros cálculos de la media y la desviación estándar en un estilo funcional extremo:</p>
    <pre>
    <code class="language-js">// Las funciones sum() y square() se definen arriba. A continuación se muestran algunas más:
    const product = (x,y) => x*y;
    const neg = partial(product, -1);
    const sqrt = partial(Math.pow, undefined, .5);
    const reciprocal = partial(Math.pow, undefined, neg(1));

    // Ahora calcule la media y la desviación estándar.
    let data = [1,1,3,5,5]; // Nuestros datos
    let mean = product(reduce(data, sum), reciprocal(data.length));
    let stddev = sqrt(product(reduce(map(data,compose(square,partial(sum, neg(mean)))),sum),
    reciprocal(sum(data.length,neg(1)))));
    [mean, stddev] // => [3, 2]</code></pre>
    <p>Nótese que este código para calcular la media y la desviación estándar es enteramente invocaciones a funciones; no hay operadores involucrados, y el número de paréntesis ha crecido tanto que este JavaScript está empezando a parecerse al código Lisp. De nuevo, este no es un estilo que yo defienda para la programación en JavaScript, pero es un ejercicio interesante para ver lo profundamente funcional que puede ser el código JavaScript.</p>
  </section>
  <section id="8-4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.8.4 Memoización</h2>
    <p>En <a href="#4-1">§8.4.1</a>, definimos una función factorial que almacenaba en caché sus resultados previamente calculados. En programación funcional, este tipo de almacenamiento en caché se denomina <em>memoización</em>. El código siguiente muestra una función de orden superior, <codeinline>memoize()</codeinline>, que acepta una función como argumento y devuelve una versión memoizada de la función:</p>
    <pre>
    <code class="language-js">// Devuelve una versión memorizada de f.
    // Sólo funciona si todos los argumentos de f tienen representaciones de cadenas distintas.
    function memoize(f) &lbrace;
      const cache = new Map(); // Caché de valores almacenado en el cierre.

      return function(...args) &lbrace;
        // Crea una versión de cadena de los argumentos para usar como clave de caché.
        let key = args.length + args.join("+");
        if (cache.has(key)) &lbrace;
          return cache.get(key);
        } else &lbrace;
          let result = f.apply(this, args);
          cache.set(key, result);
          return result;
        }
      };
    }</code></pre>
    <p>La función <codeinline>memoize()</codeinline> crea un nuevo objeto para utilizarlo como caché y asigna este objeto a una variable local para que sea privado (en el cierre) de la función devuelta. La función devuelta convierte su matriz de argumentos en una cadena y utiliza esa cadena como nombre de propiedad para el objeto de caché. Si existe un valor en la caché, lo devuelve directamente. En caso contrario, llama a la función especificada para calcular el valor de estos argumentos, lo almacena en caché y lo devuelve. Así es como podemos utilizar <codeinline>memoize()</codeinline>:</p>
    <pre>
    <code class="language-js">// Devuelve el máximo común divisor de dos números enteros utilizando el 
    // algoritmo euclidiano: https://es.wikipedia.org/wiki/Algoritmo_de_Euclides
    function gcd(a,b) &lbrace;  // Se ha omitido la comprobación de tipos para a y b
      if (a &lt; b) &lbrace;       // Asegúrese de que a >= b cuando comenzamos
        [a, b] = [b, a]; // Asignación de desestructuración para intercambiar variables
      }
      while(b !== 0) &lbrace;   // Este es el algoritmo de Euclides para MCD
        [a, b] = [b, a%b];
      }
      return a;
    }

    const gcdmemo = memoize(gcd);
    gcdmemo(85, 187)    // => 17
    
    // Tenga en cuenta que cuando escribimos una función recursiva que vamos a memorizar, 
    // generalmente queremos recurrir a la versión memorizada, no a la original.
    const factorial = memoize(function(n) &lbrace;
      return (n &lt;= 1) ? 1 : n * factorial(n-1);
    });
    factorial(5)        // => 120: also caches values for 4, 3, 2 and 1.</code></pre>
  </section>
  <section id="9" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>8.9 Resumen</h2>
    <p>Algunos puntos clave que conviene recordar sobre este capítulo son los siguientes:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede definir funciones con la palabra clave <codeinline>function</codeinline> y con la sintaxis de flecha <codeinline>=&gt;</codeinline> de ES6.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede invocar funciones, que pueden utilizarse como métodos y constructores.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Algunas funciones de ES6 permiten definir valores por defecto para parámetros de función opcionales, reunir varios argumentos en una matriz mediante un parámetro rest y desestructurar argumentos de objetos y matrices en parámetros de función.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Puede utilizar el operador de extensión <codeinline>...</codeinline> para pasar los elementos de una matriz u otro objeto iterable como argumentos en una invocación de función.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Una función definida dentro de una función envolvente y devuelta por ésta conserva el acceso a su ámbito léxico y, por tanto, puede leer y escribir las variables definidas dentro de la función externa. Las funciones utilizadas de este modo se denominan <em>closures</em>, y se trata de una técnica que merece la pena comprender.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las funciones son objetos que pueden ser manipulados por JavaScript, y esto permite un estilo funcional de programación.
        </p>
      </li>
    </ul>
  </section>
</Layoutjavascript>