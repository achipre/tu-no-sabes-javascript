---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-7" capSiguiente="capitulo-9" />
  <section class="fadeIn">
    <h1>Funciones</h1>
    <p>Este capítulo trata sobre las funciones de JavaScript. Las funciones son un bloque de construcción fundamental para los programas JavaScript y una característica común en casi todos los lenguajes de programación. Puede que ya estés familiarizado con el concepto de función bajo un nombre como <em>subrutina</em> o <em>procedimiento</em>.</p>
    <p>Una <em>función</em> es un bloque de código JavaScript que se define una vez, pero que puede ejecutarse o <em>invocarse</em> tantas veces como se desee. Las funciones JavaScript están <em>parametrizadas</em>: la definición de una función puede incluir una lista de identificadores, conocidos como <em>parámetros</em>, que funcionan como variables locales para el cuerpo de la función. Las invocaciones de funciones proporcionan valores, o <em>argumentos</em>, para los parámetros de la función. Las funciones suelen utilizar los valores de sus argumentos para calcular un <em>valor de retorno</em> que se convierte en el valor de la expresión de invocación de la función. Además de los argumentos, cada invocación tiene otro valor, el <em>contexto de invocación</em>, que es el valor de la palabra clave <codeinline>this</codeinline>.</p>
    <p>Si una función se asigna a una propiedad de un objeto, se denomina <em>método</em> de ese objeto. Cuando una función es invocada <em>sobre</em> o <em>a través</em> de un objeto, ese objeto es el contexto de invocación o el valor <codeinline>this</codeinline> para la función. Las funciones diseñadas para inicializar un objeto recién creado se llaman <em>constructores</em>. Los constructores se describieron en <a href="capitulo-6#2">§6.2</a> y se tratarán de nuevo en el <a href="capitulo-9">Capítulo 9</a>.</p>
    <p>En JavaScript, las funciones son objetos y pueden ser manipuladas por los programas. Java Script puede asignar funciones a variables y pasarlas a otras funciones, por ejemplo. Como las funciones son objetos, se les pueden asignar propiedades e incluso invocar métodos.</p>
    <p>Las definiciones de funciones JavaScript pueden anidarse dentro de otras funciones, y tienen acceso a cualquier variable que esté en el ámbito en el que se definen. Esto significa que las funciones JavaScript son <em>closures</em>, y permite importantes y potentes técnicas de programación.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>8.1 Definición de funciones</h2>
    <p>La forma más sencilla de definir una función JavaScript es con la palabra clave <codeinline>function</codeinline>, que puede utilizarse como declaración o como expresión. ES6 define una nueva forma importante de definir funciones sin la palabra clave <codeinline>function</codeinline>: las "funciones flecha" tienen una sintaxis particularmente compacta y son útiles cuando se pasa una función como argumento a otra función. Las subsecciones siguientes cubren estas tres formas de definir funciones. Tenga en cuenta que algunos detalles de la sintaxis de definición de funciones que implican parámetros de función se posponen a <a href="#3">§8.3</a>.</p>
    <p>En los literales de objeto y en las definiciones de clase, existe una cómoda sintaxis abreviada para definir métodos. Esta sintaxis abreviada se trató en <a href="capitulo-6#10-5">§6.10.5</a> y es equivalente a utilizar una expresión de definición de función y asignarla a una propiedad de objeto utilizando la sintaxis literal de objeto básica <codeinline>name:value</codeinline>. En otro caso especial, puede utilizar las palabras clave <codeinline>get</codeinline> y <codeinline>set</codeinline> en los literales de objeto para definir métodos getter y setter de propiedades especiales. Esta sintaxis de definición de función se trató en <a href="capitulo-6#10-6">§6.10.6</a>.</p>
    <p>Tenga en cuenta que las funciones también pueden definirse con el constructor <codeinline>Function()</codeinline>, que es el tema de <a href="capitulo-8#7-7">§8.7.7</a>. Además, JavaScript define algunos tipos especializados de funciones. <codeinline>function*</codeinline> define funciones generadoras (véase el <a href="capitulo-12">Capítulo 12</a>) y <codeinline>async function</codeinline> define funciones asíncronas (véase el <a href="capitulo-13">Capítulo 13</a>).</p>
  </section>
  <section id="1-1">
    <h2>8.1.1 Declaraciones de funciones</h2>
    <p>Las declaraciones de funciones constan de la palabra clave <codeinline>function</codeinline>, seguida de estos componentes:</p>
    <ul>
      <li class="font-normal">Identificador que da nombre a la función. El nombre es una parte obligatoria de las declaraciones de función: se utiliza como nombre de una variable, y el objeto de función recién definido se asigna a la variable.</li>
      <li class="font-normal">Un par de paréntesis alrededor de una lista separada por comas de cero o más identificadores. Estos identificadores son los nombres de los parámetros de la función y se comportan como variables locales dentro del cuerpo de la función.</li>
      <li class="font-normal">Un par de llaves con cero o más sentencias JavaScript en su interior. Estas sentencias son el cuerpo de la función: se ejecutan cada vez que se invoca la función.</li>
    </ul>
    <p>He aquí algunos ejemplos de declaración de funciones:</p>
    <pre>
    <code class="language-js">// Imprime el nombre y el valor de cada propiedad de o. Retorna undefined.
    function printprops(o) &lbrace;
      for(let p in o) &lbrace;
        console.log(`$&lbrace;p}: $&lbrace;o[p]}\n`);
      }
    }

    // Calcula la distancia entre el punto (x1,y1) y el punto (x2,y2)
    function distance(x1, y1, x2, y2) &lbrace;
      let dx = x2 - x1;
      let dy = y2 - y1;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // Una función recursiva (que se llama a si misma) que calcula factoriales
    // Recordemos que x! es el producto de x por todos los números menores que x
    function factorial(x) &lbrace;
      if (x &lt;= 1) return 1;
      return x * factorial(x-1);
    }</code></pre>
    <p>Una de las cosas importantes que hay que entender sobre las declaraciones de función es que el nombre de la función se convierte en una variable cuyo valor es la propia función. Las declaraciones de función se "elevan" a la parte superior del script, función o bloque que las contiene, de modo que las funciones definidas de este modo pueden invocarse desde el código que aparece antes de la definición. Otra forma de decir esto es que todas las funciones declaradas en un bloque de código JavaScript se definirán a lo largo de ese bloque, y se definirán antes de que el intérprete de JavaScript comience a ejecutar cualquiera de los códigos de ese bloque.</p>
    <p>Las funciones <codeinline>distancia()</codeinline> y <codeinline>factorial()</codeinline> que hemos descrito están diseñadas para calcular un valor, y utilizan return para devolver ese valor a su invocador. La sentencia <codeinline>return</codeinline> hace que la función deje de ejecutarse y devuelva el valor de su expresión (si existe) a quien la llama. Si la sentencia return no tiene una expresión asociada, el valor de retorno de la función es <codeinline>undefined</codeinline>.</p>
    <p>La función <codeinline>printprops()</codeinline> es diferente: su trabajo es mostrar los nombres y valores de las propiedades de un objeto. No es necesario un valor de retorno, y la función no incluye una sentencia return. El valor de una invocación de la función <codeinline>printprops()</codeinline> es siempre <codeinline>undefined</codeinline>. Si una función no contiene una sentencia <codeinline>return</codeinline>, simplemente ejecuta cada sentencia en el cuerpo de la función hasta que llega al final, y devuelve el valor <codeinline>undefined</codeinline> a la persona que la invoca.</p>
    <p>Antes de ES6, las declaraciones de funciones sólo se permitían en el nivel superior dentro de un archivo Java-Script o dentro de otra función. Aunque algunas implementaciones se saltaban la norma, técnicamente no era legal definir funciones dentro del cuerpo de bucles, condicionales u otros bloques. Sin embargo, en el modo estricto de ES6, las declaraciones de funciones están permitidas dentro de los bloques. Una función definida dentro de un bloque sólo existe dentro de ese bloque, sin embargo, y no es visible fuera del bloque.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>8.1.2 Expresiones de función</h2>
    <p>Las expresiones de función se parecen mucho a las declaraciones de función, pero aparecen en el contexto de una expresión o sentencia más amplia, y el nombre es opcional. He aquí algunos ejemplos de expresiones de función:</p>
    <pre>
    <code class="language-js">// Esta función eleva al cuadrado su argumento.
    // Ten en cuenta que lo asignamos a una variable.
    const cuadrado = function(x) &lbrace; return x*x; };

    // La expresión de función pueden incluir nombres lo cual es útil para la recursividad.
    const f = function fact(x) &lbrace; if (x &lt;= 1) return 1; else return x*fact(x-1); };
    
    // La expresión de función también puede ser utilizada como argumento a otras funciones:
    [3,2,1].sort(function(a,b) &lbrace; return a-b; });
    
    // La expresión de función a veces se definen e invocan inmediatamente:
    let diezalcuadrado = (function(x) &lbrace;return x*x;}(10));</code></pre>
    <p>Tenga en cuenta que el nombre de la función es opcional para las funciones definidas como expresiones, y la mayoría de las expresiones de función anteriores que hemos mostrado lo omiten. En realidad, una declaración de función <em>declara</em> una variable y le asigna un objeto de función. Una expresión de función, por otro lado, no declara una variable: depende de usted asignar el objeto de función recién definido a una constante o variable si va a necesitar referirse a él varias veces. Es una buena práctica utilizar <codeinline>const</codeinline> con expresiones de función para no sobrescribir accidentalmente las funciones asignando nuevos valores.</p>
    <p>Se permite un nombre para funciones, como la función factorial, que necesitan referirse a sí mismas. Si una expresión de función incluye un nombre, el ámbito local de la función para esa función incluirá un enlace de ese nombre al objeto de función. En efecto, el nombre de la función se convierte en una variable local dentro de la función. La mayoría de las funciones definidas como expresiones no necesitan nombres, lo que hace que su definición sea más compacta (aunque no tanto como las funciones de flecha, que se describen más adelante).</p>
    <p>Hay una diferencia importante entre definir una función <codeinline>f()</codeinline> con una declaración de función y asignar una función a la variable <codeinline>f</codeinline> después de crearla como una expresión. Cuando se utiliza la forma de declaración, los objetos de función se crean antes de que el código que los contiene comience a ejecutarse, y las definiciones se elevan para que pueda llamar a estas funciones desde el código que aparece sobre la sentencia de definición. Sin embargo, esto no es cierto para las funciones definidas como expresiones: estas funciones no existen hasta que la expresión que las define se evalúa realmente. Además, para invocar una función, hay que poder referirse a ella, y no se puede referir a una función definida como expresión hasta que se asigna a una variable, por lo que las funciones definidas con expresiones no pueden invocarse antes de ser definidas.</p>
  </section>
  <section id="1-3">
    <h2>8.1.3 Funciones flecha</h2>
    <p>En ES6, puede definir funciones utilizando una sintaxis particularmente compacta conocida como "funciones de flecha". Esta sintaxis recuerda a la notación matemática y utiliza una "flecha" <codeinline>=></codeinline> para separar los parámetros de la función del cuerpo de la misma. No se utiliza la palabra clave <codeinline>function</codeinline> y, dado que las funciones en flecha son expresiones en lugar de sentencias, tampoco es necesario un nombre de función. La forma general de una función de flecha es una lista de parámetros separados por comas entre paréntesis, seguida de la flecha <codeinline>=></codeinline> y el cuerpo de la función entre llaves:</p>
    <pre>
    <code class="language-js">const sum = (x, y) => &lbrace; return x + y; };</code></pre>
    <p>Pero las funciones de flecha admiten una sintaxis aún más compacta. Si el cuerpo de la función es una única sentencia <codeinline>return</codeinline>, puede omitir la palabra clave <codeinline>return</codeinline>, el punto y coma que la acompaña y las llaves, y escribir el cuerpo de la función como la expresión cuyo valor se va a devolver:</p>
    <pre>
    <code class="language-js">const sum = (x, y) => x + y;</code></pre>
    <p>Además, si una función de flecha tiene exactamente un parámetro, puede omitir los paréntesis alrededor de la lista de parámetros:</p>
    <pre>
    <code class="language-js">const polynomial = x => x*x + 2*x + 3;</code></pre>
    <p>Tenga en cuenta, sin embargo, que una función de flecha sin argumentos debe escribirse con un par de paréntesis vacíos:</p>
    <pre>
    <code class="language-js">const constantFunc = () => 42;</code></pre>
    <p>Tenga en cuenta que, al escribir una función de flecha, no debe poner una nueva línea entre los parámetros de la función y la flecha <codeinline>=></codeinline>. De lo contrario, podría terminar con una línea como <codeinline>const polinomio = x</codeinline>, que es una sentencia de asignación sintácticamente válida por sí misma.</p>
    <p>Además, si el cuerpo de la función de flecha es una única sentencia <codeinline>return</codeinline>, pero la expresión que se devuelve es un literal de objeto, hay que poner el literal de objeto entre paréntesis para evitar la ambigüedad sintáctica entre las llaves de un cuerpo de función y las llaves de un literal de objeto:</p>
    <pre>
    <code class="language-js">const f = x => &lbrace; return &lbrace; value: x }; }; // Good: f() retorna un objeto
    const g = x => (&lbrace; value: x });           // Good: g() retorna un objeto
    const h = x => &lbrace; value: x };             // Bad: h() no retorna nada
    const i = x => &lbrace; v: x, w: x };           // Bad: Syntax Error</code></pre>
    <p>En la tercera línea de este código, la función <codeinline>h()</codeinline> es realmente ambigua: el código que pretendía ser un literal de objeto puede ser interpretado como una sentencia etiquetada, por lo que se crea una función que devuelve indefinido. En la cuarta línea, sin embargo, el literal de objeto más complicado no es una sentencia válida, y este código ilegal causa un error de sintaxis.</p>
    <p>La sintaxis concisa de las funciones de flecha las hace ideales cuando se necesita pasar una función a otra función, que es algo común de hacer con métodos de array como <codeinline>map()</codeinline>, <codeinline>filter()</codeinline>, y <codeinline>reduce()</codeinline> (ver <a href="capitulo-7#8-1">§7.8.1</a>), por ejemplo:</p>
    <pre>
    <code class="language-js">// Hacer una copia de un array con elementos nulos eliminados.
    let filtered = [1,null,2,3].filter(x => x !== null); // filtered == [1,2,3]
    // Elevar al cuadrado algunos números:
    let squares = [1,2,3,4].map(x => x*x); // squares == [1,4,9,16]</code></pre>
    <p>Las funciones flecha difieren de las funciones definidas de otras formas en un aspecto crítico: heredan el valor de la palabra clave <codeinline>this</codeinline> del entorno en el que se definen en lugar de definir su propio contexto de invocación como hacen las funciones definidas de otras formas. Esta es una característica importante y muy útil de las funciones flecha, y volveremos a ella más adelante en este capítulo. Las funciones flecha también se diferencian de otras funciones en que no tienen una propiedad <codeinline>prototype</codeinline>, lo que significa que no pueden utilizarse como funciones constructoras de nuevas clases (véase <a href="capitulo-9#2">§9.2</a>).</p>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.1.4 Funciones anidadas</h2>
    <p>En JavaScript, las funciones pueden estar anidadas dentro de otras funciones. Por ejemplo:</p>
    <pre>
    <code class="language-js">function hypotenuse(a, b) &lbrace;
      function square(x) &lbrace; return x*x; }
      return Math.sqrt(square(a) + square(b));
    }</code></pre>
    <p>Lo interesante de las funciones anidadas son sus reglas de alcance de variables: pueden acceder a los parámetros y variables de la función (o funciones) en la que están anidadas. En el código que se muestra aquí, por ejemplo, la función interna <codeinline>square()</codeinline> puede leer y escribir los parámetros <codeinline>a</codeinline> y <codeinline>b</codeinline> definidos por la función externa <codeinline>hypotenuse()</codeinline>. Estas reglas de ámbito para las funciones anidadas son muy importantes, y las volveremos a considerar en <a href="#6">§8.6</a>.</p>
  </section>
  <section id="2">
    <h2>8.2 Invocación de funciones</h2>
    <p>El código JavaScript que compone el cuerpo de una función no se ejecuta cuando se
      define la función, sino cuando se invoca. Las funciones JavaScript pueden invocarse
      de cinco maneras:</p>
    <ul>
      <li class="font-normal">Como funciones</li>
      <li class="font-normal">Como métodos</li>
      <li class="font-normal">Como constructores</li>
      <li class="font-normal">Indirectamente a través de sus métodos <codeinline>call()</codeinline> y <codeinline>apply()</codeinline></li>
      <li class="font-normal">Implícitamente, mediante funciones de</li>
    </ul>
  </section>
  <section id="2-1" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2 Invocación de funciones</h2>
    <p>Las funciones se invocan como funciones o como métodos con una expresión deinvocación (<a href="capitulo-4#5">§4.5</a>). Una expresión de invocación consiste en una expresión de funciónque se evalúa a un objeto de función seguida de un paréntesis abierto, una listaseparada por comas de cero o más expresiones de argumento y un paréntesis cerrado.Si la expresión de función es una expresión de acceso a una propiedad (si la funciónes la propiedad de un objeto o un elemento de una matriz), se trata de una expresiónde invocación a un método. Ese caso se explicará en el siguiente ejemplo. El siguientecódigo incluye una serie de expresiones regulares de invocación de funciones:</p>
    <pre>
    <code class="language-js">printprops(&lbrace;x: 1});
    let total = distance(0,0,2,1) + distance(2,1,3,5);
    let probability = factorial(5)/factorial(13);</code></pre>
    <p>En una invocación, se evalúa cada expresión del argumento (las que están entreparéntesis) y los valores resultantes se convierten en los argumentos de la función.Estos valores se asignan a los parámetros nombrados en la definición de la función.En el cuerpo de la función, una referencia a un parámetro se evalúa al valor delargumento correspondiente.</p>
    <p>Para la invocación regular de funciones, el valor de retorno de la función se convierteen el valor de la expresión de invocación. Si la función retorna porque el intérpretellega al final, el valor de retorno es <codeinline>undefined</codeinline>. Si la función retorna porque elintérprete ejecuta una sentencia <codeinline>return</codeinline>, entonces el valor de retorno es elvalor de la expresión que sigue al <codeinline>return</codeinline> o es <codeinline>undefined</codeinline> si la sentencia <codeinline>return</codeinline> no tiene valor.</p>
    <article>
      <p class="title-article">Invocación condicional</p>
      <p>En ES2020 puede insertar <codeinline>?.</codeinline> después de la expresión de la función y antes de laparéntesis abierta en una invocación de función para invocar la función sólo si no es <codeinline>null</codeinline> o <codeinline>undefined</codeinline>. Es decir, la expresión <codeinline>f?.(x)</codeinline> es equivalente (suponiendo que nohaya efectos secundarios) a:</p>
    <pre>
    <code class="language-js">(f !== null && f !== undefined) ? f(x) : undefined</code></pre>
      <p>Encontrará más detalles sobre esta sintaxis de invocación condicional en <a href="capitulo-4#5-1">§4.5.1</a>.</p>
    </article>
    <p>Para la invocación de funciones en modo no estricto, el contexto de invocación (elvalor <codeinline>this</codeinline>) es el objeto global. En modo estricto, sin embargo, el contexto deinvocación es <codeinline>undefined</codeinline>. Tenga en cuenta que las funciones definidas utilizando lasintaxis de flecha se comportan de manera diferente: siempre heredan el valor <codeinline>this</codeinline> que está en vigor donde se definen.</p>
    <p>Las funciones escritas para ser invocadas como funciones (y no como métodos) nosuelen utilizar la palabra clave <codeinline>this</codeinline>. Sin embargo, esta palabra clave puede utilizarse para determinar si el modo estricto está activado:</p>
    <pre>
    <code class="language-js">// Define e invoca una función para determinar si el modo estricto está activado
    const strict = (function() &lbrace; return !this; }());</code></pre>
    <article>
      <p class="title-article">Funciones recursivas y pila</p>
      <p>Una función <em>recursiva</em> es aquella, como la función <codeinline>factorial()</codeinline> del principio de estecapítulo, que se llama a sí misma. Algunos algoritmos, como los que implicanestructuras de datos basadas en árboles, pueden implementarse de formaparticularmente elegante con funciones recursivas. Al escribir una función recursiva,sin embargo, es importante pensar en las restricciones de memoria. Cuando unafunción A llama a la función B y, a continuación, la función B llama a la función C, elintérprete de Java Script debe realizar un seguimiento de los contextos de ejecuciónde las tres funciones. Cuando la función C finaliza, el intérprete necesita saber dóndereanudar la ejecución de la función B, y cuando la función B finaliza, necesita saberdónde reanudar la ejecución de la función A. Puede imaginar estos contextos deejecución como una pila. Cuando una función llama a otra función, un nuevocontexto de ejecución es introducido en la pila. Cuando esa función retorna, sucontexto de ejecución es retirado de la pila. Si una función se llama a sí mismarecursivamente 100 veces, la pila tendrá 100 objetos introducidos en ella, y luego esos100 objetos serán retirados. Esta pila de llamadas ocupa memoria. En el hardwaremoderno, normalmente está bien escribir funciones recursivas que se llamen a símismas cientos de veces. Pero si una función se llama a sí misma diez mil veces, esprobable que falle con un error como "Maximum call-stack size exceeded".</p>
    </article>
  </section>
  <section id="2-2">
    <h2>8.2.2 Invocación de métodos</h2>
    <p>Un <em>método</em> no es más que una función JavaScript que se almacena en una propiedad de un objeto. Si tienes una función <codeinline>f</codeinline> y un objeto <codeinline>o</codeinline>, puedes definir un método llamado <codeinline>m</codeinline> de <codeinline>o</codeinline> con la siguiente línea:</p>
    <pre>
    <code class="language-js">o.m = f;</code></pre>
    <p>Una vez definido el método <codeinline>m()</codeinline> del objeto <codeinline>o</codeinline>, invócalo así:</p>
    <pre>
    <code class="language-js">o.m();</code></pre>
    <p>O, si <codeinline>m()</codeinline> espera dos argumentos, podrías invocarla así:</p>
    <pre>
    <code class="language-js">o.m(x, y);</code></pre>
    <p>El código de este ejemplo es una expresión de invocación: incluye una expresión de función <codeinline>o.m</codeinline> y dos expresiones de argumento, <codeinline>x</codeinline> e <codeinline>y</codeinline>. La expresión de función es en sí misma una expresión de acceso a propiedades, lo que significa que la función se invoca como un método y no como una función normal.</p>
    <p>Los argumentos y el valor de retorno de una invocación de método se tratan exactamente igual que en el caso de una invocación de función normal. Sin embargo, las invocaciones a métodos difieren de las invocaciones a funciones en un aspecto importante: el contexto de invocación. Las expresiones de acceso a propiedades constan de dos partes: un objeto (en este caso <codeinline>o</codeinline>) y un nombre de propiedad (<codeinline>m</codeinline>). En una expresión de invocación de método como ésta, el objeto <codeinline>o</codeinline> se convierte en el contexto de invocación, y el cuerpo de la función puede referirse a ese objeto utilizando la palabra clave <codeinline>this</codeinline>. He aquí un ejemplo concreto:</p>
    <pre>
    <code class="language-js">let calculator = &lbrace; // Un objeto literal
      operand1: 1,
      operand2: 1,
      add() &lbrace; // Estamos usando la sintaxis abreviada de métodos para esta función.
        // Notese el uso de la palabra clave this para referirse al objeto contenedor.
        this.result = this.operand1 + this.operand2;
      }
    };
    calculator.add(); // Una invocación al método para calcular 1+1.
    calculator.result // => 2</code></pre>
    <p>La mayoría de las invocaciones de métodos utilizan la notación de punto para el acceso a propiedades, pero las expresiones de acceso a propiedades que utilizan corchetes también provocan la invocación de métodos. Por ejemplo, las siguientes son invocaciones de métodos:</p>
    <pre>
    <code class="language-js">o["m"](x,y); // Otra forma de escribir a m[o](x,y).
    a[0](z)      // Tambien una invocación a un método (suponiendo que a[0] es una función).</code></pre>
    <p>Las invocaciones de métodos también pueden implicar expresiones de acceso a propiedades más complejas:</p>
    <pre>
    <code class="language-js">customer.surname.toUpperCase(); // Invoca el método en customer.surname
    f().m(); // Invoca el método m() en el retorno de f().</code></pre>
    <p>Los métodos y la palabra clave <codeinline>this</codeinline> son fundamentales en el paradigma de la programación orientada a objetos. A cualquier función que se utilice como método se le pasa un argumento implícito: el objeto a través del cual se invoca. Típicamente, un método realiza algún tipo de operación sobre ese objeto, y la sintaxis de invocación de método es una forma elegante de expresar el hecho de que una función está operando sobre un objeto. Compare las dos líneas siguientes:</p>
    <pre>
    <code class="language-js">rect.setSize(width, height);
    setRectSize(rect, width, height);</code></pre>
    <p>Las hipotéticas funciones invocadas en estas dos líneas de código pueden realizar exactamente la misma operación sobre el (hipotético) objeto <codeinline>rect</codeinline>, pero la sintaxis método-invocación de la primera línea indica más claramente la idea de que es el objeto <codeinline>rect</codeinline> el foco principal de la operación.</p>
    <article>
      <p class="title-article">Encadenamiento de métodos</p>
      <p>Cuando los métodos devuelven objetos, puede utilizar el valor de retorno de una invocación de método como parte de una invocación posterior. Esto da como resultado una serie (o "cadena") de invocaciones a métodos como una única expresión. Cuando se trabaja con operaciones asíncronas basadas en promesas (véase el <a href="capitulo-13">Capítulo 13</a>), por ejemplo, es habitual escribir código estructurado de este modo:</p>
    <pre>
    <code class="language-js">// Corre tres operaciones asíncronas. Maneja errores.
    doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);</code></pre>
      <p>Cuando escriba un método que no tenga un valor de retorno propio, considere la posibilidad de que el método devuelva <codeinline>this</codeinline>. Si hace esto de forma consistente en toda su API, habilitará un estilo de programación conocido como <em>encadenamiento de métodos</em><sup>1</sup> en el que un objeto puede nombrarse una vez y luego pueden invocarse múltiples métodos sobre él:</p>
    <pre>
    <code class="language-js">new Square().x(100).y(100).size(50).outline("red").fill("blue").draw();</code></pre>
    </article>
    <p>Tenga en cuenta que <codeinline>this</codeinline> se trata de una palabra clave, no de un nombre de variable o propiedad. La sintaxis de JavaScript no permite asignarle un valor <codeinline>this</codeinline>.</p>
    <p>La palabra clave <codeinline>this</codeinline> no tiene el mismo ámbito que las variables y, excepto en el caso de las funciones flecha, las funciones anidadas no heredan el valor <codeinline>this</codeinline> de la función que las contiene. Si una función anidada es invocada como un método, su valor <codeinline>this</codeinline> es el objeto sobre el que fue invocada. Si una función anidada (que no es una función de flecha) se invoca como una función, su valor <codeinline>this</codeinline> será el objeto global (modo no estricto) o <codeinline>undefined</codeinline> (modo estricto). Es un error común asumir que una función anidada definida dentro de un método e invocada como función puede utilizar <codeinline>this</codeinline> para obtener el contexto de invocación del método. El siguiente código demuestra el problema:</p>
    <pre>
    <code class="language-js">let o = &lbrace;            // Un objeto o.
      m: function() &lbrace;    // El método m del objeto.
        let self = this; // Guarda el valor "this" en una variable.
        this === o       // => true: "this" es un objeto o.
        f();             // Ahora llama a la función auxiliar f().

        function f() &lbrace;   // Una función anidada f
          this === o     // => false: "this" es global o undefined
          self === o     // => true: self es el valor "this" exterior.
        }
      }
    };
    o.m();               // Invoca el método m en el objeto o.</code></pre>
    <p>Dentro de la función anidada <codeinline>f()</codeinline>, la palabra clave <codeinline>this</codeinline> no es igual al objeto <codeinline>o</codeinline>. Esto es ampliamente considerado como un fallo en el lenguaje JavaScript, y es importante ser consciente de ello. El código anterior muestra una solución común. Dentro del método <codeinline>m</codeinline>, asignamos el valor <codeinline>this</codeinline> a una variable <codeinline>self</codeinline>, y dentro de la función anidada <codeinline>f</codeinline>, podemos usar <codeinline>self</codeinline> en lugar de <codeinline>this</codeinline> para referirnos al objeto contenedor.</p>
    <p>En ES6 y posteriores, otra solución a este problema es convertir la función anidada <codeinline>f</codeinline> en una función de flecha, que heredará correctamente este valor:</p>
    <pre>
    <code class="language-js">const f = () => &lbrace;
      this === o // true, ya que las funciones flechas heredan this.
    };</code></pre>
    <p>Las funciones definidas como expresiones en lugar de sentencias no son hoisted, por lo que para que este código funcione, la definición de función para <codeinline>f</codeinline> tendrá que ser movida dentro del método <codeinline>m</codeinline> para que aparezca antes de ser invocado.</p>
    <p>Otra solución consiste en invocar el método <codeinline>bind()</codeinline> de la función anidada para definir una nueva función que se invoque implícitamente sobre un objeto especificado:</p>
    <pre>
    <code class="language-js">const f = (function() &lbrace;
      this === o // true, ya que vinculamos esta función a la externa this.
    }).bind(this);</code></pre>
    <p>Hablaremos más sobre <codeinline>bind()</codeinline> en <a href="capitulo-8#7-5">§8.7.5</a>.</p>
  </section>
  <section id="2-3" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2.3 Invocación de constructores</h2>
    <p>Si una invocación a una función o método va precedida de la palabra clave <codeinline>new</codeinline>, se trata de una invocación a un constructor. (Las invocaciones a constructores se introdujeron en <a href="capitulo-4#6">§4.6</a> y <a href="capitulo-6#2-2">§6.2.2</a>, y los constructores se tratarán con más detalle en el <a href="capitulo-9">Capítulo 9</a>.) Las invocaciones a constructores difieren de las invocaciones a funciones y métodos en su manejo de argumentos, contexto de invocación y valor de retorno.</p>
    <p>Si una invocación a un constructor incluye una lista de argumentos entre paréntesis, esas expresiones de argumentos son evaluadas y pasadas a la función de la misma forma que lo serían para las invocaciones a funciones y métodos. No es una práctica común, pero puede omitir un par de paréntesis vacíos en una invocación a un constructor. Las dos líneas siguientes, por ejemplo, son equivalentes:</p>
    <pre>
    <code class="language-js">o = new Object();
    o = new Object;</code></pre>
    <p>Una invocación a un constructor crea un nuevo objeto vacío que hereda del objeto especificado por la propiedad <codeinline>prototype</codeinline> del constructor. Las funciones constructoras están pensadas para inicializar objetos, y este objeto recién creado se utiliza como contexto de invocación, por lo que la función constructora puede referirse a él con la palabra clave <codeinline>this</codeinline>. Tenga en cuenta que el nuevo objeto se utiliza como contexto de invocación incluso si la invocación del constructor parece una invocación a un método. Es decir, en la expresión <codeinline>new o.m()</codeinline>, o no se utiliza como contexto de invocación.</p>
    <p>Las funciones constructoras no suelen utilizar la palabra clave <codeinline>return</codeinline>. Normalmente inician el nuevo objeto y luego retornan implícitamente cuando llegan al final de su cuerpo. En este caso, el nuevo objeto es el valor de la expresión de invocación del constructor. Sin embargo, si un constructor utiliza explícitamente la sentencia <codeinline>return</codeinline> para devolver un objeto, entonces ese objeto se convierte en el valor de la expresión de invocación. Si el constructor utiliza <codeinline>return</codeinline> sin ningún valor, o si devuelve un valor primitivo, ese valor de retorno se ignora y el nuevo objeto se utiliza como valor de la invocación.</p>
  </section>
  <section id="2-4">
    <h2>8.2.4 Invocación indirecta</h2>
    <p>Las funciones JavaScript son objetos y, como todos los objetos JavaScript, tienen métodos. Dos de estos métodos, <codeinline>call()</codeinline> y <codeinline>apply()</codeinline>, invocan a la función indirectamente. Ambos métodos permiten especificar explícitamente el valor <codeinline>this</codeinline> para la invocación, lo que significa que se puede invocar cualquier función como método de cualquier objeto, aunque no sea realmente un método de ese objeto. Ambos métodos también permiten especificar los argumentos de la invocación. El método <codeinline>call()</codeinline> utiliza su propia lista de argumentos como argumentos de la función, y el método <codeinline>apply()</codeinline> espera que se utilice una matriz de valores como argumentos. Los métodos <codeinline>call()</codeinline> y <codeinline>apply()</codeinline> se describen en detalle en <a href="capitulo-8#7-4">§8.7.4</a>.</p>
  </section>
  <section id="2-5" class="py-4 xs:py-5 sm:py-6">
    <h2>8.2.5 Invocación implícita de funciones</h2>
    <p>Hay varias características del lenguaje JavaScript que no parecen invocaciones de funciones pero que hacen que se invoquen funciones. Tenga mucho cuidado al escribir funciones que puedan ser invocadas implícitamente, ya que los errores, efectos secundarios y problemas de rendimiento en estas funciones son más difíciles de diagnosticar y solucionar que en las funciones normales por la sencilla razón de que puede que no sea obvio a partir de una simple inspección de su código cuándo están siendo invocadas.</p>
    <p>Las características del lenguaje que pueden causar la invocación implícita de funciones incluyen:</p>
    <ul>
      <li class="font-normal">Si un objeto tiene definidos getters o setters, entonces la consulta o el establecimiento del valor de sus propiedades puede invocar esos métodos. Para más información, véase <a href="capitulo-6#10-6">§6.10.6</a>.</li>
      <li class="font-normal">Cuando un objeto se utiliza en un contexto de cadena (como cuando se concatena con una cadena), se llama a su método <codeinline>toString()</codeinline>. Del mismo modo, cuando un objeto se utiliza en un contexto numérico, se invoca a su método <codeinline>valueOf()</codeinline>. Para más detalles, véase <a href="capitulo-3#3-9">§3.9.3</a>.</li>
      <li class="font-normal">Cuando se realiza un bucle sobre los elementos de un objeto iterable, se producen una serie de llamadas a métodos. El <a href="capitulo-12">Capítulo 12</a> explica cómo funcionan los iteradores a nivel de llamada a funciones y demuestra cómo escribir estos métodos para que puedas definir tus propios tipos de iterables.</li>
      <li class="font-normal">Un literal de plantilla etiquetado es una invocación a una función disfrazada. <a href="capitulo-14#5">§14.5</a> muestra cómo escribir funciones que pueden usarse junto con cadenas de literales de plantilla.</li>
      <li class="font-normal">Los objetos proxy (descritos en <a href="capitulo-14#7">§14.7</a>) tienen su comportamiento completamente controlado por funciones. Casi cualquier operación sobre uno de estos objetos hará que se invoque una función.</li>
    </ul>
  </section >
  <section id="3">
    <h2>8.3 Argumentos y parámetros de las funciones</h2>
    <p>Las definiciones de funciones de JavaScript no especifican un tipo esperado para los parámetros de la función, y las invocaciones de funciones no realizan ninguna comprobación de tipo en los valores de los argumentos que se pasan. De hecho, las invocaciones de funciones JavaScript ni siquiera comprueban el número de argumentos que se pasan. Las subsecciones siguientes describen lo que ocurre cuando se invoca una función con menos argumentos que los parámetros declarados o con más argumentos que los parámetros declarados. También demuestran cómo puede comprobar explícitamente el tipo de argumentos de la función si necesita asegurarse de que una función no se invoca con argumentos inadecuados.</p>
  </section>
  <section id="3-1" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.1 Parámetros opcionales y valores por defecto</h2>
    <p>Cuando se invoca una función con menos argumentos que parámetros declarados, los parámetros adicionales se fijan a su valor por defecto, que normalmente es <codeinline>undefined</codeinline>. A menudo resulta útil escribir funciones de modo que algunos argumentos sean opcionales. A continuación se ofrece un ejemplo:</p>
    <pre>
    <code class="language-js">// Añade los nombres de las enumaerable propiedades de un objeto o de
    // un array, y retorna a. Si se omite, crea y devuelve un nuevo array.
    function getPropertyNames(o, a) &lbrace;
      if (a === undefined) a = []; // Si es undefined, usa un nuevo array
      for(let property in o) a.push(property);
      return a;
    }

    // getPropertyNames() puede ser invocada con una o dos argumentos:
    let o = &lbrace;x: 1}, p = &lbrace;y: 2, z: 3}; // Dos objetos para testear
    let a = getPropertyNames(o); // a == ["x"]; Obteniendo las propiedades de o en un nuevo array
    getPropertyNames(p, a); // a == ["x","y","z"]; agrega las propiedades de p</code></pre>
    <p>En lugar de utilizar una sentencia <codeinline>if</codeinline> en la primera línea de esta función, puede utilizar el operador <codeinline>||</codeinline>. de esta forma idiomática:</p>
    <pre>
    <code class="language-js">a = a || [];</code></pre>
    <p>Recuerde de <a href="capatulo-4#10-2">§4.10.2</a> que el operador <codeinline>||</codeinline> devuelve su primer argumento si es verdadero y, en caso contrario, devuelve su segundo argumento. En este caso, si se pasa cualquier objeto como segundo argumento, la función utilizará ese objeto. Pero si el segundo argumento (o se pasa <codeinline>null</codeinline> u otro valor falso), se utilizará en su lugar una matriz vacía recién creada.</p>
    <p>Tenga en cuenta que cuando diseñe funciones con argumentos opcionales, debe asegurarse de poner los opcionales al final de la lista de argumentos para que puedan ser omitidos. El programador que llame a tu función no puede omitir el primer argumento y pasar el segundo: tendría que pasar explícitamente <codeinline>undefined</codeinline> como primer argumento.</p>
    <p>En ES6 y posteriores, puede definir un valor predeterminado para cada uno de los parámetros de la función directamente en la lista de parámetros de la función. Sólo tiene que seguir el nombre del parámetro con un signo igual y el valor por defecto a utilizar cuando no se proporciona ningún argumento para ese parámetro:</p>
    <pre>
    <code class="language-js">// Añade los nombres de las propiedades enumerables del objeto o al
    // array a, y retorna a. Si a es omitido, crea y devuelve un nuevo array.
    function getPropertyNames(o, a = []) &lbrace;
      for(let property in o) a.push(property);
      return a;
    }</code></pre>
    <p>Las expresiones de parámetros por defecto se evalúan cuando se llama a la función, no cuando se define, por lo que cada vez que se invoca a esta función <codeinline>getPropertyNames()</codeinline> con un argumento, se crea y se pasa una nueva matriz vacía.<sup>2</sup> Probablemente sea más fácil razonar sobre las funciones si los parámetros por defecto son constantes (o expresiones literales como <codeinline>[]</codeinline> y <codeinline>&lbrace;}</codeinline>). Pero esto no es necesario: puede utilizar variables, o invocaciones de funciones, por ejemplo, para calcular el valor por defecto de un parámetro. Un caso interesante es que, para funciones con múltiples parámetros, puede utilizar el valor de un parámetro anterior para definir el valor por defecto de los parámetros que le siguen:</p>
    <pre>
    <code class="language-js">// Esta funcion retorna un objeto que resenta las dimensiones de un rectangulo.
    // Si solo se proporciona un ancho, hazlo el doble de alto que de ancho.
    const rectangle = (width, height=width*2) => (&lbrace;width, height});
    rectangle(1) // => &lbrace; width: 1, height: 2 }</code></pre>
    <p>Este código demuestra que los parámetros por defecto funcionan con las funciones de flecha. Lo mismo ocurre con las funciones de método abreviado y todas las demás formas de definición de funciones.</p>
  </section>
  <section id="3-2">
    <h2>8.3.2 Parámetros restantes y listas de argumentos de longitud variable</h2>
    <p>Los parámetros por defecto nos permiten escribir funciones que pueden invocarse con menos argumentos que parámetros. Los <em>parámetros Rest</em> permiten el caso contrario: nos permiten escribir funciones que pueden invocarse con un número arbitrario de argumentos superior al de parámetros. He aquí un ejemplo de función que espera uno o más argumentos numéricos y devuelve el mayor de ellos:</p>
    <pre>
    <code class="language-js">function max(first=-Infinity, ...rest) &lbrace;
      let maxValue = first; // Empieza asumuendo que el primer argumento es el mayor
      // A continuación, realice un bucle con el resto de los argumentos, buscando los mas grandes.
      for(let n of rest) &lbrace;
        if (n > maxValue) &lbrace;
          maxValue = n;
        }
      }
      // Return the biggest
      return maxValue;
    }

    max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000</code></pre>
    <p>Un parámetro restante va precedido de tres puntos y debe ser el último parámetro de una declaración de función. Cuando se invoca una función con un parámetro restante, los argumentos que se pasan se asignan primero a los parámetros no restantes y, a continuación, los argumentos restantes (es decir, el "resto" de los argumentos) se almacenan en una matriz que se convierte en el valor del parámetro restante. Este último punto es importante: dentro del cuerpo de una función, el valor de un parámetro rest siempre será una matriz. La matriz puede estar vacía, pero un parámetro rest nunca estará <codeinline>undefined</codeinline>. (De esto se deduce que nunca es útil -y no legal- definir un parámetro por defecto para un parámetro rest).</p>
    <p>Las funciones como la del ejemplo anterior que pueden aceptar cualquier número de argumentos se denominan <em>funciones variádicas</em>, <em>funciones de aridad variable</em> o <em>funciones vararg</em>. En este libro se utiliza el término más coloquial, <em>varargs</em>, que data de los primeros días del lenguaje de programación C.</p>
    <p>No confunda el operador <codeinline>...</codeinline> que define un parámetro de reposo en una definición de función con el operador de propagación <codeinline>...</codeinline>, descrito en <a href="#3-4">§8.3.4</a>, que puede utilizarse en invocaciones de funciones.</p>
  </section>
  <section id="3-3" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.3 El objeto Arguments</h2>
    <p>Los parámetros Rest se introdujeron en JavaScript en ES6. Antes de esa versión del lenguaje, las funciones varargs se escribían utilizando el objeto Arguments: dentro del cuerpo de cualquier función, el identificador <codeinline>arguments</codeinline> hace referencia al objeto Arguments para esa invocación. El objeto Arguments es un objeto tipo array (véase <a href="capitulo-7#9">§7.9</a>) que permite recuperar los valores de los argumentos pasados a la función por número, en lugar de por nombre. Aquí está la función <codeinline>max()</codeinline> de antes, reescrita para utilizar el objeto Arguments en lugar de un parámetro rest:</p>
    <pre>
    <code class="language-js">function max(x) &lbrace;
      let maxValue = -Infinity;
      // Recorre los argumentos, buscando y recuperando el mayor.
      for(let i = 0; i &lt; arguments.length; i++) &lbrace;
        if (arguments[i] > maxValue) maxValue = arguments[i];
      }
      // Devuelve el mayor
      return maxValue;
    }

    max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000</code></pre>
    <p>El objeto Arguments se remonta a los primeros días de JavaScript y conlleva un extraño bagaje histórico que lo hace ineficiente y difícil de optimizar, especialmente fuera del modo estricto. Es posible que aún encuentres código que utilice el objeto Arguments, pero deberías evitar utilizarlo en cualquier código nuevo que escribas. Al refactorizar código antiguo, si encuentra una función que utiliza <codeinline>arguments</codeinline>, a menudo puede sustituirla por un parámetro de reposo <codeinline>...args</codeinline>. Parte del desafortunado legado del objeto Arguments es que, en modo estricto, <codeinline>arguments</codeinline> se trata como una palabra reservada, y no puedes declarar un parámetro de función o una variable local con ese nombre.</p>
  </section>
  <section id="3-4">
    <h2>8.3.4 El operador Spread para llamadas a funciones</h2>
    <p>El operador de distribución <codeinline>...</codeinline> se utiliza para descomprimir, o "distribuir", los elementos de una matriz (o cualquier otro objeto iterable, como las cadenas) en un contexto en el que se esperan valores individuales. En <a href="capitulo-7#1-2">§7.1.2</a> hemos visto cómo se utiliza el operador de distribución con los literales de matrices. El operador puede utilizarse, del mismo modo, en invocaciones a funciones:</p>
    <pre>
    <code class="language-js">let numbers = [5, 2, 10, -1, 9, 100, 1];
    Math.min(...numbers) // => -1</code></pre>
    <p>Tenga en cuenta que <codeinline>...</codeinline> no es un operador verdadero en el sentido de que no puede evaluarse para producir un valor. Se trata de una sintaxis especial de JavaScript que puede utilizarse en literales de matrices e invocaciones de funciones.</p>
    <p>Cuando utilizamos la misma sintaxis <codeinline>...</codeinline> en una definición de función en lugar de una invocación de función, tiene el efecto contrario al operador spread. Como vimos en <a href="#3-2">§8.3.2</a>, el uso de <codeinline>...</codeinline> en una definición de función reúne varios argumentos de función en una matriz. Los parámetros Rest y el operador spread son a menudo útiles juntos, como en la siguiente función, que toma un argumento de función y devuelve una versión instrumentada de la función para su comprobación:</p>
    <pre>
    <code class="language-js">// Esta función toma una función y devuelve una versión envuelta
    function timed(f) &lbrace;
      return function(...args) &lbrace; // Recoge los argumentos en un array de parametros restantes
        console.log(`Introducción función $&lbrace;f.name}`);
        let startTime = Date.now();
        try &lbrace;
          // Pasar todos nuestros argumentos a la función envuelta
          return f(...args); // Vuelve a distribuir los argumentos
        }
        finally &lbrace;
          // Antes de devolver el valor, imprime el tiempo de ejecución
          console.log(`Exiting $&lbrace;f.name} after $&lbrace;Date.now()-startTime}ms`);
        }
      };
    }

    // Calcula la suma de los números entre 1 y n por fuerza bruta
    function benchmark(n) &lbrace;
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) sum += i;
    return sum;
    }

    // Ahora invoca la version temporizada de esa funcion de prueba
    timed(benchmark)(1000000) // => 500000500000; esta es la suma de los números.</code></pre>
  </section>
  <section id="3-5" class="py-4 xs:py-5 sm:py-6">
    <h2>8.3.5 Desestructuración de argumentos de función en parámetros</h2>
    <p>Cuando se invoca una función con una lista de valores de argumentos, esos valores acaban asignándose a los parámetros declarados en la definición de la función. Esta fase inicial de la invocación de funciones se parece mucho a la asignación de variables. Por tanto, no debe sorprendernos que podamos utilizar las técnicas de asignación desestructurante (véase <a href="capitulo-3#3-10">§3.10.3</a>) con las funciones.</p>
    <p>Si defines una función que tiene nombres de parámetros entre corchetes, le estás diciendo a la función que espere que se pase un valor de matriz por cada par de corchetes. Como parte del proceso de invocación, los argumentos de la matriz se descompondrán en los parámetros nombrados individualmente. Como ejemplo, supongamos que estamos representando vectores 2D como matrices de dos números, donde el primer elemento es la coordenada X y el segundo elemento es la coordenada Y. Con esta simple estructura de datos, podríamos decir a la función que espere un valor de matriz para cada par de corchetes. Con esta simple estructura de datos, podríamos escribir la siguiente función para sumar dos vectores:</p>
    <pre>
    <code class="language-js">function vectorAdd(v1, v2) &lbrace;
    return [v1[0] + v2[0], v1[1] + v2[1]];
    }
    vectorAdd([1,2], [3,4]) // => [4,6]</code></pre>
    <p>El código sería más fácil de entender si desestructuráramos los dos argumentos vectoriales en parámetros con nombres más claros:</p>
    <pre>
    <code class="language-js">function vectorAdd([x1,y1], [x2,y2]) &lbrace; // Descomprimir 2 argumentos en 4 parametros.
      return [x1 + x2, y1 + y2];
    }
    vectorAdd([1,2], [3,4]) // => [4,6]</code></pre>
    <p>Del mismo modo, si está definiendo una función que espera un argumento objeto, puede desestructurar los parámetros de ese objeto. Volvamos a utilizar un ejemplo vectorial, sólo que esta vez supongamos que representamos los vectores como objetos con parámetros <codeinline>x</codeinline> e <codeinline>y</codeinline>:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} por el valor scalar
    function vectorMultiply(&lbrace;x, y}, scalar) &lbrace;
      return &lbrace; x: x*scalar, y: y*scalar };
    }
    vectorMultiply(&lbrace;x: 1, y: 2}, 2) // => &lbrace;x: 2, y: 4 }</code></pre>
    <p>Este ejemplo de desestructuración de un único argumento de objeto en dos parámetros es bastante claro porque los nombres de los parámetros que utilizamos coinciden con los nombres de las propiedades del objeto entrante. La sintaxis es más verbosa y confusa cuando se necesita desestructurar propiedades con un nombre en parámetros con nombres diferentes. Aquí está el ejemplo de suma de vectores, implementado para vectores basados en objetos:</p>
    <pre>
    <code class="language-js">function vectorAdd(
      &lbrace;x: x1, y: y1}, // Desempaqueta el primer objeto en los parametros x1 y y1
      &lbrace;x: x2, y: y2} // Desempaqueta el segundo objeto en los parametros x2 y y2
    )
    &lbrace;
    return &lbrace; x: x1 + x2, y: y1 + y2 };
    }
    vectorAdd(&lbrace;x: 1, y: 2}, &lbrace;x: 3, y: 4}) // => &lbrace;x: 4, y: 6}</code></pre>
    <p>Lo complicado de la sintaxis de desestructuración como <codeinline>&lbrace;x:x1, y:y1}</codeinline> es recordar cuáles son los nombres de las propiedades y cuáles los de los parámetros. La regla a tener en cuenta para desestructurar asignaciones y desestructurar llamadas a funciones es que las variables o parámetros que se declaran van en los lugares donde se esperaría que fueran los valores en un literal de objeto. Así que los nombres de las propiedades siempre van a la izquierda de los dos puntos, y los nombres de los parámetros (o variables) a la derecha.</p>
    <p>Puede definir parámetros por defecto con parámetros desestructurados. He aquí una multiplicación vectorial que funciona con vectores 2D o 3D:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} o &lbrace;x,y,z} por el valor scalar
    function vectorMultiply(&lbrace;x, y, z=0}, scalar) &lbrace;
      return &lbrace; x: x*scalar, y: y*scalar, z: z*scalar };
    }
    vectorMultiply(&lbrace;x: 1, y: 2}, 2) // => &lbrace;x: 2, y: 4, z: 0}</code></pre>
    <p>Algunos lenguajes (como Python) permiten a quien llama a una función invocarla con argumentos especificados en forma <codeinline>name=value</codeinline>, lo que resulta conveniente cuando hay muchos argumentos opcionales o cuando la lista de parámetros es lo suficientemente larga como para que resulte difícil recordar el orden correcto. JavaScript no permite esto directamente, pero se puede aproximar desestructurando un argumento objeto en los parámetros de la función. Consideremos una función que copia un número especificado de elementos de una matriz en otra matriz con desplazamientos iniciales especificados opcionalmente para cada matriz. Puesto que hay cinco parámetros posibles, algunos de los cuales tienen valores por defecto, y sería difícil para un llamador recordar en qué orden pasar los argumentos, podemos definir e invocar la función <codeinline>arraycopy()</codeinline> así:</p>
    <pre>
    <code class="language-js">function arraycopy(&lbrace;from, to=from, n=from.length, fromIndex=0, toIndex=0}) &lbrace;
      let valuesToCopy = from.slice(fromIndex, fromIndex + n);
      to.splice(toIndex, 0, ...valuesToCopy);
      return to;
    }
    let a = [1,2,3,4,5], b = [9,8,7,6,5];
    arraycopy(&lbrace;from: a, n: 3, to: b, toIndex: 4}) // => [9,8,7,6,1,2,3,5]</code></pre>
    <p>Al desestructurar una matriz, puede definir un parámetro de reposo para los valores adicionales dentro de la matriz que se está descomprimiendo. Ese parámetro restante entre corchetes es completamente diferente del verdadero parámetro restante de la función:</p>
    <pre>
    <code class="language-js">// Esta función espera un argumento de array. Los dos primeros elementos
    // de ese array se descomprimen en los parámetros x e y. Los elementos
    // restantes se almacenan en el array de coordenadas. Y los argumentos
    // posteriores al primer array se empaquetan en el array restante.
    function f([x, y, ...coords], ...rest) &lbrace;
    return [x+y, ...rest, ...coords]; // Note: operador de propagación aqui
    }
    f([1, 2, 3, 4], 5, 6) // => [3, 5, 6, 3, 4]</code></pre>
    <p>En ES2018, también se puede utilizar un parámetro rest cuando se desestructura un objeto. El valor de ese parámetro rest será un objeto que tenga las propiedades que no se hayan desestructurado. Los parámetros de reposo de objetos suelen ser útiles con el operador de dispersión de objetos, que también es una nueva función de ES2018:</p>
    <pre>
    <code class="language-js">// Multiplica el vector &lbrace;x,y} o &lbrace;x,y,z} por un valor scalar, conserva otras props
    function vectorMultiply(&lbrace;x, y, z=0, ...props}, scalar) &lbrace;
    return &lbrace; x: x*scalar, y: y*scalar, z: z*scalar, ...props };
    }
    vectorMultiply(&lbrace;x: 1, y: 2, w: -1}, 2) // => &lbrace;x: 2, y: 4, z: 0, w: -1}</code></pre>
    <p>Por último, tenga en cuenta que, además de desestructurar objetos argumento y matrices, también puede desestructurar matrices de objetos, objetos que tienen propiedades de matriz y objetos que tienen propiedades de objeto, básicamente a cualquier profundidad. Consideremos un código gráfico que representa círculos como objetos con propiedades <codeinline>x</codeinline>, <codeinline>y</codeinline>, <codeinline>radius</codeinline> y <codeinline>color</codeinline>, donde la propiedad <codeinline>color</codeinline> es una matriz de componentes de color rojo, verde y azul. Podría definir una función que espera que se le pase un único objeto círculo, pero que desestructura ese objeto círculo en seis parámetros separados:</p>
    <pre>
    <code class="language-js">function drawCircle(&lbrace;x, y, radius, color: [r, g, b]}) &lbrace;
      // Aun no implementado
    }</code></pre>
    <p>Si la desestructuración de los argumentos de la función es más complicada que esto, encuentro que el código se vuelve más difícil de leer, en lugar de más simple. A veces, es más claro ser explícito sobre el acceso a las propiedades de los objetos y la indexación de los arrays.</p>
  </section>
  <section id="3-6">
    <h2>8.3.6 Tipos de argumentos</h2>
    <p>Los parámetros de los métodos JavaScript no tienen tipos declarados, y no se realiza ninguna comprobación de tipos en los valores que se pasan a una función. Puede ayudar a que su código sea autodocumentado eligiendo nombres descriptivos para los argumentos de las funciones y documentándolos cuidadosamente en los comentarios de cada función. (Como alternativa, consulte <a href="capitulo-17#8">§17.8</a> para una extensión del lenguaje que permite superponer la comprobación de tipos al JavaScript normal).</p>
    <p>Como se describe en <a href="capitulo-3#9">§3.9</a>, JavaScript realiza conversiones de tipo liberales según sea necesario. Por lo tanto, si escribes una función que espera un argumento de cadena y luego llamas a esa función con un valor de otro tipo, el valor que pasaste simplemente se convertirá en una cadena cuando la función intente usarlo como una cadena. Todos los tipos primitivos pueden convertirse en cadenas, y todos los objetos tienen métodos <codeinline>toString()</codeinline> (aunque no necesariamente útiles), por lo que nunca se produce un error en este caso.</p>
    <p>Sin embargo, esto no siempre es cierto. Consideremos de nuevo el método <codeinline>arraycopy()</codeinline> mostrado anteriormente. Espera uno o dos argumentos de array y fallará si estos argumentos son del tipo incorrecto. A menos que esté escribiendo una función privada que sólo será llamada desde partes cercanas de su código, puede valer la pena añadir código para comprobar los tipos de argumentos como éste. Es mejor que una función falle inmediatamente y de forma predecible cuando se le pasan valores erróneos que empezar a ejecutarse y fallar más tarde con un mensaje de error que probablemente no sea claro. He aquí una función de ejemplo que realiza la comprobación de tipos:</p>
    <pre>
    <code class="language-js">// Devuelve la suma de los elementos del objeto iterable a.
    // El elemento de a deben ser todos números.
    function sum(a) &lbrace;
      let total = 0;
      for(let element of a) &lbrace; // Lanza TypeError si no es iterable
        if (typeof element !== "number") &lbrace;
        throw new TypeError("sum(): los elementos deben ser números");
        }
        total += element;
      }
      return total;
    }
    sum([1,2,3]) // => 6
    sum(1, 2, 3); // !TypeError: 1 no es iterable
    sum([1,2,"3"]); // !TypeError: el elemento 2 no es un número</code></pre>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>8.4 Funciones como valores</h2>
  </section>
</Layoutjavascript>