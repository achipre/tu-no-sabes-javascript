---
import Navegation from "../../components/Navegation.astro";
import Layoutjavascript from "../../layouts/Layoutjavascript.astro";
---
<Layoutjavascript title="JavaScript: La guia definitiva">
  <Navegation capAnterior="capitulo-6" capSiguiente="capitulo-8" />
  <section class="fadeIn">
    <header class="flex justify-between">
      <img class="h-10" src="/public/javascript/siete.svg" alt="Capitulo Siete">
      <h1 class="text-right">Arrays</h1>
    </header>
    <p>Este capítulo documenta los arrays, un tipo de datos fundamental en JavaScript y en la mayoría de los demás lenguajes de programación. Un <em>array</em> es una colección ordenada de valores. Cada valor se llama <em>elemento</em>, y cada elemento tiene una posición numérica en el array, conocida como su <em>índice</em>. Las matrices de JavaScript son <em>no tipadas</em>: un elemento de una matriz puede ser de cualquier tipo, y distintos elementos de la misma matriz pueden ser de tipos diferentes. Los elementos de una matriz pueden ser incluso objetos u otras matrices, lo que permite crear estructuras de datos complejas, como matrices de objetos y matrices de matrices. Las matrices de JavaScript se <em>basan en ceros</em> y utilizan índices de 32 bits: el índice del primer elemento es 0, y el índice más alto posible es 4294967294 (2<sup class="bg-transparent mx-0 px-1">32</sup>-2), para un tamaño máximo de matriz de 4.294.967.295 elementos. Las matrices de JavaScript son <em>dinámicas</em>: crecen o decrecen según las necesidades, y no es necesario declarar un tamaño fijo para la matriz cuando se crea ni reasignarla cuando cambia el tamaño. Las matrices de JavaScript pueden ser <em>dispersas</em>: los elementos no tienen por qué tener índices contiguos y puede haber huecos. Todas las matrices de JavaScript tienen una propiedad de <codeinline>length</codeinline>. Para las matrices no dispersas, esta propiedad especifica el número de elementos de la matriz. En las matrices dispersas, la <codeinline>length</codeinline> es mayor que el índice más alto de cualquier elemento.</p>
    <p>Los arrays JavaScript son una forma especializada de objeto JavaScript, y los índices de los arrays son realmente poco más que nombres de propiedades que resultan ser enteros. Hablaremos más sobre las especializaciones de los arrays en otra parte de este capítulo. Las implementaciones suelen optimizar los arrays para que el acceso a los elementos indexados numéricamente sea mucho más rápido que el acceso a las propiedades de los objetos normales.</p>
    <p>Los arrays heredan propiedades de <codeinline>Array.prototype</codeinline>, que define un rico conjunto de métodos de manipulación de arrays, tratados en <a href="capitulo-7#8">§7.8</a>. La mayoría de estos métodos son <em>genéricos</em>. La mayoría de estos métodos son genéricos, lo que significa que funcionan correctamente no sólo para arrays verdaderos, sino para cualquier "objeto tipo array". Hablaremos de los objetos tipo array en <a href="capitulo-7#9">§7.9</a>. Por último, las cadenas de JavaScript se comportan como matrices de caracteres, y hablaremos de ello en <a href="capitulo-7#10">§7.10</a>.</p>
    <p>ES6 introduce un conjunto de nuevas clases de arrays conocidas colectivamente como "arrays tipados". A diferencia de las matrices normales de JavaScript, las matrices tipadas tienen una longitud fija y un tipo de elemento numérico fijo. Ofrecen un alto rendimiento y acceso a nivel de byte a los datos binarios y se tratan en <a href="capitulo-11#2">§11.2</a>.</p>
  </section>
  <section id="1" class="py-4 xs:py-5 sm:py-6">
    <h2>7.1 Creación de Arrays</h2>
    <p>Existen varias formas de crear matrices. Las subsecciones siguientes explican cómo crear matrices con:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Matrices literales
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El operador <codeinline>...</codeinline> spread sobre un objeto iterable
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El constructor <codeinline>Array()</codeinline>
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de fábrica <codeinline>Array.of()</codeinline> y <codeinline>Array.from()</codeinline>
        </p>
      </li>
    </ul>
  </section>
  <section id="1-1">
    <h2>7.1.1 Arrays literales</h2>
    <p>La forma más sencilla de crear una matriz es con un literal de matriz, que no es más que una lista separada por comas de elementos de matriz entre corchetes. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">let empty = [];                 // Un array sin elementos
    let primes = [2, 3, 5, 7, 11];  // Un array con cinco elementos numéricos
    let misc = [ 1.1, true, "a", ]; // 3 elementos de varios tipos + coma al final</code></pre>
    <p>Los valores de un literal de matriz no tienen por qué ser constantes; pueden ser expresiones arbitrarias:</p>
    <pre class="language-js">
    <code class="language-js">let base = 1024;
    let table = [base, base+1, base+2, base+3];</code></pre>
    <p>Los literales de matriz pueden contener literales de objeto u otros literales de matriz:</p>
    <pre class="language-js">
    <code class="language-js">let b = [[1, &lbrace;x: 1, y: 2}], [2, &lbrace;x: 3, y: 4}]];</code></pre>
    <p>Si un literal de matriz contiene varias comas seguidas sin ningún valor entre ellas, la matriz es dispersa (véase <a href="capitulo-7#3">§7.3</a>). Los elementos de la matriz para los que se omiten valores no existen, pero aparecen como <codeinline>undefined</codeinline> si se consultan:</p>
    <pre class="language-js">
    <code class="language-js">let count = [1,,3]; // Elementos con indice 0 y 2. Ningun elemento en el índice 1.
    let undefs = [,,];  // Un array sin elementos pero con longitud 2.</code></pre>
    <p>La sintaxis literal de matriz permite una coma final opcional, por lo que <codeinline>[,,]</codeinline> tiene una longitud de 2, no de 3.</p>
  </section>
  <section id="1-2" class="py-4 xs:py-5 sm:py-6">
    <h2>7.1.2 El operador Spread </h2>
    <p>En ES6 y posteriores, puedes utilizar el “spread operator,” <codeinline>...</codeinline>, para incluir los elementos de una matriz dentro de un literal de matriz:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1, 2, 3];
    let b = [0, ...a, 4]; // b == [0, 1, 2, 3, 4]</code></pre>
    <p>Los tres puntos "extienden" la matriz a para que sus elementos se conviertan en elementos dentro de la matriz literal que se está creando. Es como si <codeinline>...a</codeinline> se sustituyera por los elementos de la matriz a, enumerados literalmente como parte de la matriz literal que la encierra. (Ten en cuenta que, aunque llamemos a estos tres puntos operador de extensión, no se trata de un verdadero operador porque sólo puede utilizarse en literales de array y, como veremos más adelante en el libro, en invocaciones de funciones).</p>
    <p>El operador de dispersión es una forma práctica de crear una copia (superficial) de un array:</p>
    <pre class="language-js">
    <code class="language-js">let original = [1,2,3];
    let copy = [...original];
    copy[0] = 0; // Modifica la copy, no cambia la original
    original[0]  // => 1</code></pre>
    <p>El operador spread funciona sobre cualquier objeto iterable. (Los objetos <em>iterables</em> son sobre los que itera el bucle <codeinline>for/of</codeinline>; los vimos por primera vez en <a href="capitulo-5#4-4">§5.4.4</a>, y veremos mucho más sobre ellos en el <a href="capitulo-12">Capítulo 12</a>.) Las cadenas son iterables, así que puedes usar un operador spread para convertir cualquier cadena en un array de cadenas de un solo carácter:</p>
    <pre class="language-js">
    <code class="language-js">let digits = [..."0123456789ABCDEF"];
    digits // => ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]</code></pre>
    <p>Los objetos set (<a href="capitulo-11#1-1">§11.1.1</a>) son iterables, por lo que una forma sencilla de eliminar elementos duplicados de un array es convertir el array en un set e inmediatamente después volver a convertir el set en un array utilizando el operador spread:</p>
    <pre class="language-js">
    <code class="language-js">let letters = [..."hello world"];
    [...new Set(letters)] // => ["h","e","l","o"," ","w","r","d"]</code></pre>
  </section>
  <section id="1-3">
    <h2>7.1.3 El constructor Array()</h2>
    <p>Otra forma de crear un array es con el constructor <codeinline>Array()</codeinline>. Puedes invocar este constructor de tres formas distintas:</p>
    <ul class="flex flex-col gap-4 xs:gap-5 sm:gap-6">
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Llámalo sin argumentos:
        </p>
      </li>
    <pre class="language-js">
    <code class="language-js">let a = new Array();</code></pre>
      <li class="font-normal list-none pl-5 xs:pl-6 sm:pl-7 md:pl-8">Este método crea una matriz vacía sin elementos y es equivalente a la matriz literal <codeinline>[]</codeinline>.</li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Llámelo con un único argumento numérico, que especifica una longitud:
        </p>
      </li>
    <pre class="language-js">
    <code class="language-js">let a = new Array(10);</code></pre>
      <li class="font-normal list-none pl-5 xs:pl-6 sm:pl-7 md:pl-8">Esta técnica crea un array con la longitud especificada. Esta forma del constructor <codeinline>Array()</codeinline> puede utilizarse para preasignar una matriz cuando se sabe de antemano cuántos elementos se necesitarán. Tenga en cuenta que no se almacenan valores en la matriz, y las propiedades de índice de matriz "0", "1", etc. ni siquiera están definidas para la matriz.</li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Especifique explícitamente dos o más elementos de matriz o un único elemento no numérico para la array:
        </p>
      </li>
    <pre class="language-js">
    <code class="language-js">let a = new Array(5, 4, 3, 2, 1, "testing, testing");</code></pre>
      <li class="font-normal list-none pl-5 xs:pl-6 sm:pl-7 md:pl-8">De esta forma, los argumentos del constructor se convierten en los elementos del nuevo array. Utilizar un literal de array es casi siempre más sencillo que este uso del constructor <codeinline>Array()</codeinline>.</li>
    </ul>
  </section>
  <section id="1-4" class="py-4 xs:py-5 sm:py-6"> 
    <h2>7.1.4 Array.of()</h2>
    <p>Cuando la función constructora <codeinline>Array()</codeinline> se invoca con un argumento numérico, utiliza ese argumento como longitud de la matriz. Pero cuando se invoca con más de un argumento numérico , trata esos argumentos como elementos de la array que se va a crear. Esto significa que el constructor <codeinline>Array()</codeinline> no puede utilizarse para crear una matriz con un único elemento numérico.</p>
    <p>En ES6, la función <codeinline>Array.of()</codeinline> aborda este problema: es un método de fábrica que crea y devuelve una nueva array, utilizando los valores de sus argumentos (independientemente de cuántos sean) como elementos de la array:</p>
    <pre class="language-js">
    <code class="language-js">Array.of()      // => []; regresa un array vacío sin argumentos
    Array.of(10)    // => [10]; puede crear un array con un solo argumento numérico
    Array.of(1,2,3) // => [1, 2, 3]</code>
    </pre>
  </section>
  <section id="1-5">
    <h2>7.1.5 Array.from()</h2>
    <p><codeinline>Array.from</codeinline> es otro método de fábrica de arrays introducido en ES6. Espera un objeto iterable o tipo array como primer argumento y devuelve un nuevo array que contiene los elementos de ese objeto. Con un argumento iterable, <codeinline>Array.from(iterable)</codeinline> funciona como el operador de propagación <codeinline>[...iterable]</codeinline>. También es una forma sencilla de hacer una copia de un array:</p>
    <pre class="language-js">
    <code class="language-js">let copy = Array.from(original);</code></pre>
    <p><codeinline>Array.from()</codeinline> también es importante porque define una forma de hacer una copia real de un objeto tipo array. Los objetos tipo array son objetos no array que tienen una propiedad de longitud numérica y tienen valores almacenados con propiedades cuyos nombres resultan ser enteros. Cuando se trabaja con JavaScript del lado del cliente, los valores de retorno de algunos métodos del navegador web son tipo array, y puede ser más fácil trabajar con ellos si primero los conviertes en verdaderos arrays:</p>
    <pre class="language-js">
    <code class="language-js">let truearray = Array.from(arraylike);</code></pre>
    <p><codeinline>Array.from()</codeinline> también acepta un segundo argumento opcional. Si pasas una función como segundo argumento, mientras se construye el nuevo array, cada elemento del objeto fuente se pasará a la función que especifiques, y el valor de retorno de la función se almacenará en el array en lugar del valor original. (Esto es muy parecido al método array <codeinline>map()</codeinline> que se introducirá más adelante en el capítulo, pero es más eficiente realizar el mapeo mientras se construye el array que construir el array y luego mapearlo a otro nuevo array).</p>
  </section>
  <section id="2" class="py-4 xs:py-5 sm:py-6">
    <h2>7.2 Lectura y escritura de los elementos en el Array</h2>
    <p>Para acceder a un elemento de una matriz se utiliza el operador <codeinline>[]</codeinline>. A la izquierda de los corchetes debe aparecer una referencia a la matriz. Dentro de los corchetes debe aparecer una expresión arbitraria que tenga un valor entero no negativo. Puede utilizar esta sintaxis tanto para leer como para escribir el valor de un elemento de una matriz. Por lo tanto, las siguientes son sentencias JavaScript legales</p>
    <pre class="language-js">
    <code class="language-js">let a = ["world"];  // Comienza con un array de un elemento
    let value = a[0];   // Lee el elemento 0
    a[1] = 3.14;        // Escribe el elemento 1
    let i = 2;
    a[i] = 3;           // Escribe el elemento 2
    a[i + 1] = "hello"; // Escribe el elemento 3
    a[a[i]] = a[0];     // Lee elementos 0 y 2, excribe el elemento 2</code></pre>
    <p>Lo que tienen de especial los arrays es que cuando utilizas nombres de propiedades que son enteros no negativos menores que 2<sup class="bg-transparent mx-0 px-1">32</sup>-1, el array mantiene automáticamente el valor de la propiedad <codeinline>length</codeinline> por ti. En el ejemplo anterior, por ejemplo, hemos creado una array <codeinline>a</codeinline> con un único elemento. A continuación, asignamos valores a los índices 1, 2 y 3. La propiedad de <codeinline>length</codeinline> del array cambiaba a medida que lo hacíamos, así:</p>
    <pre class="language-js">
    <code class="language-js">a.length // => 4</code></pre>
    <p>Recuerde que las matrices son un tipo especializado de objeto. Los corchetes utilizados para acceder a los elementos de las matrices funcionan igual que los corchetes utilizados para acceder a las propiedades de los objetos. JavaScript convierte el índice numérico de la matriz especificado en una cadena (el índice <codeinline>1</codeinline> se convierte en la cadena <codeinline>"1"</codeinline>) y, a continuación, utiliza esa cadena como nombre de la propiedad. La conversión del índice de un número a una cadena no tiene nada de especial: también se puede hacer con objetos normales:</p>
    <pre class="language-js">
    <code class="language-js">let o = &lbrace;};    // Crea un objeto plano
    o[1] = "one";  // Indicalo con un entero
    o["1"]         // => "one"; los nombre de las propiedades numericas y de cadena son iguales</code></pre>
    <p>Es útil distinguir claramente un <codeinline>índice de array</codeinline> de un <codeinline>nombre de propiedad de objeto</codeinline>. Todos los índices son nombres de propiedades, pero sólo los nombres de propiedades que son enteros entre 0 y 2<sup class="bg-transparent mx-0 px-1">32</sup>-2 son índices. Todas las matrices son objetos, y se pueden crear propiedades de cualquier nombre en ellos. Sin embargo, si utiliza propiedades que son índices de matrices, las matrices tienen el comportamiento especial de actualizar su propiedad de <codeinline>length</codeinline> según sea necesario.</p>
    <p>Tenga en cuenta que puede indexar una matriz utilizando números negativos o que no sean enteros. Cuando se hace esto, el número se convierte en una cadena, y esa cadena se utiliza como nombre de la propiedad. Como el nombre no es un entero no negativo, se trata como una propiedad de objeto regular, no como un índice de matriz. Además, si indexa una matriz con una cadena que resulta ser un entero no negativo, se comporta como un índice de matriz, no como una propiedad de objeto. Lo mismo ocurre si se utiliza un número de coma flotante que es igual que un entero:</p>
    <pre class="language-js">
    <code class="language-js">a[-1.23] = true;  // esto crea una propiedad llamada -1.23
    a["1000"] = 0;    // Este es el elemnto milesimo del array.
    a[1.000] = 1;     // Array en el indice 1. Igual que a[1] = 1;</code></pre>
    <p>El hecho de que los índices de las matrices sean simplemente un tipo especial de
      nombre de propiedad de objeto significa que las matrices de JavaScript no tienen
      noción de error "fuera de límites". Cuando intentas consultar una propiedad
      inexistente de cualquier objeto, no obtienes un error; simplemente obtienes
      undefined. Esto es tan cierto para las matrices como para los objetos:</p>
    <pre class="language-js">
    <code class="language-js">let a = [true, false];  // Este array tiene 2 elementos en el indice 0 y 1.
    a[2]                    // => undefined; no hay elemento con este indice.
    a[-1]                   // => undefined; no hay propiedad con este nombre</code></pre>
  </section>
  <section id="3">
    <h2>7.3 Matrices dispersas</h2>
    <p>Una matriz <em>dispersa</em> es aquella en la que los elementos no tienen índices contiguos que comiencen en 0. Normalmente, la propiedad <codeinline>length</codeinline> de una matriz especifica el número de elementos de la matriz. Si la matriz es dispersa, el valor de la propiedad <codeinline>length</codeinline> es mayor que el número de elementos. Las matrices dispersas pueden crearse con el constructor <codeinline>Array()</codeinline> o simplemente asignando a una matriz un índice mayor que la <codeinline>length</codeinline> actual de la matriz.</p>
    <pre class="language-js">
    <code class="language-js">let a = new Array(5); // Sin elementos, pero a.length es 5.
    a = [];               // Crea un array sin elementos y longitud 0.
    a[1000] = 0;          // La asignación añade un elemento pero establece la longitud a 1001.</code></pre>
    <p>Más adelante veremos que también se puede hacer un array disperso con el operador <codeinline>delete</codeinline>.</p>
    <p>Las matrices suficientemente dispersas se implementan normalmente de una forma más lenta y eficiente en memoria que las matrices densas, y la búsqueda de elementos en una matriz de este tipo llevará aproximadamente el mismo tiempo que la búsqueda de propiedades de un objeto normal.</p>
    <p>Tenga en cuenta que cuando omite un valor en un literal de matriz (utilizando comas repetidas como en <codeinline>[1,,3]</codeinline>), la matriz resultante es dispersa y los elementos omitidos simplemente no existen:</p>
    <pre class="language-js">
    <code class="language-js">let a1 = [,];         // Este array no tiene elementos y su longitud es 1
    let a2 = [undefined]; // Este array tiene un elemento undefined.
    0 in a1               // => false: a1 no tiene elementos con indice 0.
    0 in a2               // => true: a2 tiene el valor undefined en el indice 0.</code></pre>
    <p>Comprender los arrays dispersos es importante para entender la verdadera naturaleza de los arrays de JavaScript. En la práctica, sin embargo, la mayoría de las matrices JavaScript con las que trabajará no serán dispersas. Y, si tiene que trabajar con una matriz dispersa, su código probablemente la tratará igual que trataría una matriz no dispersa con elementos <codeinline>undefined</codeinline>.</p>
  </section>
  <section id="4" class="py-4 xs:py-5 sm:py-6">
    <h2>7.4 Longitud de arrays</h2>
    <p>Todas las matrices tienen una propiedad de <codeinline>length</codeinline>, que las diferencia de los objetos normales de JavaScript. Para las matrices densas (es decir, no dispersas), la propiedad <codeinline>length</codeinline> especifica el número de elementos de la matriz. Su valor es uno más que el índice más alto de la matriz:</p>
    <pre class="language-js">
    <code class="language-js">[].length            // => 0: el array no tiene elementos.
    ["a","b","c"].length // => 3: el indice mas alto es 2. La longitud es 3</code></pre>
    <p>Cuando una matriz es dispersa, la propiedad de <codeinline>length</codeinline> es mayor que el número de elementos, y todo lo que podemos decir al respecto es que se garantiza que la <codeinline>length</codeinline> sea mayor que el índice de cada elemento de la matriz. O, dicho de otro modo, una matriz (dispersa o no) nunca tendrá un elemento cuyo índice sea mayor o igual que su <codeinline>length</codeinline>. Para mantener esta invariante, las matrices tienen dos comportamientos especiales. El primero lo hemos descrito antes: si asignas un valor a un elemento de la matriz cuyo índice <codeinline>i</codeinline> es mayor o igual que la <codeinline>length</codeinline> actual de la matriz, el valor de la propiedad <codeinline>length</codeinline> se establece en <codeinline>i+1</codeinline>.</p>
    <p>El segundo comportamiento especial que implementan las matrices para mantener la invariante de <codeinline>length</codeinline> es que, si se establece la propiedad de longitud en un entero no negativo <codeinline>n</codeinline> menor que su valor actual, cualquier elemento de la matriz cuyo índice sea mayor o igual que <codeinline>n</codeinline> se elimina de la matriz:</p>
    <pre class="language-js">
    <code class="language-js">a = [1,2,3,4,5]; // Comienza un array con 5 elementos.
    a.length = 3;    // a ahora es [1,2,3].
    a.length = 0;    // Borra todos los elementos. a es []
    a.length = 5;    // La longitud es 5. pero sin elementos, como new Array(5)</code></pre>
    <p>También puede establecer la propiedad <codeinline>length</codeinline> de un array a un valor mayor que su valor actual. Al hacer esto no se añade ningún elemento nuevo a la matriz; simplemente se crea un área dispersa al final de la matriz.</p>
  </section>
  <section id="5">
    <h2>7.5 Agrega y elimina elementos de un array</h2>
    <p>Ya hemos visto la forma más sencilla de añadir elementos a un array: basta con asignar valores a nuevos índices:</p>
    <pre class="language-js">
    <code class="language-js">let a = [];     // Comienza con un array vacío.
    a[0] = "zero";  // Agrega un elemento al array.
    a[1] = "one";</code></pre>
    <p>También puedes utilizar el método <codeinline>push()</codeinline> para añadir uno o más valores al final de un array:</p>
    <pre class="language-js">
    <code class="language-js">let a = [];           // Comineza con un array vacío.
    a.push("zero");       // Agrega un valor al final. a = ["zero"]
    a.push("one", "two"); // Agrega dos valores mas. a = ["zero", "one", "two"]</code></pre>
    <p>Introducir un valor en una matriz <codeinline>a</codeinline> es lo mismo que asignar el valor <codeinline>a[a.length]</codeinline>. Puede utilizar el método <codeinline>unshift()</codeinline> (descrito en <a href="#8">§7.8</a>) para insertar un valor al principio de una matriz, desplazando los elementos existentes de la matriz a índices superiores. El método <codeinline>pop()</codeinline> es lo contrario de <codeinline>push()</codeinline>: elimina el último elemento de la matriz y lo devuelve, reduciendo la longitud de una matriz en 1. Del mismo modo, el método <codeinline>shift()</codeinline> elimina y devuelve el primer elemento de la matriz, reduciendo la longitud en 1 y desplazando todos los elementos a un índice inferior al índice actual. Para más información sobre estos métodos, véase <a href="#8">§7.8</a>.</p>
    <p>Puedes borrar elementos de un array con el operador <codeinline>delete</codeinline>, igual que puedes borrar propiedades de un objeto:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3];
    delete a[2]; // a ahora no tiene el elementos en el indice 2
    2 in a // => false: no esta definido el indice 2 en el array.
    a.length // => 3: el delete no afecta la longitud del array.</code></pre>
    <p>Borrar un elemento de un array es similar (pero sutilmente diferente) a asignar <codeinline>undefined</codeinline> a ese elemento. Tenga en cuenta que el uso de <codeinline>delete</codeinline> en un elemento de array no altera la propiedad de <codeinline>length</codeinline> y no desplaza los elementos con índices más altos hacia abajo para llenar el vacío que deja la propiedad eliminada. Si borras un elemento de un array, el array se vuelve disperso.</p>
    <p>Como vimos anteriormente, también puedes eliminar elementos del final de un array simplemente estableciendo la propiedad <codeinline>length</codeinline> a la nueva longitud deseada.</p>
    <p>Por último, <codeinline>splice()</codeinline> es el método de propósito general para insertar, borrar oreemplazar elementos de una matriz. Altera la propiedad <odeinline>length</odeinline> y desplaza los elementos de la matriz a índices superiores o inferiores según sea necesario. Para más detalles, véase <a href="#8">§7.8</a>.</p>
  </section>
  <section id="6" class="py-4 xs:py-5 sm:py-6">
    <h2>7.6 Iteración en arrays</h2>
    <p>A partir de ES6, la forma más sencilla de recorrer cada uno de los elementos de un array (o cualquier objeto iterable) es con el bucle <codeinline>for/of</codeinline>, que se trató en detalle en <a href="capitulo-5#4-4">§5.4.4</a>:</p>
    <pre class="language-js">
    <code class="language-js">let letters = [..."Hola mundo"]; // Un array de letras.
    let string = "";
    for(let letter of letters) &lbrace;
      string += letter;
    }
    string // => "Hola mundo"; rensamblamos el texto original</code></pre>
    <p>El iterador de matrices incorporado que utiliza el bucle <codeinline>for/of</codeinline> devuelve los elementos de una matriz en orden ascendente. No tiene un comportamiento especial para matrices dispersas y simplemente devuelve <codeinline>undefined</codeinline> para cualquier elemento de la matriz que no exista.</p>
    <p>Si desea utilizar un bucle <codeinline>for/of</codeinline> para un array y necesita conocer el índice de cada elemento del array, utilice el método <codeinline>entries()</codeinline> del array, junto con la asignación de desestructuración, de la siguiente manera:</p>
    <pre class="language-js">
    <code class="language-js">let everyother = "";
    for(let [index, letter] of letters.entries()) &lbrace;
      if (index % 2 === 0) everyother += letter; // letras en indices pares
    }
    everyother // => "Hl ud"</code></pre>
    <p>Otra buena forma de iterar matrices es con <codeinline>forEach()</codeinline>. No se trata de una nueva forma del bucle <codeinline>for</codeinline>, sino de un método de matrices que ofrece un enfoque funcional de la iteración de matrices. Pasas una función al método <codeinline>forEach()</codeinline> de un array, y <codeinline>forEach()</codeinline> invoca tu función una vez en cada elemento del array:</p>
    <pre class="language-js">
    <code class="language-js">let uppercase = "";
    letters.forEach(letter => &lbrace; // Observe aqui la sintaxis de funcione flecha.
      uppercase += letter.toUpperCase();
    });
    uppercase // => "HELLO WORLD"</code></pre>
    <p>Como era de esperar, <codeinline>forEach()</codeinline> itera la matriz en orden, y en realidad pasa el índice de la matriz a su función como un segundo argumento, que es ocasionalmente útil. A diferencia del bucle <codeinline>for/of</codeinline>, <codeinline>forEach()</codeinline> es consciente de las matrices dispersas y no invoca su función para los elementos que no están allí.</p>
    <p><a href="#8-1">§7.8.1</a> documenta el método <codeinline>forEach()</codeinline> con más detalle. Esa sección también cubre métodos relacionados como <codeinline>map()</codeinline> y <codeinline>filter()</codeinline> que realizan tipos especializados de iteración de matrices.</p>
    <p>También puedes recorrer los elementos de una matriz con un simple <codeinline>for</codeinline> (<a href="capitulo-5#4-3">§5.4.3</a>):</p>
    <pre class="language-js">
    <code class="language-js">let vowels = "";
    for(let i = 0; i &lt; letters.length; i++) &lbrace; // Para cada indice en el array
      let letter = letters[i];                // Obtener el elemento de ese indice
      if (/[aeiou]/.test(letter)) &lbrace;           // Utiliza una prueba de expresión regular
        vowels += letter;                     // Si es una vocal, guardarla
      }
    }
    vowels // => "eoo"</code></pre>
    <p>En bucles anidados, u otros contextos donde el rendimiento es crítico, a veces puede ver este bucle básico de iteración de array escrito de forma que la longitud del array sólo se busque una vez en lugar de en cada iteración. Ambas formas de bucle <codeinline>for</codeinline> son idiomáticas, aunque no son especialmente comunes, y con los intérpretes modernos de JavaScript no está nada claro que tengan ningún impacto en el rendimiento:</p>
    <pre class="language-js">
    <code class="language-js">// Guarda la longitud del array en una variable local
    for(let i = 0, len = letters.length; i &lt; len; i++) &lbrace;
      // el cuerpo del bucle sigue siendo el mismo. 
    }
    // Itera hacia atras desde el final del array hasta el principio
    for(let i = letters.length-1; i >= 0; i--) &lbrace;
      // el cuerpo del bucle sigue siendo el mismo.
    }</code></pre>
    <p>Estos ejemplos suponen que la matriz es densa y que todos los elementos contienen datos válidos. Si este no es el caso, deberías probar los elementos del array antes de usarlos. Si quieres omitir elementos no definidos o inexistentes, puedes escribir:</p>
    <pre class="language-js">
    <code class="language-js">for(let i = 0; i &lbrace; a.length; i++) &lbrace;
      if (a[i] === undefined) continue; // Salta elementos indefinidos + inexistentes
      // cuerpo del bucle aqui
    }</code></pre>
  </section>
  <section id="7">
    <h2>7.7 Arrays multifuncional</h2>
    <p>JavaScript no admite verdaderas matrices multidimensionales, pero puede aproximarse a ellas con matrices de matrices. Para acceder a un valor de una matriz de matrices, basta con utilizar dos veces el operador []. Por ejemplo, supongamos que la variable matriz es una matriz de matrices de números. Cada elemento de matrix[x] es una matriz de números. Para acceder a un número concreto dentro de esta matriz, se escribiría matrix[x][y]. He aquí un ejemplo concreto que utiliza una matriz bidimensional como tabla de multiplicar:</p>
    <pre class="language-js">
    <code class="language-js">// Crea un array multidimensional
    let table = new Array(10); // 10 filas en el array
    for(let i = 0; i &lt; table.length; i++) &lbrace;
      table[i] = new Array(10); // Cada fila tiene 10 columnas
    }

    // Inicializa el array multidimensional
    for(let row = 0; row &lt; table.length; row++) &lbrace;
      for(let col = 0; col &lt; table[row].length; col++) &lbrace;
        table[row][col] = row*col;
      }
    }

    // Usa el array multidimensional para calcular 5*7
    table[5][7] // => 35</code></pre>
  </section>
  <section id="8" class="py-4 xs:py-5 sm:py-6">
    <h2>7.8 Metodos del Array</h2>
    <p>Las secciones anteriores se han centrado en la sintaxis básica de JavaScript para
      trabajar con matrices. Sin embargo, en general, los métodos definidos por la clase
      Array son los más potentes. Las siguientes secciones documentan estos métodos.
      Mientras lees sobre estos métodos, ten en cuenta que algunos de ellos modifican el
      array sobre el que son invocados y otros dejan el array sin cambios. Algunos métodos
      devuelven una matriz: a veces, se trata de una nueva matriz, y la original no se
      modifica. Otras veces, un método modificará la matriz en su lugar y también
      devolverá una referencia a la matriz modificada.</p>
    <p>Cada una de las subsecciones siguientes cubre un grupo de métodos de array relacionados:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de iteración recorren los elementos de una matriz, normalmente invocando una función especificada en cada uno de esos elementos.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de pila y cola añaden y eliminan elementos de una matriz al principio y al final de la misma.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de submatrices sirven para extraer, borrar, insertar, rellenar y copiar regiones contiguas de una matriz mayor.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los métodos de búsqueda y ordenación sirven para localizar elementos dentro de una matriz y para ordenar los elementos de una matriz.
        </p>
      </li>
    </ul>
    <p>Las siguientes subsecciones también cubren los métodos estáticos de la clase Array y algunos métodos misceláneos para concatenar arrays y convertir arrays en cadenas.</p>
  </section>
  <section id="8-1">
    <h2>7.8.1 Metodos iterador de arrays</h2>
    <p>Los métodos descritos en esta sección iteran sobre matrices pasando los elementos de
    la matriz, en orden, a una función que usted suministra, y proporcionan formas
    convenientes de iterar, mapear, filtrar, probar y reducir matrices.</p>
    <p>Sin embargo, antes de explicar los métodos en detalle, vale la pena hacer algunas
    generali- zaciones sobre ellos. En primer lugar, todos estos métodos aceptan una
    función como primer argumento e invocan esa función una vez por cada elemento (o
    algunos elementos) de la matriz. Si la matriz es dispersa, la función que se pasa no se
    invoca para elementos inexistentes. En la mayoría de los casos, la función se invoca
    con tres argumentos: el valor del elemento de la matriz, el índice del elemento de la
    matriz y la propia matriz. A menudo, sólo se necesita el primero de estos argumentos
    y se pueden ignorar el segundo y el tercero.</p>
    <p>La mayoría de los métodos de iteración descritos en las siguientes subsecciones
    aceptan un segundo argumento opcional. Si se especifica, la función se invoca como
    si fuera un método de este segundo argumento. Es decir, el segundo argumento que
    se pasa se convierte en el valor de la palabra clave <codeinline>this</codeinline> dentro de la función que se
    pasa como primer argumento. El valor de retorno de la función que se pasa suele ser importante, pero distintos métodos manejan el de diferentes maneras. Ninguno de los métodos descritos aquí modifica el array sobre
    el que se invocan (aunque la función que se pasa puede modificar el array, por
    supuesto). </p>
    <p>Cada una de estas funciones se invoca con una función como primer argumento, y es
    muy común definir esa función en línea como parte de la expresión de invocación del
    método en lugar de utilizar una función existente definida en otro lugar. La sintaxis
    de la función flecha (véase <a href="capitulo-8#1-3">§8.1.3</a>) funciona especialmente bien con estos métodos, y
    la utilizaremos en los ejemplos que siguen.</p>
    <p class="title-article text-left">forEach()</p>
    <p>El método <codeinline>forEach()</codeinline> recorre una matriz, invocando una función especificada para cada elemento. Como hemos descrito, se pasa la función como primer argumento a <codeinline>forEach()</codeinline>. <codeinline>forEach()</codeinline> invoca entonces la función con tres argumentos: el valor del elemento de la matriz, el índice del elemento de la matriz y la propia matriz. Si sólo le interesa el valor del elemento de la matriz, puede escribir una función con un solo parámetro; los argumentos adicionales se ignorarán:</p>
    <pre class="language-js">
    <code class="language-js">let data = [1,2,3,4,5], sum = 0;
    // Calcula la suma de los elementos del array
    data.forEach(value => &lbrace; sum += value; }); // sum == 15
    // Ahora incrementa cada elemento del array
    data.forEach(function(v, i, a) &lbrace; a[i] = v + 1; }); // data == [2,3,4,5,6]</code></pre>
    <p>Tenga en cuenta que <codeinline>forEach()</codeinline> no proporciona una forma de terminar la iteración
    antes de que todos los elementos hayan sido pasados a la función. Es decir, no existe
    un equivalente del estado <codeinline>break</codeinline> que se puede utilizar con un bucle for normal.</p>
    <p class="title-article text-left">map()</p>
    <p>El método <codeinline>map()</codeinline> pasa cada elemento del array sobre el que se invoca a la función que
    especifiques y devuelve un array que contiene los valores devueltos por tu función.
    Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1, 2, 3];
    a.map(x => x*x) // => [1, 4, 9]: la funcion toma x y devuelve x*x</code></pre>
    <p>La función que se pasa a <codeinline>map()</codeinline> se invoca del mismo modo que una función pasada a
      <codeinline>forEach()</codeinline>. Sin embargo, para el método <codeinline>map()</codeinline>, la función pasada debe devolver un
    valor. Tenga en cuenta que <codeinline>map()</codeinline> devuelve una nueva matriz: no modifica la matriz
    sobre la que se invoca. Si esa matriz es dispersa, no se llamará a su función para los
    elementos que falten, pero la matriz devuelta será dispersa del mismo modo que la
    matriz original: tendrá la misma longitud y los mismos elementos que falten.</p>
    <p class="title-article text-left">filter()</p>
    <p>El método <codeinline>filter()</codeinline> devuelve una matriz que contiene un subconjunto de los
    elementos de la matriz sobre la que se invoca. La función que se le pasa debe ser
    predicado: una función que devuelve <codeinline>true</codeinline> o <codeinline>false</codeinline>. El predicado se invoca del
    mismo modo que <codeinline>forEach()</codeinline> y <codeinline>map()</codeinline>. Si el valor de retorno es <codeinline>true</codeinline>, o un valor
    que se convierte en <codeinline>true</codeinline>, entonces el elemento pasado al predicado es un
    miembro del subconjunto y se añade a la matriz que se convertirá en el valor de
    retorno. Ejemplos:</p>
    <pre class="language-js">
    <code class="language-js">let a = [5, 4, 3, 2, 1];
    a.filter(x => x &lt; 3) // => [2, 1]; valores menores que 3
    a.filter((x,i) => i%2 === 0) // => [5, 3, 1]; cualquier otro valor</code></pre>
    <p>Observe que <codeinline>filter()</codeinline> omite los elementos que faltan en las matrices dispersas y que su valor de retorno es siempre denso. Para cerrar los huecos de una matriz dispersa, puede hacer lo siguiente:</p>
    <pre class="language-js">
    <code class="language-js">let dense = sparse.filter(() => true);</code></pre>
    <p>Y para cerrar huecos y eliminar elementos indefinidos y nulos, puedes usar <codeinline>filter</codeinline>, así:</p>
    <pre class="language-js">
    <code class="language-js">a = a.filter(x => x !== undefined && x !== null);</code></pre>
    <p class="title-article text-left">find() y findIndex()</p>
    <p>Los métodos <codeinline>find()</codeinline> y <codeinline>findIndex()</codeinline> son como <codeinline>filter()</codeinline> en el sentido de que recorrenla matriz en busca de elementos para los que la función de predicado devuelva un valor verdadero. Sin embargo, a diferencia de <codeinline>filter()</codeinline>, estos dos métodos dejan de iterar la primera vez que el predicado encuentra un elemento. Cuando esto ocurre, <codeinline>find()</codeinline> devuelve el elemento coincidente y <codeinline>findIndex()</codeinline> devuelve el índice del elemento coincidente. Si no se encuentra ningún elemento coincidente, <codeinline>find()</codeinline> devuelve <codeinline>undefined</codeinline> y <codeinline>findIndex()</codeinline> devuelve <codeinline>-1</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.findIndex(x => x === 3) // => 2; el valor 3 está en el índice 2
    a.findIndex(x => x &lt; 0)   // => -1; no hay numeros negativos en el array
    a.find(x => x % 5 === 0)  // => 5: este es un múltiplo de 5
    a.find(x => x % 7 === 0)  // => undefined: no hay múltiplos de 7 en el array</code></pre>
    <p class="title-article text-left">every() and some()</p>
    <p>Los métodos <codeinline>every()</codeinline> y <codeinline>some()</codeinline> son predicados de matriz: aplican una función de predicado especificada a los elementos de la matriz y devuelven <codeinline>true</codeinline> o <codeinline>false</codeinline>.</p>
    <p>El método <codeinline>every()</codeinline> es como el cuantificador matemático "para todos" ∀: devuelve <codeinline>true</codeinline> si y sólo si su función de predicado devuelve <codeinline>true</codeinline> para todos los elementos de la matriz:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.every(x => x &lt; 10)       // => true: todos los valores son menores que 10
    a.every(x => x % 2 === 0)  // => false: no todos los valores son pares.</code></pre>
    <p>El método <codeinline>some()</codeinline> es como el cuantificador matemático "existe" ∃: devuelve <codeinline>true</codeinline> si existe al menos un elemento en la matriz para el que el predicado devuelve <codeinline>true</codeinline> y devuelve <codeinline>false</codeinline> si y sólo si el predicado devuelve <codeinline>false</codeinline> para todos los elementos del array:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.some(x => x%2===0) // => true; a tiene algunos elementos pares
    a.some(isNaN) // => false; a no tiene numeros NaN.</code>
    </pre>
    <p>Tenga en cuenta que tanto <codeinline>every()</codeinline> como <codeinline>some()</codeinline> dejan de iterar los elementos de la matriz en cuanto saben qué valor devolver. <codeinline>some()</codeinline> devuelve <codeinline>true</codeinline> la primera vez que su predicado devuelve <codeinline>&lt;code>true&lt;/code></codeinline> y sólo itera por toda la matriz si su predicado siempre devuelve <codeinline>false</codeinline>. <codeinline>every()</codeinline> es lo contrario: devuelve <codeinline>false</codeinline> la primera vez que su predicado devuelve <codeinline>false</codeinline> y sólo itera por todos los elementos si su predicado siempre devuelve <codeinline>true</codeinline>. Observe también que, por convención matemática, <codeinline>every()</codeinline> devuelve <codeinline>true</codeinline> y <codeinline>some()</codeinline> devuelve <codeinline>false</codeinline> cuando se invoca sobre una matriz vacía.</p>
    <p class="title-article text-left">reduce() and reduceRight()</p>
    <p>Los métodos <codeinline>reduce()</codeinline> y <codeinline>reduceRight()</codeinline> combinan los elementos de un array, utilizando la función que especifiques, para producir un único valor. Esta es una operación común en la programación funcional y también recibe los nombres de "inyectar" y "plegar". Los ejemplos ayudan a ilustrar cómo funciona:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.reduce((x,y) => x+y, 0)          // => 15; la suma de los valores
    a.reduce((x,y) => x*y, 1)          // => 120; el producto de los valores
    a.reduce((x,y) => (x > y) ? x : y) // => 5; el valor mas grande</code></pre>
    <p><codeinline>reduce()</codeinline> recibe dos argumentos. El primero es la función que realiza la operación de reducción. La tarea de esta función de reducción es combinar o reducir de algún modo dos valores en un único valor y devolver ese valor reducido. En los ejemplos que hemos mostrado aquí, las funciones combinan dos valores sumándolos, multiplicándolos y eligiendo el mayor. El segundo argumento (opcional) es un valor inicial que se pasa a la función.</p>
    <p>Las funciones utilizadas con <codeinline>reduce()</codeinline> son diferentes de las funciones utilizadas con <codeinline>forEach()</codeinline> y <codeinline>map()</codeinline>. El valor familiar, el índice y los valores del array se pasan como segundo, tercer y cuarto argumento. El primer argumento es el resultado acumulado de la reducción hasta el momento. En la primera llamada a la función, este primer argumento es el valor inicial pasado como segundo argumento a <codeinline>reduce()</codeinline>. En llamadas posteriores, es el valor devuelto por la invocación anterior de la función. En el primer ejemplo, la función de reducción se llama primero con los argumentos 0 y 1. Los suma y devuelve 1. A continuación, se llama de nuevo con los argumentos 1 y 2. A continuación, se invoca de nuevo con los argumentos 1 y 2 y devuelve 3. A continuación, calcula 3+3=6, luego 6+4=10 y, por último, 10+5=15. Este valor final, 15, se convierte en el resultado de la reducción. Este valor final, 15, se convierte en el valor de retorno de <codeinline>reduce()</codeinline>.</p>
    <p>Puede que haya notado que la tercera llamada a <codeinline>reduce()</codeinline> en este ejemplo sólo tiene un argumento: no se especifica ningún valor inicial. Cuando se invoca a <codeinline>reduce()</codeinline> sin un valor inicial, utiliza el primer elemento de la matriz como valor inicial. Esto significa que la primera llamada a la función de reducción tendrá el primer y el segundo elemento de la matriz como primer y segundo argumento. En los ejemplos de suma y producto, podríamos haber omitido el argumento del valor inicial.</p>
    <p>Llamar a <codeinline>reduce()</codeinline> en una matriz vacía sin argumento de valor inicial causa un TypeError. Si la llama con un solo valor -una matriz con un elemento y sin valor inicial o una matriz vacía y un valor inicial- simplemente devuelve ese valor sin llamar nunca a la función de reducción.</p>
    <p><codeinline>reduceRight()</codeinline> funciona igual que <codeinline>reduce()</codeinline>, salvo que procesa la matriz desde el índice más alto al más bajo (de derecha a izquierda), en lugar de hacerlo de menor a mayor. Es posible que desee hacer esto si la operación de reducción tiene asociatividad de derecha a izquierda, por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">// Calcula 2^(3^4). La exponenciación tiene procedencia de derecha a izquierda.
    let a = [2, 3, 4];
    a.reduceRight((acc,val) => Math.pow(val,acc)) // => 2.4178516392292583e+24</code></pre>
    <p>Observe que ni <codeinline>reduce()</codeinline> ni <codeinline>reduceRight()</codeinline> aceptan un argumento opcional que especifique el valor <codeinline>this</codeinline> sobre el que se invocará la función de reducción. El argumento opcional valor inicial ocupa su lugar. Consulte el método <codeinline>Function.bind()</codeinline> (<a href="capitulo-8#7-5">§8.7.5</a>) si necesita que su función de reducción se invoque como método de un objeto concreto.</p>
    <p>Los ejemplos mostrados hasta ahora han sido numéricos para simplificar, pero <codeinline>reduce()</codeinline> y <codeinline>reduceRight()</codeinline> no están pensadas únicamente para cálculosmatemáticos. Cualquier función que pueda combinar dos valores (como dos objetos)en un valor del mismo tipo puede utilizarse como función de reducción. Por otraparte, los algoritmos expresados utilizando reducciones de matrices pueden volverserápidamente complejos y difíciles de entender, y puede que descubra que es más fácil leer, escribir y razonar sobre su código si utiliza construcciones de bucle regulares para procesar sus matrices.</p>
  </section>
  <section id="8-2" class="py-4 xs:py-5 sm:py-6">
    <h2>7.8.2 Aplanamiento de matrices con flat() y flatMap()</h2>
    <p>En ES2019, el método <codeinline>flat()</codeinline> crea y devuelve una nueva matriz que contiene los mismos elementos que la matriz a la que se llama, excepto que los elementos que son a su vez matrices se "aplanan" en la matriz devuelta. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">[1, [2, 3]].flat() // => [1, 2, 3]
    [1, [2, [3]]].flat() // => [1, 2, [3]]</code></pre>
    <p>Cuando se invoca sin argumentos, <codeinline>flat()</codeinline> aplana un nivel de anidamiento. Los elementos de la matriz original que son a su vez matrices se aplanan, pero los elementos de matriz de <em>esas</em> matrices no se aplanan. Si desea aplanar más niveles, pase un número a <codeinline>flat()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1, [2, [3, [4]]]];
    a.flat(1) // => [1, 2, [3, [4]]]
    a.flat(2) // => [1, 2, 3, [4]]
    a.flat(3) // => [1, 2, 3, 4]
    a.flat(4) // => [1, 2, 3, 4]</code></pre>
    <p>El método <codeinline>flatMap()</codeinline> funciona igual que el método <codeinline>map()</codeinline> (véase "<a href="map">map()</a>"), salvo que la matriz devuelta se aplana automáticamente como si se pasara a <codeinline>flat()</codeinline>. Es decir, llamar a <codeinline>a.flatMap(f)</codeinline> es lo mismo que (pero más eficiente que) <codeinline>a.map(f).flat()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let phrases = ["hola mundo", "la guia definitiva"];
    let words = phrases.flatMap(phrase => phrase.split(" "));
    words // => ["hola", "mundo", "la", "guia", "definitiva"];</code></pre>
    <p>Se puede pensar en <codeinline>flatMap()</codeinline> como una generalización de <codeinline>map()</codeinline> que permite asignar cada elemento de la matriz de entrada a cualquier número de elementos de la matriz de salida. En particular, <codeinline>flatMap()</codeinline> permite asignar elementos de entrada a una matriz vacía, que se aplana a nada en la matriz de salida:</p>
    <pre class="language-js">
    <code class="language-js">// Convertir numeros no negativos en sus raíces cuadradas
    [-2, -1, 1, 2].flatMap(x => x &lt; 0 ? [] : Math.sqrt(x)) // => [1, 2**0.5]</code></pre>
  </section>
  <section id="8-3">
    <h2>7.8.3 Añadir matrices con concat()</h2>
    <p>El método <codeinline>concat()</codeinline> crea y devuelve una nueva matriz que contiene los elementos de la matriz original sobre la que se invocó <codeinline>concat()</codeinline>, seguidos de cada uno de los argumentos de <codeinline>concat()</codeinline>. Si alguno de estos argumentos es a su vez una matriz, entonces son los elementos de la matriz los que se concatenan, no la propia matriz. Tenga en cuenta, sin embargo, que <codeinline>concat()</codeinline> no aplana recursivamente matrices de matrices. <codeinline>concat()</codeinline> no modifica la matriz sobre la que se invoca:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3];
    a.concat(4, 5)          // => [1,2,3,4,5]
    a.concat([4,5],[6,7])   // => [1,2,3,4,5,6,7]; el array se aplana
    a.concat(4, [5,[6,7]])  // => [1,2,3,4,5,[6,7]]; pero no arrays anidados
    a                       // => [1,2,3]; el array original no se modifica</code></pre>
    <p>Tenga en cuenta que <codeinline>concat()</codeinline> hace una nueva copia de la matriz a la que se llama. En muchos casos, esto es lo correcto, pero es una operación cara. Si se encuentra escribiendo código como <codeinline>a = a.concat(x)</codeinline>, entonces debería pensar en modificar su matriz en su lugar con <codeinline>push()</codeinline> o <codeinline>splice()</codeinline> en lugar de crear una nueva.</p>
  </section>
  <section id="8-4" class="py-4 xs:py-5 sm:py-6">
    <h2>7.8.4 Pilas y colas con push(), pop(), shift() y unshift()</h2>
    <p>Los métodos <codeinline>push()</codeinline> y <codeinline>pop()</codeinline> permiten trabajar con matrices como si fueran pilas. El método <codeinline>push()</codeinline> añade uno o más elementos nuevos al final de una matriz y devuelve la nueva longitud de la matriz. A diferencia de <codeinline>concat()</codeinline>, <codeinline>push()</codeinline> no aplana los argumentos de la matriz. El método <codeinline>pop()</codeinline> hace lo contrario: borra el último elemento de una matriz, disminuye la longitud de la matriz y devuelve el valor que ha eliminado. Tenga en cuenta que ambos métodos modifican la matriz en su lugar. La combinación de <codeinline>push()</codeinline> y <codeinline>pop()</codeinline> permite utilizar una matriz JavaScript para implementar una pila de primeras entradas y últimas salidas. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">let stack = [];     // stack == []
    stack.push(1,2);    // stack == [1,2];
    stack.pop();        // stack == [1]; retorna 2
    stack.push(3);      // stack == [1,3]
    stack.pop();        // stack == [1]; retorna 3
    stack.push([4,5]);  // stack == [1,[4,5]]
    stack.pop()         // stack == [1]; retorna [4,5]
    stack.pop();        // stack == []; retorna 1</code></pre>
    <p>El método <codeinline>push()</codeinline> no aplana un array que le pases, pero si quieres empujar todos los elementos de un array a otro array, puedes usar la operación spread (<a href="capitulo-8#3-4">§8.3.4</a>) para aplanarlo explícitamente:</p>
    <pre class="language-js">
    <code class="language-js">a.push(...values);</code></pre>
    <p>Los métodos <codeinline>unshift()</codeinline> y <codeinline>shift()</codeinline> se comportan de forma muy parecida a <codeinline>push()</codeinline> y <codeinline>pop()</codeinline>, excepto en que insertan y eliminan elementos desde el principio de una matriz en lugar de desde el final. <codeinline>unshift()</codeinline> añade uno o varios elementos al principio de la matriz, desplaza los elementos existentes de la matriz a índices superiores para hacer espacio y devuelve la nueva longitud de la matriz. <codeinline>shift()</codeinline> elimina y devuelve el primer elemento de la matriz, desplazando todos los elementos posteriores un lugar hacia abajo para ocupar el nuevo espacio vacante al principio de la matriz. Podrías usar <codeinline>unshift()</codeinline> y <codeinline>shift()</codeinline> para implementar una pila, pero sería menos eficiente que usar <codeinline>push()</codeinline> y <codeinline>pop()</codeinline> porque los elementos del array necesitan ser desplazados hacia arriba o hacia abajo cada vez que un elemento es añadido o eliminado al principio del array. En su lugar, puedes implementar una estructura de datos de cola utilizando <codeinline>push()</codeinline> para añadir elementos al final de una matriz y <codeinline>shift()</codeinline> para eliminarlos desde el principio de la matriz:</p>
    <pre class="language-js">
    <code class="language-js">let q = [];   // q == []
    q.push(1,2);  // q == [1,2]
    q.shift();    // q == [2]; retorna 1
    q.push(3)     // q == [2, 3]
    q.shift()     // q == [3]; retorna 2
    q.shift()     // q == []; retorna 3</code></pre>
    <p>Hay una característica de <codeinline>unshift()</codeinline> que merece la pena destacar porque puede resultarle sorprendente. Cuando se pasan varios argumentos a <codeinline>unshift()</codeinline>, se insertan todos a la vez, lo que significa que terminan en la matriz en un orden diferente al que tendrían si se insertaran de uno en uno:</p>
    <pre class="language-js">
    <code class="language-js">let a = [];     // a == []
    a.unshift(1)    // a == [1]
    a.unshift(2)    // a == [2, 1]
    a = [];         // a == []
    a.unshift(1,2)  // a == [1, 2]</code></pre>
  </section>
  <section id="8.5">
    <h2>7.8.5 Submatrices con slice(), splice(), fill() y copyWithin()</h2>
    <p>Las matrices definen una serie de métodos que funcionan en regiones contiguas, o submatrices o "rebanadas" de una matriz. Las siguientes secciones describen métodos para extraer, reemplazar, rellenar y copiar rebanadas.</p>
    <p class="title-article text-left">slice()</p>
    <p>El método <codeinline>slice()</codeinline> devuelve una <em>porción</em>, o submatriz, de la matriz especificada. Sus dos argumentos especifican el inicio y el final de la porción a devolver. La matriz devuelta contiene el elemento especificado por el primer argumento y todos los elementos subsiguientes hasta, pero sin incluir, el elemento especificado por el segundo argumento. Si sólo se especifica un argumento, la matriz devuelta contiene todos los elementos desde la posición inicial hasta el final de la matriz. Si uno de los argumentos es negativo, especifica un elemento de la matriz relativo a la longitud de la matriz. Un argumento -1, por ejemplo, especifica el último elemento de la matriz, y un argumento -2 especifica el elemento anterior. Tenga en cuenta que <codeinline>slice()</codeinline> no modifica la matriz sobre la que se invoca. He aquí algunos ejemplos:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.slice(0,3);   // Retorna [1,2,3]
    a.slice(3);     // Retorna [4,5]
    a.slice(1,-1);  // Retorna [2,3,4]
    a.slice(-3,-2); // Retorna [3]</code></pre>
    <p class="title-article text-left">splice()</p>
    <p><codeinline>splice()</codeinline> es un método de propósito general para insertar o eliminar elementos de una matriz. A diferencia de <codeinline>slice()</codeinline> y <codeinline>concat()</codeinline>, <codeinline>splice()</codeinline> modifica la matriz sobre la que se invoca. Tenga en cuenta que <codeinline>splice()</codeinline> y <codeinline>slice()</codeinline> tienen nombres muy similares pero realizan operaciones sustancialmente diferentes.</p>
    <p><codeinline>splice()</codeinline> puede borrar elementos de una matriz, insertar nuevos elementos en una matriz o realizar ambas operaciones al mismo tiempo. Los elementos de la matriz que vienen después del punto de inserción o borrado tienen sus índices aumentados o disminuidos según sea necesario para que permanezcan contiguos con el resto de la matriz. El primer argumento de <codeinline>splice()</codeinline> especifica la posición de la matriz en la que debe comenzar la inserción y/o borrado. El segundo argumento especifica el número de elementos que deben ser eliminados (empalmados) de la matriz. (Observe que ésta es otra diferencia entre estos dos métodos. El segundo argumento de <codeinline>splice()</codeinline> es una posición final. El segundo argumento de <codeinline>splice()</codeinline> es una longitud). Si se omite este segundo argumento, se eliminan todos los elementos de la matriz desde el elemento inicial hasta el final de la matriz. <codeinline>splice()</codeinline> devuelve una matriz con los elementos eliminados, o una matriz vacía si no se ha eliminado ningún elemento. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5,6,7,8];
    a.splice(4)   // => [5,6,7,8]; a ahora es [1,2,3,4]
    a.splice(1,2) // => [2,3]; a ahora es [1,4]
    a.splice(1,1) // => [4]; a ahora es [1]</code></pre>
    <p>Los dos primeros argumentos de <codeinline>splice()</codeinline> especifican qué elementos de la matriz deben eliminarse. Estos argumentos pueden ir seguidos de cualquier número de argumentos adicionales que especifiquen los elementos que se van a insertar en la matriz, comenzando en la posición especificada por el primer argumento. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.splice(2,0,"a","b") // => []; a ahora es [1,2,"a","b",3,4,5]
    a.splice(2,2,[1,2],3) // => ["a","b"]; a ahora es [1,2,[1,2],3,3,4,5]</code></pre>
    <p>Tenga en cuenta que, a diferencia de <codeinline>concat()</codeinline>, <codeinline>splice()</codeinline> inserta las propias matrices, no los elementos de esas matrices.</p>
    <p class="title-article text-left">fill()</p>
    <p>El método <codeinline>fill()</codeinline> establece los elementos de una matriz, o un segmento de una matriz, a un valor especificado. Modifica la matriz a la que se llama y también devuelve la matriz modificada:</p>
    <pre class="language-js">
    <code class="language-js">let a = new Array(5); // Comienza sin elementos y con longitud 5
    a.fill(0)             // => [0,0,0,0,0]; rellenar el array con ceros
    a.fill(9, 1)          // => [0,9,9,9,9]; rellena con 9 empezando en el indice 1
    a.fill(8, 2, -1)      // => [0,9,8,8,9]; rellena con 8 en los indices 2, 3</code></pre>
    <p>El primer argumento de <codeinline>fill()</codeinline> es el valor que se asigna a los elementos de la matriz. El segundo argumento opcional especifica el índice inicial. Si se omite, el llenado comienza en el índice 0. El tercer argumento opcional especifica el índice final: se rellenarán los elementos de la matriz hasta este índice, pero sin incluirlo. Si se omite este argumento, la matriz se rellena desde el índice inicial hasta el final. Puede especificar índices relativos al final del array pasando números negativos, igual que con <codeinline>slice()</codeinline>.</p>
    <p class="title-article text-left">copyWithin()</p>
    <p><codeinline>copyWithin()</codeinline> copia una porción de una matriz a una nueva posición dentro de la matriz. Modifica la matriz en su lugar y devuelve la matriz modificada, pero no cambiará la longitud de la matriz. El primer argumento especifica el índice de destino al que se copiará el primer elemento. El segundo argumento especifica el índice del primer elemento a copiar. Si se omite este segundo argumento, se utiliza 0. El tercer argumento especifica el final de la porción de elementos a copiar. Si se omite, se utiliza la longitud de la matriz. Se copiarán los elementos desde el índice inicial hasta el índice final, pero sin incluirlos. Puede especificar índices relativos al final de la matriz pasando números negativos, igual que para <codeinline>slice()</codeinline>:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3,4,5];
    a.copyWithin(1)       // => [1,1,2,3,4]: copia los elementos del array 
    a.copyWithin(2, 3, 5) // => [1,1,3,4,4]: copia los últimos 2 elementos a index 2
    a.copyWithin(0, -2)   // => [4,4,3,4,4]: los desplazamientos negativos también funcionan</code></pre>
    <p><codeinline>copyWithin()</codeinline> es un método de alto rendimiento especialmente útil con matrices tipadas (véase <a href="capitulo-11#2">§11.2</a>) Se basa en la función <codeinline>memmove()</codeinline> de la biblioteca estándar de C. Tenga en cuenta que la copia funcionará correctamente incluso si hay solapamiento entre las regiones de origen y destino.</p>
  </section>
  <section id="8-6" class="py-4 xs:py-5 sm:py-6">
    <h2>7.8.6 Métodos de búsqueda y ordenación de matrices</h2>
    <p>Las matrices implementan los métodos <codeinline>indexOf()</codeinline>, <codeinline>lastIndexOf()</codeinline> e <codeinline>includes()</codeinline> que son similares a los métodos del mismo nombre de las cadenas. También existen los métodos <codeinline>sort()</codeinline> e <codeinline>reverse()</codeinline> para reordenar los elementos de una matriz. Estos métodos se describen en las subsecciones siguientes.</p>
    <p class="title-article text-left">indexOf() y lastIndexOf()</p>
    <p><codeinline>indexOf()</codeinline> y <codeinline>lastIndexOf()</codeinline> buscan en una matriz un elemento con un valor especificado y devuelven el índice del primer elemento encontrado, o <codeinline>-1</codeinline> si no se encuentra ninguno. <codeinline>indexOf()</codeinline> busca en la matriz desde el principio hasta el final, y <codeinline>lastIndexOf()</codeinline> busca desde el final hasta el principio:</p>
    <pre class="language-js">
    <code class="language-js">let a = [0,1,2,1,0];
    a.indexOf(1)      // => 1: a[1] is 1
    a.lastIndexOf(1)  // => 3: a[3] is 1
    a.indexOf(3)      // => -1: no hay elemento con el valor de 3</code></pre>
    <p><codeinline>indexOf()</codeinline> y <codeinline>lastIndexOf()</codeinline> comparan su argumento con los elementos de la matriz utilizando el equivalente del operador <codeinline>===</codeinline>. Si la matriz contiene objetos en lugar de valores primitivos, estos métodos comprueban si dos referencias se refieren exactamente al mismo objeto. Si realmente quieres ver el contenido de un objeto, prueba a utilizar el método <codeinline>find()</codeinline> con tu propia función predicada personalizada.</p>
    <p><codeinline>indexOf()</codeinline> y <codeinline>lastIndexOf()</codeinline> toman un segundo argumento opcional que especifica el índice de la matriz en el que comenzar la búsqueda. Si se omite este argumento, <codeinline>indexOf()</codeinline> empieza por el principio y <codeinline>lastIndexOf()</codeinline> empieza por el final. Se permiten valores negativos para el segundo argumento y se tratan como un desplazamiento desde el final de la matriz, al igual que para el método <codeinline>slice()</codeinline>: un valor de <codeinline>-1</codeinline>, por ejemplo, especifica el último elemento de la matriz.</p>
    <p>La siguiente función busca un valor especificado en una matriz y devuelve una matriz con <em>todos</em> los índices coincidentes. Esto demuestra cómo se puede utilizar el segundo argumento de <codeinline>indexOf()</codeinline> para encontrar coincidencias más allá del primero.</p>
    <pre class="language-js">
    <code class="language-js">// Encuentra todas las ocurrencias de un valor x en un array a y devuelve un array
    // de indices de coincidencia
    function findall(a, x) &lbrace;
      let results = [],           // Los arrays de indices que devolveremos
        len = a.length,           // La longitud del array a ser buscado
        pos = 0;                  // La posición desde la que buscar
      while(pos &lt; len) &lbrace;          // Mientras que haya elementos para buscar...
        pos = a.indexOf(x, pos);  // Buscar
        if (pos === -1) break;    // Si no encuentras nada, salir
        results.push(pos);        // De lo contrario, guardar el índice encontrado
        pos = pos + 1;            // Y comienza la búsqueda del siguiente elemento
      }
      return results;             // Devuelve el array de indices
    }</code></pre>
    <p>Tenga en cuenta que las cadenas tienen métodos <codeinline>indexOf()</codeinline> y <codeinline>lastIndexOf()</codeinline> que funcionan como estos métodos de matriz, excepto que un segundo argumento negativo se trata como cero.</p>
    <p class="title-article text-left">includes()</p>
    <p>El método <codeinline>includes()</codeinline> de ES2016 toma un único argumento y devuelve <codeinline>true</codeinline> si la matriz contiene ese valor o <codeinline>false</codeinline> en caso contrario. No indica el índice del valor, sólo si existe. El método <codeinline>includes()</codeinline> es efectivamente una prueba de pertenencia a un conjunto para los arrays. Tenga en cuenta, sin embargo, que las matrices no son una representación eficiente de los conjuntos, y si está trabajando con más de unos pocos elementos, debe utilizar un objeto Set real (<a href="capitulo-11#1-1">§11.1.1</a>).</p>
    <p>El método <codeinline>includes()</codeinline> es ligeramente diferente del método <codeinline>indexOf()</codeinline> en un aspecto importante. <codeinline>indexOf()</codeinline> comprueba la igualdad utilizando el mismo algoritmo que el operador <codeinline>===</codeinline>, y ese algoritmo de igualdad considera que el valor no numérico es diferente de cualquier otro valor, incluido él mismo. <codeinline>includes()</codeinline> utiliza una versión ligeramente diferente de la igualdad que considera que <codeinline>NaN</codeinline> es igual a sí mismo. Esto significa que <codeinline>indexOf()</codeinline> no detectará el valor <codeinline>NaN</codeinline> en una matriz, pero <codeinline>includes()</codeinline> sí lo hará:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,true,3,NaN];
    a.includes(true)  // => true
    a.includes(2)     // => false
    a.includes(NaN)   // => true
    a.indexOf(NaN)    // => -1; indexOf no puede encontrar NaN</code></pre>
    <p class="title-article text-left">sort()</p>
    <p><codeinline>sort()</codeinline> ordena los elementos de una matriz en su lugar y devuelve la matriz ordenada. Cuando se llama a <codeinline>sort()</codeinline> sin argumentos, ordena los elementos de la matriz por orden alfabético (convirtiéndolos temporalmente en cadenas para realizar la comparación, si es necesario):</p>
    <pre class="language-js">
    <code class="language-js">let a = ["banana", "cherry", "apple"];
    a.sort(); // a == ["apple", "banana", "cherry"]</code></pre>
    <p>Si una matriz contiene elementos indefinidos, se ordenan al final de la matriz. Para ordenar una matriz en un orden distinto del alfabético, debe pasar una función de comparación como argumento a <codeinline>sort()</codeinline>. Esta función decide cuál de sus dos argumentos debe aparecer primero en la matriz ordenada. Si el primer argumento debe aparecer antes que el segundo, la función de comparación debe devolver un número menor que cero. Si el primer argumento debe aparecer después del segundo en la matriz ordenada, la función debe devolver un número mayor que cero. Y si los dos valores son equivalentes (es decir, si su orden es irrelevante), la función de comparación debe devolver 0. Así, por ejemplo, para ordenar los elementos de una matriz en orden numérico en lugar de alfabético, puede hacer lo siguiente:</p>
    <pre class="language-js">
    <code class="language-js">let a = [33, 4, 1111, 222];
    a.sort();               // a == [1111, 222, 33, 4]; orden alfabético
    a.sort(function(a,b) &lbrace;  // Pasa una función de comparación
    return a-b;             // Returns &lt; 0, 0, or > 0, dependiendo del orden
    });                     // a == [4, 33, 222, 1111]; orden numerico
    a.sort((a,b) => b-a);   // a == [1111, 222, 33, 4]; invertir el orden numérico</code></pre>
    <p>Como otro ejemplo de ordenación de elementos de matrices, puede realizar una ordenación alfabética sin distinguir mayúsculas de minúsculas en una matriz de cadenas pasando una función de comparación que convierte ambos argumentos a minúsculas (con el método <codeinline>toLowerCase()</codeinline>) antes de compararlos:</p>
    <pre class="language-js">
    <code class="language-js">let a = ["ant", "Bug", "cat", "Dog"];
    a.sort(); // a == ["Bug","Dog","ant","cat"]; orden sensible a mayúsculas y minúsculas
    a.sort(function(s,t) &lbrace;
      let a = s.toLowerCase();
      let b = t.toLowerCase();
      if (a &lt; b) return -1;
      if (a > b) return 1;
      return 0;
    }); // a == ["ant","Bug","cat","Dog"]; orden sensible a mayúsculas y minúsculas</code></pre>
    <p class="title-article text-left">reverse()</p>
    <p>El método <codeinline>reverse()</codeinline> invierte el orden de los elementos de una matriz y devuelve la matriz invertida. Lo hace en su lugar; en otras palabras, no crea una nueva matriz con los elementos reordenados, sino que los reordena en la matriz ya existente:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3];
    a.reverse(); // a == [3,2,1]</code></pre>
  </section>
  <section id="8-7">
    <h2>7.8.7 Conversión de arrays a cadenas</h2>
    <p>La clase Array define tres métodos que pueden convertir arrays en cadenas, que es algo que generalmente se hace al crear mensajes de registro y de error. (Si desea guardar el contenido de un array en forma textual para su posterior reutilización, serialice el array con <codeinline>JSON.stringify()</codeinline> [<a href="capitulo-6#8">§6.8</a>] en lugar de utilizar los métodos descritos aquí).</p>
    <p>El método join() convierte todos los elementos de una matriz en cadenas y las concatena, devolviendo la cadena resultante. Puede especificar una cadena opcional que separe los elementos en la cadena resultante. Si no se especifica ninguna cadena separadora, se utiliza una coma:</p>
    <pre class="language-js">
    <code class="language-js">let a = [1,2,3];
    a.reverse();            // a == [3,2,1]
    a.join(" ")             // => "1 2 3"
    a.join("")              // => "123"
    let b = new Array(10);  // Un array de 10 elementos vacíos
    b.join("-")             // => "---------": un string de 9 guiones</code></pre>
    <p>El método <codeinline>join()</codeinline> es el inverso del método <codeinline>String.split()</codeinline>, que crea una matriz dividiendo una cadena en trozos.</p>
    <p>Las matrices, como todos los objetos de JavaScript, tienen un método <codeinline>toString()</codeinline>. Para un array, este método funciona igual que el método <codeinline>join()</codeinline> sin argumentos:</p>
    <pre class="language-js">
    <code class="language-js">[1,2,3].toString()          // => "1,2,3"
    ["a", "b", "c"].toString()  // => "a,b,c"
    [1, [2,"c"]].toString()     // => "1,2,c"</code></pre>
    <p>Tenga en cuenta que la salida no incluye corchetes ni ningún otro tipo de delimitador alrededor del valor de la matriz.</p>
    <p><codeinline>toLocaleString()</codeinline> es la versión localizada de <codeinline>toString()</codeinline>. Convierte cada elemento de la matriz en una cadena llamando al método <codeinline>toLocaleString()</codeinline> del elemento y, a continuación, concatena las cadenas resultantes utilizando una cadena separadora específica de la localización (y definida por la implementación).</p>
  </section>
  <section id="8-8" class="py-4 xs:py-5 sm:py-6">
    <h2>7.8.8 Funciones estáticas de matrices</h2>
    <p>Además de los métodos de array que ya hemos documentado, la clase Array también define tres funciones estáticas que puedes invocar a través del constructor Array en lugar de sobre los arrays. <codeinline>Array.of()</codeinline> y <codeinline>Array.from()</codeinline> son métodos de fábrica para crear nuevas matrices. Se documentaron en <a href="#1-4">§7.1.4</a> y <a href="#1-5">§7.1.5</a>.</p>
    <p>La otra función estática de array es <codeinline>Array.isArray()</codeinline>, que es útil para determinar si un valor desconocido es un array o no:</p>
    <pre class="language-js">
    <code class="language-js">Array.isArray([]) // => true
    Array.isArray(&lbrace;}) // => false</code></pre>
  </section>
  <section id="9">
    <h2>7.9 Objetos similares a matrices</h2>
    <p>Como hemos visto, las matrices de JavaScript tienen algunas características especiales que otros objetos no tienen:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La propiedad de <codeinline>length</codeinline> se actualiza automáticamente a medida que se añaden nuevos elementos a la lista.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Si se ajusta la <codeinline>length</codeinline> a un valor menor, se trunca la matriz.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Las matrices heredan métodos útiles de <codeinline>Array.prototype</codeinline>.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          <codeinline>Array.isArray()</codeinline> devuelve verdadero para las matrices.
        </p>
      </li>
    </ul>
    <p>Estas son las características que distinguen a los arrays de JavaScript de los objetos normales. Pero no son las características esenciales que definen un array. A menudo es perfectamente razonable tratar cualquier objeto con una propiedad de <codeinline>length</codeinline> numérica y sus correspondientes propiedades de enteros no negativos como un tipo de array.</p>
    <p>Estos objetos "tipo array" aparecen ocasionalmente en la práctica, y aunque no puedes invocar directamente métodos de array sobre ellos o esperar un comportamiento especial de la propiedad <codeinline>length</codeinline>, puedes iterar a través de ellos con el mismo código que usarías para un array real. Resulta que muchos algoritmos de matrices funcionan igual de bien con objetos similares a matrices que con matrices reales. Esto es especialmente cierto si tus algoritmos tratan el array como de sólo lectura o si al menos dejan la longitud del array sin cambios.</p>
    <p>El siguiente código toma un objeto normal, le añade propiedades para convertirlo en un objeto similar a un array y, a continuación, itera a través de los "elementos" del pseudoarray resultante:</p>
    <pre class="language-js">
    <code class="language-js">let a = &lbrace;}; // Comienza con un objeto vacio normal

    // Agrega propiedades para convertirlo en un array
    let i = 0;
    while(i &lt; 10) &lbrace;
      a[i] = i * i;
      i++;
    }
    a.length = i;

    // Ahora itera como si fuera un array real
    let total = 0;
    for(let j = 0; j &lt; a.length; j++) &lbrace;
      total += a[j];
    }</code></pre>
    <p>En JavaScript del lado del cliente, varios métodos para trabajar con documentos HTML (como <codeinline>document.querySelectorAll()</codeinline>, por ejemplo) devuelven objetos similares a matrices. Aquí tienes una función que puedes utilizar para buscar objetos que funcionen como arrays:</p>
    <pre class="language-js">
    <code class="language-js">// Determina si o es un objeto tipo array.
    // Strings y funciones tienen propiedades de longitud numéricas y
    // excluido por la prueba typeof. En JavaScript del lado del cliente, los
    // nodos de texto en el DOM tiene una propiedad de longitud numérica y
    // puede ser necesario excluirlo con una prueba adicional.
    function isArrayLike(o) &lbrace;
      if (o &&                        // o no es null, undefined, etc.
        typeof o === "object" &&      // o es un objeto
        Number.isFinite(o.length) &&  // o.length es un número finito
        o.length >= 0 &&              // o.length no es negativo
        Number.isInteger(o.length) && // o.length es un entero
        o.length &lt; 4294967295) &lbrace;      // o.length &lt; 2^32 - 1
        return true;                  // Entonces o es tipo array.
      } else &lbrace;
        return false;                 // Caso contrario, no lo es.
      }
    }</code></pre>
    <p>En una sección posterior veremos que las cadenas se comportan como matrices. No obstante, las pruebas como ésta para objetos tipo array suelen devolver <codeinline>false</codeinline> para las cadenas: normalmente es mejor tratarlas como cadenas, no como arrays.</p>
    <p>La mayoría de los métodos de array de JavaScript se definen a propósito para que sean genéricos y funcionen correctamente cuando se aplican a objetos tipo array además de a arrays reales. Dado que los objetos tipo array no heredan de <codeinline>Array.prototype</codeinline>, no es posible invocar métodos de array directamente sobre ellos. Sin embargo, puedes invocarlos indirectamente utilizando el método <codeinline>Function.call</codeinline> (véase <a href="capitulo-8#7-4">§8.7.4</a> para más detalles):</p>
    <pre class="language-js">
    <code class="language-js">let a = &lbrace;"0": "a", "1": "b", "2": "c", length: 3}; // An array-like object
    Array.prototype.join.call(a, "+")                  // => "a+b+c"
    Array.prototype.map.call(a, x => x.toUpperCase())  // => ["A","B","C"]
    Array.prototype.slice.call(a, 0)                   // => ["a","b","c"]: true array copy
    Array.from(a)                                      // => ["a","b","c"]: easier array copy</code></pre>
    <p>La penúltima línea de este código invoca el método Array <codeinline>slice()</codeinline> en un objeto tipo array para copiar los elementos de ese objeto en un verdadero objeto array. Este es un truco idiomático que existe en mucho código heredado, pero ahora es mucho más fácil de hacer con <codeinline>Array.from()</codeinline>.</p>
  </section>
  <section id="10" class="py-4 xs:py-5 sm:py-6">
    <h2>7.10 Cadenas como matrices</h2>
    <p>Las cadenas JavaScript se comportan como matrices de sólo lectura de caracteres Unicode UTF-16. En lugar de acceder a caracteres individuales con el método <codeinline>charAt()</codeinline>, puede utilizar corchetes:</p>
    <pre class="language-js">
    <code class="language-js">let s = "test";
    s.charAt(0) // => "t"
    s[1]        // => "e"</code></pre>
    <p>El operador <codeinline>typeof</codeinline> sigue devolviendo "cadena" para las cadenas, por supuesto, y el método <codeinline>Array.isArray()</codeinline> devuelve <codeinline>false</codeinline> si se le pasa una cadena.</p>
    <p>La principal ventaja de las cadenas indexables es simplemente que podemos sustituir las llamadas a <codeinline>charAt()</codeinline> por corchetes, que son más concisos y legibles, y potencialmente más eficientes. Sin embargo, el hecho de que las cadenas se comporten como matrices también significa que podemos aplicarles métodos genéricos de matrices. Por ejemplo:</p>
    <pre class="language-js">
    <code class="language-js">Array.prototype.join.call("JavaScript", " ") // => "J a v a S c r i p t"</code></pre>
    <p>Tenga en cuenta que las cadenas son valores inmutables, por lo que cuando se tratan como matrices, son matrices de sólo lectura. Los métodos de matrices como <codeinline>push()</codeinline>, <codeinline>sort()</codeinline>, <codeinline>reverse()</codeinline> y <codeinline>splice()</codeinline> modifican una matriz en su lugar y no funcionan con cadenas. Sin embargo, intentar modificar una cadena utilizando un método de matriz no provoca un error: simplemente falla en silencio.</p>
  </section>
  <section id="11" class="pb-4 xs:pb-5 sm:pb-6">
    <h2>7.11 Resumen</h2>
    <p>Este capítulo ha cubierto en profundidad los arrays de JavaScript, incluyendo detalles esotéricos sobre arrays dispersos y objetos tipo array. Los puntos principales de este capítulo son:</p>
    <ul>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Los literales de matriz se escriben como listas de valores separados por comas entre corchetes.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          Para acceder a cada elemento de la matriz, especifique el índice deseado entre corchetes.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          El bucle <codeinline>for/of</codeinline> y el operador <codeinline>...</codeinline> spread introducidos en ES6 son formas especialmente útiles de iterar matrices.
        </p>
      </li>
      <li class="font-normal list-none flex gap-2 xs:gap-3 sm:gap-4">
        <span class="text-lg xs:text-xs sm:text-base md:text-lg">⏺</span>
        <p>
          La clase Array define un rico conjunto de métodos para manipular arrays, y deberías asegurarte de familiarizarte con la API Array.
        </p>
      </li>
    </ul>
  </section>
</Layoutjavascript>