---
import Layoutcracking from "../../layouts/Layoutcracking.astro"
---
<Layoutcracking title="Como superar una entrevista de codificación">
  <h1>Parte VII</h1>
  <h2>Preguntas técnicas</h2>
  <article>
    <p>
      Las preguntas técnicas son la base de las entrevistas de muchas de las principales empresas tecnológicas. Muchos candidatos se sienten intimidados por la dificultad de estas preguntas, pero hay formas lógicas de abordarlas.
    </p>
  </article>
  <article>
    <h3>►
      Cómo prepararse
    </h3>
    <p>
      Muchos candidatos se limitan a leer los problemas y las soluciones. Eso es como intentar aprender cálculo leyendo un problema y su respuesta. Hay que practicar la resolución de problemas. Memorizar las soluciones no te ayudará mucho.
    </p>
    <p>
      Haga lo siguiente con cada problema de este libro (y con cualquier otro problema que se le plantee):
    </p>
    <ol>
      <li><em>Intente resolver el problema por su cuenta.</em>
        Al final de este libro encontrará algunas pistas, pero esfuércese por desarrollar una solución con la menor ayuda posible. Muchas preguntas están diseñadas para ser difíciles, ¡no pasa nada! Cuando estés resolviendo un problema, asegúrate de pensar en la eficiencia de espacio y tiempo.
      </li>
      <li><em>Escribe el código en papel.</em>
        Codificar en un ordenador ofrece lujos como el resaltado de sintaxis, la compleción del código y la depuración rápida. Codificar en papel no. Acostúmbrate a esto -y a lo lento que es escribir y editar código- codificando en papel.
      </li>
      <li><em>Prueba tu código en papel.</em>
        Esto significa probar los casos generales, los casos base, los casos de error, etcétera. Tendrás que hacerlo durante la entrevista, así que es mejor que lo practiques con antelación.
      </li>
      <li><em>Escribe tu código en papel tal cual en un ordenador.</em>
        Probablemente cometerás un montón de errores. Haz una lista de todos los errores que cometas para tenerlos en cuenta durante la entrevista.
      </li>
    </ol>
    <p>Además, intenta hacer tantos simulacros de entrevista como puedas. Tú y un amigo podéis turnaros para haceros entrevistas de prueba. Aunque tu amigo no sea un entrevistador experto, puede guiarte a través de un problema de codificación o algoritmo. También aprenderás mucho experimentando lo que es ser entrevistador.</p>
  </article>
  <article>
    <h3>► Lo que necesitas saber</h3>
    <p>
      Los tipos de preguntas sobre estructuras de datos y algoritmos en los que se centran muchas empresas no son pruebas de conocimientos. Sin embargo, presuponen unos conocimientos básicos.
    </p>
  </article>
  <article>
    <p><strong>Estructuras de datos, algoritmos y conceptos básicos</strong></p>
    <p>
      La mayoría de los entrevistadores no preguntarán sobre algoritmos específicos para equilibrar árboles binarios u otros algoritmos complejos. Francamente, al llevar varios años fuera de la escuela, probablemente tampoco recuerden estos algoritmos.
    </p>
    <p>
      Por lo general, sólo se espera que conozcas lo básico. Aquí tienes una lista de conocimientos imprescindibles:
    </p>
    <div class="w-full flex justify-center my-8">
      <table class="font-poppins">
        <thead>
          <tr>
            <td>Estructura de Datos</td>
            <td>Algoritmos</td>
            <td>Conceptos</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Listas enlazadas</td>
            <td>Búsqueda exhaustiva</td>
            <td>Manipulación de bits</td>
          </tr>
          <tr>
            <td>Árboles, Pruebas y Gráficos</td>
            <td>Búsqueda en profundidad</td>
            <td>Memoria (pila vs. montón)</td>
          </tr>
          <tr>
            <td>Pilas y colas</td>
            <td>Búsqueda binaria</td>
            <td>Recursión</td>
          </tr>
          <tr>
            <td>Montones</td>
            <td>Ordenación combinada</td>
            <td>Programación dinámica</td>
          </tr>
          <tr>
            <td>Vectores y listas array</td>
            <td>Ordenación rápida</td>
            <td>Tiempo y espacio Big O</td>
          </tr>
          <tr>
            <td>Tablas hash</td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
    </div>
    <p>
      Para cada uno de estos temas, asegúrate de que entiendes cómo utilizarlos e implementarlos y, en su caso, la complejidad espacial y temporal.
    </p>
    <p>
      Practicar la implementación de las estructuras de datos y el algoritmo (en papel, y luego en un ordenador) también es un gran ejercicio. Te ayudará a aprender cómo funciona el interior de las estructuras de datos, lo que es importante para muchas entrevistas.
    </p>
    <p class="pl-4 sm:pl-6 md:pl-8 border-l-2 sm:border-l-4 md:border-l-8 border-black">
      ¿Te has perdido este párrafo? Es muy importante. Si no te sientes muy, muy cómodo con cada una de las estructuras de datos y algoritmos listados, practica implementándolos desde cero
    </p>
    <p>
      En particular, las tablas hash son un tema extremadamente importante. Asegúrate de que te sientes muy cómodo con esta estructura de datos.
    </p>
  </article>
  <article>
    <p><strong>Tabla de Potencias de 2</strong></p>
    <p>
      La tabla de abajo es útil para muchas preguntas que involucran escalabilidad o cualquier tipo de limitación de memoria. Memo rizar esta tabla no es estrictamente necesario, pero puede ser útil. Al menos debería sentirse cómodo derivándola.
    </p>
    <div class="w-full flex justify-center my-8">
      <table class="font-poppins">
        <thead  class="text-center">
          <tr>
            <td>Power of 2</td>
            <td>Exact Value (x)</td>
            <td>Approx. Value</td>
            <td>X Bytes into MB, GB, etc.</td>
          </tr>
        </thead>
        <tbody class="text-center">
          <tr>
            <td>7</td>
            <td>128</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>8</td>
            <td>256</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>10</td>
            <td>1024</td>
            <td>1 thousand</td>
            <td>1 KB</td>
          </tr>
          <tr>
            <td>16</td>
            <td>65,536</td>
            <td></td>
            <td>64 KB</td>
          </tr>
          <tr>
            <td>20</td>
            <td>1,048,576</td>
            <td>1 million</td>
            <td>1 M</td>
          </tr>
          <tr>
            <td>30</td>
            <td>1,073,741,824</td>
            <td>1 billion</td>
            <td>1 GB</td>
          </tr>
          <tr>
            <td>32</td>
            <td>4,294,967,296</td>
            <td></td>
            <td>4 GB</td>
          </tr>
          <tr>
            <td>40</td>
            <td>l,099,511,627,776</td>
            <td>1 trillion</td>
            <td>1 TB</td>
          </tr>
        </tbody>
      </table>
    </div>
    <p>
      Por ejemplo, puedes usar esta tabla para calcular rápidamente que un vector de bits que asigna cada entero de 32 bits a un valor booleano puede caber en la memoria de una máquina típica. Hay 2<sup>32</sup> números enteros. Dado que cada entero ocupa un bit en este vector de bits, necesitamos 2<sup>32</sup> bits (o 2<sup>29</sup> bytes) para almacenar esta asignación, lo que equivale aproximadamente a medio giga byte de memoria, que puede almacenarse fácilmente en una máquina normal.
    </p>
    <p>
      Si va a realizar una entrevista telefónica con una empresa que opera a través de Internet, puede resultarle útil tener esta tabla a mano.
    </p>
  </article>
  <article>
    <h3>► Recorrido del problema</h3>
    <p>
      El siguiente mapa/diagrama de flujo te guía a través de la resolución de un problema. Utilícelo en sus prácticas. Puedes descargar este manual y otros más en CrackingTheCodinglnterview.com.
    </p>
    <p class="font-light italic text-center sm:text-2xl md:text-3xl">
      Un diagrama de flujo de resolución de problemas
    </p>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">1</span>
        Escuche
      </p>
      <p>
        <strong>Presta mucha dosis de atención</strong> a toda la información de la descripción del problema. Probablemente la necesites toda para un algoritmo óptimo.
      </p>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">2</span>
        Ejemplo
      </p>
      <p>
        La mayoría de los ejemplos son demasiado pequeños o son casos especiales. <strong>Depura tu ejemplo</strong>. ¿Es un caso especial? ¿Es lo suficientemente grande?
      </p>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">3</span>
        Fuerza bruta
      </p>
      <p>
        Consigue una solución de fuerza bruta lo antes posible. No te preocupes por desarrollar un algoritmo eficiente todavía. Establece un algoritmo ingenuo y su tiempo de ejecución, luego optimiza a partir de ahí. Pero no codifique todavía'.
      </p>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">4</span>
        Optimiza
      </p>
      <p>
        Repasa tu fuerza bruta con la <strong>optimización BUD</strong> o prueba algunas de estas ideas:
      </p>
      <ol>
        <li>
          Busca cualquier información no utilizada. Normalmente necesitas toda la información de un problema.
        </li>
        <li>
          Resuélvelo manualmente en un ejemplo, luego haz ingeniería inversa de tu proceso de pensamiento. ¿Cómo lo resolviste?
        </li>
        <li>
          Resuélvelo «incorrectamente» y piensa por qué falla el algoritmo. ¿Puedes solucionar esos problemas?
        </li>
        <li>
          Haz una tabla de tiempos vs. espacios. ¡Las tablas hash son especialmente útiles!
        </li>
        <li>
        </li>
      </ol>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">5</span>
        Recorrido
      </p>
      <p>
        Ahora que tiene una solución óptima, <strong>repase su planteamiento en detalle</strong>. Asegúrate de que entiendes todos los detalles antes de empezar a programar.
      </p>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">6</span>
        Implementar
      </p>
      <p>
        Tu objetivo es escribir un <strong>código atractivo</strong>. Modulariza tu código desde el principio y refactoriza para limpiar todo lo que no sea bonito.
      </p>
      <p class="bg-red-200">
        <strong>Sigue hablando</strong> Tu entrevistador quiere saber cómo enfocas el problema.
      </p>
    </div>
    <div>
      <p class="text-3xl"><span class="bg-red-400 w-4 sm:w-8 md:w-12 h-4 sm:h-8 md:h-12 inline-block rounded-lg text-pink-100 font-bold text-center text-lg sm:text-xl md:text-3xl !leading-[3rem]">7</span>
        Prueba
      </p>
      <p>
        Haz las pruebas en este orden:
      </p>
      <ol>
        <li>
          Prueba conceptual. Recorre el código como lo harías en una revisión detallada.
        </li>
        <li>
          Código inusual o no estándar.
        </li>
        <li>
          Puntos calientes, como nodos aritméticos y nulos.
        </li>
        <li>
          Pequeños casos de prueba. Es mucho más rápido que un caso de prueba grande e igual de eficaz.
        </li>
        <li>
          Casos especiales y casos extremos.
        </li>
      </ol>
      <p>
        Y cuando encuentres errores, <strong>¡arréglalos con cuidado!</strong>
      </p>
    </div>
    <div class="bg-red-200 p-6 rounded-lg">
      <p class="text-2xl">
        BUD Optimización 
      </p>
      <p>
        Cuellos de botella 
      </p>
      <p>
        Trabajo innecesario 
      </p>
      <p>
        Trabajo duplicado
      </p>

    </div>


    







    <p>
      Repasaremos este organigrama con más detalle.
    </p>
  </article>
  <article>
    <p><strong>Qué esperar</strong>
    </p>
    <p>
      Se supone que las entrevistas son difíciles. Si no obtienes todas -o ninguna- respuesta inmediatamente, ¡no pasa nada! Es lo normal y no está mal.
    </p>
    <p>
      Escucha las indicaciones del entrevistador. El entrevistador puede desempeñar un papel más o menos activo en la resolución del problema. El nivel de participación del entrevistador dependerá de tu rendimiento, de la dificultad de la pregunta, de lo que el entrevistador esté buscando y de la propia personalidad del entrevistador.
    </p>
    <p>
      Cuando le planteen un problema (o cuando esté practicando), resuelva el problema siguiendo el planteamiento que se expone a continuación.
    </p>
  </article>
  <article>
    <p><strong>1. Escuche con atención</strong>
    </p>
    <p>
      Es probable que hayas oído este consejo antes, pero te digo algo más que el consejo estándar de «asegúrate de que oyes el problema correctamente».
    </p>
    <p>
      Sí, tienes que escuchar el problema y asegurarte de que lo has oído bien. También debes preguntar todo aquello sobre lo que no estés seguro.
    </p>
    <p>
      Pero digo algo más que eso.
    </p>
    <p>
      Escucha atentamente el problema y asegúrate de haber registrado mentalmente cualquier información exclusiva que contenga.
    </p>
    <p>
      Por ejemplo, supongamos que una pregunta empieza con una de las siguientes líneas. Es razonable suponer que la información está ahí por alguna razón.
    </p>
    <ul>
      <li>
        «Dados dos arrays que están ordenados, hallar ..:
        <p>
          Probablemente necesites saber que los datos están ordenados. El algoritmo óptimo para la situación ordenada es probablemente diferente del algoritmo óptimo para la situación sin ordenar.
        </p>
      </li>
      <li>
        «Diseñar un algoritmo para ser ejecutado repetidamente en un servidor que ...»
        <p>
          La situación del servidor que se ejecuta repetidamente es diferente de la situación en la que se ejecuta una sola vez. ¿Quizás esto signifique que se almacenan datos en caché? ¿O quizás justifique algún cálculo previo razonable sobre el conjunto de datos inicial?
        </p>
      </li>
    </ul>
    <p>
      Es poco probable (aunque no imposible) que tu entrevistador te dé esta información si no afecta al algoritmo.
    </p>
    <p>
      Muchos candidatos escucharán el problema correctamente. Pero a los diez minutos de desarrollar un algoritmo, se han olvidado de algunos de los detalles clave del problema. Ahora se encuentran en una situación en la que realmente no pueden resolver el problema de forma óptima.
    </p>
    <p>
      Su primer algoritmo no necesita utilizar esa información. Pero si te encuentras atascado, o sigues trabajando para desarrollar algo más óptimo, pregúntate si has utilizado toda la información del problema.
    </p>
    <p>
      Puede que incluso te resulte útil escribir la información pertinente en la pizarra.
    </p>
  </article>
  <article>
    <p><strong>
      2. Dibuje un ejemplo
      </strong></p>
    <p>
      Un ejemplo puede mejorar drásticamente tu capacidad para resolver una pregunta de una entrevista y, sin embargo, muchos candidatos se limitan a intentar resolver la pregunta mentalmente.
    </p>
    <p>
      Cuando oigas una pregunta, levántate de la silla, ve a la pizarra y dibuja un ejemplo. 
    </p>
    <p>
      Pero dibujar un ejemplo es todo un arte. Quieres un buen ejemplo.
    </p>
    <p>
      Normalmente, un candidato puede dibujar algo como esto para un ejemplo de un árbol de búsqueda binario:
    </p>
    <p>
      Este es un mal ejemplo por varias razones. Primero, es demasiado pequeño. Tendrás problemas para encontrar un patrón en un ejemplo tan pequeño. Segundo, no es específico. Un árbol de búsqueda binario tiene valores. ¿Y si los números te dicen algo sobre cómo enfocar el problema? Tercero, en realidad es un caso especial. No es sólo un árbol equilibrado, sino también un hermoso y perfecto árbol en el que cada nodo que no sea la hoja tiene dos hijos. Los casos especiales pueden ser muy engañosos.
    </p>
    <p>
      En su lugar, desea crear un ejemplo que es:
    </p>
    <ul>
      <li>
        Específico. Debe utilizar números reales o cadenas (si es aplicable al problema).
      </li>
      <li>
        Suficientemente grande. La mayoría de los ejemplos son demasiado pequeños, aproximadamente un 50%.
      </li>
      <li>
        No sea un caso especial. Tenga cuidado. Es muy fácil dibujar inadvertidamente un caso especial. Si hay alguna forma de que tu ejemplo sea un caso especial (incluso si crees que probablemente no será un gran problema), deberías arreglarlo.
      </li>
    </ul>
    <p>
      Intenta hacer el mejor ejemplo que puedas. Si más tarde resulta que tu ejemplo no es del todo correcto, puedes y debes arreglarlo.
    </p>
  </article>
  <article>
    <p><strong>Enunciar una fuerza bruta</strong>
    </p>
    <p>
      Una vez que tengas un ejemplo hecho (en realidad, puedes cambiar el orden de los pasos 2 y 3 en algunos problemas), plantea una fuerza bruta. Está bien y es de esperar que tu algoritmo inicial no sea muy óptimo.
    </p>
    <p>
      Algunos candidatos no indican la fuerza bruta porque piensan que es obvio y terrible. Pero aquí está la cosa: Incluso si es obvio para ti, no es necesariamente obvio para todos los candidatos. No querrás que tu inter-espectador piense que te cuesta ver incluso la solución fácil.
    </p>
    <p>
      No pasa nada porque esta solución inicial sea terrible. Explica cuál es la complejidad espacial y temporal, y luego sumérgete en las mejoras.
    </p>
    <p>
      A pesar de ser posiblemente lento, un algoritmo de fuerza bruta es valioso para discutir. Es un punto de partida para las optimizaciones y te ayuda a entender el problema.
    </p>
  </article>
  <article>
    <p><strong>Optimice</strong>
    </p>
    <p>
      Una vez que tengas un algoritmo de fuerza bruta, deberías trabajar en su optimización. Algunas técnicas que funcionan bien son:
    </p>
    <ol>
      <li>
        Busca cualquier información que no utilices. ¿Te dijo tu entrevistador que la matriz estaba ordenada? ¿Cómo puedes aprovechar esa información?
      </li>
      <li>
        Utiliza un ejemplo nuevo. A veces, el simple hecho de ver un ejemplo diferente te despejará la mente o te ayudará a ver un patrón en el problema.
      </li>
      <li>
        Resuélvelo «incorrectamente»: al igual que tener una solución ineficiente puede ayudarte a encontrar una solución eficiente, tener una solución incorrecta puede ayudarte a encontrar una solución correcta. Por ejemplo, si te piden que generes un valor aleatorio a partir de un conjunto en el que todos los valores tengan la misma probabilidad, una solución incorrecta podría ser la que devuelve un valor semialeatorio: Se puede obtener cualquier valor, pero algunos son más probables que otros. Entonces puedes pensar por qué esa solución no es perfectamente aleatoria. ¿Puedes reequilibrar las probabilidades?
      </li>
      <li>
        Compensa tiempo y espacio. A veces, almacenar información adicional sobre el problema puede ayudar a optimizar el tiempo de ejecución.
      </li>
      <li>
        Precalcular la información. ¿Hay alguna forma de reorganizar los datos (ordenación, etc.) o de calcular algunos valores por adelantado que ayude a ahorrar tiempo a largo plazo?
      </li>
      <li>
        Utiliza una tabla hash. Las tablas hash se utilizan mucho en las preguntas de las entrevistas y deberían estar en tu mente.
      </li>
      <li>
        Piensa en el mejor tiempo de ejecución concebible (discutido en la pagina 72).
      </li>
    </ol>
    <p>
      Recorre la fuerza bruta con estas ideas en mente y busca BUD (página 67).
    </p>
    <p>

    </p>
  </article>
  <article>
    <p><strong>5. Recorrido</strong></p>
    <p>
      Una vez que hayas dado con un algoritmo óptimo, no te lances a codificarlo. Tómate un momento para consolidar tu comprensión del algoritmo.
    </p>
    <p>
      La codificación en pizarra es lenta, muy lenta. También lo es probar el código y corregirlo. Como resultado, necesitas asegurarte de que lo tienes lo más cerca posible de «perfecto» al principio.
    </p>
    <p>
      Recorre tu algoritmo y hazte una idea de la estructura del código. Sepa cuáles son las variables y cuándo cambian.
    </p>
    <p>
      ¿Y el pseudocódigo? Puedes escribir pseudocódigo si quieres. Ten cuidado con lo que escribes. Pasos básicos ("(1) Buscar matriz. (2) Buscar el mayor. (3) Insertar en el montón:«) o una lógica breve (»si p &#60 q, mueve p. si no, mueve q") pueden ser valiosos. Pero cuando tu pseudocódigo empieza a tener bucles for que están escritos en inglés sencillo, entonces estás esencialmente escribiendo código descuidado. Probablemente sería más rápido simplemente escribir el código
    </p>
    <p>
      Si no entiendes exactamente lo que vas a escribir, te costará codificarlo. Te llevará más tiempo terminar el código y es más probable que cometas errores importantes.
    </p>
  </article>
  <article>
    <p><strong>6. Implementa</strong>
    </p>
    <p>
      Ahora que tienes un algoritmo óptimo y sabes exactamente lo que vas a escribir, sigue adelante e impleméntalo.
    </p>
    <p>
      Empieza a codificar en la esquina superior izquierda de la pizarra (necesitarás espacio). Evita el «salto de línea» (cada línea de código se escribe con una inclinación extraña). Esto hace que tu código parezca desordenado y puede ser muy confuso cuando se trabaja en un lenguaje sensible al espacio en blanco, como Python.
    </p>
    <p>
      Recuerda que sólo tienes una pequeña cantidad de código para demostrar que eres un gran desarrollador. Cada cosa cuenta. Escribe código bonito.
    </p>
    <p>
      Código bonito significa
    </p>
    <ul>
      <li>
        Código modularizado. Esto demuestra un buen estilo de codificación. También hace las cosas más fáciles para usted. Si su algoritmo utiliza una matriz inicializada a &#123&#1231, 2, 3}, &#1234, 5, 6}, ...}, no pierda su tiempo escribiendo este código de inicialización. Simplemente imagine que tiene una función initlncrementalMatrix(int size). Rellena los detalles más tarde si lo necesitas.
      </li>
      <li>
        Comprobación de errores. Algunos entrevistadores se preocupan mucho por esto, mientras que otros no. Un buen compromiso aquí es añadir un todo y luego simplemente explicar en voz alta lo que le gustaría probar.
      </li>
      <li>
        Utiliza otras clases/estructuras cuando sea apropiado. Si necesita devolver una lista de puntos iniciales y finales de una función, puede hacerlo como una matriz bidimensional. Sin embargo, es mejor hacerlo como una lista de objetos StartEndPair (o posiblemente Range). No es necesario rellenar los detalles de la clase. Haz como si existiera y ocúpate de los detalles más adelante si tienes tiempo.
      </li>
      <li>
        Buenos nombres de variables. El código que utiliza variables de una sola letra en todas partes es difícil de leer. Eso no quiere decir que haya nada malo en usar i y j, cuando sea apropiado (como en un bucle for básico que recorre un array). Sin embargo, tenga cuidado con dónde lo hace. Si escribes algo como int i = startOfChild ( array), puede que haya un nombre mejor para esta variable, como startChild.
        <p>
          Los nombres de variables largos también pueden ser lentos de escribir. Un buen compromiso con el que la mayoría de los entrevistadores estarán de acuerdo es abreviarlo después del primer uso. Puedes usar startChild la primera vez, y luego explicar a tu entrevistador que lo abreviarás como sc después de esto.
        </p>
      </li>
    </ul>
    <p>
      Los detalles de lo que constituye un buen código varían según los entrevistadores y los candidatos, y según el problema en sí. Céntrate en escribir código bonito, sea lo que sea lo que eso signifique para ti.
    </p>
    <p>
      Si ves algo que puedes refactorizar más adelante, explícaselo a tu entrevistador y decide si merece la pena dedicarle tiempo. Normalmente sí, pero no siempre.
    </p>
    <p>
      Si te confundes (algo habitual), vuelve al ejemplo y repásalo.
    </p>
  </article>
  <article>
    <p><strong>Prueba</strong>
    </p>
    <p>
      En el mundo real no registrarías código sin probarlo, y tampoco deberías «enviar» código en una vista interna sin probarlo.
    </p>
    <p>
      Hay formas inteligentes y no tan inteligentes de probar el código.
    </p>
    <p>
      Lo que hacen muchos candidatos es tomar su ejemplo anterior y probarlo con su código. Eso puede descubrir errores, pero llevará mucho tiempo hacerlo. Las pruebas manuales son muy lentas. Si realmente usaste un ejemplo grande y bonito para desarrollar tu algoritmo, entonces te llevará mucho tiempo encontrar ese pequeño error al final de tu código.
    </p>
    <p>
      En su lugar, prueba este enfoque:
    </p>
    <ul>
      <li>
        Empieza con una prueba «conceptual». Una prueba conceptual significa simplemente leer y analizar lo que hace cada línea de código. Piénsalo como si estuvieras explicando las líneas de código a un revisor de código. ¿Hace el código lo que crees que debería hacer?
      </li>
      <li>
        Código de aspecto extraño. Comprueba dos veces esa línea de código que dice x = longitud - 2. Investiga ese bucle for que empieza en i = Aunque sin duda lo hiciste por alguna razón, es muy fácil equivocarse ligeramente.
      </li>
      <li>
        Puntos calientes. Has codificado lo suficiente como para saber qué cosas pueden causar problemas. Casos base en código recursivo. División entera. Nodos nulos en árboles binarios. El inicio y el final de la iteración a través de una lista enlazada. Comprueba dos veces esas cosas.
      </li>
      <li>
        Pequeños casos de prueba. Esta es la primera vez que usamos un caso de prueba real y específico para probar el código. No utilices ese gran array de 8 elementos de la parte del algoritmo. En su lugar, utilice una matriz de 3 o 4 elementos. Es probable que descubra los mismos errores, pero será mucho más rápido hacerlo.
      </li>
      <li>
        Casos especiales. Pruebe su código contra valores nulos o de un solo elemento, los casos extremos y otros casos especiales.
      </li>
    </ul>
    <p>
      Cuando encuentres errores (y probablemente los encuentres), por supuesto que debes corregirlos. Pero no te limites a hacer la primera corrección que se te ocurra. En lugar de eso, analiza detenidamente por qué se ha producido el fallo y asegúrate de que tu solución es la mejor.
    </p>
  </article>
  <article>
    <h3>► Optimizar y solucionar Técnica nº 1: Buscar BUD
    </h3>
    <p>
      Este es quizás el enfoque más útil que he encontrado para optimizar problemas. «BUD» es un acrónimo tonto de
    </p>
    <ul>
      <li>
        Cuellos de botella
      </li>
      <li>
        Trabajo innecesario
      </li>
      <li>
        Trabajo duplicado
      </li>
    </ul>
    <p>
      Estas son tres de las cosas más comunes que un algoritmo puede «perder» el tiempo haciendo. Puedes recorrer tu fuerza bruta en busca de estas cosas. Cuando encuentres una de ellas, puedes centrarte en deshacerte de ella.
    </p>
    <p>
      Si sigue sin ser óptimo, puedes repetir este enfoque en tu mejor algoritmo actual.
    </p>
  </article>
  <article>
    <p><strong>Cuellos de botella</strong></p>
    <p>
      Un cuello de botella es una parte del algoritmo que ralentiza el tiempo de ejecución global. Esto suele ocurrir de dos maneras:
    </p>
    <ul>
      <li>
        Tienes un trabajo de una sola vez que ralentiza tu algoritmo. Por ejemplo, supongamos que tienes un algoritmo de dos pasos en el que primero ordenas el array y luego encuentras los elementos con una propiedad concreta. El primer paso esO(N log N) y el segundo esO(N). Tal vez se podría reducir el segundo paso aO(log N) o 0(1), pero ¿importaría? No demasiado. Desde luego, no es una prioridad, ya queO(N log N) es el cuello de botella. Si no optimizas el primer paso, todo el algoritmo seráO(N log N).
      </li>
      <li>
        Hay una parte del trabajo que se hace repetidamente, como la búsqueda. Quizá puedas reducirlo deO(N) aO(log N)oincluso0(1), lo que acelerará enormemente el tiempo de ejecución de todo el proceso.
      </li>
    </ul>
    <p>
      Optimizar un cuello de botella puede suponer una gran diferencia en el tiempo de ejecución total.
    </p>
    <p>
      Ejemplo: Dada una matriz de valores enteros distintos, cuente el número de pares de enteros que tienen diferencia k. Por ejemplo, dada la matriz &#1231, 7, 5, 9, 2, 12, 3} y la diferencia k = 2, hay cuatro pares con diferencia2: (1, 3), (3, 5), (5, 7), (7, 9).
    </p>
    <p>
      Un algoritmo de fuerza bruta consiste en recorrer la matriz, empezando por el primer elemento, y luego buscar entre los elementos restantes (que formarán el otro lado del par). Para cada par, calcule la diferencia. Si la diferencia es igual a k, incrementar un contador de la diferencia.
    </p>
    <p>
      El cuello de botella aquí es la búsqueda repetida del «otro lado» del par. Por tanto, es lo principal que hay que optimizar.
    </p>
    <p>
      ¿Cómo podemos encontrar más rápidamente el «otro lado» correcto? Bueno, en realidad conocemos el otro lado de (x, ? ). Es x + k o x - k. Si ordenamos la matriz, podríamos encontrar el otro lado para cada uno de los N elementos en tiempoO(log N) haciendo una búsqueda binaria.
    </p>
    <p>
      Ahora tenemos un algoritmo de dos pasos, donde ambos pasos tomanO(N log N) tiempo. Ahora, la ordenación es el nuevo cuello de botella. Optimizar el segundo paso no ayudará porque el primer paso nos está ralentizando de todos modos.
    </p>
    <p>
      Sólo tenemos que deshacernos por completo del primer paso y operar sobre una matriz sin ordenar. ¿Cómo podemos encontrar cosas rápidamente en un array sin ordenar? Con una tabla hash.
    </p>
    <p>
      Tirar todo en la matriz en la tabla hash. Luego, para saber si x + k o x - k existen en la matriz, sólo tenemos que buscarlo en la tabla hash. Podemos hacer esto en tiempo O(N).
    </p>
  </article>
  <article>
    <p><strong>Trabajo innecesario</strong></p>
    <p>
      Ejemplo: Imprimir todas las soluciones enteras positivas de la ecuación a3 + b3 c3 + d3 donde a, b, c, y d son enteros entre 1 y 1000.
    </p>
    <p>
      Una solución de fuerza bruta sólo tendrá cuatro bucles for anidados. Algo como:
    </p>
    <p>
      Este algoritmo itera a través de todos los valores posibles de a, b, c, y d y comprueba si esa combinación resulta funcionar.
    </p>
    <p>
      Es necesario seguir buscando otros posibles valores de d. Sólo uno podría funcionar. Al menos deberíamos hacer una pausa después de encontrar una solución válida.
    </p>
    <p>
      Esto no supondrá un cambio significativo en el tiempo de ejecución -nuestro algoritmo sigue siendo O(N4)- pero es una buena solución rápida para hacer que
    </p>
    <p>
      ¿Hay algo que no sea necesario? Sí. Si sólo hay un valor válido para cada (a, b, c), podemos calcularlo. Es simple matemática.
    </p>
    <p>
      La sentencia if de la línea 6 es importante. La línea 5 siempre encontrará un valor para d, pero tenemos que comprobar que es el valor entero correcto.
    </p>
    <p>
      Esto reducirá nuestro tiempo de ejecución de O(N4 ) a O(N3 ).
    </p>
  </article>
  <article>
    <p>
      <strong>Trabajo duplicado</strong>
    </p>
    <p>
      Utilizando el mismo problema y algoritmo de fuerza bruta que antes, busquemos esta vez el trabajo duplicado.
    </p>
    <p>
      El algoritmo funciona esencialmente iterando a través de todos los pares (a, b) y luego buscando en todos los pares (c, d) para encontrar si hay alguna coincidencia con ese par (a, b).
    </p>
    <p>
      ¿Por qué seguimos calculando todos los pares (c, d) para cada par (a, b)? Deberíamos crear la lista de pares ( c, d) una sola vez y, cuando tengamos un par (a, b), buscar las coincidencias en la lista ( c, d). Podemos localizar rápidamente las coincidencias insertando cada par ( c,d) en una tabla hash que mapee desde la suma hasta el par (o, mejor dicho, la lista de pares que tienen esa suma).
    </p>
    <p>
      En realidad, una vez que tenemos el mapa de todos los pares ( c,d), podemos utilizarlo directamente. No necesitamos generar los pares (a, b). Cada (a, b) ya estará en el mapa.
    </p>
    <p>
      Esto reducirá nuestro tiempo de ejecución a O(N2).
    </p>
  </article>
  <article>
    <h3>► Optimizar y resolver Técnica #2: DIY (Do It Yourself)</h3>
    <p>
      La primera vez que oíste hablar de cómo encontrar un elemento en una matriz ordenada (antes de que te enseñaran la búsqueda binaria), probablemente no dijiste: «Ah, ja, compararemos el elemento objetivo con el punto medio y luego recurriremos a la mitad apropiada».
    </p>
    <p>
      Y, sin embargo, se puede dar a alguien que no tenga conocimientos de informática una pila ordenada alfabéticamente de trabajos de estudiantes y es probable que implemente algo como la búsqueda binaria para localizar el trabajo de un estudiante. Probablemente dirá, «Dios, ¿Peter Smith? Estará en algún lugar al final de la pila». Escogerán un trabajo al azar en el medio (más o menos), compararán el nombre con “Peter Smith” y luego continuarán este proceso con el resto de los trabajos. Aunque no tienen conocimientos de búsqueda binaria, lo entienden intuitivamente.
    </p>
    <p>
      Nuestros cerebros son así de curiosos. Si decimos «Diseña un algoritmo», la gente se hace un lío. Pero si se les da un ejemplo real, ya sea de los datos (por ejemplo, una matriz) o de la vida real paralela (por ejemplo, una pila de papeles), su intuición les da un algoritmo muy bueno.
    </p>
    <p>
      He visto esto ocurrir innumerables veces con candidatos.Su algoritmo informático es extraordinariamente lento, pero cuando se les pide que resuelvan el mismo problema manualmente, inmediatamente hacen algo bastante rápido. (Y no es demasiado sorprendente, en cierto sentido.Las cosas que son lentas para un ordenador suelen ser lentas a mano.¿Por qué ibas a someterte a un trabajo extra?).
    </p>
    <p>
      Por eso, cuando tengas una duda, intenta resolverla intuitivamente con un ejemplo real. A menudo, un ejemplo más grande será más fácil.
    </p>
    <p>
      Ejemplo: Dadas una cadena más pequeña y una cadena más grande b, diseña un algoritmo para encontrar todas las permutaciones de la cadena más corta dentro de la más larga.
    </p>
    <p>
      Piensa por un momento cómo resolverías este problema. Ten en cuenta que las permutaciones son reorganizaciones de la cadena, por lo que los caracteres de s pueden aparecer en cualquier orden en b. Sin embargo, deben ser contiguos (no estar separados por otros caracteres).
    </p>
    <p>
      Si eres como la mayoría de los candidatos, probablemente pensaste en algo como Generar todas las permutaciones de s y luego buscar cada una de ellas en b. Como hay S! permutaciones, esto llevaráO(S ! * B) tiempo, dondeS es la longitud de s y B es la longitud de b.
    </p>
    <p>
      Esto funciona, pero es un algoritmo extraordinariamente lento. De hecho, es peor que un algoritmo exponencial. Si s tiene 14 caracteres, son más de 87 mil millones de permutaciones. Añade un carácter más a s y tendremos 15 veces más permutaciones.
    </p>
    <p>
      Enfocado de otra manera, podrías desarrollar un algoritmo decente con bastante facilidad. Ponte un ejemplo grande, como este:
    </p>
    <p>
      <p>s: abbc</p>
      <p>b: cbabadcbbabbcbabaabccbabc</p>
    </p>
    <p>
      ¿Dónde están las permutaciones de s dentro de b? No te preocupes por cómo lo haces. Sólo encuéntralas. ¡Hasta un niño de 12 años podría hacerlo!
    </p>
    <p>
      (No, en serio, ve a buscarlas. ¡Yo esperaré!)
    </p>
    <p>
      He subrayado debajo cada permutación.
    </p>
      <p>s: abbc</p>
      <p>b: cbabadcbbabbcbabaabccbabc</p>
      <p><span>---</span><span>---</span><span>---</span></p>
      <p><span>---</span><span>---</span><span>---</span></p>
      <p><span>---</span></p>
    <p>
      ¿Los has encontrado? ¿Cómo?
    </p>
    <p>
      ¡Pocas personas -incluso las que antes dieron con las 0(5 ! algoritmos generan realmente todos los permutaciones de abbc para localizar esas permutaciones en b.Casi todo el mundo adopta uno de dos enfoques(muy similares):
    </p>
    <ol>
      <li>
        Casi todo el mundo adopta uno de estos dos enfoques (muy similares): 1. Recorrer la banda y mirar las ventanas correderas de 4 caracteres (cada una de las cuales tiene una longitud de 4) y comprobar si cada ventana es una permutación de s.
      </li>
      <li>
        Cada vez que vea un carácter ins, compruebe si los cuatro caracteres siguientes (la longitud de s) son una permutación de s.
      </li>
    </ol>
    <p>
      Dependiendo de la implementación exacta de la parte «es una permutación», probablemente obtendrás un tiempo de ejecución de O(B *S), O(B *SlogS) u O(B *52). Ninguno de estos algoritmos es el óptimo (existe un algoritmo 0( B)), pero es mucho mejor que lo que teníamos antes.
    </p>
    <p>
      Prueba este método cuando resuelvas preguntas. Utiliza un ejemplo grande y bonito, y resuélvelo intuitivamente -es decir, manualmente- para el ejemplo concreto.
    </p>
    <p>
      Presta especial atención a cualquier «optimización» que hayas hecho de forma intuitiva o automática. Por ejemplo, al resolver este problema, puede que te hayas saltado la ventana deslizante con «d» porque «d» no está en abbc. Esa es una optimización que hizo tu cerebro, y es algo que al menos deberías tener en cuenta en tu algoritmo.
    </p>
  </article>
  <article>
    <h3>► Optimizar y resolver Técnica nº 3: Simplificar y generalizar</h3>
    <p>
      Con Simplificar y Generalizar, aplicamos un enfoque de varios pasos. Primero simplificamos o ajustamos alguna restricción, como el tipo de datos. A continuación, resolvemos esta nueva versión simplificada del problema. Por último, una vez que tenemos un algoritmo para el problema simplificado, intentamos adaptarlo para la versión más compleja.
    </p>
    <p>
      Ejemplo: Se puede formar una nota de rescate recortando palabras de una revista para formar una nueva frase. Cómo averiguar si una nota de rescate (representada como una cadena) puede formarse a partir de una revista dada (cadena)?
    </p>
    <p>
      Para simplificar el problema, podemos modificarlo de modo que estemos recortando caracteres de una revista en lugar de palabras enteras.
    </p>
    <p>
      Podemos resolver el problema simplificado de la nota de rescate con caracteres simplemente creando una matriz y contando los caracteres. Cada punto de la matriz corresponde a una letra. En primer lugar, contamos el número de veces que aparece cada carácter en la nota de rescate y, a continuación, revisamos la revista para ver si tenemos todos esos caracteres.
    </p>
    <p>
      Cuando generalizamos el algoritmo, hacemos algo muy parecido. Esta vez, en lugar de crear un array con el recuento de caracteres, creamos una tabla hash que mapea desde una palabra hasta su frecuencia.
    </p>
  </article>
  <article>
    <h3>► Optimizar y resolver Técnica 4: Caso base y construcción</h3>
    <p>
      Con Caso base y construir, resolvemos el problema primero para un caso base (por ejemplo, n = 1) y luego tratamos de construir a partir de ahí. Cuando llegamos a casos más complejos o interesantes (a menudo n = 3 o n = 4), intentamos construirlos utilizando las soluciones anteriores.
    </p>
    <p>
      Ejemplo: Diseñe un algoritmo para imprimir todas las permutaciones de una cadena. Para simplificar, suponga que todas las cadenas son únicas.
    </p>
    <p>
      Considere una cadena de prueba abcdefg.
    </p>
    <p>
      <p>Case "a" --> &#123"a"}</p>
      <p>Case "ab" --> &#123"ab", "ba"}</p>
      <p>Case "abc" --> ?</p>
    </p>
    <p>
      Este es el primer caso «interesante». Si tuviéramos la respuesta a P («ab»), ¿cómo podríamos generar P («abc»)? Bueno, la letra adicional es «c», así que podemos meter c en todos los puntos posibles. Es decir:
    </p>
    <p>
      Ahora que entendemos el patrón, podemos desarrollar un algoritmo general recursivo1: Generamos todas las permutaciones de s1- - -sn «cortando» el último carácter y generando todas las permutaciones de s1- - - sn_1. Una vez que tenemos la lista de todas las permutaciones de s1- - - sn_1, iteramos a través de esta lista. Una vez que tenemos la lista de todas las permutaciones de s1 - - - sn_1, iteramos por ella. Para cada cadena, insertamos Sn en cada posición de la cadena.
    </p>
    <p>
      Los algoritmos Base Case y Build suelen dar lugar a algoritmos recursivos naturales.
    </p>
  </article>
  <article>
    <h3>► Optimizar y resolver Técnica nº 5: Lluvia de ideas sobre la estructura de datos</h3>
    <p>
      Este enfoque es ciertamente complicado, pero a menudo funciona. Podemos simplemente recorrer una lista de estructuras de datos e intentar aplicar cada una de ellas. Este enfoque es útil porque resolver un problema puede ser trivial una vez que se nos ocurre utilizar, por ejemplo, un árbol.
    </p>
    <p>
      Ejemplo: Los números se generan aleatoriamente y se almacenan en una matriz (en expansión). ¿Cómo se puede saber la mediana?
    </p>
    <p>
      Nuestra lluvia de ideas sobre estructuras de datos podría ser la siguiente:
    </p>
    <ul>
      <li>
        ¿Lista enlazada? Probablemente no. Las listas enlazadas no suelen funcionar muy bien a la hora de acceder y ordenar números.
      </li>
      <li>
        ¿Matriz? Tal vez, pero ya tienes una matriz. ¿Podrías mantener los elementos ordenados de alguna manera? Probablemente sea caro. Dejemos esto para más adelante y volvamos a ello si es necesario.
      </li>
      <li>
        ¿Árbol binario? Es posible, ya que los árboles binarios se ordenan bastante bien. De hecho, si el árbol de búsqueda binario está perfectamente equilibrado, la parte superior podría ser la mediana. Pero, cuidado, si hay un número par de elementos, la mediana es en realidad la media de los dos elementos centrales. Los dos elementos del medio no pueden estar en la cima. Esto es probablemente un algoritmo viable, pero vamos a volver a ella.
      </li>
      <li>
        ¿Un montón? Un montón es realmente bueno en el ordenamiento básico y el seguimiento de máximos y mínimos. Esto es interesante: si tuvieras dos montones, podrías controlar la mitad mayor y la mitad menor de los elementos. La mitad más grande se mantiene en un montón min, de tal manera que el elemento más pequeño de la mitad más grande está en la raíz. La mitad más pequeña se guarda en un montón máximo, de forma que el elemento más grande de la mitad más pequeña esté en la raíz. Ahora, con estas estructuras de datos, tienes los elementos medianos potenciales en las raíces. Si los montones ya no tienen el mismo tamaño, puedes «reequilibrarlos» rápidamente sacando un elemento de un montón y poniéndolo en el otro.
      </li>
    </ul>
    <p>
      Note that the more problems you do, the more developed your instinct on which data structure to apply will be. You will also develop a more finely tuned instinct as to which of these approaches is the most useful.
    </p>
  </article>
  <article>
    <h3>► Best Conceivable Runtime (BCR)</h3>
    <p>
      Considering the best conceivable runtime can offer a useful hint for some problem.
    </p>
    <p>
      The best conceivable runtime is, literally, the best runtime you could conceive of a solution to a problem having. You can easily prove that there is no way you could beat the BCR.
    </p>
    <p>
      For example, suppose you want to compute the number of elements that two arrays (of length A and B) have in common. You immediately know that you can't do that in better than O(A + B) time because you have to "touch" each element in each array. O(A + B) is the BCR.
    </p>
    <p>
      Or, suppose you want to print all pairs of values within an array. You know you can't do that in better than 0(N2) time because there are N2 pairs to print.
    </p>
    <p>
      Be careful though! Suppose your interviewer asks you to find all pairs with sum k within an array (assuming all distinct elements). Some candidates who have not fully mastered the concept of BCR will say that the BCR is O(N2 ) because you have to look at N2 pairs.
    </p>
    <p>
      Eso no es cierto. Que quiera todos los pares con una suma determinada no significa que tenga que mirar todos los pares. De hecho, no es necesario.
    </p>
    <p>
      ¿Cuál es la relación entre el mejor tiempo de ejecución concebible y el mejor tiempo de ejecución del caso? Ninguna. El mejor tiempo de ejecución concebible es para un problema y es en gran medida una función de las entradas y salidas. No tiene ninguna relación particular con un algoritmo específico. De hecho, si calculas el Mejor Tiempo de Ejecución Concebible pensando en lo que hace tu algoritmo, probablemente estés haciendo algo mal. El Mejor Caso de Tiempo de Ejecución es para un algoritmo específico (y es un valor casi inútil).
    </p>
    <p>
      Ten en cuenta que el mejor tiempo de ejecución concebible no es necesariamente alcanzable, sólo dice que no puedes hacerlo mejor que él.
    </p>
  </article>
  <article>
    <p>
      <strong>Un ejemplo de cómo usar BCR</strong>
    </p>
    <p>
      Pregunta: Dadas dos matrices ordenadas, encontrar el número de elementos en común. Las matrices tienen la misma longitud y cada una tiene todos los elementos distintos.
    </p>
    <p>
      Empecemos con un buen ejemplo. Subrayaremos los elementos en común.
    </p>
    <p>A: 13 27 35 40 49 55 59</p>
    <p>B: 17 35 39 40 55 58 60</p>
    <p>
      Un algoritmo de fuerza bruta para este problema es empezar con cada elemento en A y buscarlo en B. Esto lleva O(N2) tiempo ya que para cada uno de N elementos en A, necesitamos hacer unaO(N) búsqueda en B.
    </p>
    <p>
      El BCR esO(N), porque sabemos que tendremos que mirar cada elemento al menos una vez y hay 2N elementos en total. (Si nos saltamos un elemento, entonces el valor de ese elemento podría cambiar el resultado. Por ejemplo, si nunca miramos el último valor de B, entonces ese 60 podría ser un 59).
    </p>
    <p>
      Pensemos en dónde estamos ahora. Tenemos un algoritmoO(N2) y queremos hacerlo mejor, potencialmente, pero no necesariamente, tan rápido comoO(N). Fuerza bruta: O(N2) Algoritmo óptimo: ? BCR: O(N)
    </p>
    <p>
      ¿Qué hay entre O(N2) y O(N)? Muchas cosas. Infinitas cosas en realidad. Teóricamente podríamos tener un algoritmo que fueraO(N log(log(log(log(N))))). Sin embargo, tanto en las entrevistas como en la vida real, ese tiempo de ejecución no se menciona mucho.
    </p>
    <p>
      Intenta recordarlo en tu entrevista, porque despista a mucha gente. El tiempo de ejecución no es una pregunta de respuesta múltiple. Sí, es muy común tener un tiempo de ejecución que sea O(log N), O(N), O(N log N), O(N2) o O(2N). Pero no hay que asumir que algo tiene un tiempo de ejecución aparticular por puro proceso de eliminación. De hecho, esas veces en las que estás confuso sobre el tiempo de ejecución y quieres hacer conjeturas, son las más probables de tener un tiempo de ejecución no obvio y menos común. Puede que el tiempo de ejecución sea 0(N2 K), donde N es el tamaño de la matriz y K es el número de pares. Deriva, no adivines.
    </p>
    <p>
      Lo más probable es que nos dirijamos hacia un algoritmoO(N) o un algoritmoO(N log N). ¿Qué nos dice esto? Si imaginamos el tiempo de ejecución de nuestro algoritmo actual como O(N x N), llegar a O(N) u O(N x log N) podría significar reducir ese segundo O(N) de la ecuación a O(1)o0(log N).
    </p>
    <p>
      Esta es una de las utilidades de BCR. Podemos utilizar los tiempos de ejecución para obtener una «pista» de lo que tenemos que reducir.
    </p>
    <p>
      El segundo 0(N) proviene de la búsqueda. La matriz está ordenada. ¿Podemos buscar en un array ordenado en un tiempo más rápido que O(N)?
    </p>
    <p>
      Pues sí. Podemos usar la búsqueda binaria para encontrar un elemento en un array ordenado en tiempo O(log N).
    </p>
    <p>
      Ahora tenemos un algoritmo mejorado: O(N log N).
    </p>
    <p>
      Fuerza bruta: O(N2)\n Algoritmo mejorado: O(N log N)\n Algoritmo óptimo: ?\n BCR: O(N) 
    </p>
    <p>
      ¿Podemos hacerlo aún mejor? Hacerlo mejor probablemente signifique reducir ese O(log N)a0(1).
    </p>
    <p>
      En general, no podemos buscar en una matriz -incluso en una matriz ordenada- en un tiempo mejor que O(log N). Sin embargo, este no es el caso general. Estamos haciendo esta búsqueda una y otra vez.
    </p>
    <p>
      El BCR nos dice que nunca tendremos un algoritmo más rápido que O(N). Por lo tanto, cualquier trabajo que hagamos en tiempo O(N) es un «regalo»: no afectará a nuestro tiempo de ejecución.
    </p>
    <p>
      Vuelve a leer la lista de consejos de optimización de la página 64. ¿Hay algo que pueda ayudarnos?
    </p>
    <p>
      Uno de los consejos sugiere precomputar o hacer trabajo por adelantado. Cualquier trabajo previo que hagamos en tiempo O(N) es gratis. No afectará a nuestro tiempo de ejecución.
    </p>
    <p>
      Este es otro lugar donde BCR puede ser útil. Cualquier trabajo que hagas que sea menor o igual que el BCR es «gratis», en el sentido de que no afectará a tu tiempo de ejecución. Puede que incluso quieras eliminarlo, pero todavía no es una prioridad.
    </p>
    <p>
      Nuestro objetivo sigue siendo reducir la búsqueda de O(log N) a 0(1). Cualquier precomputación que sea O(N) o menos es «gratis».
    </p>
    <p>
      En este caso, podemos meter todo lo que hay en B en una tabla hash. Esto tomará O(N) tiempo. A continuación, sólo tenemos que ir a través de A y buscar cada elemento en la tabla hash. Esta consulta (o búsqueda) es 0(1), por lo que nuestro tiempo de ejecución es O(N).
    </p>
    <p>
      Supongamos que nuestro entrevistador nos hace una pregunta que nos pone los pelos de punta: ¿Podemos hacerlo mejor?
    </p>
    <p>
      No, no en términos de tiempo de ejecución. Hemos conseguido el tiempo de ejecución más rápido posible, por lo que no podemos optimizar el tiempo O grande. Podríamos optimizar la complejidad espacial.
    </p>
    <p>
      Este es otro punto en el que BCR resulta útil. Nos dice que ya hemos «terminado» de optimizar el tiempo de ejecución y que, por tanto, deberíamos centrar nuestros esfuerzos en la complejidad espacial.
    </p>
    <p>
      De hecho, incluso sin que el entrevistador nos lo pidiera, deberíamos tener un signo de interrogación con respecto a nuestro algoritmo. Habríamos conseguido exactamente el mismo tiempo de ejecución si los datos no estuvieran ordenados. Entonces, ¿por qué el entrevistador nos dio matrices ordenadas? No es algo inaudito, pero sí un poco extraño.
    </p>
    <p>
      Volvamos a nuestro ejemplo.
    </p>
    <p>A: 13 27 35 40 49 55 59</p>
    <p>B: 17 35 39 40 55 58 60</p>
    <p>
      Ahora estamos buscando un algoritmo que:
    </p>
    <ul>
      <li>
        Opere en el espacio 0(1) (probablemente). Ya tenemos un algoritmo de espacio O(N) con tiempo de ejecución óptimo. Si queremos utilizar menos espacio adicional, eso probablemente significa que no hay espacio adicional. Por lo tanto, necesitamos eliminar la tabla hash.
      </li>
      <li>
        Opera en tiempo o(N) (probablemente). Probablemente querremos al menos igualar el mejor tiempo de ejecución actual, y sabemos que no podemos superarlo.
      </li>
      <li>
        Utiliza el hecho de que las matrices están ordenadas.
      </li>
    </ul>
    <p>
      Nuestro mejor algoritmo que no usa espacio extra fue el de búsqueda binaria. Pensemos en optimizarlo. Podemos intentar recorrer el algoritmo.
    </p>
    <ol>
      <li>
        Do a binary search in B for A[0] = 13. Not found.
      </li>
      <li>
        Do a binary search in B for A[ 1] = 27. Not found.
      </li>
      <li>
        Do a binary search in B for A[2] = 35. Found a tB[l].
      </li>
      <li>
        Do a binary search in B for A[3] = 40. Found at B[5].
      </li>
      <li>
        Do a binary search in B for A[4] = 49. Not found.
      </li>
      <li>...
      </li>
    </ol>
    <p>
      Piensa enBUD. El cuello de botella es la búsqueda. ¿Hay algo innecesario o duplicado?
    </p>
    <p>
      Es innecesario que A[3] = 40 haya buscado en todoB.Sabemos que acabamos de encontrar 35 enB[1], así que 40 seguramente no estará antes que 35.
    </p>
    <p>
      Cada búsqueda binaria debe empezar donde terminó la anterior.
    </p>
    <p>
      De hecho, ahora no necesitamos hacer una búsqueda binaria. Podemos simplemente hacer una búsqueda lineal. Siempre y cuando la búsqueda lineal en B sólo está recogiendo donde la última lo dejó, sabemos que vamos a estar operando en tiempo lineal.
    </p>
    <ol>
      <li>
        Do a binary search in B for A[0] = 13. Not found.
      </li>
      <li>
        Do a binary search in B for A[ 1] = 27. Not found.
      </li>
      <li>
        Do a binary search in B for A[2] = 35. Found a tB[l].
      </li>
      <li>
        Do a binary search in B for A[3] = 40. Found at B[5].
      </li>
      <li>
        Do a binary search in B for A[4] = 49. Not found.
      </li>
      <li>...
      </li>
    </ol>
    <p>
      Este algoritmo es muy similar a la fusión de dos matrices ordenadas. Funciona en tiempo O(N) y espacio 0(1).
    </p>
    <p>
      Ahora hemos alcanzado el BCR y tenemos un espacio mínimo. Sabemos que no podemos hacerlo mejor.
    </p>
    <p>
      Esta es otra form a de utilizarBCR. Si alguna vez alcanzas elBCR y tienes 0(1) espacio adicional, entonces sabes que no puedes optimizar el gran O de tiempo o espacio
    </p>
    <p>
      El mejor tiempo de ejecución concebible no es un concepto de algoritmo «real», en el sentido de que no lo encontrarás en los libros de texto de algoritmos. Pero a mí personalmente me ha resultado muy útil, tanto para resolver problemas como para ayudar a otras personas a resolverlos.
    </p>
    <p>
      Si te cuesta entenderlo, asegúrate primero de comprender el tiempo O grande (página 38). Necesitas dominarlo. Una vez que lo domines, averiguar elBCR de un problema te llevará literalmente unos segundos.
    </p>
  </article>
  <article>
    <h3>► Manejo de respuestas incorrectas</h3>
    <p>
      Uno de los rumores más extendidos -y peligrosos- es que los candidatos tienen que acertar todas las preguntas. Esto no es del todo cierto.
    </p>
    <p>
      En primer lugar, las respuestas a las preguntas de la entrevista no deben considerarse «correctas» o «incorrectas»: cuando evalúo la actuación de alguien en una entrevista, nunca pienso: «¿Cuántas preguntas ha acertado?». No es una evaluación binaria. Se trata más bien de ver cómo de óptima era su solución final, cuánto tardaron en llegar a ella, cuánta ayuda necesitaron y cómo de limpio era su código. Hay una serie de factores.
    </p>
    <p>
      En segundo lugar, tu rendimiento se evalúa en comparación con el de otros candidatos. Por ejemplo, si resuelves una pregunta de forma óptima en 15 minutos y otra persona resuelve una pregunta más fácil en cinco minutos, ¿esa persona lo hizo mejor que tú? Puede que sí, pero puede que no. Si se le plantean preguntas muy fáciles, cabe esperar que obtenga soluciones óptimas muy rápidamente. Pero si las preguntas son difíciles, entonces es de esperar que cometa una serie de errores.
    </p>
    <p>
      En tercer lugar, muchas -posiblemente la mayoría- de las preguntas son demasiado difíciles como para esperar que incluso un buen candidato obtenga inmediatamente el algoritmo óptimo. Las preguntas que suelo plantear suelen llevar entre 20 y 30 minutos a los candidatos fuertes.
    </p>
    <p>
      En la evaluación de miles de expedientes de contratación en Google, sólo he visto una vez a un candidato con una serie de entrevistas «impecables». Todos los demás, incluidos los cientos que recibieron ofertas, cometieron errores.
    </p>
  </article>
  <article>
    <h3>Cuando ya ha oído una pregunta antes</h3>
    <p>
      Si ya has oído una pregunta antes, admíteselo a tu entrevistador. El entrevistador te hace estas preguntas para evaluar tu capacidad de resolución de problemas. Si ya conoces la pregunta, no le estás dando la oportunidad de evaluarte.
    </p>
    <p>
      Además, tu entrevistador puede considerar muy deshonesto que no le reveles que conoces la pregunta. (Y, a la inversa, ganarás muchos puntos de honestidad si lo revelas).
    </p>
  </article>
  <article>
    <h3>► El lenguaje "perfecto" para las entrevistas</h3>
    <p>
      En muchas de las mejores empresas, los entrevistadores no son exigentes con los idiomas. Les interesa más saber cómo resuelves los problemas que si sabes un idioma concreto.
    </p>
    <p>
      Otras empresas, sin embargo, están más vinculadas a un idioma y les interesa ver lo bien que puedes programar en un lenguaje concreto.
    </p>
    <p>
      Si te dan a elegir entre varios idiomas, lo más probable es que elijas aquel con el que te sientas más cómodo.
    </p>
    <p>
      Dicho esto, si tienes varios idiomas buenos, debes tener en cuenta lo siguiente.
    </p>
    <p><strong>Prevalencia</strong>
    </p>
    <p>
      No es obligatorio, pero es ideal que tu entrevistador conozca el idioma en el que estás codificando. Un idioma más conocido puede ser mejor por este motivo.
    </p>
    <p><strong>Legibilidad del lenguaje</strong>
    </p>
    <p>
      Aunque tu entrevistador no conozca tu lenguaje de programación, debería ser capaz de entenderlo. Algunos lenguajes son más legibles que otros debido a su similitud con otros.
    </p>
    <p>
      Por ejemplo, Java es bastante fácil de entender, aunque no se haya trabajado con él. La mayoría de la gente ha trabajado en algo con una sintaxis similar a Java, como C y C++.
    </p>
    <p>
      Sin embargo, lenguajes como Scala u Objective C tienen una sintaxis bastante diferente.
    </p>
    <p><strong>Problemas potenciales</strong>
    </p>
    <p>
      Algunos lenguajes te abren a problemas potenciales. Por ejemplo, usar C++ significa que, además de todos los errores habituales que puedes tener en tu código, puedes tener problemas de gestión de memoria y de punteros.
    </p>
    <p><strong>Verbosidad</strong>
    </p>
    <p>
      Algunos lenguajes son más verbosos que otros. Java, por ejemplo, es un lenguaje bastante verboso en comparación con Python. Basta con comparar los siguientes fragmentos de código.
    </p>
    <p>Python:
    </p>
    <pre>
      <code class="language-js">
        diet &#123"left": 1, "right": 2, "top": 3, "bottom": 4};
      </code>
    </pre>
    <p>Java:
    </p>
    <pre>
      <code class="language-js">
        HashMap&#60tring, Integer> diet = new HashMap&#60String, Integer>().
        diet.put("left", 1);
        dict.put("right", 2);
        diet.put("top", 3);
        dict.put("bottom", 4);
      </code>
    </pre>
    <p>
      Sin embargo, parte de la verborrea de Java puede reducirse abreviando el código. Me imagino a un candidato escribiendo algo así en una pizarra:
    </p>
    <pre>
      <code class="language-js">
        HM&#60S, I> diet= new HM&#60S, I>().
        diet.put("left", 1);
        ... "right", 2
        ... "top", 3
        ... "bottom", 4
      </code>
    </pre>
    <p>
      El candidato tendría que explicar las abreviaturas, pero a la mayoría de los entrevistadores no les importaría.
    </p>
    <p><strong>Facilidad de uso</strong>
    </p>
    <p>
      Algunas operaciones son más fáciles en unos lenguajes que en otros. Por ejemplo, en Python es muy fácil devolver varios valores de una función. En Java, la misma acción requeriría una nueva clase. Esto puede ser útil para ciertos problemas.
    </p>
    <p>
      Sin embargo, al igual que en el caso anterior, esto se puede mitigar abreviando el código o asumiendo métodos que en realidad no existen. Por ejemplo, si un lenguaje proporciona una función para transponer una matriz y otro lenguaje no, esto no hace necesariamente que el primer lenguaje sea mucho mejor para codificar (para un problema que necesite dicha función). Basta con suponer que el otro lenguaje tiene un método similar.
    </p>
  </article>
  <article>
    <h3>► Cómo es una buena programación</h3>
    <p>
      Probablemente ya sepas que a los empresarios les interesa que escribas un código «bueno y limpio». Pero, ¿qué significa esto realmente y cómo se demuestra en una entrevista? 
    </p>
    <p>
      En términos generales, un buen código tiene las siguientes propiedades:
    </p>
    <ul>
      <li><strong>Correcto:</strong>
        el código debe funcionar correctamente con todas las entradas esperadas e inesperadas.
      </li>
      <li><strong>Eficaz:</strong>
        El código debe funcionar de la forma más eficiente posible, tanto en términos de tiempo como de espacio. Esta «eficiencia» incluye tanto la eficiencia asintótica (gran 0) como la eficiencia práctica en la vida real. Es decir, un factor constante puede desaparecer al calcular el tiempo O grande, pero en la vida real puede ser muy importante.
      </li>
      <li><strong>Simple:</strong>
        If you can do something in 10 lines instead of 100, you should. Code should be as quick as possible for a developer to write.
      </li>
      <li><strong>Readable:</strong>
        A different developer should be able to read your code and understand what it does and how it does it. Readable code has comments where necessary, but it implements things in an easily understandable way. That means that your fancy code that does a bunch of complex bit shifting is not necessarily good code.
      </li>
      <li><strong>Maintainable:</strong>
        Code should be reasonably adaptable to changes during the life cycle of a product and should be easy to maintain by other developers, as well as the initial developer.
      </li>
    </ul>
    <p>
      Buscar estos aspectos requiere un acto de equilibrio. Por ejemplo, a menudo es aconsejable sacrificar cierto grado de eficiencia para que el código sea más fácil de mantener, y viceversa. 
    </p>
    <p>
      Deberías pensar en estos elementos mientras codificas durante una entrevista. Los siguientes aspectos del código son formas más específicas de demostrar la lista anterior.
    </p>
  </article>
  <article>
    <p><strong>Utilizar generosamente las estructuras de datos</strong></p>
    <p>
      Supongamos que se le pide que escriba una función para sumar dos expresiones matemáticas simples que son de la forma (donde los coeficientes y exponentes pueden ser cualquier número real positivo o negativo). Es decir, la expresión es una secuencia de términos, donde cada término es simplemente una constante multiplicada por un exponente. La entrevistadora también añade que no quiere que tengas que analizar cadenas, así que puedes utilizar cualquier estructura de datos que desees para guardar las expresiones.
    </p>
    <p>
      Hay varias formas de ponerlo en práctica.
    </p>
    <p><em>
      Mala implementación
    </em>
    </p>
    <p>
      Una mala implementación sería almacenar la expresión como una única matriz de dobles, donde el k-ésimo elemento corresponde al coeficiente del término xk en la expresión. Esta estructura es problemática porque no podría soportar expresiones con exponentes negativos o no enteros. También requeriría una matriz de 1000 elementos para almacenar sólo la expresión x1000.
    </p>
    <pre>
      <code class="language-js">
        int[] sum(double[] expr1, double[] expr2) &#123
          ...
        }
      </code>
    </pre>
    <p><em>
      Implementación menos mala
    </em>
    </p>
    <p>
      Una implementación ligeramente menos mala sería almacenar la expresión como un conjunto de dos matrices, coeficientes y exponentes. Bajo este enfoque, los términos de la expresión se almacenan en cualquier orden, pero «emparejados» de tal manera que el término ith de la expresión está representada por 
    </p>
    <p>
      Bajo esta implementación, si los coeficientes [ p] = k y los exponentes [ p] = m, entonces el término p es kxm. Aunque esto no tiene las mismas limitaciones que la solución anterior, sigue siendo muy complicado. Necesitas llevar la cuenta de dos matrices para una sola expresión. Las expresiones podrían tener valores «indefinidos» si las matrices tuvieran longitudes diferentes. Y devolver una expresión es molesto porque necesitas devolver dos arrays.
    </p>
    <pre>
      <code class="language-js">
        ??? sum(double[] coeffsl, double[] expon1, double[] coeffs2, double[] expon2) &#123
          ...
        }
      </code>
    </pre>
    <p><em>
      Buena implementación
    </em>
    </p>
    <p>
      Una buena implementación para este problema es diseñar tu propia estructura de datos para la expresión.
    </p>
    <pre>
      <code class="language-js">
        class ExprTerm &#123
          double coefficient;
          double exponent;
        }
        ExprTerm[] sum(ExprTerm[] exprl, ExprTerm[] expr2) &#123
          ...
        }
      </code>
    </pre>
    <p>
      Algunos podrían (y lo han hecho) argumentar que esto es «sobre-optimizar»: Tal vez sí, tal vez no. Independientemente de si usted piensa que es sobre-optimización, el código anterior demuestra que usted piensa acerca de cómo diseñar su código y no sólo slop algo juntos de la manera más rápida posible.
    </p>
  </article>
  <article>
    <p><strong>Reutilización adecuada del código</strong></p>
    <p>
      Suponga que se le pide que escriba una función para comprobar si el valor de un número binario (pasado como una cadena) es igual a la representación hexadecimal de una cadena.
    </p>
    <p>
      Una implementación elegante de este problema aprovecha la reutilización de código.
    </p>
    <p>
      Podríamos haber implementado código separado para convertir un número binario y un código hexadecimal, pero esto sólo hace que nuestro código sea más difícil de escribir y más difícil de mantener. En su lugar, reutilizamos el código escribiendo un método convertFromBase y un método digitToValue.
    </p>
  </article>
  <article>
    <p><strong>Modular</strong></p>
    <p>
      Escribir código modular significa separar trozos aislados de código en sus propios métodos. Esto ayuda a mantener el código más fácil de mantener, leer y probar.
    </p>
    <p>
      Imagina que estás escribiendo código para intercambiar el elemento mínimo y máximo en un array de enteros. Podrías implementarlo todo en un método como este:
    </p>
    <pre>
      <code class="language-js">
        void swapMinMax(int[] array) &#123
          int minindex= 0;
          for (int i= 1; i &#60 array.length; i++) &#123
            if (array[i] &#60 array[minindex]) &#123
              minindex = i;
            }
          }
          int maxindex= 0;
          for (inti= 1; i &#60 array.length; i++) &#123 
            if (array[i] > array[maxindex]) &#123
              maxindex= i;
            }
          }
          int temp= array[minindex];
          array[minindex] array[maxindex];
          array[maxindex] = temp;
        }
      </code>
    </pre>
    <p>
      O podrías implementarlo de una forma más modular separando los trozos de código relativamente aislados en sus propios métodos.
    </p>
    <pre>
      <code class="language-js">
        void swapMinMaxBetter(int[] array) &#123
          int minindex= getMinindex(array);
          int maxindex= getMaxindex(array);
          swap(array, minindex, maxindex);
            int getMinindex(int[] array) &#123 ... }
            int getMaxindex(int[] array) &#123 ... }
            void swap(int[] array, int m, int n) &#123 ... }

      </code>
    </pre>
    <p>
      Mientras que el código no modular no es particularmente horrible, lo bueno del código modular es que es fácilmente comprobable porque cada componente puede ser verificado por separado. A medida que el código se vuelve más complejo, es cada vez más importante escribirlo de forma modular. Esto hará que sea más fácil de leer y mantener. Tu entrevistador querrá verte demostrar estas habilidades en la entrevista.
    </p>
  </article>
  <article>
    <p><strong>Flexible y robusto</strong></p>
    <p>
      Que tu entrevistador sólo te pida que escribas código para comprobar si un tablero de tres en raya normal tiene un ganador, no significa que debas asumir que se trata de un tablero de 3x3. ¿Por qué no escribir el código de una forma más general que lo implemente para un tablero NxN?
    </p>
    <p>
      Escribir código flexible y de propósito general también puede significar usar variables en lugar de valores codificados o usar plantillas/génicos para resolver un problema. Si podemos escribir nuestro código para resolver un problema más general, deberíamos hacerlo.
    </p>
    <p>
      Por supuesto, hay un límite. Si la solución es mucho más compleja para el caso general, y parece innecesario en este momento, puede ser mejor simplemente implementar el caso simple y esperado.
    </p>
  </article>
  <article>
    <p><strong>Comprobación de errores</strong></p>
    <p>
      Un signo de un programador cuidadoso es que no hace suposiciones sobre la entrada. En su lugar, valida que la entrada es lo que debería ser, ya sea mediante declaraciones ASSERT o declaraciones if.
    </p>
    <p>
      Por ejemplo, recuerde el código anterior para convertir un número de su representación de base i (p. ej., base 2 o base 16) a un int.
    </p>
    <p>
      En la línea 2, comprobamos que la base es válida (asumimos que las bases mayores que 10, distintas de la base 16, no tienen representación estándar en forma de cadena). En la línea 6, hacemos otra comprobación de errores: nos aseguramos de que cada dígito está dentro del rango permitido.
    </p>
    <p>
      Este tipo de comprobaciones son críticas en el código de producción y, por tanto, también en el código de las entrevistas.
    </p>
    <p>
      Por supuesto, escribir estas comprobaciones de errores puede ser tedioso y puede hacer perder un tiempo precioso en una entrevista. Lo importante es señalar que usted escribiría las comprobaciones. Si las comprobaciones de error son mucho más que una rápida declaración if, puede ser mejor dejar algo de espacio donde irían las comprobaciones de error e indicar a tu entrevistador que las rellenarás cuando hayas terminado con el resto del código.
    </p>
  </article>
  <article>
    <h3>► No te rindas</h3>
    <p>
      Sé que las preguntas de las entrevistas pueden resultar abrumadoras, pero eso es parte de lo que el entrevistador está comprobando. ¿Te enfrentas a un reto o te encoges de miedo? Es importante que des un paso al frente y te enfrentes con entusiasmo a un problema complicado. Después de todo, recuerde que las entrevistas tienen que ser difíciles. No debería sorprenderle que le planteen un problema realmente difícil.
    </p>
    <p>
      Para obtener «puntos» extra, muestre entusiasmo por resolver problemas difíciles.
    </p>
  </article>
  <footer class="flex justify-end">
    <a class="font-khand font-bold text-3xl py-4 sm:py-8 md:py-12 sm:text-4xl md:text-5xl" href="parte-8">
      <div class="transition-all text-nowrap relative ease-linear duration-500 w-28 sm:w-40 md:w-52
      hover:w-36 sm:hover:w-48 md:hover:w-56  hover:text-sky-500
      after:content-['↦'] after:text-red-500 after:transition-all after:ease-linear after:duration-500 after:opacity-0 after:relative after:-left-3 
      hover:after:content-['↦'] hover:after:transition-all hover:after:ease-linear hover:after:duration-500 hover:after:opacity-100 hover:after:left-3">Parte VIII</div>
    </a>
  </footer>