---
import Layoutcracking from "../../../layouts/Layoutcracking.astro"
---
<Layoutcracking title="Como superar una entrevista de codificación">
  <h1>Capitulo 9</h1>
  <h2>Sistemas de Diseños y Escalabilidad</h2>
  <article>
    <p>
      A pesar de lo intimidantes que parecen, las preguntas sobre escalabilidad pueden ser de las más sencillas. No hay "trampas", ni trucos, ni algoritmos extravagantes, al menos por lo general. Lo que desconcierta a mucha gente es que creen que hay algo "mágico" en estos problemas, algún conocimiento oculto.
    </p>
    <p>
      Pero no es así. Estas preguntas están diseñadas simplemente para ver cómo te desenvolverías en el mundo real. Si tu jefe te pidiera que diseñaras un sistema, ¿qué harías?
    </p>
    <p>
      Por eso debes enfocarlo así. Afronta el problema haciéndolo como lo harías en el trabajo. Haz preguntas. Involucra al entrevistador. Discuta las ventajas y desventajas.
    </p>
    <p>
      Tocaremos algunos conceptos clave en este capítulo, pero reconoce que no se trata realmente de memorizar estos conceptos. Sí, comprender algunos componentes importantes del diseño de sistemas puede ser útil, pero se trata mucho más del proceso que sigues. Hay buenas y malas soluciones. No existe la solución perfecta.
    </p>
  </article>
  <article>
    <h3>► Manejar las preguntas</h3>
    <ul>
      <li>
        <strong>Comunicar: </strong>
        Un objetivo clave de las preguntas de diseño de sistemas es evaluar tu capacidad de comunicación. Manténgase en contacto con el entrevistador. Hágale preguntas. Hable abiertamente de los problemas de su sistema.
      </li>
      <li>
        <strong>Ve al grano primero: </strong>
        No te sumerjas directamente en la parte del algoritmo ni te centres excesivamente en una parte.
      </li>
      <li>
        <strong>Utiliza la pizarra: </strong>
        Utilizar una pizarra ayuda a tu entrevistador a seguir el diseño que propones. Acércate a la pizarra desde el principio y úsala para dibujar lo que propones.
      </li>
      <li>
        <strong>Ten en cuenta las preocupaciones del entrevistador: </strong>
        Es probable que tu entrevistador te plantee sus dudas. No las ignores, valídalas. Reconoce los problemas que te plantee y haz los cambios necesarios.
      </li>
      <li>
        <strong>Cuidado con las suposiciones: </strong>
        Una suposición incorrecta puede cambiar radicalmente el problema. Por ejemplo, si su sistema produce análisis/estadísticas para un conjunto de datos, es importante que esos análisis estén totalmente actualizados.
      </li>
      <li>
        <strong>Plantee sus hipótesis de forma explícita: </strong>
        Cuando haga suposiciones, explíquelas. De este modo, el usuario podrá corregirle si se equivoca y demostrará que, al menos, sabe cuáles son sus suposiciones.
      </li>
      <li>
        <strong>Haz estimaciones cuando sea necesario: </strong>
        En muchos casos, es posible que no dispongas de los datos que necesitas. Por ejemplo, si estás diseñando un rastreador web, puede que necesites estimar cuánto espacio necesitará para almacenar todas las URL. Puedes estimarlo con otros datos que conozcas.
      </li>
      <li>
        <strong>Conduce: </strong>
        Como candidato, debes permanecer en el asiento del conductor. Esto no significa que no hables con tu entrevistador; de hecho, debes hablar con él. Sin embargo, debe ser usted quien dirija la pregunta. Haga preguntas. Hable abiertamente de las ventajas y desventajas. Siga profundizando. Siga introduciendo mejoras.
      </li>
    </ul>
    <p>
      Estas preguntas se refieren más al proceso que al diseño final.
    </p>
  </article>
  <article>
    <h3>► Diseño: Paso a paso</h3>
    <p>
      Si tu jefe te pidiera que diseñaras un sistema como TinyURL, probablemente no te limitarías a decir "vale" y te encerrarías en tu despacho a diseñarlo tú solo. Probablemente te harías muchas más preguntas antes de hacerlo.Esta es la forma en que deberías manejarlo en una entrevista.
    </p>
  </article>
  <article>
    <p><strong>Paso 1: Analizar el problema
      </strong></p>
    <p>
      No puedes diseñar un sistema si no sabes lo que estás diseñando. El alcance del problema es importante porque quieres asegurarte de que estás construyendo lo que el entrevistador quiere y porque esto podría ser algo que el entrevistador está evaluando específicamente.
    </p>
    <p>
      Si te preguntan algo como "Diseña un URL pequeño", querrás saber qué es exactamente lo que tienes que implementar. ¿Podrá la gente especificar sus propias URLs cortas? ¿O se generarán automáticamente? ¿Tendrá que llevar un registro de los clics? ¿Las URL deben permanecer activas para siempre o tienen un tiempo de espera?
    </p>
    <p>
      Son preguntas a las que hay que responder antes de seguir adelante.
    </p>
    <p>
      Haz también aquí una lista de las principales características o casos de uso. Por ejemplo, paraTinyURL, podría ser:
    </p>
    <ul>
      <li>Acortar una URL a unaTinyURL.</li>
      <li>Análisis de una URL.</li>
      <li>Recuperación de la URL asociada a una TinyURL.</li>
      <li>Cuentas de usuario y gestión de enlaces.
      </li>
    </ul>
  </article>
  <article>
    <p><strong>Paso 2: Hacer suposiciones razonables
      </strong></p>
    <p>
      Está bien hacer algunas suposiciones (cuando sea necesario), pero deben ser razonables. Por ejemplo, no sería razonable suponer que su sistema sólo necesita procesar 100 usuarios al día, o suponer que dispone de memoria infinita.
    </p>
    <p>
      Sin embargo, podría ser razonable diseñar para un máximo de un millón de URL nuevas al día. Hacer esta suposición puede ayudarte a calcular cuántos datos puede necesitar almacenar tu sistema.
    </p>
    <p>
      Algunas suposiciones pueden requerir algo de "sentido común" (lo cual no es malo). Por ejemplo, ¿está bien que los datos estén caducados un máximo de diez minutos? Todo depende. Si una URL recién introducida tarda 10 minutos en funcionar, el problema se rompe. La gente suele querer que estas URL estén activas inmediatamente. Sin embargo, si las estadísticas están diez minutos desfasadas, no pasa nada. Hable con su entrevistador sobre este tipo de supuestos.
    </p>
  </article>
  <article>
    <p><strong>Paso 3: Dibuje los componentes principales
      </strong></p>
    <p>
      Levántate de la silla y ve a la pizarra. Dibuja un diagrama de los componentes principales. Puede que tengas algo así como un servidor frontend (o un conjunto de servidores) que extraen datos del almacén de datos del backend. Puede que haya otro conjunto de servidores que rastreen Internet en busca de datos y otro conjunto que procese los análisis. Haz un dibujo de cómo podría ser este sistema.
    </p>
    <p>
      Recorre el sistema de principio a fin para obtener un flujo. Un usuario introduce una nueva URL, ¿y luego qué?
    </p>
    <p>
      En este punto puede ser útil ignorar los principales problemas de escalabilidad y fingir que los enfoques sencillos y obvios estarán bien. Los grandes problemas los tratará en el Paso 4.
    </p>
  </article>
  <article>
    <p><strong>Paso 4: Identificar los problemas clave
      </strong></p>
    <p>
      Una vez que tenga en mente un diseño básico, céntrese en los problemas clave. ¿Cuáles serán los cuellos de botella o los principales retos del sistema?
    </p>
    <p>
      Por ejemplo, si estuviera diseñando TinyURL, una situación que podría tener en cuenta es que, mientras que algunas URL serán accedidas con poca frecuencia, otras pueden alcanzar picos repentinos. Esto puede ocurrir si una URL se publica en Reddit o en otro foro popular. No necesariamente querrás consultar constantemente la base de datos.
    </p>
    <p>
      Es posible que tu entrevistador te dé alguna orientación al respecto. Si es así, tómelas y utilícelas.
    </p>
  </article>
  <article>
    <p><strong>Paso 5: Rediseñar los temas clave
      </strong></p>
    <p>
      Una vez identificadas las cuestiones clave, es hora de ajustar el diseño a ellas. Puede que esto implique un rediseño importante o sólo algunos ajustes menores (como el uso de una caché).
    </p>
    <p>
      No te despegues de la pizarra y actualiza el diagrama a medida que cambie el diseño.
    </p>
    <p>
      Explica abiertamente las limitaciones de tu diseño. Es probable que tu entrevistador las conozca, así que es importante que tú también se las comuniques.
    </p>
  </article>
  <article>
    <h3>► Algoritmos a escala: Paso a paso</h3>
    <p>
      En algunos casos, no se te pide que diseñes un sistema entero. Sólo se te pide que diseñes una única característica o algoritmo, pero tienes que hacerlo de forma escalable. O puede que haya una parte del algoritmo que sea el foco "real" de una cuestión de diseño más amplia.
    </p>
    <p>
      En estos casos, prueba el siguiente enfoque.
    </p>
  </article>
  <article>
    <p><strong>Paso 1: Hacer preguntas
      </strong></p>
    <p>
      Como en el enfoque anterior, haz preguntas para asegurarte de que realmente entiendes la pregunta. Puede que el entrevistador haya omitido detalles (intencionadamente o no). No puedes resolver un problema si no entiendes exactamente cuál es.
    </p>
  </article>
  <article>
    <p><strong>Paso 2: Imagínatelo
      </strong></p>
    <p>
      Imagina que todos los datos caben en una sola máquina y que no hay limitaciones de memoria. ¿Cómo resolverías el problema? La respuesta a esta pregunta le proporcionará las líneas generales de su solución.
    </p>
  </article>
  <article>
    <p><strong>Paso 3: Sea realista
      </strong></p>
    <p>
      Volvamos al problema original. ¿Cuántos datos caben en una sola máquina y qué problemas pueden surgir al dividir los datos? Algunos de los problemas más comunes son cómo dividir los datos de forma lógica y cómo identificar en una máquina dónde buscar un dato diferente.
    </p>
  </article>
  <article>
    <p><strong>Paso 4: Resolver problemas
      </strong></p>
    <p>
      Por último, piense en cómo resolver los problemas que identificó en el Paso 2. Recuerde que la solución para cada problema puede ser eliminar por completo el problema o simplemente mitigarlo. Recuerde que la solución para cada problema puede consistir en eliminarlo por completo o simplemente mitigarlo. Por lo general, puede seguir utilizando (con modificaciones) el planteamiento esbozado en la etapa 1, pero en ocasiones tendrá que modificarlo radicalmente.
    </p>
    <p>
      Tenga en cuenta que un enfoque iterativo suele ser útil. Es decir, una vez resueltos los problemas del paso 3, pueden surgir otros nuevos, que también habrá que abordar.
    </p>
    <p>
      Su objetivo no es volver a diseñar un sistema complejo que las empresas han gastado millones de dólares en construir, sino demostrar que puede analizar y resolver problemas. Hacer agujeros en tu propia solución es una forma fantástica de demostrarlo.
    </p>
  </article>
  <article>
    <h3>► Conceptos clave</h3>
    <p>
      Aunque las preguntas de diseño de sistemas no son realmente pruebas de lo que sabes, ciertos conceptos pueden facilitarte mucho las cosas. Vamos a dar una breve visión general aquí. Todos estos son temas profundos y complejos, por lo que le animamos a utilizar recursos en línea para una mayor investigación.
    </p>
  </article>
  <article>
    <p><strong>Escalado horizontal o vertical
      </strong></p>
    <p>
      Un sistema puede escalarse de dos maneras.
    </p>
    <ul>
      <li>El escalado vertical significa aumentar los recursos de un nodo específico. Por ejemplo, puede añadir memoria adicional a un servidor para mejorar su capacidad de gestionar cambios de carga.</li>
      <li>El escalado horizontal significa aumentar el número de nodos. Por ejemplo, puede añadir servidores adicionales, disminuyendo así la carga en un servidor.</li>
    </ul>
    <p>
      El escalado vertical suele ser más sencillo que el horizontal, pero está limitado. Sólo se puede añadir una cantidad determinada de memoria o espacio en disco.
    </p>
  </article>
  <article>
    <p><strong>Equilibrador de carga
      </strong></p>
    <p>
      Normalmente, algunas partes del frontend de un sitio web escalable se lanzan detrás de un equilibrador de carga. Esto permite a un sistema distribuir la carga uniformemente para que un servidor no se bloquee y haga caer todo el sistema. Para ello, por supuesto, tienes que construir una red de servidores clónicos que tengan esencialmente el mismo código y acceso a los mismos datos.
    </p>
  </article>
  <article>
    <p><strong>Desnormalización de bases de datos y NoSQL
      </strong></p>
    <p>
      Las uniones en una base de datos relacional como SQL pueden volverse muy lentas a medida que el sistema crece. Por esta razón, generalmente se evitan.
    </p>
    <p>
      La desnormalización es una parte de esto. La desnormalización consiste en añadir información redundante a una base de datos para acelerar la lectura. Por ejemplo, imagine una base de datos que describa proyectos y tareas (donde un proyecto puede tener múltiples tareas). Es posible que necesite obtener el nombre del proyecto y la información de la tarea. En lugar de unir estas tablas, puede almacenar el nombre del proyecto en la tabla de tareas (además de en la tabla de proyectos).
    </p>
    <p>
      También puede utilizar una base de datos NoSQL. Una base de datos NoSQL no admite uniones y puede estructurar los datos de forma diferente. Está diseñada para escalar mejor.
    </p>
  </article>
  <article>
    <p><strong>Partición de la base de datos (Sharding)
      </strong></p>
    <p>
      Particionar significa dividir los datos en varias máquinas y asegurarse de que se puede saber qué datos están en cada máquina.
    </p>
    <p>
      Algunas formas comunes de particionar incluyen:
    </p>
    <ul>
      <li>
        <strong>Particionamiento vertical: </strong>
        Se trata básicamente de particionar por características. Por ejemplo, si estuvieras construyendo una red social, podrías tener una partición para las tablas relativas a los perfiles, otra para los mensajes, etcétera. Una desventaja es que si una de estas tablas se hace muy grande, puede que tengas que volver a particionar la base de datos (posiblemente utilizando un esquema de particionamiento diferente).
      </li>
      <li>
        <strong>Particionamiento basado en claves (o en hash): </strong>
        Utiliza alguna parte de los datos (por ejemplo, un ID) para particionarlos. Una forma muy sencilla de hacerlo es asignar N servidores y poner los datos en <code>mod(key, n)</code>. El problema es que el número de servidores es fijo. Añadir servidores adicionales significa reasignar todos los datos, una tarea muy costosa.
      </li>
      <li>
        <strong>Particionamiento basado en directorios: </strong>
        En este esquema, se mantiene una tabla de búsqueda donde se pueden encontrar los datos. Esto hace que sea relativamente fácil añadir servidores adicionales, pero tiene dos inconvenientes importantes. En primer lugar, la tabla de consulta puede ser un único punto de fallo. En segundo lugar, el acceso constante a esta tabla afecta al rendimiento.
      </li>
    </ul>
    <p>
      Muchas arquitecturas acaban utilizando múltiples esquemas de particionamiento.
    </p>
  </article>
  <article>
    <p><strong>Caché
      </strong></p>
    <p>
      Una caché en memoria puede ofrecer resultados muy rápidos. Se trata de un simple emparejamiento clave-valor que suele situarse entre la capa de aplicación y el almacén de datos.
    </p>
    <p>
      Cuando una aplicación solicita un dato, primero lo busca en la caché. Si la caché no contiene la clave, buscará los datos en el almacén de datos. (En este punto, los datos pueden -o no- estar almacenados en el almacén de datos).
    </p>
    <p>
      Cuando se cachea, se puede cachear directamente una consulta y sus resultados. O, alternativamente, puede almacenar en caché el objeto específico (por ejemplo, una versión renderizada de una parte del sitio web, o una lista de las entradas más recientes del blog).
    </p>
  </article>
  <article>
    <p><strong>Procesamiento asíncrono y colas
      </strong></p>
    <p>
      Lo ideal es que las operaciones lentas se realicen de forma asíncrona. De lo contrario, un usuario podría quedarse atascado esperando y esperando a que se complete un proceso.
    </p>
    <p>
      En algunos casos, podemos hacer esto por adelantado (es decir, podemos preprocesar). Por ejemplo, podríamos tener una cola de trabajos por hacer que actualicen alguna parte del sitio web. Si estuviéramos gestionando un foro, uno de estos trabajos podría ser volver a renderizar una página que enumera los mensajes más populares y el número de comentarios. Puede que la lista acabe estando ligeramente desactualizada, pero no pasa nada. Es mejor que un usuario se quede esperando a que el sitio web se cargue simplemente porque alguien ha añadido un nuevo comentario y ha invalidado la versión en caché de esta página.
    </p>
    <p>
      En otros casos, podríamos decirle al usuario que espere y notificarle cuando el proceso haya terminado. Probablemente hayas visto esto antes en sitios web. Quizá hayas activado alguna parte nueva de un sitio web y te diga que necesita unos minutos para importar tus datos, pero recibirás una notificación cuando haya terminado.
    </p>
  </article>
  <article>
    <p><strong>Métricas de red
      </strong></p>
    <p>
      Algunas de las métricas más importantes en torno a las redes son:
    </p>
    <ul>
      <li>
        <strong>Ancho de banda: </strong>
        es la cantidad máxima de datos que pueden transferirse en una unidad de tiempo. Suele expresarse en bits por segundo (o de forma similar, como gigabytes por segundo).
      </li>
      <li>
        <strong>Rendimiento: </strong>
        Mientras que el ancho de banda es la cantidad máxima de datos que pueden transferirse en una unidad de tiempo, el rendimiento es la cantidad real de datos que se transfieren.
      </li>
      <li>
        <strong>Latencia: </strong>
        Es el tiempo que tardan los datos en ir de un extremo a otro. Es decir, es el retardo entre que el emisor envía la información (incluso un trozo muy pequeño de datos) y el receptor la recibe.
      </li>
    </ul>
    <p>
      Imagina que tienes una cinta transportadora que traslada artículos por una fábrica. La latencia es el tiempo que tarda un artículo en ir de un lado a otro. El rendimiento es el número de artículos que salen de la cinta transportadora por segundo.
    </p>
    <ul>
      <li>Construir una cinta transportadora más ancha no cambiará la latencia. Pero sí cambiará el rendimiento y el ancho de banda. Puede colocar más artículos en la cinta y, por tanto, transferir más en una unidad de tiempo determinada.</li>
      <li>Acortar la cinta reducirá la latencia, ya que los artículos pasan menos tiempo en tránsito. No cambiará el rendimiento ni el ancho de banda. Saldrá de la cinta el mismo número de artículos por unidad de tiempo.</li>
      <li>Una cinta transportadora más rápida cambiará las tres cosas. El tiempo que tarda un artículo en recorrer la fábrica disminuye. También saldrán más artículos de la cinta transportadora por unidad de tiempo.</li>
      <li>El ancho de banda es el número de elementos que pueden transferirse por unidad de tiempo, en las mejores condiciones posibles. El rendimiento es el tiempo que realmente se tarda, cuando las máquinas quizá no funcionan bien.</li>
    </ul>
    <p>
      Es fácil no tener en cuenta la latencia, pero puede ser muy importante en determinadas situaciones. Por ejemplo, si juegas a determinados juegos en línea, la latencia puede ser muy importante. ¿Cómo puede jugar a un típico juego de deportes en línea (como un partido de fútbol para dos jugadores) si no se le notifica rápidamente el movimiento de su oponente? Además, a diferencia del rendimiento, donde al menos tienes la opción de acelerar las cosas mediante la compresión de datos, a menudo hay poco que puedas hacer sobre la latencia.
    </p>
  </article>
  <article>
    <p><strong>MapReduce
      </strong></p>
    <p>
      MapReduce se asocia a menudo con Google, pero su uso es mucho más amplio. Un programa MapReduce se utiliza normalmente para procesar grandes cantidades de datos.
    </p>
    <p>
      Como su nombre indica, un programa MapReduce requiere que escribas un paso Map y un paso Reduce. Del resto se encarga el sistema.
    </p>
    <ul>
      <li>Map toma algunos datos y emite un par <code>&#60key, value></code>.</li>
      <li>Reduce toma una clave y un conjunto de valores asociados y los "reduce" de alguna manera, emitiendo una nueva clave y valor. Los resultados de esto pueden ser devueltos al programa Reduce para una mayor reducción.</li>
    </ul>
    <p>
      MapReduce nos permite realizar una gran cantidad de procesamiento en paralelo, lo que hace que el procesamiento de grandes cantidades de datos sea más escalable.
    </p>
    <p>
      Para más información, consulte "MapReduce "en la página 642.
    </p>
  </article>
  <article>
    <h3>► Consideraciones
    </h3>
    <p>
      Además de los conceptos anteriores que debes aprender, debes tener en cuenta las siguientes cuestiones a la hora de diseñar un sistema.
    </p>
    <ul>
      <li><strong>Fallos: </strong>Esencialmente cualquier parte de un sistema puede fallar. Necesitarás planificar para muchos o todos estos fallos.</li>
      <li><strong>Disponibilidad y fiabilidad: </strong>La disponibilidad es una función del porcentaje de tiempo que el sistema está operativo. La fiabilidad es una función de la probabilidad de que el sistema esté operativo durante una determinada unidad de tiempo.</li>
      <li><strong>Lectura intensiva frente a escritura intensiva: </strong>el diseño depende de si la aplicación va a leer mucho o escribir mucho. Si tiene muchas escrituras, puedes considerar poner en cola las escrituras (¡pero piensa en los posibles fallos!). Si es de lectura intensiva, es posible que desee almacenar en caché. También podrían cambiar otras decisiones de diseño.</li>
      <li><strong>La seguridad: </strong>Las amenazas a la seguridad pueden, por supuesto, ser devastadoras para un sistema. Piensa en los tipos de problemas a los que puede enfrentarse un sistema y diseña en función de ellos.</li>
    </ul>
    <p>
      Esto es sólo para empezar con los posibles problemas de un sistema. Acuérdate de ser sincero en la entrevista sobre las ventajas y desventajas.
    </p>
  </article>
  <article>
    <h3>► No existe el sistema "perfecto".
    </h3>
    <p>
      No hay un diseño único para TinyURL o Google Maps o cualquier otro sistema que funcione a la perfección (aunque hay un gran número que funcionaría terriblemente). Siempre hay compensaciones. Dos personas podrían tener diseños sustancialmente diferentes para un sistema, siendo ambos excelentes dadas las diferentes suposiciones.
    </p>
    <p>
      Tu objetivo en estos problemas es ser capaz de entender los casos de uso, el alcance de un problema, hacer suposiciones razonables, crear un diseño sólido basado en esos supuestos, y ser abierto acerca de las debilidades de tu diseño. No esperes algo perfecto.
    </p>
  </article>
  <article>
    <h3>► Ejemplo de problema
    </h3>
    <p><em>Dada una lista de millones de documentos, ¿cómo encontrar todos los documentos que contienen una lista de palabras? Las palabras pueden aparecer en cualquier orden, pero deben ser palabras completas. Es decir, "libro" no coincide con "contable".</em>
    </p>
    <p>
      Antes de empezar a resolver el problema, tenemos que saber si se trata de una operación que se realiza una sola vez, o si este procedimiento <code>findWords</code> se llamará repetidamente. Supongamos que vamos a llamar a <code>findWords</code> muchas veces para el mismo conjunto de documentos y, por lo tanto, podemos aceptar la carga del preprocesamiento.
    </p>
  </article>
  <article>
    <p>
      <strong>Paso 1</strong>
    </p>
    <p>
      El primer paso es imaginar que sólo tenemos unas pocas docenas de documentos. ¿Cómo implementaríamos <code>findWords</code> en este caso? (Consejo: deténgase aquí e intente resolver esto usted mismo antes de seguir leyendo).
    </p>
    <pre>
      <code class="language-js">
        "books" -> &#123doc2, doc3, doc6, doc8} 
        "many" -> &#123docl, doc3, doc7, doc8, doc9}
      </code>
    </pre>
    <p>
      Una forma de hacerlo es preprocesar cada documento y crear un índice de tabla hash. Esta tabla hash asignaría desde una palabra a una lista de los documentos que contienen esa palabra.
    </p>
    <p>
      Para buscar "muchos libros", basta con hacer una intersección entre los valores de "libros" y "muchos" y obtener como resultado <code>&#123doc3, doc8}</code>.
    </p>
  </article>
  <article>
    <p>
      <strong>Paso 2</strong>
    </p>
    <p>
      Ahora volvamos al problema original. ¿Qué problemas se presentan con millones de documentos? Para empezar, es probable que tengamos que repartir los documentos entre muchas máquinas. Además, dependiendo de una serie de factores, como el número de palabras posibles y la repetición de palabras en un documento, es posible que no nos quepa toda la tabla hash en una sola máquina. Supongamos que éste es el caso.
    </p>
    <p>
      Esta división introduce las siguientes preocupaciones clave:
    </p>
    <ol>
      <li>
        ¿Cómo dividiremos nuestra tabla hash? Podríamos dividirla por palabras clave, de forma que una máquina dada contenga la lista completa de documentos para una palabra dada. O podríamos dividirla por documentos, de forma que una máquina contenga la correspondencia de palabras clave sólo para un subconjunto de documentos.
      </li>
      <li>Una vez que hayamos decidido cómo dividir los datos, puede que necesitemos procesar un documento en una máquina y enviar los resultados a otras. ¿Qué aspecto tiene este proceso? (Nota: si dividimos la tabla hash por documentos puede que este paso no sea necesario).</li>
      <li>Necesitaremos una forma de saber en qué máquina se encuentra un dato. ¿Qué aspecto tiene esta tabla de consulta y dónde se almacena?</li>
    </ol>
    <p>
      Estas son sólo tres cuestiones. Puede haber muchas más.
    </p>
  </article>
  <article>
    <p>
      <strong>Paso 3</strong>
    </p>
    <p>
      En el Paso 3, encontramos soluciones a cada una de estas cuestiones. Una solución es dividir las palabras alfabéticamente por palabra clave, de modo que cada máquina controle un rango de palabras (por ejemplo, desde "<code>after</code>" hasta "<code>apple</code>").
    </p>
    <p>
      Podemos aplicar un algoritmo sencillo en el que recorremos las palabras clave por orden alfabético, almacenando tantos datos como sea posible en una máquina. Cuando esa máquina esté llena, podemos pasar a la siguiente.
    </p>
    <p>
      La ventaja de este enfoque es que la tabla de consulta es pequeña y sencilla (ya que sólo debe especificar un rango de valores), y cada máquina puede almacenar una copia de la tabla de consulta. Sin embargo, la desventaja es que si se añaden nuevos documentos o palabras, es posible que tengamos que realizar un costoso cambio de palabras clave.
    </p>
    <p>
      Para encontrar todos los documentos que coinciden con una lista de cadenas, primero ordenaríamos la lista y luego enviaríamos a cada máquina una petición de búsqueda de las cadenas que posee la máquina. Por ejemplo, si nuestra cadena es "<code>after builds boat amaze banana</code>", la máquina 1 recibiría una petición de búsqueda de <code>&#123"after", "amaze"}</code>.
    </p>
    <p>
      La máquina 1 busca los documentos que contienen "<code>after</code>" y "<code>amaze</code>" y realiza una intersección en estas listas de documentos. La máquina 3 hace lo mismo para <code>&#123"banana", "boat", "builds"}</code>, e interseca sus listas.
    </p>
    <p>
      En el último paso, la máquina inicial realizaría una intersección sobre los resultados de la Máquina 1 y la Máquina 3. 
    </p>
    <p>
      El siguiente diagrama explica este proceso.
    </p>
    <div class="flex items-center flex-col gap-y-4">
      <div class="w-[480px] border-2 text-center border-slate-700">
        <p><code class="language-js">"after builds boat amaze banana"</code></p>
      </div>
      <div class="flex gap-8">
        <p class="border-2 w-96 text-center border-slate-700"><code class="language-js">Machine 1: "after amaze"</code></p>
        <p class="border-2 w-96 text-center border-slate-700"><code class="language-js">Machine 3: "builds boat banana"</code></p>
      </div>
      <div class="flex gap-8">
        <p class="border-2 w-96 text-center flex flex-col justify-center border-slate-700">
          <code class="language-js">"after" -> doc1, docs, doc7</code>
          <code class="language-js">"amaze" -> doc2, docs, doc7</code>
        </p>
        <p class="border-2 w-96 text-center border-slate-700">
          <code class="language-js">"builds" -> doc3, doc4, doc5</code>
          <code class="language-js">"boat" -> doc2, doc3, doc5</code>
          <code class="language-js">"banana" -> doc3, doc4, doc5</code>
        </p>
      </div>
      <div class="flex gap-8">
        <p class="border-2 w-96 text-center border-slate-700"><code class="language-js">Machine 1: "after amaze"</code></p>
        <p class="border-2 w-96 text-center border-slate-700"><code class="language-js">Machine 3: "builds boat banana"</code></p>
      </div>
      <div class="w-[480px] border-2 text-center border-slate-700">
        <p><code class="language-js">solution = docs</code></p>
      </div>
    </div>
  </article>
  <article>
    <h3 class="border-y-2 border-black">Preguntas de la entrevista</h3>
    <p>
      Estas preguntas están diseñadas para reflejar una entrevista real, por lo que no siempre estarán bien definidas. Piense en las preguntas que le haría a su entrevistador y luego haga suposiciones razonables. Puede que hagas suposiciones diferentes a las nuestras y eso te lleve a un diseño muy diferente. No pasa nada.
    </p>
    <ul>
      <li class="list-none">
        <strong>9.1 Datos de stock: </strong>
        Imagina que estás creando algún tipo de servicio al que llamarán hasta 1.000 aplicaciones cliente para obtener información sencilla sobre el precio de las acciones al final del día (apertura, cierre, máximo, mínimo). Puede suponer que ya dispone de los datos y que puede almacenarlos en el formato que desee. ¿Cómo diseñaría el servicio de cara al cliente que proporciona la información a las aplicaciones cliente? Usted es responsable del desarrollo, la puesta en marcha y la supervisión y el mantenimiento continuos del feed. Describa los diferentes métodos que ha considerado y por qué recomendaría su enfoque. Su servicio puede utilizar las tecnologías que desee y distribuir la información a las aplicaciones cliente mediante el mecanismo que elija.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #385, #396</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 372</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.2 Red social: </strong>
        ¿Cómo diseñarías las estructuras de datos de una red social muy grande como Facebook o LinkedIn? Describa cómo diseñaría un algoritmo para mostrar el camino más corto entre dos personas (por ejemplo, Yo -> Bob -> Susana -> Jason -> Tu).
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #270, #285, #304, #321</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 374</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.3 Rastreador web: </strong>
        Si estuvieras diseñando un rastreador web, ¿cómo evitarías entrar en bucles infinitos?
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #334, #353, #365</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 378</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.4 URL duplicadas: </strong>
        Tienes 10 mil millones de URLs. ¿Cómo detecta los documentos duplicados? En este caso, "duplicado" significa que las URL son idénticas.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #326, #347</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 380</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.5 Caché: </strong>
        Imagine un servidor web para un motor de búsqueda simplificado. Este sistema dispone de 100 máquinas para responder a las consultas de búsqueda, que luego pueden llamar mediante el <code>processSearch(string query)</code> a otro grupo de máquinas para obtener realmente el resultado. La máquina que responde a una determinada consulta se elige al azar, por lo que no se puede garantizar que la misma máquina responda siempre a la misma petición. El método <code>processSearch</code> es muy caro. Diseña un mecanismo de caché para las consultas más recientes. Asegúrate de explicar cómo actualizarías la caché cuando cambien los datos.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #259, #274, #293, #311</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 381</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.6 Rango de ventas: </strong>
        Una gran empresa de comercio electrónico desea listar los productos más vendidos, en general y por categoría. Por ejemplo, un producto podría ser el nº 1056 más vendido de todos, pero el nº 13 en "Equipamiento deportivo" y el nº 24 en "Seguridad". Describa cómo diseñaría este sistema.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #142, #158, #176, #189, #208, #223, #236, #244</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 385</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.7 Gestor financiero personal: </strong>
        Explica cómo diseñarías un gestor financiero personal (como Mint.com). Este sistema se conectaría a tus cuentas bancarias, analizaría tus hábitos de gasto y te haría recomendaciones.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #762, #180, #199, #212, #247, #276</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 388</strong></p>
        </div>
      </li>
      <li class="list-none">
        <strong>9.8 Pastebin: </strong>
        Diseña un sistema como Pastebin, en el que un usuario puede introducir un texto y obtener una URL generada aleatoriamente para acceder a él.
        <div class="flex justify-between items-end gap-2">
          <p><em>Pistas: #165, #184, #206, #232</em> 
          </p>
          <p class="border-t-2 border-black flex-1 border-dashed"></p>
          <p><strong>pg 392</strong></p>
        </div>
      </li>
    </ul>
    <p>
      Preguntas adicionales: Diseño Orientado a Objetos (#7.7)
    </p>
    <p>
      Las pistas comienzan en la página 662.
    </p>
  </article>
  <footer class="flex justify-end">
    <a class="font-khand font-bold text-3xl py-4 sm:py-8 md:py-12 sm:text-4xl md:text-5xl" href="capitulo-10">
      <div class="transition-all text-nowrap relative ease-linear duration-500 w-28 sm:w-40 md:w-52
      hover:w-36 sm:hover:w-48 md:hover:w-56  hover:text-sky-500
      after:content-['↦'] after:text-red-500 after:transition-all after:ease-linear after:duration-500 after:opacity-0 after:relative after:-left-3 
      hover:after:content-['↦'] hover:after:transition-all hover:after:ease-linear hover:after:duration-500 hover:after:opacity-100 hover:after:left-3"> Capitulo 10</div>
    </a>
  </footer>
</Layoutcracking>